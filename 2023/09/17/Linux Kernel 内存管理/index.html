<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Linux Kernel 内存管理 - Humoooor&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Humoooor&#039;s Blog"><meta name="msapplication-TileImage" content="/img/MyLogo.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Humoooor&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Linux 5.11 内存管理"><meta property="og:type" content="blog"><meta property="og:title" content="Linux Kernel 内存管理"><meta property="og:url" content="https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><meta property="og:site_name" content="Humoooor&#039;s Blog"><meta property="og:description" content="Linux 5.11 内存管理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://humoooor.cn/2023/09/17/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/physical_memory.png"><meta property="og:image" content="https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mem_section_fixed.png"><meta property="og:image" content="https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mem_section_dynamic.png"><meta property="og:image" content="https://humoooor.cn/2023/09/17/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/free_area.png"><meta property="og:image" content="https://humoooor.cn/2023/09/17/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/free_list.png"><meta property="og:image" content="https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/Slub.png"><meta property="article:published_time" content="2023-09-17T14:26:00.000Z"><meta property="article:modified_time" content="2023-09-26T14:33:45.718Z"><meta property="article:author" content="Humoooor"><meta property="article:tag" content="Operating System"><meta property="article:tag" content="Linux Kernel"><meta property="article:tag" content="Memory Management"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://humoooor.cn/2023/09/17/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/physical_memory.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},"headline":"Linux Kernel 内存管理","image":["https://humoooor.cn/2023/09/17/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/physical_memory.png","https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mem_section_fixed.png","https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mem_section_dynamic.png","https://humoooor.cn/2023/09/17/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/free_area.png","https://humoooor.cn/2023/09/17/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/free_list.png","https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/Slub.png"],"datePublished":"2023-09-17T14:26:00.000Z","dateModified":"2023-09-26T14:33:45.718Z","author":{"@type":"Person","name":"Humoooor"},"publisher":{"@type":"Organization","name":"Humoooor's Blog","logo":{"@type":"ImageObject","url":"https://humoooor.cn/img/MyLogo.jpg"}},"description":"Linux 5.11 内存管理"}</script><link rel="canonical" href="https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><link rel="icon" href="/img/MyLogo.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Humoooor's Blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/MyLogo.jpg" alt="Humoooor&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/friends">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/humoooor"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-09-17T14:26:00.000Z" title="2023/9/17 22:26:00">2023-09-17</time>发表</span><span class="level-item"><time dateTime="2023-09-26T14:33:45.718Z" title="2023/9/26 22:33:45">2023-09-26</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Kernel/">Kernel</a></span><span class="level-item">1 小时读完 (大约10019个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Linux Kernel 内存管理</h1><div class="content"><p>Linux 5.11 内存管理</p>
<span id="more"></span>

<h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>下面是本文可能会用到的一些关键词，防止读者混淆</p>
<ul>
<li>页：一般指一页物理页，大小一般为 4 KB</li>
<li>页面：由一页或者多个连续页组成的内存区，为 Buddy System 的最小管理单位</li>
</ul>
<h2 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h2><p>Linux 使用三级结构对物理内存进行管理</p>
<ul>
<li>Page<ul>
<li>页</li>
<li>物理内存最小的管理单元，也是虚拟内存映射到物理内存的最小单位</li>
</ul>
</li>
<li>Zone<ul>
<li>区</li>
<li>第二级结构，管理多个页</li>
</ul>
</li>
<li>Node<ul>
<li>节点</li>
<li>第一级结构，管理多个区</li>
</ul>
</li>
</ul>
<p><img src="../img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/physical_memory.png" alt="Physical Memory"></p>
<h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><p>Linux 使用 <code>page</code> 结构体来管理一个页，一般一页为 4KB</p>
<p>结构体的内容如下（结构体的定义在 <code>include/linux/mm_types.h</code> 中，这里就不把代码放出来凑字数了）</p>
<ul>
<li><code>flags</code><ul>
<li>标志位</li>
</ul>
</li>
<li><code>union1</code><ul>
<li>5 个字长</li>
<li>这个 union 根据 <code>page</code> 的不同用途，定义不同的结构体，节省内存</li>
</ul>
</li>
<li><code>union2</code><ul>
<li>memmap 管理</li>
</ul>
</li>
<li><code>_refcount</code><ul>
<li>使用计数</li>
</ul>
</li>
<li>其他扩展</li>
</ul>
<p>下面介绍比较重要的字段</p>
<h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a><code>flags</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br></pre></td></tr></table></figure>

<p>标志位，每一位表示一种状态，状态 <code>enum pageflags</code> 在 <code>include/linux/page-flags.h</code> 中定义</p>
<ul>
<li><code>PG_locked</code><ul>
<li>该页上锁，正在被使用</li>
</ul>
</li>
<li><code>PG_referenced</code><ul>
<li>该页刚被访问过，与 <code>PG_reclaim</code> 用于匿名与文件备份缓存的页面回收</li>
</ul>
</li>
<li><code>PG_reclaim</code><ul>
<li>该页可以被回收</li>
</ul>
</li>
<li><code>PG_uptodate</code><ul>
<li>最新状态（up-to-date），该页被读后会变更为最新状态</li>
</ul>
</li>
<li><code>PG_dirty</code><ul>
<li>该页被修改过</li>
</ul>
</li>
<li><code>PG_lru</code><ul>
<li>该页在 LRU 链表上</li>
</ul>
</li>
<li><code>PG_active</code><ul>
<li>该页在活跃 LRU 链表上</li>
</ul>
</li>
<li><code>PG_workingset</code><ul>
<li>该页位于某个进程的工作集（working set，在某一时刻被使用的内存页）中</li>
</ul>
</li>
<li><code>PG_waiters</code><ul>
<li>有进程在等待该页</li>
</ul>
</li>
<li><code>PG_error</code><ul>
<li>该页在 I/O 过程中出现了差错</li>
</ul>
</li>
<li><code>PG_slab</code><ul>
<li>该页由 slab 使用</li>
</ul>
</li>
<li><code>PG_owner_priv_1</code><ul>
<li>该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用</li>
</ul>
</li>
<li><code>PG_arch_1</code><ul>
<li>该页与体系结构相关联</li>
</ul>
</li>
<li><code>PG_reserved</code><ul>
<li>该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）</li>
</ul>
</li>
<li><code>PG_private</code> &amp;&amp; <code>PG_private2</code><ul>
<li>该页拥有私有数据（private 字段）</li>
</ul>
</li>
<li><code>PG_writeback</code><ul>
<li>该页正在被写到磁盘上</li>
</ul>
</li>
<li><code>PG_head</code><ul>
<li>该页是复合页（compound pages）的第一个页</li>
</ul>
</li>
<li><code>PG_mappedtodisk</code><ul>
<li>该页被映射到硬盘中</li>
</ul>
</li>
<li><code>PG_swapbacked</code><ul>
<li>该页的后备存储器为 swap/RAM</li>
</ul>
</li>
<li><code>PG_unevictable</code><ul>
<li>该页不可被回收（被锁），且会出现在 <code>LRU_UNEVICTABLE</code> 链表中</li>
</ul>
</li>
<li><code>PG_mlocked</code><ul>
<li>该页被对应的 vma 上锁（通常是系统调用 mlock）</li>
</ul>
</li>
<li><code>PG_uncached</code><ul>
<li>该页被设置为不可缓存</li>
</ul>
</li>
<li><code>PG_hwpoison</code><ul>
<li>硬件相关的标志位</li>
</ul>
</li>
<li><code>PG_arch_2</code>：64位下的体系结构相关标志位</li>
</ul>
<h4 id="mapcount"><a href="#mapcount" class="headerlink" title="_mapcount "></a><code>_mapcount </code></h4><p>该字段在 <code>union2</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> _mapcount;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> page_type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line">    <span class="type">int</span> units;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>映射计数，该页被页表映射的次数，可以理解为有多少个进程共享这一页</p>
<h4 id="refcount"><a href="#refcount" class="headerlink" title="_refcount"></a><code>_refcount</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> _refcount;</span><br></pre></td></tr></table></figure>

<p>引用计数，该页在某一个时刻被引用的个数</p>
<p>内核使用 <code>get_page</code> 函数增加引用计数，<code>put_page</code> 函数减少引用计数，当引用计数为 0 时，会调用 <code>__put_single_page</code> 释放该页</p>
<h4 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a><code>virtual</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *virtual;</span><br></pre></td></tr></table></figure>

<p>该页在<strong>内核</strong>中被映射的虚拟地址</p>
<h4 id="基础内存模型"><a href="#基础内存模型" class="headerlink" title="基础内存模型"></a>基础内存模型</h4><p>Linux 定义了三种内存模型，定义在 <code>include/asm-generic/memory_model.h</code> 中</p>
<p>#todo 做一张内存模型的图</p>
<h5 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h5><p>平滑内存模型，顾名思义，所有的物理内存地址连续，一个 <code>page</code> 数组 <code>mem_map</code> 全局变量来表示对应的所有物理内存</p>
<h5 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h5><p>非连续内存模型，顾名思义，物理内存地址不完全连续，内存之间存在<strong>空洞（hole）</strong></p>
<p>每一段连续物理内存由 <code>pglist_data</code> 结构体表示，结构体中 <code>node_mem_map</code> 字段为一个 <code>page</code> 数组，该数组对应这一段连续物理内存</p>
<p>再往上一层，有一个 <code>pglist_data</code> 指针数组 <code>node_data</code> 全局变量来存放每个 <code>pglist_data</code> 的地址</p>
<h5 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h5><p>离散内存模型，该内存模型相当于<strong>可热插拔</strong>的非连续内存模型，是最常用的基础内存模型</p>
<p>物理内存以 <strong>section</strong>（节）为单位进行管理，每一段连续物理内存由 <code>mem_section</code> 结构体中的 <code>section_mem_map</code> 对应</p>
<blockquote>
<p><code>section_mem_map</code> 本身是一个 unsigned long 变量，可以通过 <code>section_mem_map &amp; SECTION_MAP_MASK</code> 来获取对应的 section 首地址，内核中用 <code>__section_mem_map_addr</code> 函数表示这一操作</p>
</blockquote>
<p>再往上一层，有一个 <code>mem_section</code> 二维数组 <code>mem_section</code>（同名）存放每个 <code>mem_section</code> 的实体或地址，这个二维数组大小可以是固定的，也可以是动态的（<code>struct mem_section **mem_section</code>，一般在 section 比较多的情况下需要开启 CONFIG_SPARSEMEM_EXTREME），指针可能为空</p>
<figure class="highlight c"><figcaption><span>mm/sparse.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">    ____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT (PAGE_SIZE / sizeof (struct mem_section))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>固定和动态大小的二维数组 <code>mem_section</code> 布局是不同的</li>
<li>固定大小的 <code>mem_section</code> 实际上是一个一维指针数组<ul>
<li>第二维的大小 SECTIONS_PER_ROOT 为 1</li>
</ul>
</li>
<li>动态大小的 <code>mem_section</code> 是实实在在的二维数组<ul>
<li>第二维的大小 SECTIONS_PER_ROOT，即一页所能存放的 <code>mem_section</code> 结构体的个数</li>
<li>也就是说，<code>mem_section</code> 会连续存储在一页中，并且有多个页来存储 <code>mem_section</code>，也表明 section 数量也确实多</li>
</ul>
</li>
</ul>
<p>下图为固定大小的 <code>mem_section</code></p>
<p><img src="img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mem_section_fixed.png" alt="mem_section_fixed"></p>
<p>下面是动态大小的 <code>mem_section</code></p>
<p><img src="img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mem_section_dynamic.png" alt="mem_section_dynamic"></p>
<h4 id="PFN-与-page-地址的转换"><a href="#PFN-与-page-地址的转换" class="headerlink" title="PFN 与 page 地址的转换"></a>PFN 与 <code>page</code> 地址的转换</h4><p>在内核中常会用到 PFN（页帧号 Page Frame Number） 来简单表示一个页（而不是用复杂的 <code>page</code> 指针地址表示），可以理解为该页在物理内存的位置号，使用上会涉及到 PFN 与 <code>page</code> 地址之间的转换 <code>__page_to_pfn</code> 和 <code>__pfn_to_page</code></p>
<p>这里只讲 Sparse Memory 的转换，宏定义位于 <code>include/linux/memory_model</code> 中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SPARSEMEM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(pg)					\</span></span><br><span class="line"><span class="meta">(&#123;	const struct page *__pg = (pg);				\</span></span><br><span class="line"><span class="meta">	int __sec = page_to_section(__pg);			\</span></span><br><span class="line"><span class="meta">	(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));	\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)				\</span></span><br><span class="line"><span class="meta">(&#123;	unsigned long __pfn = (pfn);			\</span></span><br><span class="line"><span class="meta">	struct mem_section *__sec = __pfn_to_section(__pfn);	\</span></span><br><span class="line"><span class="meta">	__section_mem_map_addr(__sec) + __pfn;		\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>注意 <code>mem_section</code> 的 <code>section_mem_map</code> 是等于该 section 第一个 <code>page</code> 的地址减去 section 第一个 <code>page</code> 对应的页在物理内存中的位置号 start_pfn</p>
<p>由此可以得到下面的公式</p>
<p>$$<br>PFN = index_{page} + start_pfn = addr_{page} - addr_{section_first_page} + start_pfn = addr_{page} - section_mem_map<br>$$</p>
<h5 id="page-地址-gt-PFN"><a href="#page-地址-gt-PFN" class="headerlink" title="page 地址 -&gt; PFN"></a><code>page</code> 地址 -&gt; PFN</h5><p>首先使用 <code>page_to_section</code> 通过 <code>page</code> 的 <code>flags</code> 字段该页所属 section 号</p>
<figure class="highlight c"><figcaption><span>include/linux/mm.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">page_to_section</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>__nr_to_section</code> 获取对应的 <code>mem_section</code> 结构体地址</p>
<figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">nr_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">nr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">    <span class="keyword">if</span> (!mem_section)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!mem_section[SECTION_NR_TO_ROOT(nr)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;mem_section[SECTION_NR_TO_ROOT(nr)][nr &amp; SECTION_ROOT_MASK];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTION_NR_TO_ROOT(sec) ((sec) / SECTIONS_PER_ROOT)</span></span><br></pre></td></tr></table></figure>

<p><code>SECTION_NR_TO_ROOT</code> 是计算该 section 在二维数组的第一个下标，与 SECTION_ROOT_MASK 做与运算，获取在二维数组的第二个下标</p>
<p>然后使用 <code>__section_mem_map_addr</code> 获取 <code>page</code> 所在 section 的 <code>section_mem_map</code></p>
<figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">section_mem_map_addr</span>(<span class="keyword">struct</span> <span class="title">mem_section</span> *<span class="title">section</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">map</span> = section-&gt;section_mem_map;</span><br><span class="line">    <span class="comment">// 去掉标志位</span></span><br><span class="line">    <span class="built_in">map</span> &amp;= SECTION_MAP_MASK;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> page *)<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后作差即可得到 PFN</p>
<h5 id="PFN-gt-page-地址"><a href="#PFN-gt-page-地址" class="headerlink" title="PFN -&gt; page 地址"></a>PFN -&gt; <code>page</code> 地址</h5><p>先通过 <code>__pfn_to_section</code> 将 pfn 转换成对应的 section</p>
<figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">pfn_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">pfn</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pfn_to_section_nr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中会调用 <code>pfn_to_section_nr</code> 获取所属 section 号，再通过 <code>__nr_to_section</code> 获取 <code>mem_section</code> 地址</p>
<p>然后使用 <code>__section_mem_map_addr</code> 获取 <code>page</code> 所在 section 的 <code>section_mem_map</code></p>
<p>最后相加即可得到 <code>page</code> 地址</p>
<h4 id="Sparse-Memory-Virtual-Memmap"><a href="#Sparse-Memory-Virtual-Memmap" class="headerlink" title="Sparse Memory Virtual Memmap"></a>Sparse Memory Virtual Memmap</h4><p>这是 Linux 最常用的内存模型之一</p>
<p>开启虚拟地址空间到物理地址空间的映射，虚拟地址空间的所有页都是连续的，所有的 <code>page</code> 都抽象到一个虚拟数组 <code>vmemmap</code> 中，PFN 也就代表着该页在虚拟空间的位置</p>
<figure class="highlight c"><figcaption><span>include/asm-generic/memory_model.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)	(vmemmap + (pfn))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(page)	(unsigned long)((page) - vmemmap)</span></span><br></pre></td></tr></table></figure>

<p>使用简单的加减法即可互相转换</p>
<h3 id="Zone"><a href="#Zone" class="headerlink" title="Zone"></a>Zone</h3><p>Linux 使用<strong>区</strong>来管理一段内存页，使用 <code>zone</code> 结构体表示，结构体定义位于 <code>include/linux/mmzone.h</code></p>
<p>区根据地址不同分为不同的区</p>
<ul>
<li>ZONE_DMA<ul>
<li>0 - 16 MB</li>
</ul>
</li>
<li>ZONE_DMA32<ul>
<li>16 MB - 4 GB</li>
<li>x86_64 独有</li>
</ul>
</li>
<li>ZONE_NORMAL<ul>
<li>x86：16 - 896 MB</li>
<li>x86_64：4 GB+</li>
</ul>
</li>
<li>ZONE_HIGHMEM<ul>
<li>896 MB+</li>
<li>x86 独有</li>
</ul>
</li>
</ul>
<p>下面介绍比较重要的字段</p>
<h4 id="watermark"><a href="#watermark" class="headerlink" title="_watermark"></a><code>_watermark</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _watermark[NR_WMARK]; <span class="comment">// NR_WMARK = 3</span></span><br></pre></td></tr></table></figure>

<p>水位线，每个区从高到低有三档水位线：<code>WMARK_HIGH</code>、<code>WMARK_LOW</code>、<code>WMARK_MIN</code></p>
<p>Buddy System 会根据空闲内存和水位线比较判断当前的内存情况，进行内存回收</p>
<h4 id="zone-pgdat"><a href="#zone-pgdat" class="headerlink" title="zone_pgdat"></a><code>zone_pgdat</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">zone_pgdat</span>;</span></span><br></pre></td></tr></table></figure>

<p>指向 zone 所属的节点</p>
<h4 id="pageset"><a href="#pageset" class="headerlink" title="pageset"></a><code>pageset</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br></pre></td></tr></table></figure>

<p>多 CPU 的引入会导致条件竞争，其中一个解决办法是锁，但是频繁的加解锁和等待时间造成巨大的开销，因此引入 <code>per_cpu_pageset</code> 结构体，为每一个 CPU 单独准备一个页面仓库 <code>pageset</code>，即每个 CPU 的 <code>pageset</code> 指针指向不同的实体</p>
<p>Buddy System 初始化时会将页面均匀地放在各个 CPU 的 <code>pageset</code> 中，分配时优先从自己的 <code>pageset</code> 中分配</p>
<figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> <span class="title">pcp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    s8 expire;</span><br><span class="line">    u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    s8 stat_threshold;</span><br><span class="line">    s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 页面数量</span></span><br><span class="line">    <span class="type">int</span> high;       <span class="comment">// 高水位线</span></span><br><span class="line">    <span class="type">int</span> batch;      <span class="comment">// 如果页面数量为 0，从该 zone 中的补充数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pcp-list 页面链表，一种迁移类型一个链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">MIGRATE_PCPTYPES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="free-area"><a href="#free-area" class="headerlink" title="free_area"></a><code>free_area</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span> <span class="comment">// MAX_ORDER = 11</span></span><br></pre></td></tr></table></figure>

<p>存放 Buddy System 分阶管理的页面，页面以双向链表形式连接</p>
<p><img src="../img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/free_area.png" alt="free_area"></p>
<h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Linux 使用<strong>节点</strong>来管理几个内存区，使用 <code>pglist_data</code> 结构体表示，结构体定义位于 <code>include/linux/mmzone.h</code></p>
<p>使用内存控制器来划分节点，同一内存控制器下的 CPU 对应的节点内存为<strong>本地内存</strong></p>
<p>大部分计算机只有一个 Node</p>
<p>#todo </p>
<h2 id="Buddy-System"><a href="#Buddy-System" class="headerlink" title="Buddy System"></a>Buddy System</h2><h3 id="内存组织形式"><a href="#内存组织形式" class="headerlink" title="内存组织形式"></a>内存组织形式</h3><p>在 Buddy System 中，按照空闲页面的大小进行分阶（order）管理，第 n 阶就是 2 的 n 次方个页的大小，存储在 <code>zone</code> 的 <code>free_area</code> 中，<strong>页面</strong>为 Buddy System 的最小管理单位</p>
<p>空闲页面以双向链表的形式进行连接</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/mmzone.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span> <span class="comment">// MAX_ORDER = 11</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_free;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/types.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="free-list"><a href="#free-list" class="headerlink" title="free_list"></a><code>free_list</code></h4><p>本质是一个双向链表，由于页面迁移机制，还要按照不同的迁移类型（migrate type）对相同大小页面进行分类</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span>  </span><br><span class="line">    MIGRATE_UNMOVABLE,</span><br><span class="line">    MIGRATE_MOVABLE,</span><br><span class="line">    MIGRATE_RECLAIMABLE,</span><br><span class="line">    MIGRATE_PCPTYPES,</span><br><span class="line">    MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA  </span></span><br><span class="line">    MIGRATE_CMA,  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION  </span></span><br><span class="line">    MIGRATE_ISOLATE,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">    MIGRATE_TYPES  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>MIGRATE_UNMOVABLE：这类型页面在内存当中有着固定的位置，不能移动</li>
<li>MIGRATE_MOVABLE：这类页面可以随意移动，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li>
<li>MIGRATE_RECLAIMABLE：这类页面不能直接移动，但是可以删除，例如映射文件的页</li>
<li>MIGRATE_PCPTYPES：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移仅限于同一节点内</li>
<li>MIGRATE_CMA：<code>Contiguous Memory Allocator</code>，即连续的物理内存</li>
<li>MIGRATE_ISOLATE：不能从该链表分配页面，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li>
<li>MIGRATE_TYPES：表示迁移类型的数目</li>
</ul>
<p><img src="../img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/free_list.png" alt="free_list"></p>
<h4 id="nr-free"><a href="#nr-free" class="headerlink" title="nr_free"></a><code>nr_free</code></h4><p>当前 <code>free_area</code> 中的空闲页面数量</p>
<h3 id="页面分配"><a href="#页面分配" class="headerlink" title="页面分配"></a>页面分配</h3><p>Buddy System 提供了一些用与分配页面的接口函数，它们最终都会调用核心函数 <code>struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask)</code></p>
<p>下面围绕核心函数来介绍页面分配机制</p>
<h4 id="gfp-t"><a href="#gfp-t" class="headerlink" title="gfp_t"></a><code>gfp_t</code></h4><p>GFP 即 Get Free Page</p>
<p>核心函数的第一个参数 <code>gfp_t</code> 表示在分配页面时的标志位，定义位于 <code>include/linux/gfp.h</code> 中</p>
<h5 id="内存管理区修饰符"><a href="#内存管理区修饰符" class="headerlink" title="内存管理区修饰符"></a>内存管理区修饰符</h5><p>主要描述从哪块内存区分配内存</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_DMA</td>
<td>从 ZONE_DMA 区中分配内存</td>
</tr>
<tr>
<td>__GFP_HIGNMEM</td>
<td>从 ZONE_HIGHMEM 区中分配内存</td>
</tr>
<tr>
<td>__GFP_DMA32</td>
<td>从 ZONE_DMA32 区中分配内存</td>
</tr>
<tr>
<td>__GFP_MOVABLE</td>
<td>内存规整时可以迁移或回收页面</td>
</tr>
</tbody></table>
<h5 id="移动和替换修饰符"><a href="#移动和替换修饰符" class="headerlink" title="移动和替换修饰符"></a>移动和替换修饰符</h5><p>主要描述分配的页面的迁移属性</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_RECLAIMABLE</td>
<td>分配的内存页面可以回收</td>
</tr>
<tr>
<td>__GFP_WRITE</td>
<td>申请的页面会被弄成脏页</td>
</tr>
<tr>
<td>__GFP_HARDWALL</td>
<td>强制使用 cpuset 内存分配策略</td>
</tr>
<tr>
<td>__GFP_THISNODE</td>
<td>在指定的节点上分配内存</td>
</tr>
<tr>
<td>__GFP_ACCOUNT</td>
<td>kmemcg 会记录分配过程</td>
</tr>
</tbody></table>
<h5 id="水位线修饰符"><a href="#水位线修饰符" class="headerlink" title="水位线修饰符"></a>水位线修饰符</h5><table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_ATOMIC</td>
<td>高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td>
</tr>
<tr>
<td>__GFP_HIGH</td>
<td>分配内存的过程中不可以睡眠或执行页面回收动作</td>
</tr>
<tr>
<td>__GFP_MEMALLOC</td>
<td>允许访问所有的内存</td>
</tr>
<tr>
<td>__GFP_NOMEMALLOC</td>
<td>不允许访问最低警戒水位线下的系统预留内存</td>
</tr>
</tbody></table>
<h5 id="回收修饰符"><a href="#回收修饰符" class="headerlink" title="回收修饰符"></a>回收修饰符</h5><p>主要描述页面回收的相关属性</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_IO</td>
<td>启动物理 I/O 传输</td>
</tr>
<tr>
<td>__GFP_FS</td>
<td>允许调用底层 FS 文件系统。可避免分配器递归到可能已经持有锁的文件系统中，避免死锁</td>
</tr>
<tr>
<td>__GFP_DIRECT_RECLAIM</td>
<td>分配内存过程中可以使用直接内存回收</td>
</tr>
<tr>
<td>__GFP_KSWAPD_RECLAIM</td>
<td>内存到达低水位时唤醒 kswapd 线程异步回收内存</td>
</tr>
<tr>
<td>__GFP_RECLAIM</td>
<td>表示是否可以直接内存回收或者使用 kswapd 线程进行回收</td>
</tr>
<tr>
<td>__GFP_RETRY_MAYFAIL</td>
<td>分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，使整个系统受益</td>
</tr>
<tr>
<td>__GFP_NOFAIL</td>
<td>内存分配失败后无限制的重复尝试，直到分配成功</td>
</tr>
<tr>
<td>__GFP_NORETRY</td>
<td>直接页面回收或者内存规整后还是无法分配内存时，不启用 retry 反复尝试分配内存，直接返回 NULL</td>
</tr>
</tbody></table>
<h5 id="行为修饰符"><a href="#行为修饰符" class="headerlink" title="行为修饰符"></a>行为修饰符</h5><p>主要描述分配页面时的行为</p>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Fescription</th>
</tr>
</thead>
<tbody><tr>
<td>__GFP_NOWARN</td>
<td>关闭内存分配过程中的 WARNING</td>
</tr>
<tr>
<td>__GFP_COMP</td>
<td>分配的内存页面将被组合成复合页</td>
</tr>
<tr>
<td>__GFP_ZERO</td>
<td>返回一个全部填充为 0 的页面</td>
</tr>
</tbody></table>
<h5 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h5><table>
<thead>
<tr>
<th>Flag</th>
<th>Element</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>GFP_ATOMIC</td>
<td>__GFP_HIGH | __GFP_ATOMIC | __GFP_KSWAPD_RECLAIM</td>
<td>分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td>__GFP_RECLAIM | __GFP_IO | __GFP_FS</td>
<td>分配内存时可以被阻塞(即休眠)</td>
</tr>
<tr>
<td>GFP_KERNEL_ACCOUNT</td>
<td>GFP_KERNEL | __GFP_ACCOUNT</td>
<td>和 GFP_KERNEL 作用一样，但是分配的过程会被 kmemcg 记录</td>
</tr>
<tr>
<td>GFP_NOWAIT</td>
<td>__GFP_KSWAPD_RECLAIM</td>
<td>分配过程中不允许因直接内存回收而导致停顿</td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>__GFP_RECLAIM</td>
<td>不需要启动任何的 I/O 操作</td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td>__GFP_RECLAIM | __GFP_IO</td>
<td>不会有访问任何文件系统的操作</td>
</tr>
<tr>
<td>GFP_USER</td>
<td>__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL</td>
<td>用户空间的进程分配内存</td>
</tr>
<tr>
<td>GFP_DMA</td>
<td>__GFP_DMA</td>
<td>从 ZONE_DMA 区分配内存</td>
</tr>
<tr>
<td>GFP_DMA32</td>
<td>__GFP_DMA32</td>
<td>从 ZONE_DMA32 区分配内存</td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td>GFP_USER | __GFP_HIGHMEM</td>
<td>用户进程分配内存，优先使用 ZONE_HIGHMEM，且这些页面不允许迁移</td>
</tr>
<tr>
<td>GFP_HIGHUSER_MOVABLE</td>
<td>GFP_HIGHUSER | __GFP_MOVABLE</td>
<td>和 GFP_HIGHUSER 类似，但是页面可以迁移</td>
</tr>
<tr>
<td>GFP_TRANSHUGE_LIGHT</td>
<td>GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM</td>
<td>透明大页的内存分配， light 表示不进行内存压缩和回收</td>
</tr>
<tr>
<td>GFP_TRANSHUGE</td>
<td>GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM</td>
<td>和 GFP_TRANSHUGE_LIGHT 类似，通常 khugepaged 使用该标志</td>
</tr>
</tbody></table>
<h4 id="alloc-context"><a href="#alloc-context" class="headerlink" title="alloc_context"></a><code>alloc_context</code></h4><p>分配结构体，描述一次内存分配的上下文信息，此结构体会在核心参数中使用到</p>
<figure class="highlight c"><figcaption><span>mm/internal.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line">	<span class="type">nodemask_t</span> *nodemask;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line">	<span class="type">int</span> migratetype;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">highest_zoneidx</span>;</span></span><br><span class="line">	<span class="type">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="zone-list"><a href="#zone-list" class="headerlink" title="zone_list"></a><code>zone_list</code></h5><p>保存此次分配操作的<strong>区</strong>的列表，实际上就是 <code>zone</code> 结构体的指针数组</p>
<figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">	<span class="type">int</span> zone_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="preferred-zoneref"><a href="#preferred-zoneref" class="headerlink" title="preferred_zoneref"></a><code>preferred_zoneref</code></h5><p>表示优先进行分配的区</p>
<h5 id="spread-dirty-pages"><a href="#spread-dirty-pages" class="headerlink" title="spread_dirty_pages"></a><code>spread_dirty_pages</code></h5><p>表示此次分配的页面是否会被修改且需要写回</p>
<h4 id="alloc-pages-nodemask-函数"><a href="#alloc-pages-nodemask-函数" class="headerlink" title="__alloc_pages_nodemask 函数"></a><code>__alloc_pages_nodemask</code> 函数</h4><p>该函数为核心函数，所有页面分配的 API 函数都是基于该函数的封装</p>
<p>函数参数</p>
<ul>
<li><code>gfp_t gpf_mask</code>：分配标志位</li>
<li><code>unsigned int order</code>：页面的阶</li>
<li><code>int prederred_nid</code>：选取的 Node 的 id</li>
<li><code>nodemask_t *nodemask</code>：限制可选取的 mask，一般为 0，不会限制</li>
</ul>
<figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">    <span class="type">gfp_t</span> alloc_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测 order 是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">        WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出允许使用的 gfp 标志位</span></span><br><span class="line">    gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">    alloc_mask = gfp_mask;</span><br><span class="line">    <span class="comment">// 分配前的准备</span></span><br><span class="line">    <span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直到所有的 local zone 都被考虑之前，禁止从 falling back 到内存碎片的传递</span></span><br><span class="line">    alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次分配尝试，快速分配</span></span><br><span class="line">    page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">    <span class="keyword">if</span> (likely(page))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Apply scoped allocation constraints. This is mainly about GFP_NOFS</span></span><br><span class="line"><span class="comment">     * resp. GFP_NOIO which has to be inherited for all allocation requests</span></span><br><span class="line"><span class="comment">     * from a particular context which has been marked by</span></span><br><span class="line"><span class="comment">     * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">    ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Restore the original nodemask if it was potentially replaced with</span></span><br><span class="line"><span class="comment">     * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">    page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">        unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">        __free_pages(page, order);</span><br><span class="line">        page = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步骤主要分为三步</p>
<ol>
<li>检查参数的合法性，做分配前的准备工作</li>
<li>进行<strong>快速分配</strong>，成功则直接返回结果</li>
<li>若快速分配失败，进行<strong>慢速分配</strong></li>
</ol>
<h5 id="分配前的准备工作"><a href="#分配前的准备工作" class="headerlink" title="分配前的准备工作"></a>分配前的准备工作</h5><p>通过调用 <code>prepare_alloc_page</code> 来初始化 <code>alloc_context</code> 结构体、获取区等</p>
<figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">prepare_alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> preferred_nid, <span class="type">nodemask_t</span> *nodemask,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> alloc_context *ac, <span class="type">gfp_t</span> *alloc_mask,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> *alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过 gfp 标志位，获取可使用的区的最大下标</span></span><br><span class="line">    ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">    <span class="comment">// 获取可用区的列表</span></span><br><span class="line">    ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line">    ac-&gt;nodemask = nodemask;</span><br><span class="line">    <span class="comment">// 获取迁移类型</span></span><br><span class="line">    ac-&gt;migratetype = gfp_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果开启了 cpusets（限制某组进程仅在某些 CPU 和内存上运行），设置对应标志位</span></span><br><span class="line">    <span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line">        *alloc_mask |= __GFP_HARDWALL;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果是在中断的上下文中，那么这次分配与当前任务的上下文无关</span></span><br><span class="line"><span class="comment">         * 那么选择任意节点都可以</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!in_interrupt() &amp;&amp; !ac-&gt;nodemask)</span><br><span class="line">            ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs_reclaim_acquire(gfp_mask);</span><br><span class="line">    fs_reclaim_release(gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要进行内存回收</span></span><br><span class="line">    might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据标志位判断页面是否需要回写，Dirty zone 的平衡只在快速分配中做</span></span><br><span class="line">    ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 zone_list 第一个区作为 preferred_zoneref</span></span><br><span class="line">    ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">                    ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从指定的节点中一个 <code>zone_list</code> 作为可用区的列表</li>
<li>根据 cpuset 情况设置标志位</li>
<li>判断是否页面需要回写</li>
<li>取出 <code>zone_list</code> 第一个区作为 <code>preferred_zoneref</code></li>
</ol>
<h5 id="快速分配：get-page-from-freelist-函数"><a href="#快速分配：get-page-from-freelist-函数" class="headerlink" title="快速分配：get_page_from_freelist 函数"></a>快速分配：<code>get_page_from_freelist</code> 函数</h5><p>通过 <code>get_page_from_freelist</code> 遍历 <code>alloc_context</code> 的 <code>zone_list</code> 中获取内存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 扫描 zonelist, 寻找有足够空闲空间的 zone</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置避免内存碎片的标志位</span></span><br><span class="line">    no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">    <span class="comment">// 首先扫描 preferred_zoneref</span></span><br><span class="line">    z = ac-&gt;preferred_zoneref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个封装 for 循环的宏，从 z 开始遍历 zone_list 可使用的 zone</span></span><br><span class="line">    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">                    ac-&gt;nodemask) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果开启 cpuset，检查当前 zone 是否满足要求</span></span><br><span class="line">        <span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">            (alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">            !__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当需要分配需要回写的页，而 zone 中脏页达到限制后需要跳过</span></span><br><span class="line">        <span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;</span><br><span class="line">                last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 node 数量大于 1，且当前 zone 非 preferred_zone</span></span><br><span class="line">        <span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line">            <span class="type">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果遍历到离 CPU 比较远的 zone，去掉避免碎片的标志</span></span><br><span class="line"><span class="comment">             * 即倾向于 local node 中的 zone，即使会产生内存碎片</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line">            <span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">                alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取水位线，并做检查</span></span><br><span class="line">        mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">        <span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">                       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">                       gfp_mask)) &#123;</span><br><span class="line">            <span class="comment">// 如果水位线没通过，进入下面流程</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">            <span class="comment">// 如果该 zone 包含 deferred pages，可以尝试扩展该 zone</span></span><br><span class="line">            <span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">                    <span class="keyword">goto</span> try_this_zone;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果标志忽略水位线，直接尝试从该 zone 进行分配</span></span><br><span class="line">            <span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line">                <span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node_reclaim_mode == <span class="number">0</span> ||</span><br><span class="line">                !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行页面回收</span></span><br><span class="line">            ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">            <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">                <span class="comment">// 不扫描</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">                <span class="comment">// 扫描但不能回收</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 回收后是否达标</span></span><br><span class="line">                <span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">                    ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line">                    <span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">        <span class="comment">// 正式进入页面分配</span></span><br><span class="line">        page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">                gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            <span class="comment">// 取到了，则初始化页面并返回</span></span><br><span class="line">            prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">                reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">            <span class="comment">// 没取到，如果该 zone 有 deferred pages，扩展后再试一遍</span></span><br><span class="line">            <span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">                    <span class="keyword">goto</span> try_this_zone;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在一台 UMA machine 上可能所有 zone 都是内存碎片</span></span><br><span class="line"><span class="comment">     * 无法避免碎片，重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">        alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从 <code>preferred_zoneref</code> 开始遍历 <code>zone_list</code> 寻找满足要求的 zone<ol>
<li>如果开启了 cpuset，检查当前 zone 是否满足要求，若否，寻找下一个 zone</li>
<li>检查当前 zone 的脏页数量达到限制，若否，寻找下一个 zone</li>
<li>检查当前 zone 是否属于另一个 node，若是，则清除 <code>ALLOC_NOFRAGMENT</code> 标志，重新遍历，因为 local node 重要性大于内存碎片</li>
<li>检查水位线是否达标<ol>
<li>若设置了 <code>ALLOC_NO_WATERMARKS</code> 忽略检查</li>
<li>若未达标，调用 <code>node_reclaim</code> 函数进行页面回收</li>
<li>若回收后 zone 仍不满足要求，则寻找下一个 zone</li>
</ol>
</li>
</ol>
</li>
<li>调用 <code>rmqueue</code> 函数，对满足要求的 zone 进行内存分配，即 Buddy System 分配算法</li>
</ol>
<p>下面仔细看看 Buddy System 分配算法</p>
<h5 id="rmqueue-函数"><a href="#rmqueue-函数" class="headerlink" title="rmqueue 函数"></a><code>rmqueue</code> 函数</h5><figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">            <span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大多数情况只需要一个页的大小</span></span><br><span class="line">    <span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * MIGRATE_MOVABLE pcplist 可能在 CMA 区域有页面</span></span><br><span class="line"><span class="comment">         * 如果 CMA 开启且不分配 CMA，则需要略过 MIGRATE_MOVABLE 的页面</span></span><br><span class="line"><span class="comment">         * 即当 CMA 没开启，或分配标志有 ALLOC_CMA，或页面不是 MIGRATE_MOVABLE</span></span><br><span class="line"><span class="comment">         * 都可以使用 pcplist</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||</span><br><span class="line">                migratetype != MIGRATE_MOVABLE) &#123;</span><br><span class="line">            page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,</span><br><span class="line">                    migratetype, alloc_flags);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 不希望调用者尝试分配 order &gt; 1 的页面且带有 __GFP_NOFAIL 标志</span></span><br><span class="line"><span class="comment">     * 可能会导致无限尝试分配失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 加锁，开始内存分配了</span></span><br><span class="line">    spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        page = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * HIGHATOMIC 区域是为高 order 分配保留的，因此 0 order 应该跳过</span></span><br><span class="line"><span class="comment">         * 当 order &gt; 0，且有 ALLOC_HARDER 标志（高优先级分配）</span></span><br><span class="line"><span class="comment">         * 调用 __rmqueue_smallest 分配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;</span><br><span class="line">            page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line">            <span class="keyword">if</span> (page)</span><br><span class="line">                trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 __rmqueue 分配</span></span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后检查分配的页面是否是新页面，防止 overlap</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order));</span><br><span class="line">    <span class="comment">// 解锁，分配完成</span></span><br><span class="line">    spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    __mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">                  get_pcppage_migratetype(page));</span><br><span class="line"></span><br><span class="line">    __count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">    zone_statistics(preferred_zone, zone);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;</span><br><span class="line">        clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">        wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>对于一个页大小的页面，除了 CMA 开启且不分配 CMA 的 MIGRATE_MOVABLE 页面，都可以通过 <code>rmqueue_pcplist</code> 从 CPU 的内存仓库中分配<ul>
<li>CMA 一般用于嵌入式，目的是分配一块连续的物理内存，这里不细讲</li>
</ul>
</li>
<li>如果 order &gt; 0 且分配优先级比较高，则调用 <code>__rmqueue_smallest</code> 分配</li>
<li>否则都调用 <code>__rmqueue</code> 分配内存</li>
<li>对页面进行检查是否是新页，不是则跳到第 2 步重新分配</li>
</ol>
<h6 id="rmqueue-pcplist-函数"><a href="#rmqueue-pcplist-函数" class="headerlink" title="rmqueue_pcplist 函数"></a><code>rmqueue_pcplist</code> 函数</h6><p>从 <code>per_cpu_pageset</code> 中分配 order-0（单页）页面</p>
<figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">rmqueue_pcplist</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> zone *zone, <span class="type">gfp_t</span> gfp_flags,</span></span><br><span class="line"><span class="params">             <span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭中断</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    <span class="comment">// 取出 pcplist</span></span><br><span class="line">    pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line">    <span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</span><br><span class="line">    <span class="comment">// 分配页面</span></span><br><span class="line">    page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        __count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span>);</span><br><span class="line">        zone_statistics(preferred_zone, zone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启中断</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">            <span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 pcplist 为空</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">            <span class="comment">// 调用 rmqueue_bulk 函数从 zone 中获取 batch 个页面到 pcplist 中</span></span><br><span class="line">            <span class="comment">// 其中会调用 __rmqueue 函数从 zone 取页面</span></span><br><span class="line">            pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</span><br><span class="line">                    READ_ONCE(pcp-&gt;batch), <span class="built_in">list</span>,</span><br><span class="line">                    migratetype, alloc_flags);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从链表中脱链</span></span><br><span class="line">        page = list_first_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> page, lru);</span><br><span class="line">        list_del(&amp;page-&gt;lru);</span><br><span class="line">        pcp-&gt;count--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (check_new_pcp(page));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>取出 pcplist</li>
<li>调用 <code>__rmqueue_pcplist</code> 函数分配页面<ol>
<li>如果 pcplist 为空，调用 <code>rmqueue_bulk</code> 函数从当前 zone 获取若干页面加入到 pcplist 中</li>
<li>从 pcplist 链表中脱链，取出一个页面</li>
</ol>
</li>
<li>返回页面</li>
</ol>
<h6 id="rmqueue-smallest-函数"><a href="#rmqueue-smallest-函数" class="headerlink" title="__rmqueue_smallest 函数"></a><code>__rmqueue_smallest</code> 函数</h6><p>核心函数</p>
<figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 zone 中寻找合适大小的页面，</span></span><br><span class="line">	<span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">        <span class="comment">// 取出 free_area 从中取出页面</span></span><br><span class="line">		area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">		page = get_page_from_free_area(area, migratetype);</span><br><span class="line">		<span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="comment">// 如果当前 order 的页面为空，则选更高 order 的页面</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 脱链</span></span><br><span class="line">		del_page_from_free_list(page, zone, current_order);</span><br><span class="line">        <span class="comment">// 在 expand 中进行拆分和上链</span></span><br><span class="line">		expand(zone, page, order, current_order, migratetype);</span><br><span class="line">    	<span class="comment">// 设置页的迁移类型</span></span><br><span class="line">		set_pcppage_migratetype(page, migratetype);</span><br><span class="line">		<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前 order 循环到需要分配的 order</span></span><br><span class="line">    <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">        high--;</span><br><span class="line">        size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 可能将后半页面标记作为守护页，在前半页被释放后，会进行合并</span></span><br><span class="line"><span class="comment">         * 对应的页表项也不会被创建，这部分也不会出现在虚拟地址空间中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将后半页面添加到对应大小和迁移类型的链表中</span></span><br><span class="line">        add_to_free_list(&amp;page[size], zone, high, migratetype);</span><br><span class="line">        <span class="comment">// 设置后半页面的 order</span></span><br><span class="line">        set_buddy_order(&amp;page[size], high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>从 zone 取出大小合适的页面，如果当前 order 的页面为空，那么从更高 order 的链表中去取</li>
<li>将页面脱链</li>
<li>调用 <code>expand</code> 函数将页面进行拆分和上链<ol>
<li>从当前 order 循环到需要分配的 order</li>
<li>后半页面添加到对应大小的链表中</li>
<li>设置前半页面的 order，下一步继续拆分，直到 order 刚好合适</li>
</ol>
</li>
<li>设置页面的迁移类型，返回页面</li>
</ol>
<h6 id="rmqueue-函数-1"><a href="#rmqueue-函数-1" class="headerlink" title="__rmqueue 函数"></a><code>__rmqueue</code> 函数</h6><figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;</span><br><span class="line">            zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;</span><br><span class="line">            zone_page_state(zone, NR_FREE_PAGES) / <span class="number">2</span>) &#123;</span><br><span class="line">            page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line">            <span class="keyword">if</span> (page)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">    page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">            page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 __rmqueue_fallback 看其他迁移类型有没有可以用的页面偷过来</span></span><br><span class="line">        <span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">                                alloc_flags))</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (page)</span><br><span class="line">        trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果开启了 CMA，从 CMA 区域获取页面（不细讲）</li>
<li>调用 <code>__rmqueue_smallest</code> 从 zone 对应迁移类型的链表中取页面</li>
<li>如果失败了，从 CMA 区域获取页面</li>
<li>如果还是失败了，调用 <code>__rmqueue_fallback</code> 从 zone 其他迁移类型的链表中寻找可用的页面放到当前迁移类型的链表中，重试步骤 2</li>
<li>如果还没有就寄</li>
</ol>
<h5 id="慢速分配：-alloc-pages-slowpath-函数"><a href="#慢速分配：-alloc-pages-slowpath-函数" class="headerlink" title="慢速分配：__alloc_pages_slowpath 函数"></a>慢速分配：<code>__alloc_pages_slowpath</code> 函数</h5><p>快速分配不成功说明系统可能没有足够的连续空闲页面，接下来进入慢速分配，先进行内存碎片整理与内存回收，再进行分配</p>
<p>#todo</p>
<h4 id="上层-API-函数"><a href="#上层-API-函数" class="headerlink" title="上层 API 函数"></a>上层 API 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__alloc_pages_node <span class="comment">/*返回 struct page 的指针*/</span></span><br><span class="line">    __alloc_pages</span><br><span class="line">        __alloc_pages_nodemask</span><br><span class="line"></span><br><span class="line">alloc_pages        <span class="comment">/*返回 struct page 的指针*/</span></span><br><span class="line">    alloc_pages_current</span><br><span class="line">        __alloc_pages_nodemask  </span><br><span class="line"></span><br><span class="line">__get_free_pages   <span class="comment">/*返回页面的虚拟地址*/</span></span><br><span class="line">    alloc_pages</span><br><span class="line">        alloc_pages_current</span><br><span class="line">            __alloc_pages_nodemask</span><br></pre></td></tr></table></figure>

<h3 id="页面释放"><a href="#页面释放" class="headerlink" title="页面释放"></a>页面释放</h3><p>Buddy System 的 buddy 其实就在于页面释放时，寻找与被释放的页面<strong>内存对齐</strong>的页面（可能与上一页面，也可能是下一页面）作为 buddy，检查该 buddy 是否可以合并</p>
<p>buddy 实际上就是指守护页或空闲页面</p>
<p><code>__free_one_page</code> 是页面释放的核心函数，这里的 page 是指页面，而不是页</p>
<p>函数定义于 <code>mm/page_alloc.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __free_one_page(<span class="keyword">struct</span> page *page,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> pfn,</span><br><span class="line">        <span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span><br><span class="line">        <span class="type">int</span> migratetype, <span class="type">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> buddy_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> combined_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_order;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line">    <span class="type">bool</span> to_tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最高 order</span></span><br><span class="line">    max_order = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查参数的合法性</span></span><br><span class="line">    VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">    VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">    VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">        __mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">    VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">    VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">continue_merging:</span><br><span class="line">    <span class="comment">// 只要还能合并，order 没到最高 order，就继续合并</span></span><br><span class="line">    <span class="keyword">while</span> (order &lt; max_order) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">            __mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">                                migratetype);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算 buddy 的 PFN</span></span><br><span class="line">        buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">        buddy = page + (buddy_pfn - pfn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pfn_valid_within(buddy_pfn))</span><br><span class="line">            <span class="keyword">goto</span> done_merging;</span><br><span class="line">        <span class="comment">// 检查 buddy 是否能合并，比如是否被释放，是否同阶，是否在同一 zone</span></span><br><span class="line">        <span class="keyword">if</span> (!page_is_buddy(page, buddy, order))</span><br><span class="line">            <span class="keyword">goto</span> done_merging;</span><br><span class="line">        <span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">            <span class="comment">// 若 buddy 是守护页，则去除守护页标志</span></span><br><span class="line">            clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则将 buddy 脱链，以便合并</span></span><br><span class="line">            del_page_from_free_list(buddy, zone, order);</span><br><span class="line">        <span class="comment">// 计算合并后的 page 属性</span></span><br><span class="line">        combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">        page = page + (combined_pfn - pfn);</span><br><span class="line">        pfn = combined_pfn;</span><br><span class="line">        order++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (order &lt; MAX_ORDER - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果到了这里，说明 order &gt;= pageblock_order</span></span><br><span class="line"><span class="comment">         * 希望阻止隔离 pageblock 上的页面与正常 pageblock 的合并</span></span><br><span class="line"><span class="comment">         * 如果不阻止，可能导致错误的空闲页或 CMA 计数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line">            <span class="comment">// 如果有隔离 pageblock，需要停止合并</span></span><br><span class="line">            <span class="type">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">            buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">            buddy = page + (buddy_pfn - pfn);</span><br><span class="line">            buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">                    &amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">                        is_migrate_isolate(buddy_mt)))</span><br><span class="line">                <span class="keyword">goto</span> done_merging;</span><br><span class="line">        &#125;</span><br><span class="line">        max_order = order + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> continue_merging;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">    <span class="comment">// 合并完成后，设置页面的 order，设置 buddy 标志位</span></span><br><span class="line">    set_buddy_order(page, order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断插入到链表头还是链表尾，通常是链表头，遵循 LIFO</span></span><br><span class="line">    <span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">        to_tail = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">        to_tail = shuffle_pick_tail();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果该页面很大或下一个页面也是空闲的，则插入到链表尾</span></span><br><span class="line">        to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to_tail)</span><br><span class="line">        add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">        page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>计算 max_order 和 buddy 的 PFN</li>
<li>通过 <code>page_is_buddy</code> 检查 buddy 是否可以合并<ul>
<li>该 buddy 是否设置 buddy 标志位或是守卫页</li>
<li>是否同 order</li>
<li>是否在同一 zone</li>
</ul>
</li>
<li>如果可以合并，取消 buddy 标志位并脱链，或取消守卫页标志位</li>
<li>计算合并后的页面属性，跳转到步骤 1，继续合并，直到到达 max_order 或 buddy 不能合并</li>
<li>判断是否有隔离 pageblock（pageblock 是一种比较大的页面，order &gt;= MAX_ORDER-1）<ul>
<li>如果有则停止合并</li>
<li>如果没有，则跳转到步骤 1 尝试继续合并</li>
</ul>
</li>
<li>合并完成，设置页面 order 和 buddy 标志位（表示页面为空闲页面）</li>
<li>判断插入到空间页面的链表头还是链表尾，通常是链表头，遵循 LIFO</li>
</ol>
<h4 id="上层-API-函数-1"><a href="#上层-API-函数-1" class="headerlink" title="上层 API 函数"></a>上层 API 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">free_pages</span><br><span class="line">    __free_pages</span><br><span class="line">        free_the_page</span><br><span class="line">            free_unref_page or __free_pages_ok</span><br><span class="line">                free_one_page</span><br><span class="line">                    __free_one_page</span><br></pre></td></tr></table></figure>

<h2 id="Slab"><a href="#Slab" class="headerlink" title="Slab"></a>Slab</h2><p>Buddy System 分配的页面单位是页，而往往使用的时候并不需要那么大的空间，因此需要更细粒度的内存分配器对从 Buddy System 获取的页面进行管理，也就是 Slab Allocator，它会将页面分割成小的对象（object）供其他组件使用</p>
<p>Slab 又被称为内核的堆管理器，动态分配内存</p>
<ul>
<li>Slab 经历了三个版本<ul>
<li>Slab：最初版本，机制复杂，效率不高</li>
<li>Slob：用于嵌入式等的简化版本</li>
<li>Slub：优化后的通用版本</li>
</ul>
</li>
</ul>
<p>本文主要介绍 Slub，Linux 最常用的内存分配器</p>
<p>下图是 Slub 的结构概览</p>
<p><img src="img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/Slub.png" alt="Slub"></p>
<h3 id="基本结构体"><a href="#基本结构体" class="headerlink" title="基本结构体"></a>基本结构体</h3><h4 id="slab"><a href="#slab" class="headerlink" title="slab"></a><code>slab</code></h4><p>Slub 将从 Buddy System 获取的页面称为一张 slab，对应的匿名结构体内嵌在 <code>page</code> 结构体中，新版本的 Slub 是单独拿出一个 <code>slab</code> 结构体，本质上也是复用 <code>page</code> 结构体</p>
<p>定义位于 <code>include/linux/mm_types.h</code></p>
<p>下面介绍与 slab 有关的几个重要字段</p>
<h5 id="slab-list"><a href="#slab-list" class="headerlink" title="slab_list"></a><code>slab_list</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br></pre></td></tr></table></figure>

<p>按用途连接多个 slab 的双向链表</p>
<h5 id="slab-cache"><a href="#slab-cache" class="headerlink" title="slab_cache"></a><code>slab_cache</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br></pre></td></tr></table></figure>

<p>该 slab 的内存池，后面会详细介绍</p>
<h5 id="freelist"><a href="#freelist" class="headerlink" title="freelist"></a><code>freelist</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *freelist;</span><br></pre></td></tr></table></figure>

<p>该 slab 的空闲对象单向链表，指向第一个空闲对象</p>
<h5 id="counters"><a href="#counters" class="headerlink" title="counters"></a><code>counters</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">        <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">        <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>inuse</code>：已被使用的对象数量</li>
<li><code>objects</code>：对象总数</li>
<li><code>frozen</code>：是否归属于特定 CPU</li>
</ul>
<p><code>couters</code> 和上面三个字段属于同一内存，后面有大量对 <code>couters</code> 的赋值操作，实际上是对 <code>inuse</code> &amp; <code>objects</code> &amp; <code>frozen</code> 的赋值</p>
<h4 id="kmem-cache"><a href="#kmem-cache" class="headerlink" title="kmem_cache"></a><code>kmem_cache</code></h4><p>用于分配特定大小或用途的对象的内存池，每个 <code>kmem_cache</code> 有若干张 slab</p>
<p>所有的 <code>kmem_cache</code> 存储在一个通用 <code>kmalloc_caches</code> 数组中，并构成一个双向链表</p>
<figure class="highlight c"><figcaption><span>mm/slab_common.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class"><span class="title">kmalloc_caches</span>[<span class="title">NR_KMALLOC_TYPES</span>][<span class="title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="title">ro_after_init</span> =</span></span><br><span class="line">&#123; <span class="comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_caches);</span><br></pre></td></tr></table></figure>

<p><code>kmem_cache</code> 结构体定义位于 <code>include/linux/slub_def.h</code></p>
<p>下面介绍几个重要字段</p>
<h5 id="cpu-slab"><a href="#cpu-slab" class="headerlink" title="cpu_slab"></a><code>cpu_slab</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br></pre></td></tr></table></figure>

<p>percpu 变量，每个 CPU 独有一个，相当于每个 CPU 的内存池</p>
<h5 id="flags-1"><a href="#flags-1" class="headerlink" title="flags"></a><code>flags</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">slab_flags_t</span> flags;</span><br></pre></td></tr></table></figure>

<p>标志位，用于回收等</p>
<h5 id="min-partial"><a href="#min-partial" class="headerlink" title="min_partial"></a><code>min_partial</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br></pre></td></tr></table></figure>

<p>node partial 链表上 slab 的最大数量</p>
<h5 id="size-amp-object-size"><a href="#size-amp-object-size" class="headerlink" title="size &amp; object_size"></a><code>size</code> &amp; <code>object_size</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> object_size;</span><br></pre></td></tr></table></figure>

<ul>
<li>size：对象的实际大小</li>
<li>object_size：对象所能存放的数据大小</li>
</ul>
<h5 id="offset"><a href="#offset" class="headerlink" title="offset"></a><code>offset</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset;</span><br></pre></td></tr></table></figure>

<p>一张 slab 上空闲对象指针在对象上的偏移</p>
<h5 id="oo"><a href="#oo" class="headerlink" title="oo"></a><code>oo</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>低 16 位：一张 slab 上的对象数量</li>
<li>高 16 位：一张 slab 的大小（order）</li>
</ul>
<h5 id="min"><a href="#min" class="headerlink" title="min"></a><code>min</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br></pre></td></tr></table></figure>

<p>一张 slab 上最少的对象数量</p>
<h5 id="allocflags"><a href="#allocflags" class="headerlink" title="allocflags"></a><code>allocflags</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">gfp_t</span> allocflags;</span><br></pre></td></tr></table></figure>

<p>存放 GFP 标志位</p>
<h5 id="ctor"><a href="#ctor" class="headerlink" title="ctor"></a><code>ctor</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br></pre></td></tr></table></figure>

<p>对象的构造函数，分配对象会调用该函数进行初始化</p>
<h5 id="inuse"><a href="#inuse" class="headerlink" title="inuse"></a><code>inuse</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> inuse;</span><br></pre></td></tr></table></figure>

<p>实际上就是 <code>object_size</code></p>
<h5 id="align"><a href="#align" class="headerlink" title="align"></a><code>align</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> align;</span><br></pre></td></tr></table></figure>

<p>对象对齐的宽度</p>
<h5 id="random-seq"><a href="#random-seq" class="headerlink" title="random_seq"></a><code>random_seq</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br></pre></td></tr></table></figure>

<p>用于在 slab 初始化时，随机化 <code>freelist</code> 上空闲对象的连接顺序</p>
<h5 id="useroffset-amp-usersize"><a href="#useroffset-amp-usersize" class="headerlink" title="useroffset &amp; usersize"></a><code>useroffset</code> &amp; <code>usersize</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> useroffset;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usersize;</span><br></pre></td></tr></table></figure>

<p>Hardened Usercopy 保护相关</p>
<ul>
<li><code>useroffset</code>：用户空间能读写的区域起始偏移</li>
<li><code>usersize</code>：用户空间能读写的区域大小</li>
</ul>
<h5 id="node"><a href="#node" class="headerlink" title="node"></a><code>node</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br></pre></td></tr></table></figure>

<p><code>kmem_cache_node</code> 数组，对应不同 node 的后备内存池</p>
<h5 id="kmem-cache-类型"><a href="#kmem-cache-类型" class="headerlink" title="kmem_cache 类型"></a><code>kmem_cache</code> 类型</h5><p><code>kmem_cache</code> 有四种类型，在进行内存分配时若未指定内存池，则会根据 <code>allocflags</code> 从不同的 <code>kmem_cache</code> 中取</p>
<figure class="highlight c"><figcaption><span>include/linux/slab.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">kmalloc_cache_type</span> &#123;</span></span><br><span class="line">	KMALLOC_NORMAL = <span class="number">0</span>,</span><br><span class="line">	KMALLOC_RECLAIM,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">	KMALLOC_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	NR_KMALLOC_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>KMALLOC_NORMAL</code>：通用内存池，对应 <code>kmalloc-*</code>，分配 flag 为 <code>GFP_KERNEL</code></li>
<li><code>KMALLOC_RECLAIM</code>：用于 DMA 的内存池，对应 <code>kmalloc-dma-*</code></li>
<li><code>KMALLOC_DMA</code>：可以被回收的内存池，对应 <code>kmalloc-rcl-*</code></li>
</ul>
<p>若没开启 DMA 选项，则合并入 <code>KMALLOC_NORMAL</code> 内存池</p>
<h5 id="slab-alias"><a href="#slab-alias" class="headerlink" title="slab alias"></a>slab alias</h5><p>一种对同等/近似大小对象的 <code>kmem_cache</code> 进行复用的机制</p>
<p>当要创建一个 <code>kmem_cache</code> 时，若已存在能分配相等/近似大小的对象的 <code>kmem_cache</code>，则不会创建新的 <code>kmem_cache</code>，而是为原有的 <code>kmem_cache</code> 起一个别名，作为“新的” <code>kmem_cache</code> 返回</p>
<p>例如 Linux 4.4 以前，<code>cred</code> 结构体与其他大小为 192 字节的结构体，会从同一个 <code>kmem_cache</code> —— <code>kmalloc-192</code> 中分配，就很容易被 UAF 漏洞利用提权</p>
<p>Linux 4.4 后，开启 <code>SLAB_ACCOUNT</code> 后，<code>cred</code> 结构体属于高权限结构体，会创建一个单独的 <code>kmem_cache</code> —— <code>cred_jar</code> 单独给 <code>cred</code> 结构体使用，而其他普通同大小的结构体使用 <code>kmalloc-192</code>，彼此之间互不干扰</p>
<h3 id="分配和释放"><a href="#分配和释放" class="headerlink" title="分配和释放"></a>分配和释放</h3><ul>
<li>分配：<ul>
<li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回</li>
<li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被加入到 <code>kmem_cache_node</code> 的 <strong>full</strong> 链表，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回</li>
<li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用</li>
</ul>
</li>
<li>释放：<ul>
<li>若被释放 object 属于 <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist</li>
<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist</li>
<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 full 链表上的 slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会从 full 链表迁移到 partial 链表</strong></li>
</ul>
</li>
</ul>
<p>以上便是 slub allocator 的基本原理</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Linux Kernel 内存管理</p><p><a href="https://humoooor.cn/2023/09/17/Linux Kernel 内存管理/">https://humoooor.cn/2023/09/17/Linux Kernel 内存管理/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Humoooor</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-09-17</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-09-26</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Operating-System/">Operating System</a><a class="link-muted mr-2" rel="tag" href="/tags/Linux-Kernel/">Linux Kernel</a><a class="link-muted mr-2" rel="tag" href="/tags/Memory-Management/">Memory Management</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2023/06/05/2023.06/"><span class="level-item">2023.06</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "253b3404d135fe4b680ab222ee6bd9e7",
            repo: "humoooor.github.io",
            owner: "Humoooor",
            clientID: "2262fbb1802e5dc5cc56",
            clientSecret: "55e61f8ed70fa2bcec90cf254ac1864f21cb350b",
            admin: ["Humoooor"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/MyLogo.jpg" alt="Humoooor"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Humoooor</p><p class="is-size-6 is-block">Free to Hack</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">7</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/humoooor" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/humoooor"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:humoooor@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#关键词"><span class="level-left"><span class="level-item">1</span><span class="level-item">关键词</span></span></a></li><li><a class="level is-mobile" href="#物理内存"><span class="level-left"><span class="level-item">2</span><span class="level-item">物理内存</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Page"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Page</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#flags"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">flags</span></span></a></li><li><a class="level is-mobile" href="#mapcount"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">_mapcount </span></span></a></li><li><a class="level is-mobile" href="#refcount"><span class="level-left"><span class="level-item">2.1.3</span><span class="level-item">_refcount</span></span></a></li><li><a class="level is-mobile" href="#virtual"><span class="level-left"><span class="level-item">2.1.4</span><span class="level-item">virtual</span></span></a></li><li><a class="level is-mobile" href="#基础内存模型"><span class="level-left"><span class="level-item">2.1.5</span><span class="level-item">基础内存模型</span></span></a></li><li><a class="level is-mobile" href="#PFN-与-page-地址的转换"><span class="level-left"><span class="level-item">2.1.6</span><span class="level-item">PFN 与 page 地址的转换</span></span></a></li><li><a class="level is-mobile" href="#Sparse-Memory-Virtual-Memmap"><span class="level-left"><span class="level-item">2.1.7</span><span class="level-item">Sparse Memory Virtual Memmap</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Zone"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Zone</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#watermark"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">_watermark</span></span></a></li><li><a class="level is-mobile" href="#zone-pgdat"><span class="level-left"><span class="level-item">2.2.2</span><span class="level-item">zone_pgdat</span></span></a></li><li><a class="level is-mobile" href="#pageset"><span class="level-left"><span class="level-item">2.2.3</span><span class="level-item">pageset</span></span></a></li><li><a class="level is-mobile" href="#free-area"><span class="level-left"><span class="level-item">2.2.4</span><span class="level-item">free_area</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Node"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Node</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Buddy-System"><span class="level-left"><span class="level-item">3</span><span class="level-item">Buddy System</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#内存组织形式"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">内存组织形式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#free-list"><span class="level-left"><span class="level-item">3.1.1</span><span class="level-item">free_list</span></span></a></li><li><a class="level is-mobile" href="#nr-free"><span class="level-left"><span class="level-item">3.1.2</span><span class="level-item">nr_free</span></span></a></li></ul></li><li><a class="level is-mobile" href="#页面分配"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">页面分配</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#gfp-t"><span class="level-left"><span class="level-item">3.2.1</span><span class="level-item">gfp_t</span></span></a></li><li><a class="level is-mobile" href="#alloc-context"><span class="level-left"><span class="level-item">3.2.2</span><span class="level-item">alloc_context</span></span></a></li><li><a class="level is-mobile" href="#alloc-pages-nodemask-函数"><span class="level-left"><span class="level-item">3.2.3</span><span class="level-item">__alloc_pages_nodemask 函数</span></span></a></li><li><a class="level is-mobile" href="#上层-API-函数"><span class="level-left"><span class="level-item">3.2.4</span><span class="level-item">上层 API 函数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#页面释放"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">页面释放</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#上层-API-函数-1"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">上层 API 函数</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Slab"><span class="level-left"><span class="level-item">4</span><span class="level-item">Slab</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基本结构体"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">基本结构体</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#slab"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">slab</span></span></a></li><li><a class="level is-mobile" href="#kmem-cache"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">kmem_cache</span></span></a></li></ul></li><li><a class="level is-mobile" href="#分配和释放"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">分配和释放</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-17T14:26:00.000Z">2023-09-17</time></p><p class="title"><a href="/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Linux Kernel 内存管理</a></p><p class="categories"><a href="/categories/Kernel/">Kernel</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-05T03:04:00.000Z">2023-06-05</time></p><p class="title"><a href="/2023/06/05/2023.06/">2023.06</a></p><p class="categories"><a href="/categories/MonthReport/">MonthReport</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-23T03:21:00.000Z">2023-05-23</time></p><p class="title"><a href="/2023/05/23/Xv6%20%E5%89%96%E6%9E%90/">Xv6 剖析</a></p><p class="categories"><a href="/categories/Course/">Course</a> / <a href="/categories/Course/MIT-6-1810-2022Fall/">MIT 6.1810 2022Fall</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-10T12:05:00.000Z">2023-05-10</time></p><p class="title"><a href="/2023/05/10/2023.05/">2023.05</a></p><p class="categories"><a href="/categories/MonthReport/">MonthReport</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-04-09T08:00:00.000Z">2023-04-09</time></p><p class="title"><a href="/2023/04/09/2023.04/">2023.04</a></p><p class="categories"><a href="/categories/MonthReport/">MonthReport</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Linux-Kernel/"><span class="tag">Linux Kernel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Memory-Management/"><span class="tag">Memory Management</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pwn/"><span class="tag">Pwn</span><span class="tag">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RISC-V/"><span class="tag">RISC-V</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Xv6/"><span class="tag">Xv6</span><span class="tag">7</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/MyLogo.jpg" alt="Humoooor&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 Humoooor</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/humoooor"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>